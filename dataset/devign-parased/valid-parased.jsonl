{"project": "qemu", "commit_id": "aa1530dec499f7525d2ccaa0e3a876dc8089ed1e", "target": 1, "func": "static void filter_mirror_setup(NetFilterState *nf, Error **errp)\n{\n    MirrorState *s = FILTER_MIRROR(nf);\n    Chardev *chr;\n    chr = qemu_chr_find(s->outdev);\n    if (chr == NULL) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", s->outdev);\n    qemu_chr_fe_init(&s->chr_out, chr, errp);", "idx": 8}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int64_t sub64(const int64_t a, const int64_t b)\n\n{\n\n\treturn a - b;\n\n}\n", "idx": 10}
{"project": "qemu", "commit_id": "089da572b956ef0f8f5b8d5917358e07892a77c2", "target": 1, "func": "void fw_cfg_add_callback(FWCfgState *s, uint16_t key, FWCfgCallback callback,\n\n                         void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    assert(key & FW_CFG_WRITE_CHANNEL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    assert(key < FW_CFG_MAX_ENTRY && len <= 65535);\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n}\n", "idx": 15}
{"project": "qemu", "commit_id": "98f343395e937fa1db3a28dfb4f303f97cfddd6c", "target": 1, "func": "static void emulated_push_error(EmulatedState *card, uint64_t code)\n\n{\n\n    EmulEvent *event = (EmulEvent *)g_malloc(sizeof(EmulEvent));\n\n\n\n    assert(event);\n\n    event->p.error.type = EMUL_ERROR;\n\n    event->p.error.code = code;\n\n    emulated_push_event(card, event);\n\n}\n", "idx": 22}
{"project": "qemu", "commit_id": "c39ce112b60ffafbaf700853e32bea74cbb2c148", "target": 0, "func": "static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n\n{\n\n    int32_t datalen;\n\n    int lun;\n\n\n\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n\n    lun = busid & 7;\n\n    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);\n\n    datalen = scsi_req_enqueue(s->current_req, buf);\n\n    s->ti_size = datalen;\n\n    if (datalen != 0) {\n\n        s->rregs[ESP_RSTAT] = STAT_TC;\n\n        s->dma_left = 0;\n\n        s->dma_counter = 0;\n\n        if (datalen > 0) {\n\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n\n        } else {\n\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n\n        }\n\n        scsi_req_continue(s->current_req);\n\n    }\n\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n\n    esp_raise_irq(s);\n\n}\n", "idx": 51}
{"project": "qemu", "commit_id": "3098dba01c7daab60762b6f6624ea88c0d6cb65a", "target": 0, "func": "void gdb_do_syscall(gdb_syscall_complete_cb cb, const char *fmt, ...)\n\n{\n\n    va_list va;\n\n    char buf[256];\n\n    char *p;\n\n    target_ulong addr;\n\n    uint64_t i64;\n\n    GDBState *s;\n\n\n\n    s = gdbserver_state;\n\n    if (!s)\n\n        return;\n\n    gdb_current_syscall_cb = cb;\n\n    s->state = RS_SYSCALL;\n\n#ifndef CONFIG_USER_ONLY\n\n    vm_stop(EXCP_DEBUG);\n\n#endif\n\n    s->state = RS_IDLE;\n\n    va_start(va, fmt);\n\n    p = buf;\n\n    *(p++) = 'F';\n\n    while (*fmt) {\n\n        if (*fmt == '%') {\n\n            fmt++;\n\n            switch (*fmt++) {\n\n            case 'x':\n\n                addr = va_arg(va, target_ulong);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx, addr);\n\n                break;\n\n            case 'l':\n\n                if (*(fmt++) != 'x')\n\n                    goto bad_format;\n\n                i64 = va_arg(va, uint64_t);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, \"%\" PRIx64, i64);\n\n                break;\n\n            case 's':\n\n                addr = va_arg(va, target_ulong);\n\n                p += snprintf(p, &buf[sizeof(buf)] - p, TARGET_FMT_lx \"/%x\",\n\n                              addr, va_arg(va, int));\n\n                break;\n\n            default:\n\n            bad_format:\n\n                fprintf(stderr, \"gdbstub: Bad syscall format string '%s'\\n\",\n\n                        fmt - 1);\n\n                break;\n\n            }\n\n        } else {\n\n            *(p++) = *(fmt++);\n\n        }\n\n    }\n\n    *p = 0;\n\n    va_end(va);\n\n    put_packet(s, buf);\n\n#ifdef CONFIG_USER_ONLY\n\n    gdb_handlesig(s->c_cpu, 0);\n\n#else\n\n    cpu_interrupt(s->c_cpu, CPU_INTERRUPT_EXIT);\n\n#endif\n\n}\n", "idx": 71}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void tricore_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    TriCoreCPU *cpu = TRICORE_CPU(obj);\n\n    CPUTriCoreState *env = &cpu->env;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled()) {\n\n        tricore_tcg_init();\n\n    }\n\n}\n", "idx": 88}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_content_storage(MXFContext *mxf, ByteIOContext *pb, int tag)\n\n{\n\n    switch (tag) {\n\n    case 0x1901:\n\n        mxf->packages_count = get_be32(pb);\n\n        if (mxf->packages_count >= UINT_MAX / sizeof(UID))\n\n            return -1;\n\n        mxf->packages_refs = av_malloc(mxf->packages_count * sizeof(UID));\n\n        if (!mxf->packages_refs)\n\n            return -1;\n\n        url_fskip(pb, 4); /* useless size of objects, always 16 according to specs */\n\n        get_buffer(pb, (uint8_t *)mxf->packages_refs, mxf->packages_count * sizeof(UID));\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 125}
{"project": "FFmpeg", "commit_id": "c3e6e8f06c42499bd020fd0b37f9542150e6067b", "target": 0, "func": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n\n{\n\n    void **ptrptr = ptr;\n\n    void *ret;\n\n    if (size <= 0 || nmemb >= INT_MAX / size)\n\n        return AVERROR(ENOMEM);\n\n    if (nmemb <= 0) {\n\n        av_freep(ptr);\n\n        return 0;\n\n    }\n\n    ret = av_realloc(*ptrptr, nmemb * size);\n\n    if (!ret) {\n\n        av_freep(ptr);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    *ptrptr = ret;\n\n    return 0;\n\n}\n", "idx": 127}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel16_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_16w_msa(src - 2,\n\n                            src - (stride * 2) +\n\n                            sizeof(uint8_t), stride, dst, stride, 16);\n\n}\n", "idx": 137}
{"project": "qemu", "commit_id": "35f754620615138aaae0ef72602f84c88fd8de0f", "target": 1, "func": "struct vhost_net *vhost_net_init(VLANClientState *backend, int devfd,\n\n                                 bool force)\n\n{\n\n\n    return NULL;\n\n}", "idx": 143}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "static int bit8x8_c(MpegEncContext *s, uint8_t *src1, uint8_t *src2,\n\n                    ptrdiff_t stride, int h)\n\n{\n\n    const uint8_t *scantable = s->intra_scantable.permutated;\n\n    LOCAL_ALIGNED_16(int16_t, temp, [64]);\n\n    int i, last, run, bits, level, start_i;\n\n    const int esc_length = s->ac_esc_length;\n\n    uint8_t *length, *last_length;\n\n\n\n    av_assert2(h == 8);\n\n\n\n    s->pdsp.diff_pixels(temp, src1, src2, stride);\n\n\n\n    s->block_last_index[0 /* FIXME */] =\n\n    last                               =\n\n        s->fast_dct_quantize(s, temp, 0 /* FIXME */, s->qscale, &i);\n\n\n\n    bits = 0;\n\n\n\n    if (s->mb_intra) {\n\n        start_i     = 1;\n\n        length      = s->intra_ac_vlc_length;\n\n        last_length = s->intra_ac_vlc_last_length;\n\n        bits       += s->luma_dc_vlc_length[temp[0] + 256]; // FIXME: chroma\n\n    } else {\n\n        start_i     = 0;\n\n        length      = s->inter_ac_vlc_length;\n\n        last_length = s->inter_ac_vlc_last_length;\n\n    }\n\n\n\n    if (last >= start_i) {\n\n        run = 0;\n\n        for (i = start_i; i < last; i++) {\n\n            int j = scantable[i];\n\n            level = temp[j];\n\n\n\n            if (level) {\n\n                level += 64;\n\n                if ((level & (~127)) == 0)\n\n                    bits += length[UNI_AC_ENC_INDEX(run, level)];\n\n                else\n\n                    bits += esc_length;\n\n                run = 0;\n\n            } else\n\n                run++;\n\n        }\n\n        i = scantable[last];\n\n\n\n        level = temp[i] + 64;\n\n\n\n        av_assert2(level - 64);\n\n\n\n        if ((level & (~127)) == 0)\n\n            bits += last_length[UNI_AC_ENC_INDEX(run, level)];\n\n        else\n\n            bits += esc_length;\n\n    }\n\n\n\n    return bits;\n\n}\n", "idx": 146}
{"project": "qemu", "commit_id": "3e4f910c8d490a1490409a7e381dbbb229f9d272", "target": 1, "func": "static void ehci_mem_writew(void *ptr, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    fprintf(stderr, \"EHCI doesn't handle 16-bit writes to MMIO\\n\");\n\n    exit(1);\n\n}\n", "idx": 155}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void xendev_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->props = xendev_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n\n\n\n\n\n}", "idx": 161}
{"project": "qemu", "commit_id": "1fa795a853255fcc93e5d3e2a92d161a2ed96eb8", "target": 1, "func": "static uint64_t qdev_get_prop_mask64(Property *prop)\n\n{\n\n    assert(prop->info == &qdev_prop_bit);\n\n    return 0x1 << prop->bitnr;\n\n}\n", "idx": 162}
{"project": "qemu", "commit_id": "12b7f57e2cfcd665cf5a21b4ae3c23b9361c5c05", "target": 0, "func": "static void smp_parse(const char *optarg)\n\n{\n\n    int smp, sockets = 0, threads = 0, cores = 0;\n\n    char *endptr;\n\n    char option[128];\n\n\n\n    smp = strtoul(optarg, &endptr, 10);\n\n    if (endptr != optarg) {\n\n        if (*endptr == ',') {\n\n            endptr++;\n\n        }\n\n    }\n\n    if (get_param_value(option, 128, \"sockets\", endptr) != 0)\n\n        sockets = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"cores\", endptr) != 0)\n\n        cores = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"threads\", endptr) != 0)\n\n        threads = strtoull(option, NULL, 10);\n\n    if (get_param_value(option, 128, \"maxcpus\", endptr) != 0)\n\n        max_cpus = strtoull(option, NULL, 10);\n\n\n\n    /* compute missing values, prefer sockets over cores over threads */\n\n    if (smp == 0 || sockets == 0) {\n\n        sockets = sockets > 0 ? sockets : 1;\n\n        cores = cores > 0 ? cores : 1;\n\n        threads = threads > 0 ? threads : 1;\n\n        if (smp == 0) {\n\n            smp = cores * threads * sockets;\n\n        }\n\n    } else {\n\n        if (cores == 0) {\n\n            threads = threads > 0 ? threads : 1;\n\n            cores = smp / (sockets * threads);\n\n        } else {\n\n            threads = smp / (cores * sockets);\n\n        }\n\n    }\n\n    smp_cpus = smp;\n\n    smp_cores = cores > 0 ? cores : 1;\n\n    smp_threads = threads > 0 ? threads : 1;\n\n    if (max_cpus == 0)\n\n        max_cpus = smp_cpus;\n\n}\n", "idx": 174}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_2f_1r_to_dolby(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        output[1][i] -= output[3][i];\n\n        output[2][i] += output[3][i];\n\n    }\n\n    memset(output[3], 0, sizeof(output[3]));\n\n}\n", "idx": 183}
{"project": "FFmpeg", "commit_id": "d2a2b08cfe2ab382a4ad756c0a08ff78eb284ef9", "target": 0, "func": "static int config_props(AVFilterLink *outlink)\n\n{\n\n    AVFilterContext *ctx = outlink->src;\n\n    AVFilterLink *inlink = outlink->src->inputs[0];\n\n    ScaleContext *scale = ctx->priv;\n\n    int64_t w, h;\n\n\n\n    if (!(w = scale->w))\n\n        w = inlink->w;\n\n    if (!(h = scale->h))\n\n        h = inlink->h;\n\n    if (w == -1)\n\n        w = av_rescale(h, inlink->w, inlink->h);\n\n    if (h == -1)\n\n        h = av_rescale(w, inlink->h, inlink->w);\n\n\n\n    if (w > INT_MAX || h > INT_MAX ||\n\n        (h * inlink->w) > INT_MAX  ||\n\n        (w * inlink->h) > INT_MAX)\n\n        av_log(ctx, AV_LOG_ERROR, \"Rescaled value for width or height is too big.\\n\");\n\n\n\n    outlink->w = w;\n\n    outlink->h = h;\n\n\n\n    /* TODO: make algorithm configurable */\n\n    scale->sws = sws_getContext(inlink ->w, inlink ->h, inlink ->format,\n\n                                outlink->w, outlink->h, outlink->format,\n\n                                SWS_BILINEAR, NULL, NULL, NULL);\n\n\n\n    av_log(ctx, AV_LOG_INFO, \"w:%d h:%d fmt:%s\\n\",\n\n           outlink->w, outlink->h, av_pix_fmt_descriptors[outlink->format].name);\n\n\n\n    scale->input_is_pal = inlink->format == PIX_FMT_PAL8      ||\n\n                          inlink->format == PIX_FMT_BGR4_BYTE ||\n\n                          inlink->format == PIX_FMT_RGB4_BYTE ||\n\n                          inlink->format == PIX_FMT_BGR8      ||\n\n                          inlink->format == PIX_FMT_RGB8;\n\n\n\n    return !scale->sws;\n\n}\n", "idx": 188}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_pwt_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_read8(opaque, addr);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* FRC */\n\n        return s->frc;\n\n    case 0x04:\t/* VCR */\n\n        return s->vrc;\n\n    case 0x08:\t/* GCR */\n\n        return s->gcr;\n\n    }\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 227}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t lduw_be_phys(target_phys_addr_t addr)\n\n{\n\n    return lduw_phys_internal(addr, DEVICE_BIG_ENDIAN);\n\n}\n", "idx": 235}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static int find_stream_index(AVFormatContext *s)\n\n{\n\n    int i;\n\n    AVStream *st;\n\n\n\n    if (s->nb_streams <= 0)\n\n        return -1;\n\n    for(i = 0; i < s->nb_streams; i++) {\n\n        st = s->streams[i];\n\n        if (st->codec.codec_type == CODEC_TYPE_VIDEO) {\n\n            return i;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 253}
{"project": "qemu", "commit_id": "f332e830e38b3ff3953ef02ac04e409ae53769c5", "target": 1, "func": "static void parse_type_bool(Visitor *v, const char *name, bool *obj,\n\n                            Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n\n\n    if (siv->string) {\n\n        if (!strcasecmp(siv->string, \"on\") ||\n\n            !strcasecmp(siv->string, \"yes\") ||\n\n            !strcasecmp(siv->string, \"true\")) {\n\n            *obj = true;\n\n            return;\n\n        }\n\n        if (!strcasecmp(siv->string, \"off\") ||\n\n            !strcasecmp(siv->string, \"no\") ||\n\n            !strcasecmp(siv->string, \"false\")) {\n\n            *obj = false;\n\n            return;\n\n        }\n\n    }\n\n\n\n    error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n               \"boolean\");\n\n}\n", "idx": 257}
{"project": "FFmpeg", "commit_id": "d0d8a9b1384ba3cd465d6ef3439f3979d4518b4b", "target": 1, "func": "void ff_rtsp_undo_setup(AVFormatContext *s)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n\n        RTSPStream *rtsp_st = rt->rtsp_streams[i];\n\n        if (!rtsp_st)\n\n            continue;\n\n        if (rtsp_st->transport_priv) {\n\n            if (s->oformat) {\n\n                AVFormatContext *rtpctx = rtsp_st->transport_priv;\n\n                av_write_trailer(rtpctx);\n\n                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n                    uint8_t *ptr;\n\n                    url_close_dyn_buf(rtpctx->pb, &ptr);\n\n                    av_free(ptr);\n\n                } else {\n\n                    url_fclose(rtpctx->pb);\n\n                }\n\n                av_metadata_free(&rtpctx->streams[0]->metadata);\n\n                av_metadata_free(&rtpctx->metadata);\n\n\n                av_free(rtpctx->streams[0]);\n\n                av_free(rtpctx);\n\n            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)\n\n                ff_rdt_parse_close(rtsp_st->transport_priv);\n\n            else if (CONFIG_RTPDEC)\n\n                rtp_parse_close(rtsp_st->transport_priv);\n\n        }\n\n        rtsp_st->transport_priv = NULL;\n\n        if (rtsp_st->rtp_handle)\n\n            url_close(rtsp_st->rtp_handle);\n\n        rtsp_st->rtp_handle = NULL;\n\n    }\n\n}", "idx": 268}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t sp804_read(void *opaque, target_phys_addr_t offset,\n\n                           unsigned size)\n\n{\n\n    sp804_state *s = (sp804_state *)opaque;\n\n\n\n    if (offset < 0x20) {\n\n        return arm_timer_read(s->timer[0], offset);\n\n    }\n\n    if (offset < 0x40) {\n\n        return arm_timer_read(s->timer[1], offset - 0x20);\n\n    }\n\n\n\n    /* TimerPeriphID */\n\n    if (offset >= 0xfe0 && offset <= 0xffc) {\n\n        return sp804_ids[(offset - 0xfe0) >> 2];\n\n    }\n\n\n\n    switch (offset) {\n\n    /* Integration Test control registers, which we won't support */\n\n    case 0xf00: /* TimerITCR */\n\n    case 0xf04: /* TimerITOP (strictly write only but..) */\n\n        return 0;\n\n    }\n\n\n\n    hw_error(\"%s: Bad offset %x\\n\", __func__, (int)offset);\n\n    return 0;\n\n}\n", "idx": 292}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void timerlist_rearm(QEMUTimerList *timer_list)\n\n{\n\n    /* Interrupt execution to force deadline recalculation.  */\n\n    if (timer_list->clock->type == QEMU_CLOCK_VIRTUAL) {\n\n        qemu_start_warp_timer();\n\n    }\n\n    timerlist_notify(timer_list);\n\n}\n", "idx": 298}
{"project": "qemu", "commit_id": "13f59ae8157e8ec238fa8aefe5309909a1eeb7e2", "target": 0, "func": "bool error_is_type(Error *err, const char *fmt)\n\n{\n\n    const char *error_class;\n\n    char *ptr;\n\n    char *end;\n\n\n\n    if (!err) {\n\n        return false;\n\n    }\n\n\n\n    ptr = strstr(fmt, \"'class': '\");\n\n    assert(ptr != NULL);\n\n    ptr += strlen(\"'class': '\");\n\n\n\n    end = strchr(ptr, '\\'');\n\n    assert(end != NULL);\n\n\n\n    error_class = error_get_field(err, \"class\");\n\n    if (strlen(error_class) != end - ptr) {\n\n        return false;\n\n    }\n\n\n\n    return strncmp(ptr, error_class, end - ptr) == 0;\n\n}\n", "idx": 311}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_load_main(OneNANDState *s, int sec, int secn,\n\n                void *dest)\n\n{\n\n    if (s->bdrv_cur)\n\n        return bdrv_read(s->bdrv_cur, sec, dest, secn) < 0;\n\n    else if (sec + secn > s->secs_cur)\n\n        return 1;\n\n\n\n    memcpy(dest, s->current + (sec << 9), secn << 9);\n\n\n\n    return 0;\n\n}\n", "idx": 319}
{"project": "FFmpeg", "commit_id": "69e7daf6ce2a5893936ba18572c58180b29d67f9", "target": 1, "func": "static void generate_offset_lut(DiracGolombLUT *lut, int off)\n\n{\n\n    int idx;\n\n    for (idx = 0; idx < LUT_SIZE; idx++) {\n\n        DiracGolombLUT *l = &lut[idx];\n\n\n\n        INIT_RESIDUE(res);\n\n        SET_RESIDUE(res, idx, LUT_BITS);\n\n\n\n        l->preamble      = CONVERT_TO_RESIDUE(res >> (RSIZE_BITS - off), off);\n\n        l->preamble_bits = off;\n\n        l->sign = ((l->preamble >> (RSIZE_BITS - l->preamble_bits)) & 1) ? -1 : +1;\n\n\n\n        search_for_golomb(l, res << off, LUT_BITS - off);\n\n    }\n\n}\n", "idx": 342}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_pop_next_tx_descr(VMXNET3State *s,\n\n                          int qidx,\n\n                          struct Vmxnet3_TxDesc *txd,\n\n                          uint32_t *descr_idx)\n\n{\n\n    Vmxnet3Ring *ring = &s->txq_descr[qidx].tx_ring;\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n\n\n    vmxnet3_ring_read_curr_cell(d, ring, txd);\n\n    if (txd->gen == vmxnet3_ring_curr_gen(ring)) {\n\n        /* Only read after generation field verification */\n\n        smp_rmb();\n\n        /* Re-read to be sure we got the latest version */\n\n        vmxnet3_ring_read_curr_cell(d, ring, txd);\n\n        VMXNET3_RING_DUMP(VMW_RIPRN, \"TX\", qidx, ring);\n\n        *descr_idx = vmxnet3_ring_curr_cell_idx(ring);\n\n        vmxnet3_inc_tx_consumption_counter(s, qidx);\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 345}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_excp_BookE (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_APU]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00000000;\n\n    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00000000;\n\n    env->excp_prefix = 0x00000000;\n\n    env->ivor_mask = 0x0000FFE0;\n\n    env->ivpr_mask = 0xFFFF0000;\n\n    /* Hardware reset vector */\n\n    env->hreset_vector = 0xFFFFFFFCUL;\n\n#endif\n\n}\n", "idx": 346}
{"project": "qemu", "commit_id": "0ccb9c1d8128a020720d5c6abf99a470742a1b94", "target": 1, "func": "DISAS_INSN(divw)\n\n{\n\n    TCGv reg;\n\n    TCGv tmp;\n\n    TCGv src;\n\n    int sign;\n\n\n\n    sign = (insn & 0x100) != 0;\n\n    reg = DREG(insn, 9);\n\n    if (sign) {\n\n        tcg_gen_ext16s_i32(QREG_DIV1, reg);\n\n    } else {\n\n        tcg_gen_ext16u_i32(QREG_DIV1, reg);\n\n    }\n\n    SRC_EA(env, src, OS_WORD, sign, NULL);\n\n    tcg_gen_mov_i32(QREG_DIV2, src);\n\n    if (sign) {\n\n        gen_helper_divs(cpu_env, tcg_const_i32(1));\n\n    } else {\n\n        gen_helper_divu(cpu_env, tcg_const_i32(1));\n\n    }\n\n\n\n    tmp = tcg_temp_new();\n\n    src = tcg_temp_new();\n\n    tcg_gen_ext16u_i32(tmp, QREG_DIV1);\n\n    tcg_gen_shli_i32(src, QREG_DIV2, 16);\n\n    tcg_gen_or_i32(reg, tmp, src);\n\n\n\n    set_cc_op(s, CC_OP_FLAGS);\n\n}\n", "idx": 354}
{"project": "FFmpeg", "commit_id": "a165b53daa8a3a526d2328ca72c4aa9e7f163045", "target": 1, "func": "static void RENAME(vertical_compose53iL0)(uint8_t *_b0, uint8_t *_b1, uint8_t *_b2,\n\n                                          int width)\n\n{\n\n    int i;\n\n    TYPE *b0 = (TYPE *)_b0;\n\n    TYPE *b1 = (TYPE *)_b1;\n\n    TYPE *b2 = (TYPE *)_b2;\n\n    for (i = 0; i < width; i++)\n\n        b1[i] -= (b0[i] + b2[i] + 2) >> 2;\n\n}\n", "idx": 368}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static void handle_user_command(Monitor *mon, const char *cmdline)\n\n{\n\n    QDict *qdict;\n\n    const mon_cmd_t *cmd;\n\n\n\n    qdict = qdict_new();\n\n\n\n    cmd = monitor_parse_command(mon, cmdline, 0, mon->cmd_table, qdict);\n\n    if (!cmd)\n\n        goto out;\n\n\n\n    if (handler_is_async(cmd)) {\n\n        user_async_cmd_handler(mon, cmd, qdict);\n\n    } else if (handler_is_qobject(cmd)) {\n\n        QObject *data = NULL;\n\n\n\n        /* XXX: ignores the error code */\n\n        cmd->mhandler.cmd_new(mon, qdict, &data);\n\n        assert(!monitor_has_error(mon));\n\n        if (data) {\n\n            cmd->user_print(mon, data);\n\n            qobject_decref(data);\n\n        }\n\n    } else {\n\n        cmd->mhandler.cmd(mon, qdict);\n\n    }\n\n\n\nout:\n\n    QDECREF(qdict);\n\n}\n", "idx": 378}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_exception_return(DisasContext *s, TCGv pc)\n\n{\n\n    TCGv tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, 0xffffffff);\n\n    dead_tmp(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n", "idx": 390}
{"project": "qemu", "commit_id": "db0289b9b26cb653d5662f5d6a2a52d70243cd56", "target": 1, "func": "static bool bdrv_drain_recurse(BlockDriverState *bs, bool begin)\n\n{\n\n    BdrvChild *child, *tmp;\n\n    bool waited;\n\n\n\n    /* Ensure any pending metadata writes are submitted to bs->file.  */\n\n    bdrv_drain_invoke(bs, begin);\n\n\n\n    /* Wait for drained requests to finish */\n\n    waited = BDRV_POLL_WHILE(bs, atomic_read(&bs->in_flight) > 0);\n\n\n\n    QLIST_FOREACH_SAFE(child, &bs->children, next, tmp) {\n\n        BlockDriverState *bs = child->bs;\n\n        bool in_main_loop =\n\n            qemu_get_current_aio_context() == qemu_get_aio_context();\n\n        assert(bs->refcnt > 0);\n\n        if (in_main_loop) {\n\n            /* In case the recursive bdrv_drain_recurse processes a\n\n             * block_job_defer_to_main_loop BH and modifies the graph,\n\n             * let's hold a reference to bs until we are done.\n\n             *\n\n             * IOThread doesn't have such a BH, and it is not safe to call\n\n             * bdrv_unref without BQL, so skip doing it there.\n\n             */\n\n            bdrv_ref(bs);\n\n        }\n\n        waited |= bdrv_drain_recurse(bs, begin);\n\n        if (in_main_loop) {\n\n            bdrv_unref(bs);\n\n        }\n\n    }\n\n\n\n    return waited;\n\n}\n", "idx": 396}
{"project": "FFmpeg", "commit_id": "a8d67efa53dae1d14614e3a7bd4e77e4eab066ab", "target": 0, "func": "static int count_paired_channels(uint8_t (*layout_map)[3], int tags, int pos, int *current) {\n\n    int num_pos_channels = 0;\n\n    int first_cpe = 0;\n\n    int sce_parity = 0;\n\n    int i;\n\n    for (i = *current; i < tags; i++) {\n\n        if (layout_map[i][2] != pos)\n\n            break;\n\n        if (layout_map[i][0] == TYPE_CPE) {\n\n            if (sce_parity) {\n\n                if (pos == AAC_CHANNEL_FRONT || !first_cpe) {\n\n                    sce_parity = 0;\n\n                } else {\n\n                    return -1;\n\n                }\n\n            }\n\n            num_pos_channels += 2;\n\n            first_cpe = 1;\n\n        } else {\n\n            num_pos_channels++;\n\n            sce_parity ^= 1;\n\n        }\n\n    }\n\n    if (sce_parity &&\n\n        ((pos == AAC_CHANNEL_FRONT && first_cpe) || pos == AAC_CHANNEL_SIDE))\n\n            return -1;\n\n    *current = i;\n\n    return num_pos_channels;\n\n}\n", "idx": 420}
{"project": "qemu", "commit_id": "ecbb5ea1041d2894f5efb9317acd519c4fd81ad5", "target": 1, "func": "uint64_t helper_sublv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 - op2);\n\n    if (unlikely(((~tmp) ^ op1 ^ (-1UL)) & ((~tmp) ^ op2) & (1UL << 31))) {\n\n        helper_excp(EXCP_ARITH, EXCP_ARITH_OVERFLOW);\n\n    }\n\n    return op1;\n\n}\n", "idx": 427}
{"project": "FFmpeg", "commit_id": "5b0ad91b996506632708dcefc22d2835d04a4dba", "target": 1, "func": "static int img_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n    VideoData *s = s1->priv_data;\n\n    char filename[1024];\n\n    int ret;\n\n    ByteIOContext f1, *f;\n\n\n\n    if (get_frame_filename(filename, sizeof(filename),\n\n                           s->path, s->img_number) < 0)\n\n        return -EIO;\n\n    \n\n    if (!s->is_pipe) {\n\n        f = &f1;\n\n        if (url_fopen(f, filename, URL_RDONLY) < 0)\n\n            return -EIO;\n\n    } else {\n\n        f = &s1->pb;\n\n        if (url_feof(f))\n\n            return -EIO;\n\n    }\n\n\n\n    av_new_packet(pkt, s->img_size);\n\n    pkt->stream_index = 0;\n\n\n\n    switch(s->img_fmt) {\n\n    case IMGFMT_PGMYUV:\n\n        ret = pgm_read(s, f, pkt->data, pkt->size, 1);\n\n        break;\n\n    case IMGFMT_PGM:\n\n        ret = pgm_read(s, f, pkt->data, pkt->size, 0);\n\n        break;\n\n    case IMGFMT_YUV:\n\n        ret = yuv_read(s, filename, pkt->data, pkt->size);\n\n        break;\n\n    case IMGFMT_PPM:\n\n        ret = ppm_read(s, f, pkt->data, pkt->size);\n\n        break;\n\n    default:\n\n        return -EIO;\n\n    }\n\n    \n\n    if (!s->is_pipe) {\n\n        url_fclose(f);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        av_free_packet(pkt);\n\n        return -EIO; /* signal EOF */\n\n    } else {\n\n        s->img_number++;\n\n        return 0;\n\n    }\n\n}\n", "idx": 446}
{"project": "qemu", "commit_id": "c8057f951d64de93bfd01569c0a725baa9f94372", "target": 1, "func": "void configure_alarms(char const *opt)\n\n{\n\n    int i;\n\n    int cur = 0;\n\n    int count = ARRAY_SIZE(alarm_timers) - 1;\n\n    char *arg;\n\n    char *name;\n\n    struct qemu_alarm_timer tmp;\n\n\n\n    if (!strcmp(opt, \"?\")) {\n\n        show_available_alarms();\n\n        exit(0);\n\n    }\n\n\n\n    arg = g_strdup(opt);\n\n\n\n    /* Reorder the array */\n\n    name = strtok(arg, \",\");\n\n    while (name) {\n\n        for (i = 0; i < count && alarm_timers[i].name; i++) {\n\n            if (!strcmp(alarm_timers[i].name, name))\n\n                break;\n\n        }\n\n\n\n        if (i == count) {\n\n            fprintf(stderr, \"Unknown clock %s\\n\", name);\n\n            goto next;\n\n        }\n\n\n\n        if (i < cur)\n\n            /* Ignore */\n\n            goto next;\n\n\n\n\t/* Swap */\n\n        tmp = alarm_timers[i];\n\n        alarm_timers[i] = alarm_timers[cur];\n\n        alarm_timers[cur] = tmp;\n\n\n\n        cur++;\n\nnext:\n\n        name = strtok(NULL, \",\");\n\n    }\n\n\n\n    g_free(arg);\n\n\n\n    if (cur) {\n\n        /* Disable remaining timers */\n\n        for (i = cur; i < count; i++)\n\n            alarm_timers[i].name = NULL;\n\n    } else {\n\n        show_available_alarms();\n\n        exit(1);\n\n    }\n\n}\n", "idx": 449}
{"project": "qemu", "commit_id": "bef0fd5958120542f126f2dedbfce65d8839a94d", "target": 0, "func": "void ide_sector_read(IDEState *s)\n\n{\n\n    int64_t sector_num;\n\n    int ret, n;\n\n\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    s->error = 0; /* not needed by IDE spec, but needed by Windows */\n\n    sector_num = ide_get_sector(s);\n\n    n = s->nsector;\n\n    if (n == 0) {\n\n        /* no more sector to read from disk */\n\n        ide_transfer_stop(s);\n\n    } else {\n\n#if defined(DEBUG_IDE)\n\n        printf(\"read sector=%\" PRId64 \"\\n\", sector_num);\n\n#endif\n\n        if (n > s->req_nb_sectors)\n\n            n = s->req_nb_sectors;\n\n\n\n        bdrv_acct_start(s->bs, &s->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);\n\n        ret = bdrv_read(s->bs, sector_num, s->io_buffer, n);\n\n        bdrv_acct_done(s->bs, &s->acct);\n\n        if (ret != 0) {\n\n            if (ide_handle_rw_error(s, -ret,\n\n                BM_STATUS_PIO_RETRY | BM_STATUS_RETRY_READ))\n\n            {\n\n                return;\n\n            }\n\n        }\n\n        ide_transfer_start(s, s->io_buffer, 512 * n, ide_sector_read);\n\n        ide_set_irq(s->bus);\n\n        ide_set_sector(s, sector_num + n);\n\n        s->nsector -= n;\n\n    }\n\n}\n", "idx": 497}
{"project": "qemu", "commit_id": "249e7e0fff080df0eff54730f3b6459d92d61e5a", "target": 0, "func": "static void cpu_ioreq_pio(ioreq_t *req)\n\n{\n\n    int i;\n\n\n\n    if (req->dir == IOREQ_READ) {\n\n        if (!req->data_is_ptr) {\n\n            req->data = do_inp(req->addr, req->size);\n\n        } else {\n\n            uint32_t tmp;\n\n\n\n            for (i = 0; i < req->count; i++) {\n\n                tmp = do_inp(req->addr, req->size);\n\n                write_phys_req_item(req->data, req, i, &tmp);\n\n            }\n\n        }\n\n    } else if (req->dir == IOREQ_WRITE) {\n\n        if (!req->data_is_ptr) {\n\n            do_outp(req->addr, req->size, req->data);\n\n        } else {\n\n            for (i = 0; i < req->count; i++) {\n\n                uint32_t tmp = 0;\n\n\n\n                read_phys_req_item(req->data, req, i, &tmp);\n\n                do_outp(req->addr, req->size, tmp);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 498}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_display_character(sPAPREnvironment *spapr,\n\n                                   uint32_t token, uint32_t nargs,\n\n                                   target_ulong args,\n\n                                   uint32_t nret, target_ulong rets)\n\n{\n\n    uint8_t c = rtas_ld(args, 0);\n\n    VIOsPAPRDevice *sdev = vty_lookup(spapr, 0);\n\n\n\n    if (!sdev) {\n\n        rtas_st(rets, 0, -1);\n\n    } else {\n\n        vty_putchars(sdev, &c, sizeof(c));\n\n        rtas_st(rets, 0, 0);\n\n    }\n\n}\n", "idx": 512}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "static int bdrv_rd_badreq_sectors(BlockDriverState *bs,\n\n                                  int64_t sector_num, int nb_sectors)\n\n{\n\n    return\n\n        nb_sectors < 0 ||\n\n        sector_num < 0 ||\n\n        nb_sectors > bs->total_sectors ||\n\n        sector_num > bs->total_sectors - nb_sectors;\n\n}\n", "idx": 521}
{"project": "qemu", "commit_id": "2d40564aaab3a99fe6ce00fc0fc893c02e9443ec", "target": 1, "func": "static int handle_update_file_cred(int dirfd, const char *name, FsCred *credp)\n\n{\n\n    int fd, ret;\n\n    fd = openat(dirfd, name, O_NONBLOCK | O_NOFOLLOW);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n    ret = fchmod(fd, credp->fc_mode & 07777);\n\n    if (ret < 0) {\n\n        goto err_out;\n\n    }\n\n    ret = fchownat(fd, \"\", credp->fc_uid, credp->fc_gid, AT_EMPTY_PATH);\n\nerr_out:\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 526}
{"project": "qemu", "commit_id": "ccbcfedd17fd2d13521fcee66810d0df464ec1cc", "target": 1, "func": "int qemu_devtree_setprop(void *fdt, const char *node_path,\n\n                         const char *property, void *val_array, int size)\n\n{\n\n    int offset;\n\n\n\n    offset = fdt_path_offset(fdt, node_path);\n\n    if (offset < 0)\n\n        return offset;\n\n\n\n    return fdt_setprop(fdt, offset, property, val_array, size);\n\n}\n", "idx": 536}
{"project": "FFmpeg", "commit_id": "330deb75923675224fb9aed311d3d6ce3ec52420", "target": 1, "func": "static void backup_duplicate_context(MpegEncContext *bak, MpegEncContext *src){\n\n#define COPY(a) bak->a= src->a\n\n    COPY(allocated_edge_emu_buffer);\n\n    COPY(edge_emu_buffer);\n\n    COPY(me.scratchpad);\n\n    COPY(me.temp);\n\n    COPY(rd_scratchpad);\n\n    COPY(b_scratchpad);\n\n    COPY(obmc_scratchpad);\n\n    COPY(me.map);\n\n    COPY(me.score_map);\n\n    COPY(blocks);\n\n    COPY(block);\n\n    COPY(start_mb_y);\n\n    COPY(end_mb_y);\n\n    COPY(me.map_generation);\n\n    COPY(pb);\n\n    COPY(dct_error_sum);\n\n    COPY(dct_count[0]);\n\n    COPY(dct_count[1]);\n\n    COPY(ac_val_base);\n\n    COPY(ac_val[0]);\n\n    COPY(ac_val[1]);\n\n    COPY(ac_val[2]);\n\n#undef COPY\n\n}\n", "idx": 646}
{"project": "FFmpeg", "commit_id": "84343dd9d3b8e19c95c0f641a9f97915efec0633", "target": 0, "func": "static av_cold void free_frame_buffers(Indeo3DecodeContext *ctx)\n\n{\n\n    int p;\n\n\n\n    ctx->width=\n\n    ctx->height= 0;\n\n\n\n    for (p = 0; p < 3; p++) {\n\n        av_freep(&ctx->planes[p].buffers[0]);\n\n        av_freep(&ctx->planes[p].buffers[1]);\n\n        ctx->planes[p].pixels[0] = ctx->planes[p].pixels[1] = 0;\n\n    }\n\n}\n", "idx": 653}
{"project": "FFmpeg", "commit_id": "a8dbe9514f865f6a8efb304a720025cb1ef9ae3f", "target": 0, "func": "static AVInputFormat *probe_input_format(AVProbeData *pd, int is_opened)\n\n{\n\n    AVInputFormat *fmt1, *fmt;\n\n    int score, score_max;\n\n\n\n    fmt = NULL;\n\n    score_max = 0;\n\n    for(fmt1 = first_iformat; fmt1 != NULL; fmt1 = fmt1->next) {\n\n        if (!is_opened && !(fmt1->flags & AVFMT_NOFILE))\n\n            continue;\n\n        score = 0;\n\n        if (fmt1->extensions) {\n\n            if (match_ext(pd->filename, fmt1->extensions)) {\n\n                score = 50;\n\n            }\n\n        } else if (fmt1->read_probe) {\n\n            score = fmt1->read_probe(pd);\n\n        }\n\n        if (score > score_max) {\n\n            score_max = score;\n\n            fmt = fmt1;\n\n        }\n\n    }\n\n    return fmt;\n\n}\n", "idx": 668}
{"project": "qemu", "commit_id": "c9f4b77ad5783bd84bca4ab99d4b3d6ee61de01c", "target": 1, "func": "static void pc_dimm_check_memdev_is_busy(Object *obj, const char *name,\n\n                                      Object *val, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(val), errp);\n\n    if (memory_region_is_mapped(mr)) {\n\n        char *path = object_get_canonical_path_component(val);\n\n        error_setg(errp, \"can't use already busy memdev: %s\", path);\n\n        g_free(path);\n\n    } else {\n\n        qdev_prop_allow_set_link_before_realize(obj, name, val, errp);\n\n    }\n\n}\n", "idx": 670}
{"project": "FFmpeg", "commit_id": "69fa23961ededd725c68b188493cf2653d70f4fd", "target": 1, "func": "int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)\n\n{\n\n    int ret;\n\n    AVStream *st;\n\n\n\n    ff_read_frame_flush(s);\n\n\n\n    if(flags & AVSEEK_FLAG_BYTE)\n\n        return av_seek_frame_byte(s, stream_index, timestamp, flags);\n\n\n\n    if(stream_index < 0){\n\n        stream_index= av_find_default_stream_index(s);\n\n        if(stream_index < 0)\n\n            return -1;\n\n\n\n        st= s->streams[stream_index];\n\n       /* timestamp for default must be expressed in AV_TIME_BASE units */\n\n        timestamp = av_rescale(timestamp, st->time_base.den, AV_TIME_BASE * (int64_t)st->time_base.num);\n\n    }\n\n\n\n    /* first, we try the format specific seek */\n\n    if (s->iformat->read_seek)\n\n        ret = s->iformat->read_seek(s, stream_index, timestamp, flags);\n\n    else\n\n        ret = -1;\n\n    if (ret >= 0) {\n\n        return 0;\n\n    }\n\n\n\n    if(s->iformat->read_timestamp)\n\n        return av_seek_frame_binary(s, stream_index, timestamp, flags);\n\n    else\n\n        return av_seek_frame_generic(s, stream_index, timestamp, flags);\n\n}\n", "idx": 682}
{"project": "FFmpeg", "commit_id": "fa0f62c37d90c0760bddccba2054578e2c61ae1a", "target": 0, "func": "static int mpeg_mux_end(AVFormatContext *ctx)\n\n{\n\n    StreamInfo *stream;\n\n    int i;\n\n\n\n    /* flush each packet */\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        stream = ctx->streams[i]->priv_data;\n\n        if (stream->buffer_ptr > 0) {\n\n            if (i == (ctx->nb_streams - 1)) \n\n                flush_packet(ctx, i, 1);\n\n            else\n\n                flush_packet(ctx, i, 0);\n\n        }\n\n    }\n\n\n\n    /* write the end header */\n\n    //put_be32(&ctx->pb, ISO_11172_END_CODE);\n\n    //put_flush_packet(&ctx->pb);\n\n\n\n    for(i=0;i<ctx->nb_streams;i++)\n\n        av_freep(&ctx->streams[i]->priv_data);\n\n\n\n    return 0;\n\n}\n", "idx": 691}
{"project": "qemu", "commit_id": "83d768b5640946b7da55ce8335509df297e2c7cd", "target": 1, "func": "static void virtio_scsi_complete_req(VirtIOSCSIReq *req)\n\n{\n\n    VirtIOSCSI *s = req->dev;\n\n    VirtQueue *vq = req->vq;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n\n\n    qemu_iovec_from_buf(&req->resp_iov, 0, &req->resp, req->resp_size);\n\n    virtqueue_push(vq, &req->elem, req->qsgl.size + req->resp_iov.size);\n\n    if (s->dataplane_started && !s->dataplane_fenced) {\n\n        virtio_scsi_dataplane_notify(vdev, req);\n\n    } else {\n\n        virtio_notify(vdev, vq);\n\n    }\n\n\n\n    if (req->sreq) {\n\n        req->sreq->hba_private = NULL;\n\n        scsi_req_unref(req->sreq);\n\n    }\n\n    virtio_scsi_free_req(req);\n\n}\n", "idx": 696}
{"project": "qemu", "commit_id": "233aa5c2d1cf4655ffe335025a68cf5454f87dad", "target": 1, "func": "static int inet_connect_addr(struct addrinfo *addr, bool block,\n\n                             bool *in_progress)\n\n{\n\n    int sock, rc;\n\n\n\n    if (in_progress) {\n\n        *in_progress = false;\n\n    }\n\n\n\n    sock = qemu_socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);\n\n    if (sock < 0) {\n\n        fprintf(stderr, \"%s: socket(%s): %s\\n\", __func__,\n\n                inet_strfamily(addr->ai_family), strerror(errno));\n\n        return -1;\n\n    }\n\n    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));\n\n    if (!block) {\n\n        socket_set_nonblock(sock);\n\n    }\n\n    /* connect to peer */\n\n    do {\n\n        rc = 0;\n\n        if (connect(sock, addr->ai_addr, addr->ai_addrlen) < 0) {\n\n            rc = -socket_error();\n\n        }\n\n    } while (rc == -EINTR);\n\n\n\n    if (!block && QEMU_SOCKET_RC_INPROGRESS(rc)) {\n\n        if (in_progress) {\n\n            *in_progress = true;\n\n        }\n\n    } else if (rc < 0) {\n\n        closesocket(sock);\n\n        return -1;\n\n    }\n\n    return sock;\n\n}\n", "idx": 705}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_rfci(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    /* Restore CPU state */\n\n    gen_helper_rfci(cpu_env);\n\n    gen_sync_exception(ctx);\n\n#endif\n\n}\n", "idx": 712}
{"project": "FFmpeg", "commit_id": "ca8064d2d1b293d7a8011bf0a08005c11ae8ba67", "target": 1, "func": "static int opt_new_stream(const char *opt, const char *arg)\n\n{\n\n    AVFormatContext *oc;\n\n    if (nb_output_files <= 0) {\n\n        fprintf(stderr, \"At least one output file must be specified\\n\");\n\n        ffmpeg_exit(1);\n\n    }\n\n    oc = output_files[nb_output_files - 1];\n\n\n\n    if      (!strcmp(opt, \"newvideo\"   )) new_video_stream   (oc);\n\n    else if (!strcmp(opt, \"newaudio\"   )) new_audio_stream   (oc);\n\n    else if (!strcmp(opt, \"newsubtitle\")) new_subtitle_stream(oc);\n\n    else av_assert0(0);\n\n    return 0;\n\n}\n", "idx": 713}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "void ff_vp3_v_loop_filter_c(uint8_t *first_pixel, int stride, int *bounding_values)\n\n{\n\n    unsigned char *end;\n\n    int filter_value;\n\n    const int nstride= -stride;\n\n\n\n    for (end= first_pixel + 8; first_pixel < end; first_pixel++) {\n\n        filter_value =\n\n            (first_pixel[2 * nstride] - first_pixel[ stride])\n\n         +3*(first_pixel[0          ] - first_pixel[nstride]);\n\n        filter_value = bounding_values[(filter_value + 4) >> 3];\n\n        first_pixel[nstride] = av_clip_uint8(first_pixel[nstride] + filter_value);\n\n        first_pixel[0] = av_clip_uint8(first_pixel[0] - filter_value);\n\n    }\n\n}\n", "idx": 734}
{"project": "FFmpeg", "commit_id": "12ba1b2b4d5592c0e27b0fcc83db929e8d6a8eee", "target": 0, "func": "static inline void mct_decode(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n\n{\n\n    int i, csize = 1;\n\n    void *src[3];\n\n\n\n    for (i = 1; i < 3; i++)\n\n        if (tile->codsty[0].transform != tile->codsty[i].transform) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Transforms mismatch, MCT not supported\\n\");\n\n            return;\n\n        }\n\n\n\n    for (i = 0; i < 3; i++)\n\n        if (tile->codsty[0].transform == FF_DWT97)\n\n            src[i] = tile->comp[i].f_data;\n\n        else\n\n            src[i] = tile->comp[i].i_data;\n\n\n\n    for (i = 0; i < 2; i++)\n\n        csize *= tile->comp[0].coord[i][1] - tile->comp[0].coord[i][0];\n\n\n\n    s->dsp.mct_decode[tile->codsty[0].transform](src[0], src[1], src[2], csize);\n\n}\n", "idx": 757}
{"project": "FFmpeg", "commit_id": "3193b13aa1e271f6d2dd68de67d448c08aef3c00", "target": 1, "func": "static int hls_write_header(AVFormatContext *s)\n\n{\n\n    HLSContext *hls = s->priv_data;\n\n    int ret, i;\n\n    char *p;\n\n    const char *pattern = \"%d.ts\";\n\n    int basename_size = strlen(s->filename) + strlen(pattern);\n\n\n\n    hls->number      = 0;\n\n\n\n    hls->recording_time = hls->time * 1000000;\n\n    hls->start_pts      = AV_NOPTS_VALUE;\n\n\n\n    for (i = 0; i < s->nb_streams; i++)\n\n        hls->has_video +=\n\n            s->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO;\n\n\n\n    if (hls->has_video > 1)\n\n        av_log(s, AV_LOG_WARNING,\n\n               \"More than a single video stream present, \"\n\n               \"expect issues decoding it.\\n\");\n\n\n\n    hls->oformat = av_guess_format(\"mpegts\", NULL, NULL);\n\n\n\n    if (!hls->oformat) {\n\n        ret = AVERROR_MUXER_NOT_FOUND;\n\n        goto fail;\n\n    }\n\n\n\n    hls->basename = av_malloc(basename_size);\n\n\n\n    if (!hls->basename) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    strcpy(hls->basename, s->filename);\n\n\n\n    p = strrchr(hls->basename, '.');\n\n\n\n    if (p)\n\n        *p = '\\0';\n\n\n\n    av_strlcat(hls->basename, \"%d.ts\", basename_size);\n\n\n\n    if ((ret = hls_mux_init(s)) < 0)\n\n        goto fail;\n\n\n\n    if ((ret = hls_start(s)) < 0)\n\n        goto fail;\n\n\n\n    if ((ret = avformat_write_header(hls->avf, NULL)) < 0)\n\n        return ret;\n\n\n\n\n\nfail:\n\n    if (ret) {\n\n        av_free(hls->basename);\n\n        if (hls->avf)\n\n            avformat_free_context(hls->avf);\n\n    }\n\n    return ret;\n\n}\n", "idx": 771}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void vvfat_close(BlockDriverState *bs)\n\n{\n\n    BDRVVVFATState *s = bs->opaque;\n\n\n\n    vvfat_close_current_file(s);\n\n    array_free(&(s->fat));\n\n    array_free(&(s->directory));\n\n    array_free(&(s->mapping));\n\n    if(s->cluster_buffer)\n\n        free(s->cluster_buffer);\n\n}\n", "idx": 782}
{"project": "FFmpeg", "commit_id": "25a6666f6c07c6ac8449a63d7fbce0dfd29c54cd", "target": 0, "func": "static int ivi_mc(ivi_mc_func mc, int16_t *buf, const int16_t *ref_buf,\n\n                  int offs, int mv_x, int mv_y, uint32_t pitch,\n\n                  int mc_type)\n\n{\n\n    int ref_offs = offs + mv_y * pitch + mv_x;\n\n\n\n    if (offs < 0 || ref_offs < 0 || !ref_buf)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    mc(buf + offs, ref_buf + ref_offs, pitch, mc_type);\n\n\n\n    return 0;\n\n}\n", "idx": 795}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "static void test_io_channel_setup_sync(SocketAddressLegacy *listen_addr,\n\n                                       SocketAddressLegacy *connect_addr,\n\n                                       QIOChannel **src,\n\n                                       QIOChannel **dst)\n\n{\n\n    QIOChannelSocket *lioc;\n\n\n\n    lioc = qio_channel_socket_new();\n\n    qio_channel_socket_listen_sync(lioc, listen_addr, &error_abort);\n\n\n\n    if (listen_addr->type == SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        SocketAddressLegacy *laddr = qio_channel_socket_get_local_address(\n\n            lioc, &error_abort);\n\n\n\n        g_free(connect_addr->u.inet.data->port);\n\n        connect_addr->u.inet.data->port = g_strdup(laddr->u.inet.data->port);\n\n\n\n        qapi_free_SocketAddressLegacy(laddr);\n\n    }\n\n\n\n    *src = QIO_CHANNEL(qio_channel_socket_new());\n\n    qio_channel_socket_connect_sync(\n\n        QIO_CHANNEL_SOCKET(*src), connect_addr, &error_abort);\n\n    qio_channel_set_delay(*src, false);\n\n\n\n    qio_channel_wait(QIO_CHANNEL(lioc), G_IO_IN);\n\n    *dst = QIO_CHANNEL(qio_channel_socket_accept(lioc, &error_abort));\n\n    g_assert(*dst);\n\n\n\n    test_io_channel_set_socket_bufs(*src, *dst);\n\n\n\n    object_unref(OBJECT(lioc));\n\n}\n", "idx": 814}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static void monitor_readline(const char *prompt, int is_password,\n\n                             char *buf, int buf_size)\n\n{\n\n    readline_start(prompt, is_password, monitor_readline_cb, NULL);\n\n    readline_show_prompt();\n\n    monitor_readline_buf = buf;\n\n    monitor_readline_buf_size = buf_size;\n\n    monitor_readline_started = 1;\n\n    while (monitor_readline_started) {\n\n        main_loop_wait(10);\n\n    }\n\n}\n", "idx": 815}
{"project": "FFmpeg", "commit_id": "4f5eaf0b5956e492ee5023929669b1d09aaf6299", "target": 1, "func": "static av_always_inline void decode_dc_coeffs(GetBitContext *gb, int16_t *out,\n\n                                              int blocks_per_slice)\n\n{\n\n    int16_t prev_dc;\n\n    int code, i, sign;\n\n\n\n    OPEN_READER(re, gb);\n\n\n\n    DECODE_CODEWORD(code, FIRST_DC_CB);\n\n    prev_dc = TOSIGNED(code);\n\n    out[0] = prev_dc;\n\n\n\n    out += 64; // dc coeff for the next block\n\n\n\n    code = 5;\n\n    sign = 0;\n\n    for (i = 1; i < blocks_per_slice; i++, out += 64) {\n\n        DECODE_CODEWORD(code, dc_codebook[FFMIN(code, 6U)]);\n\n        if(code) sign ^= -(code & 1);\n\n        else     sign  = 0;\n\n        prev_dc += (((code + 1) >> 1) ^ sign) - sign;\n\n        out[0] = prev_dc;\n\n    }\n\n    CLOSE_READER(re, gb);\n\n}\n", "idx": 850}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "static void avc_luma_midh_qrt_and_aver_dst_8w_msa(const uint8_t *src,\n\n                                                  int32_t src_stride,\n\n                                                  uint8_t *dst,\n\n                                                  int32_t dst_stride,\n\n                                                  int32_t height,\n\n                                                  uint8_t horiz_offset)\n\n{\n\n    uint32_t multiple8_cnt;\n\n\n\n    for (multiple8_cnt = 2; multiple8_cnt--;) {\n\n        avc_luma_midh_qrt_and_aver_dst_4w_msa(src, src_stride, dst, dst_stride,\n\n                                              height, horiz_offset);\n\n\n\n        src += 4;\n\n        dst += 4;\n\n    }\n\n}\n", "idx": 854}
{"project": "qemu", "commit_id": "72f0d0bf51362011c4d841a89fb8f5cfb16e0bf3", "target": 1, "func": "static int mp_pacl_removexattr(FsContext *ctx,\n\n                               const char *path, const char *name)\n\n{\n\n    int ret;\n\n    char *buffer;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret  = lremovexattr(buffer, MAP_ACL_ACCESS);\n\n    if (ret == -1 && errno == ENODATA) {\n\n        /*\n\n         * We don't get ENODATA error when trying to remove a\n\n         * posix acl that is not present. So don't throw the error\n\n         * even in case of mapped security model\n\n         */\n\n        errno = 0;\n\n        ret = 0;\n\n    }\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 859}
{"project": "FFmpeg", "commit_id": "f1cd9b03f3fa875eb5e394281b4b688cec611658", "target": 1, "func": "static av_cold OMXContext *omx_init(void *logctx, const char *libname, const char *prefix)\n\n{\n\n    static const char * const libnames[] = {\n\n        \"libOMX_Core.so\",\n\n        \"libOmxCore.so\",\n\n        NULL\n\n    };\n\n    const char* const* nameptr;\n\n    int ret = AVERROR_ENCODER_NOT_FOUND;\n\n    OMXContext *omx_context;\n\n\n\n    omx_context = av_mallocz(sizeof(*omx_context));\n\n    if (!omx_context)\n\n        return NULL;\n\n    if (libname) {\n\n        ret = omx_try_load(omx_context, logctx, libname, prefix);\n\n        if (ret < 0) {\n\n            av_free(omx_context);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        for (nameptr = libnames; *nameptr; nameptr++)\n\n            if (!(ret = omx_try_load(omx_context, logctx, *nameptr, prefix)))\n\n                break;\n\n        if (!*nameptr) {\n\n            av_free(omx_context);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    omx_context->ptr_Init();\n\n    return omx_context;\n\n}\n", "idx": 863}
{"project": "FFmpeg", "commit_id": "cc276c85d15272df6e44fb3252657a43cbd49555", "target": 0, "func": "int av_get_channel_layout_nb_channels(int64_t channel_layout)\n\n{\n\n    int count;\n\n    uint64_t x = channel_layout;\n\n    for (count = 0; x; count++)\n\n        x &= x-1; // unset lowest set bit\n\n    return count;\n\n}\n", "idx": 867}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static void openpic_load_IRQ_queue(QEMUFile* f, IRQQueue *q)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)\n\n        qemu_get_be32s(f, &q->queue[i]);\n\n\n\n    qemu_get_sbe32s(f, &q->next);\n\n    qemu_get_sbe32s(f, &q->priority);\n\n}\n", "idx": 882}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_pin_cfg_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_read32(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t/* FUNC_MUX_CTRL_0 */\n\n    case 0x04:\t/* FUNC_MUX_CTRL_1 */\n\n    case 0x08:\t/* FUNC_MUX_CTRL_2 */\n\n        return s->func_mux_ctrl[addr >> 2];\n\n\n\n    case 0x0c:\t/* COMP_MODE_CTRL_0 */\n\n        return s->comp_mode_ctrl[0];\n\n\n\n    case 0x10:\t/* FUNC_MUX_CTRL_3 */\n\n    case 0x14:\t/* FUNC_MUX_CTRL_4 */\n\n    case 0x18:\t/* FUNC_MUX_CTRL_5 */\n\n    case 0x1c:\t/* FUNC_MUX_CTRL_6 */\n\n    case 0x20:\t/* FUNC_MUX_CTRL_7 */\n\n    case 0x24:\t/* FUNC_MUX_CTRL_8 */\n\n    case 0x28:\t/* FUNC_MUX_CTRL_9 */\n\n    case 0x2c:\t/* FUNC_MUX_CTRL_A */\n\n    case 0x30:\t/* FUNC_MUX_CTRL_B */\n\n    case 0x34:\t/* FUNC_MUX_CTRL_C */\n\n    case 0x38:\t/* FUNC_MUX_CTRL_D */\n\n        return s->func_mux_ctrl[(addr >> 2) - 1];\n\n\n\n    case 0x40:\t/* PULL_DWN_CTRL_0 */\n\n    case 0x44:\t/* PULL_DWN_CTRL_1 */\n\n    case 0x48:\t/* PULL_DWN_CTRL_2 */\n\n    case 0x4c:\t/* PULL_DWN_CTRL_3 */\n\n        return s->pull_dwn_ctrl[(addr & 0xf) >> 2];\n\n\n\n    case 0x50:\t/* GATE_INH_CTRL_0 */\n\n        return s->gate_inh_ctrl[0];\n\n\n\n    case 0x60:\t/* VOLTAGE_CTRL_0 */\n\n        return s->voltage_ctrl[0];\n\n\n\n    case 0x70:\t/* TEST_DBG_CTRL_0 */\n\n        return s->test_dbg_ctrl[0];\n\n\n\n    case 0x80:\t/* MOD_CONF_CTRL_0 */\n\n        return s->mod_conf_ctrl[0];\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 979}
{"project": "FFmpeg", "commit_id": "f1a4dd5e480932ee580fb686988599d46bb71637", "target": 1, "func": "static int decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n\n{\n\n    int t;\n\n\n\n    if (total_freq == 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    t = rc->range * (uint64_t)cumFreq / total_freq;\n\n\n\n    rc->code1 += t + 1;\n\n    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);\n\n\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n\n        unsigned byte = bytestream2_get_byte(gb);\n\n        rc->code = (rc->code << 8) | byte;\n\n        rc->code1 <<= 8;\n\n        rc->range <<= 8;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 1003}
{"project": "qemu", "commit_id": "271a916e8a4188b0ec94bafff18aa93de0047820", "target": 1, "func": "static always_inline void gen_rldimi (DisasContext *ctx, int mbn, int shn)\n\n{\n\n    uint64_t mask;\n\n    uint32_t sh, mb;\n\n\n\n    sh = SH(ctx->opcode) | (shn << 5);\n\n    mb = MB(ctx->opcode) | (mbn << 5);\n\n    if (likely(sh == 0)) {\n\n        if (likely(mb == 0)) {\n\n            gen_op_load_gpr_T0(rS(ctx->opcode));\n\n            goto do_store;\n\n        } else if (likely(mb == 63)) {\n\n            gen_op_load_gpr_T0(rA(ctx->opcode));\n\n            goto do_store;\n\n        }\n\n        gen_op_load_gpr_T0(rS(ctx->opcode));\n\n        gen_op_load_gpr_T1(rA(ctx->opcode));\n\n        goto do_mask;\n\n    }\n\n    gen_op_load_gpr_T0(rS(ctx->opcode));\n\n    gen_op_load_gpr_T1(rA(ctx->opcode));\n\n    gen_op_rotli64_T0(sh);\n\n do_mask:\n\n    mask = MASK(mb, 63 - sh);\n\n    gen_andi_T0_64(ctx, mask);\n\n    gen_andi_T1_64(ctx, ~mask);\n\n    gen_op_or();\n\n do_store:\n\n    gen_op_store_T0_gpr(rA(ctx->opcode));\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx);\n\n}\n", "idx": 1033}
{"project": "FFmpeg", "commit_id": "6e1a167c5564085385488b4f579e9efb987d4bfa", "target": 1, "func": "static int dx2_decode_slice_410(GetBitContext *gb, AVFrame *frame,\n\n                                int line, int left,\n\n                                uint8_t lru[3][8])\n\n{\n\n    int x, y, i, j;\n\n    int width   = frame->width;\n\n\n\n    int ystride = frame->linesize[0];\n\n    int ustride = frame->linesize[1];\n\n    int vstride = frame->linesize[2];\n\n\n\n    uint8_t *Y  = frame->data[0] + ystride * line;\n\n    uint8_t *U  = frame->data[1] + (ustride >> 2) * line;\n\n    uint8_t *V  = frame->data[2] + (vstride >> 2) * line;\n\n\n\n    for (y = 0; y < left - 3 && get_bits_left(gb) > 16; y += 4) {\n\n        for (x = 0; x < width; x += 4) {\n\n            for (j = 0; j < 4; j++)\n\n                for (i = 0; i < 4; i++)\n\n                    Y[x + i + j * ystride] = decode_sym(gb, lru[0]);\n\n            U[x >> 2] = decode_sym(gb, lru[1]) ^ 0x80;\n\n            V[x >> 2] = decode_sym(gb, lru[2]) ^ 0x80;\n\n        }\n\n\n\n        Y += ystride << 2;\n\n        U += ustride;\n\n        V += vstride;\n\n    }\n\n\n\n    return y;\n\n}\n", "idx": 1042}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_set_notdirty(CPUState *env, ram_addr_t ram_addr)\n\n{\n\n    LOG_INT(\"kqemu_set_notdirty: addr=%08lx\\n\", \n\n                (unsigned long)ram_addr);\n\n    /* we only track transitions to dirty state */\n\n    if (phys_ram_dirty[ram_addr >> TARGET_PAGE_BITS] != 0xff)\n\n        return;\n\n    if (nb_ram_pages_to_update >= KQEMU_MAX_RAM_PAGES_TO_UPDATE)\n\n        nb_ram_pages_to_update = KQEMU_RAM_PAGES_UPDATE_ALL;\n\n    else\n\n        ram_pages_to_update[nb_ram_pages_to_update++] = ram_addr;\n\n}\n", "idx": 1064}
{"project": "FFmpeg", "commit_id": "91abb473fb8432226918da4fe03365ebaf688978", "target": 0, "func": "static void put_no_rnd_pixels_y2_mmx( UINT8  *block, const UINT8 *pixels, int line_size, int h)\n\n{\n\n  UINT8  *p;\n\n  const UINT8 *pix;\n\n  p = block;\n\n  pix = pixels;\n\n  MOVQ_ZERO(mm7);\n\n  JUMPALIGN();\n\n  do {\n\n    __asm __volatile(\n\n\t\"movq\t%1, %%mm0\\n\\t\"\n\n\t\"movq\t%2, %%mm1\\n\\t\"\n\n\t\"movq\t%%mm0, %%mm2\\n\\t\"\n\n\t\"movq\t%%mm1, %%mm3\\n\\t\"\n\n\t\"punpcklbw %%mm7, %%mm0\\n\\t\"\n\n\t\"punpcklbw %%mm7, %%mm1\\n\\t\"\n\n\t\"punpckhbw %%mm7, %%mm2\\n\\t\"\n\n\t\"punpckhbw %%mm7, %%mm3\\n\\t\"\n\n\t\"paddusw %%mm1, %%mm0\\n\\t\"\n\n\t\"paddusw %%mm3, %%mm2\\n\\t\"\n\n\t\"psrlw\t$1, %%mm0\\n\\t\"\n\n\t\"psrlw\t$1, %%mm2\\n\\t\"\n\n\t\"packuswb  %%mm2, %%mm0\\n\\t\"\n\n\t\"movq\t%%mm0, %0\\n\\t\"\n\n\t:\"=m\"(*p)\n\n\t:\"m\"(*pix),\n\n\t \"m\"(*(pix+line_size))\n\n\t:\"memory\");\n\n   pix += line_size;\n\n   p +=   line_size;\n\n  } while(--h);\n\n}\n", "idx": 1065}
{"project": "FFmpeg", "commit_id": "7f6e05cdfd1242a6774e89283b6e2cefde191590", "target": 1, "func": "static inline int sym_quant(int c, int e, int levels)\n\n{\n\n    int v = ((((levels * c) >> (24 - e)) + 1) >> 1) + (levels >> 1);\n\n    av_assert2(v >= 0 && v < levels);\n\n    return v;\n\n}\n", "idx": 1090}
{"project": "qemu", "commit_id": "c34d2451ed32651e14e309f94009be07d231ee96", "target": 1, "func": "static inline int seek_to_sector(BlockDriverState *bs, int64_t sector_num)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    uint32_t index, offset, position;\n\n\n\n    index = sector_num / s->tracks;\n\n    offset = sector_num % s->tracks;\n\n\n\n    // not allocated\n\n    if ((index > s->catalog_size) || (s->catalog_bitmap[index] == 0))\n\n\treturn -1;\n\n\n\n    position = (s->catalog_bitmap[index] + offset) * 512;\n\n\n\n//    fprintf(stderr, \"sector: %llx index=%x offset=%x pointer=%x position=%x\\n\",\n\n//\tsector_num, index, offset, s->catalog_bitmap[index], position);\n\n\n\n    if (lseek(s->fd, position, SEEK_SET) != position)\n\n\treturn -1;\n\n\n\n    return 0;\n\n}\n", "idx": 1091}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_epit_reload_compare_timer(IMXEPITState *s)\n\n{\n\n    if ((s->cr & (CR_EN | CR_OCIEN)) == (CR_EN | CR_OCIEN))  {\n\n        /* if the compare feature is on and timers are running */\n\n        uint32_t tmp = imx_epit_update_count(s);\n\n        uint64_t next;\n\n        if (tmp > s->cmp) {\n\n            /* It'll fire in this round of the timer */\n\n            next = tmp - s->cmp;\n\n        } else { /* catch it next time around */\n\n            next = tmp - s->cmp + ((s->cr & CR_RLD) ? TIMER_MAX : s->lr);\n\n        }\n\n        ptimer_set_count(s->timer_cmp, next);\n\n    }\n\n}\n", "idx": 1101}
{"project": "qemu", "commit_id": "eca3ed0343ba413937f34ad4f8c4822dc82924e5", "target": 1, "func": "static int handle_intercept(CPUS390XState *env)\n\n{\n\n    struct kvm_run *run = env->kvm_run;\n\n    int icpt_code = run->s390_sieic.icptcode;\n\n    int r = 0;\n\n\n\n    dprintf(\"intercept: 0x%x (at 0x%lx)\\n\", icpt_code,\n\n            (long)env->kvm_run->psw_addr);\n\n    switch (icpt_code) {\n\n        case ICPT_INSTRUCTION:\n\n            r = handle_instruction(env, run);\n\n\n        case ICPT_WAITPSW:\n\n\n\n\n\n\n\n        case ICPT_CPU_STOP:\n\n            if (s390_del_running_cpu(env) == 0) {\n\n\n\n\n\n        case ICPT_SOFT_INTERCEPT:\n\n            fprintf(stderr, \"KVM unimplemented icpt SOFT\\n\");\n\n            exit(1);\n\n\n        case ICPT_IO:\n\n            fprintf(stderr, \"KVM unimplemented icpt IO\\n\");\n\n            exit(1);\n\n\n        default:\n\n            fprintf(stderr, \"Unknown intercept code: %d\\n\", icpt_code);\n\n            exit(1);\n\n\n\n\n\n    return r;\n", "idx": 1131}
{"project": "FFmpeg", "commit_id": "60819e694ee5733741da91ebc237b20621de5bc3", "target": 1, "func": "void av_cold ff_ivi_free_buffers(IVIPlaneDesc *planes)\n\n{\n\n    int p, b, t;\n\n\n\n    for (p = 0; p < 3; p++) {\n\n        for (b = 0; b < planes[p].num_bands; b++) {\n\n            av_freep(&planes[p].bands[b].bufs[0]);\n\n            av_freep(&planes[p].bands[b].bufs[1]);\n\n            av_freep(&planes[p].bands[b].bufs[2]);\n\n\n\n\n\n            for (t = 0; t < planes[p].bands[b].num_tiles; t++)\n\n                av_freep(&planes[p].bands[b].tiles[t].mbs);\n\n            av_freep(&planes[p].bands[b].tiles);\n\n        }\n\n        av_freep(&planes[p].bands);\n\n    }\n\n}", "idx": 1132}
{"project": "qemu", "commit_id": "f69a8bde29354493ff8aea64cc9cb3b531d16337", "target": 1, "func": "static gboolean qio_channel_websock_handshake_send(QIOChannel *ioc,\n\n                                                   GIOCondition condition,\n\n                                                   gpointer user_data)\n\n{\n\n    QIOTask *task = user_data;\n\n    QIOChannelWebsock *wioc = QIO_CHANNEL_WEBSOCK(\n\n        qio_task_get_source(task));\n\n    Error *err = NULL;\n\n    ssize_t ret;\n\n\n\n    ret = qio_channel_write(wioc->master,\n\n                            (char *)wioc->encoutput.buffer,\n\n                            wioc->encoutput.offset,\n\n                            &err);\n\n\n\n    if (ret < 0) {\n\n        trace_qio_channel_websock_handshake_fail(ioc);\n\n        qio_task_set_error(task, err);\n\n        qio_task_complete(task);\n\n        return FALSE;\n\n    }\n\n\n\n    buffer_advance(&wioc->encoutput, ret);\n\n    if (wioc->encoutput.offset == 0) {\n\n        trace_qio_channel_websock_handshake_complete(ioc);\n\n        qio_task_complete(task);\n\n        return FALSE;\n\n    }\n\n    trace_qio_channel_websock_handshake_pending(ioc, G_IO_OUT);\n\n    return TRUE;\n\n}\n", "idx": 1150}
{"project": "FFmpeg", "commit_id": "840c3c05316a59c70a7470ed27aaa9c2f3ba410a", "target": 1, "func": "static int pix_norm1_altivec(uint8_t *pix, int line_size)\n\n{\n\n    int i, s = 0;\n\n    const vector unsigned int zero =\n\n        (const vector unsigned int) vec_splat_u32(0);\n\n    vector unsigned int sv = (vector unsigned int) vec_splat_u32(0);\n\n    vector signed int sum;\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        /* Read the potentially unaligned pixels. */\n\n        //vector unsigned char pixl = vec_ld(0,  pix);\n\n        //vector unsigned char pixr = vec_ld(15, pix);\n\n        //vector unsigned char pixv = vec_perm(pixl, pixr, perm);\n\n        vector unsigned char pixv = vec_vsx_ld(0,  pix);\n\n\n\n        /* Square the values, and add them to our sum. */\n\n        sv = vec_msum(pixv, pixv, sv);\n\n\n\n        pix += line_size;\n\n    }\n\n    /* Sum up the four partial sums, and put the result into s. */\n\n    sum = vec_sums((vector signed int) sv, (vector signed int) zero);\n\n    sum = vec_splat(sum, 3);\n\n    vec_vsx_st(sum, 0, &s);\n\n    return s;\n\n}\n", "idx": 1151}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_uint8(TestInputVisitorData *data,\n\n                                             const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_U8);\n\n}\n", "idx": 1161}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static void scsi_disk_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_CLASS(klass);\n\n\n\n    sc->init         = scsi_disk_initfn;\n\n    sc->destroy      = scsi_destroy;\n\n    sc->alloc_req    = scsi_new_request;\n\n    sc->unit_attention_reported = scsi_disk_unit_attention_reported;\n\n    dc->fw_name = \"disk\";\n\n    dc->desc = \"virtual SCSI disk or CD-ROM (legacy)\";\n\n    dc->reset = scsi_disk_reset;\n\n    dc->props = scsi_disk_properties;\n\n    dc->vmsd  = &vmstate_scsi_disk_state;\n\n}\n", "idx": 1180}
{"project": "qemu", "commit_id": "5add35bec1e249bb5345a47008c8f298d4760be4", "target": 0, "func": "static void test_tco2_status_bits(void)\n\n{\n\n    TestData d;\n\n    uint16_t ticks = 8;\n\n    uint16_t val;\n\n    int ret;\n\n\n\n    d.args = \"-watchdog-action none\";\n\n    test_init(&d);\n\n\n\n    stop_tco(&d);\n\n    clear_tco_status(&d);\n\n    reset_on_second_timeout(true);\n\n    set_tco_timeout(&d, ticks);\n\n    load_tco(&d);\n\n    start_tco(&d);\n\n    clock_step(ticks * TCO_TICK_NSEC * 2);\n\n\n\n    val = qpci_io_readw(d.dev, d.tco_io_base + TCO2_STS);\n\n    ret = val & (TCO_SECOND_TO_STS | TCO_BOOT_STS) ? 1 : 0;\n\n    g_assert(ret == 1);\n\n    qpci_io_writew(d.dev, d.tco_io_base + TCO2_STS, val);\n\n    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO2_STS), ==, 0);\n\n    qtest_end();\n\n}\n", "idx": 1193}
{"project": "qemu", "commit_id": "46181129eac9a56d9a948667282dd03d5015f096", "target": 0, "func": "int bdrv_child_check_perm(BdrvChild *c, uint64_t perm, uint64_t shared,\n\n                          Error **errp)\n\n{\n\n    return bdrv_check_update_perm(c->bs, perm, shared, c, errp);\n\n}\n", "idx": 1219}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void ide_flush_cb(void *opaque, int ret)\n\n{\n\n    IDEState *s = opaque;\n\n\n\n    s->pio_aiocb = NULL;\n\n\n\n    if (ret == -ECANCELED) {\n\n        return;\n\n    }\n\n    if (ret < 0) {\n\n        /* XXX: What sector number to set here? */\n\n        if (ide_handle_rw_error(s, -ret, IDE_RETRY_FLUSH)) {\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (s->bs) {\n\n        block_acct_done(bdrv_get_stats(s->bs), &s->acct);\n\n    }\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    ide_cmd_done(s);\n\n    ide_set_irq(s->bus);\n\n}\n", "idx": 1249}
{"project": "qemu", "commit_id": "adbecc89731cf3e0ae656d50ea9fa58c589c4bdc", "target": 0, "func": "static int ehci_init_transfer(EHCIPacket *p)\n\n{\n\n    uint32_t cpage, offset, bytes, plen;\n\n    dma_addr_t page;\n\n    USBBus *bus = &p->queue->ehci->bus;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    cpage  = get_field(p->qtd.token, QTD_TOKEN_CPAGE);\n\n    bytes  = get_field(p->qtd.token, QTD_TOKEN_TBYTES);\n\n    offset = p->qtd.bufptr[0] & ~QTD_BUFPTR_MASK;\n\n    qemu_sglist_init(&p->sgl, qbus->parent, 5, p->queue->ehci->as);\n\n\n\n    while (bytes > 0) {\n\n        if (cpage > 4) {\n\n            fprintf(stderr, \"cpage out of range (%d)\\n\", cpage);\n\n            return -1;\n\n        }\n\n\n\n        page  = p->qtd.bufptr[cpage] & QTD_BUFPTR_MASK;\n\n        page += offset;\n\n        plen  = bytes;\n\n        if (plen > 4096 - offset) {\n\n            plen = 4096 - offset;\n\n            offset = 0;\n\n            cpage++;\n\n        }\n\n\n\n        qemu_sglist_add(&p->sgl, page, plen);\n\n        bytes -= plen;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1265}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_register_kernel_code(const char *kernel_code)\n\n{\n\n    int i, ret = 0;\n\n    LOCK_OPENCL;\n\n    if (gpu_env.kernel_code_count >= MAX_KERNEL_CODE_NUM) {\n\n        av_log(&openclutils, AV_LOG_ERROR,\n\n         \"Could not register kernel code, maximum number of registered kernel code %d already reached\\n\",\n\n         MAX_KERNEL_CODE_NUM);\n\n        ret = AVERROR(EINVAL);\n\n        goto end;\n\n    }\n\n    for (i = 0; i < gpu_env.kernel_code_count; i++) {\n\n        if (gpu_env.kernel_code[i].kernel_string == kernel_code) {\n\n            av_log(&openclutils, AV_LOG_WARNING, \"Same kernel code has been registered\\n\");\n\n            goto end;\n\n        }\n\n    }\n\n    gpu_env.kernel_code[gpu_env.kernel_code_count].kernel_string = kernel_code;\n\n    gpu_env.kernel_code[gpu_env.kernel_code_count].is_compiled = 0;\n\n    gpu_env.kernel_code_count++;\n\nend:\n\n    UNLOCK_OPENCL;\n\n    return ret;\n\n}\n", "idx": 1274}
{"project": "qemu", "commit_id": "260fecf13b0d30621dc88da03dc1b502b7358c6b", "target": 0, "func": "BdrvChild *bdrv_open_child(const char *filename,\n\n                           QDict *options, const char *bdref_key,\n\n                           BlockDriverState* parent,\n\n                           const BdrvChildRole *child_role,\n\n                           bool allow_none, Error **errp)\n\n{\n\n    BdrvChild *c = NULL;\n\n    BlockDriverState *bs;\n\n    QDict *image_options;\n\n    int ret;\n\n    char *bdref_key_dot;\n\n    const char *reference;\n\n\n\n    assert(child_role != NULL);\n\n\n\n    bdref_key_dot = g_strdup_printf(\"%s.\", bdref_key);\n\n    qdict_extract_subqdict(options, &image_options, bdref_key_dot);\n\n    g_free(bdref_key_dot);\n\n\n\n    reference = qdict_get_try_str(options, bdref_key);\n\n    if (!filename && !reference && !qdict_size(image_options)) {\n\n        if (!allow_none) {\n\n            error_setg(errp, \"A block device must be specified for \\\"%s\\\"\",\n\n                       bdref_key);\n\n        }\n\n        QDECREF(image_options);\n\n        goto done;\n\n    }\n\n\n\n    bs = NULL;\n\n    ret = bdrv_open_inherit(&bs, filename, reference, image_options, 0,\n\n                            parent, child_role, errp);\n\n    if (ret < 0) {\n\n        goto done;\n\n    }\n\n\n\n    c = bdrv_attach_child(parent, bs, child_role);\n\n\n\ndone:\n\n    qdict_del(options, bdref_key);\n\n    return c;\n\n}\n", "idx": 1292}
{"project": "FFmpeg", "commit_id": "5bca5f87d1a32669e0357790e0d0ad8a5c9c998b", "target": 0, "func": "av_cold void ff_videodsp_init_x86(VideoDSPContext *ctx, int bpc)\n\n{\n\n#if HAVE_YASM\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if ARCH_X86_32\n\n    if (EXTERNAL_MMX(cpu_flags) && bpc <= 8) {\n\n        ctx->emulated_edge_mc = emulated_edge_mc_mmx;\n\n    }\n\n    if (EXTERNAL_AMD3DNOW(cpu_flags)) {\n\n        ctx->prefetch = ff_prefetch_3dnow;\n\n    }\n\n#endif /* ARCH_X86_32 */\n\n    if (EXTERNAL_MMXEXT(cpu_flags)) {\n\n        ctx->prefetch = ff_prefetch_mmxext;\n\n#if ARCH_X86_32\n\n        if (bpc <= 8)\n\n            ctx->emulated_edge_mc = emulated_edge_mc_mmxext;\n\n#endif /* ARCH_X86_32 */\n\n    }\n\n#if ARCH_X86_32\n\n    if (EXTERNAL_SSE(cpu_flags) && bpc <= 8) {\n\n        ctx->emulated_edge_mc = emulated_edge_mc_sse;\n\n    }\n\n#endif /* ARCH_X86_32 */\n\n    if (EXTERNAL_SSE2(cpu_flags) && bpc <= 8) {\n\n        ctx->emulated_edge_mc = emulated_edge_mc_sse2;\n\n    }\n\n#endif /* HAVE_YASM */\n\n}\n", "idx": 1324}
{"project": "qemu", "commit_id": "4c1396cb576c9b14425558b73de1584c7a9735d7", "target": 1, "func": "static void vapic_write(void *opaque, hwaddr addr, uint64_t data,\n\n                        unsigned int size)\n\n{\n\n    CPUState *cs = current_cpu;\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    hwaddr rom_paddr;\n\n    VAPICROMState *s = opaque;\n\n\n\n    cpu_synchronize_state(cs);\n\n\n\n    /*\n\n     * The VAPIC supports two PIO-based hypercalls, both via port 0x7E.\n\n     *  o 16-bit write access:\n\n     *    Reports the option ROM initialization to the hypervisor. Written\n\n     *    value is the offset of the state structure in the ROM.\n\n     *  o 8-bit write access:\n\n     *    Reactivates the VAPIC after a guest hibernation, i.e. after the\n\n     *    option ROM content has been re-initialized by a guest power cycle.\n\n     *  o 32-bit write access:\n\n     *    Poll for pending IRQs, considering the current VAPIC state.\n\n     */\n\n    switch (size) {\n\n    case 2:\n\n        if (s->state == VAPIC_INACTIVE) {\n\n            rom_paddr = (env->segs[R_CS].base + env->eip) & ROM_BLOCK_MASK;\n\n            s->rom_state_paddr = rom_paddr + data;\n\n\n\n            s->state = VAPIC_STANDBY;\n\n        }\n\n        if (vapic_prepare(s) < 0) {\n\n            s->state = VAPIC_INACTIVE;\n\n            s->rom_state_paddr = 0;\n\n            break;\n\n        }\n\n        break;\n\n    case 1:\n\n        if (kvm_enabled()) {\n\n            /*\n\n             * Disable triggering instruction in ROM by writing a NOP.\n\n             *\n\n             * We cannot do this in TCG mode as the reported IP is not\n\n             * accurate.\n\n             */\n\n            pause_all_vcpus();\n\n            patch_byte(cpu, env->eip - 2, 0x66);\n\n            patch_byte(cpu, env->eip - 1, 0x90);\n\n            resume_all_vcpus();\n\n        }\n\n\n\n        if (s->state == VAPIC_ACTIVE) {\n\n            break;\n\n        }\n\n        if (update_rom_mapping(s, env, env->eip) < 0) {\n\n            break;\n\n        }\n\n        if (find_real_tpr_addr(s, env) < 0) {\n\n            break;\n\n        }\n\n        vapic_enable(s, cpu);\n\n        break;\n\n    default:\n\n    case 4:\n\n        if (!kvm_irqchip_in_kernel()) {\n\n            apic_poll_irq(cpu->apic_state);\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 1337}
{"project": "qemu", "commit_id": "7c72ac49ae9f38fa0125296e05988655157decb5", "target": 0, "func": "static bool riccb_needed(void *opaque)\n\n{\n\n#ifdef CONFIG_KVM\n\n    if (kvm_enabled()) {\n\n        return kvm_s390_get_ri();\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 1347}
{"project": "qemu", "commit_id": "dde522bbc5feb2862afb243bb49c590fe65dce66", "target": 0, "func": "static int virtio_ccw_load_config(DeviceState *d, QEMUFile *f)\n\n{\n\n    VirtioCcwDevice *dev = VIRTIO_CCW_DEVICE(d);\n\n    CcwDevice *ccw_dev = CCW_DEVICE(d);\n\n    CCWDeviceClass *ck = CCW_DEVICE_GET_CLASS(ccw_dev);\n\n    SubchDev *s = ccw_dev->sch;\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(s);\n\n    int len;\n\n\n\n    s->driver_data = dev;\n\n    subch_device_load(s, f);\n\n    /* Re-fill subch_id after loading the subchannel states.*/\n\n    if (ck->refill_ids) {\n\n        ck->refill_ids(ccw_dev);\n\n    }\n\n    len = qemu_get_be32(f);\n\n    if (len != 0) {\n\n        dev->indicators = get_indicator(qemu_get_be64(f), len);\n\n    } else {\n\n        qemu_get_be64(f);\n\n        dev->indicators = NULL;\n\n    }\n\n    len = qemu_get_be32(f);\n\n    if (len != 0) {\n\n        dev->indicators2 = get_indicator(qemu_get_be64(f), len);\n\n    } else {\n\n        qemu_get_be64(f);\n\n        dev->indicators2 = NULL;\n\n    }\n\n    len = qemu_get_be32(f);\n\n    if (len != 0) {\n\n        dev->summary_indicator = get_indicator(qemu_get_be64(f), len);\n\n    } else {\n\n        qemu_get_be64(f);\n\n        dev->summary_indicator = NULL;\n\n    }\n\n    qemu_get_be16s(f, &vdev->config_vector);\n\n    dev->routes.adapter.ind_offset = qemu_get_be64(f);\n\n    dev->thinint_isc = qemu_get_byte(f);\n\n    dev->revision = qemu_get_be32(f);\n\n    if (s->thinint_active) {\n\n        return css_register_io_adapter(CSS_IO_ADAPTER_VIRTIO,\n\n                                       dev->thinint_isc, true, false,\n\n                                       &dev->routes.adapter.adapter_id);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 1361}
{"project": "qemu", "commit_id": "8a0e11045d5f50d300e0ab1ba05f4c8217fb5dcb", "target": 0, "func": "PCIBus *pci_pmac_u3_init(qemu_irq *pic,\n\n                         MemoryRegion *address_space_mem,\n\n                         MemoryRegion *address_space_io)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    PCIHostState *h;\n\n    UNINState *d;\n\n\n\n    /* Uninorth AGP bus */\n\n\n\n    dev = qdev_create(NULL, TYPE_U3_AGP_HOST_BRIDGE);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n    h = PCI_HOST_BRIDGE(dev);\n\n    d = U3_AGP_HOST_BRIDGE(dev);\n\n\n\n    memory_region_init(&d->pci_mmio, OBJECT(d), \"pci-mmio\", 0x100000000ULL);\n\n    memory_region_init_alias(&d->pci_hole, OBJECT(d), \"pci-hole\", &d->pci_mmio,\n\n                             0x80000000ULL, 0x70000000ULL);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000ULL,\n\n                                &d->pci_hole);\n\n\n\n    h->bus = pci_register_bus(dev, \"pci\",\n\n                              pci_unin_set_irq, pci_unin_map_irq,\n\n                              pic,\n\n                              &d->pci_mmio,\n\n                              address_space_io,\n\n                              PCI_DEVFN(11, 0), 4, TYPE_PCI_BUS);\n\n\n\n    sysbus_mmio_map(s, 0, 0xf0800000);\n\n    sysbus_mmio_map(s, 1, 0xf0c00000);\n\n\n\n    pci_create_simple(h->bus, 11 << 3, \"u3-agp\");\n\n\n\n    return h->bus;\n\n}\n", "idx": 1366}
{"project": "FFmpeg", "commit_id": "083d0f6be8a22ce936c4be6f17977104e516434f", "target": 1, "func": "static void filter_samples(AVFilterLink *inlink, AVFilterBufferRef *samplesref)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    int i;\n\n\n\n    for (i = 0; i < ctx->nb_outputs; i++)\n\n        ff_filter_samples(inlink->dst->outputs[i],\n\n                          avfilter_ref_buffer(samplesref, ~AV_PERM_WRITE));\n\n\n}", "idx": 1372}
{"project": "qemu", "commit_id": "0e438cdc932a785de72166af4641aafa103a6670", "target": 1, "func": "void coroutine_fn qemu_co_mutex_lock(CoMutex *mutex)\n\n{\n\n    Coroutine *self = qemu_coroutine_self();\n\n\n\n    trace_qemu_co_mutex_lock_entry(mutex, self);\n\n\n\n    while (mutex->locked) {\n\n        qemu_co_queue_wait(&mutex->queue);\n\n    }\n\n\n\n    mutex->locked = true;\n\n\n\n\n    trace_qemu_co_mutex_lock_return(mutex, self);\n\n}", "idx": 1385}
{"project": "FFmpeg", "commit_id": "9f06c1c61e876e930753da200bfe835817e30a53", "target": 1, "func": "static inline int decode_residual_inter(AVSContext *h) {\n\n    int block;\n\n\n\n    /* get coded block pattern */\n\n    int cbp= get_ue_golomb(&h->s.gb);\n\n    if(cbp > 63){\n\n        av_log(h->s.avctx, AV_LOG_ERROR, \"illegal inter cbp\\n\");\n\n        return -1;\n\n    }\n\n    h->cbp = cbp_tab[cbp][1];\n\n\n\n    /* get quantizer */\n\n    if(h->cbp && !h->qp_fixed)\n\n        h->qp = (h->qp + get_se_golomb(&h->s.gb)) & 63;\n\n    for(block=0;block<4;block++)\n\n        if(h->cbp & (1<<block))\n\n            decode_residual_block(h,&h->s.gb,ff_cavs_inter_dec,0,h->qp,\n\n                                  h->cy + h->luma_scan[block], h->l_stride);\n\n    decode_residual_chroma(h);\n\n\n\n    return 0;\n\n}\n", "idx": 1388}
{"project": "qemu", "commit_id": "962d4b2834e6a3b37784391a906b5fe2a7e96b74", "target": 1, "func": "static void fw_cfg_write(FWCfgState *s, uint8_t value)\n\n{\n\n    int arch = !!(s->cur_entry & FW_CFG_ARCH_LOCAL);\n\n    FWCfgEntry *e = &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];\n\n\n\n    FW_CFG_DPRINTF(\"write %d\\n\", value);\n\n\n\n    if (s->cur_entry & FW_CFG_WRITE_CHANNEL && s->cur_offset < e->len) {\n\n        e->data[s->cur_offset++] = value;\n\n        if (s->cur_offset == e->len) {\n\n            e->callback(e->callback_opaque, e->data);\n\n            s->cur_offset = 0;\n\n        }\n\n    }\n\n}\n", "idx": 1407}
{"project": "qemu", "commit_id": "548f52ea06951c20f0b91cae6cde0512ec073c83", "target": 1, "func": "int qemu_peek_buffer(QEMUFile *f, uint8_t *buf, int size, size_t offset)\n\n{\n\n    int pending;\n\n    int index;\n\n\n\n    assert(!qemu_file_is_writable(f));\n\n\n\n    index = f->buf_index + offset;\n\n    pending = f->buf_size - index;\n\n    if (pending < size) {\n\n        qemu_fill_buffer(f);\n\n        index = f->buf_index + offset;\n\n        pending = f->buf_size - index;\n\n    }\n\n\n\n    if (pending <= 0) {\n\n        return 0;\n\n    }\n\n    if (size > pending) {\n\n        size = pending;\n\n    }\n\n\n\n    memcpy(buf, f->buf + index, size);\n\n    return size;\n\n}\n", "idx": 1409}
{"project": "qemu", "commit_id": "61f52e06f0a21bab782f98ef3ea789aa6d0aa046", "target": 1, "func": "static int ahci_dma_rw_buf(IDEDMA *dma, int is_write)\n\n{\n\n    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n\n    IDEState *s = &ad->port.ifs[0];\n\n    uint8_t *p = s->io_buffer + s->io_buffer_index;\n\n    int l = s->io_buffer_size - s->io_buffer_index;\n\n\n\n    if (ahci_populate_sglist(ad, &s->sg)) {\n\n        return 0;\n\n    }\n\n\n\n    if (is_write) {\n\n        dma_buf_read(p, l, &s->sg);\n\n    } else {\n\n        dma_buf_write(p, l, &s->sg);\n\n    }\n\n\n\n    /* update number of transferred bytes */\n\n    ad->cur_cmd->status = cpu_to_le32(le32_to_cpu(ad->cur_cmd->status) + l);\n\n    s->io_buffer_index += l;\n\n\n\n    DPRINTF(ad->port_no, \"len=%#x\\n\", l);\n\n\n\n    return 1;\n\n}\n", "idx": 1410}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static DeviceState *sun4c_intctl_init(target_phys_addr_t addr,\n\n                                      qemu_irq *parent_irq)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    unsigned int i;\n\n\n\n    dev = qdev_create(NULL, \"sun4c_intctl\");\n\n    qdev_init(dev);\n\n\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    for (i = 0; i < MAX_PILS; i++) {\n\n        sysbus_connect_irq(s, i, parent_irq[i]);\n\n    }\n\n    sysbus_mmio_map(s, 0, addr);\n\n\n\n    return dev;\n\n}\n", "idx": 1418}
{"project": "FFmpeg", "commit_id": "87f29996415ad2c06ab00583d709fa03b5185305", "target": 1, "func": "static int gif_image_write_header(AVFormatContext *s, int width, int height,\n\n                                  int loop_count, uint32_t *palette)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVRational sar = s->streams[0]->codec->sample_aspect_ratio;\n\n    int i, aspect = 0;\n\n\n\n    if (sar.num > 0 && sar.den > 0) {\n\n        aspect = sar.num * 64 / sar.den - 15;\n\n        if (aspect < 0 || aspect > 255)\n\n            aspect = 0;\n\n    }\n\n\n\n    avio_write(pb, \"GIF\", 3);\n\n    avio_write(pb, \"89a\", 3);\n\n    avio_wl16(pb, width);\n\n    avio_wl16(pb, height);\n\n\n\n    if (palette) {\n\n        avio_w8(pb, 0xf7); /* flags: global clut, 256 entries */\n\n        avio_w8(pb, 0x1f); /* background color index */\n\n        avio_w8(pb, aspect);\n\n        for (i = 0; i < 256; i++) {\n\n            const uint32_t v = palette[i] & 0xffffff;\n\n            avio_wb24(pb, v);\n\n        }\n\n    } else {\n\n        avio_w8(pb, 0); /* flags */\n\n        avio_w8(pb, 0); /* background color index */\n\n        avio_w8(pb, aspect);\n\n    }\n\n\n\n\n\n    if (loop_count >= 0 ) {\n\n        /* \"NETSCAPE EXTENSION\" for looped animation GIF */\n\n        avio_w8(pb, 0x21); /* GIF Extension code */\n\n        avio_w8(pb, 0xff); /* Application Extension Label */\n\n        avio_w8(pb, 0x0b); /* Length of Application Block */\n\n        avio_write(pb, \"NETSCAPE2.0\", sizeof(\"NETSCAPE2.0\") - 1);\n\n        avio_w8(pb, 0x03); /* Length of Data Sub-Block */\n\n        avio_w8(pb, 0x01);\n\n        avio_wl16(pb, (uint16_t)loop_count);\n\n        avio_w8(pb, 0x00); /* Data Sub-block Terminator */\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 1422}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xA(IpvideoContext *s)\n\n{\n\n    int x, y;\n\n    unsigned char P[4];\n\n    int flags = 0;\n\n\n\n    /* 4-color encoding for each 4x4 quadrant, or 4-color encoding on\n\n     * either top and bottom or left and right halves */\n\n    CHECK_STREAM_PTR(24);\n\n\n\n    if (s->stream_ptr[0] <= s->stream_ptr[1]) {\n\n\n\n        /* 4-color encoding for each quadrant; need 32 bytes */\n\n        CHECK_STREAM_PTR(32);\n\n\n\n        for (y = 0; y < 16; y++) {\n\n            // new values for each 4x4 block\n\n            if (!(y & 3)) {\n\n                memcpy(P, s->stream_ptr, 4);\n\n                s->stream_ptr += 4;\n\n                flags = bytestream_get_le32(&s->stream_ptr);\n\n            }\n\n\n\n            for (x = 0; x < 4; x++, flags >>= 2)\n\n                *s->pixel_ptr++ = P[flags & 0x03];\n\n\n\n            s->pixel_ptr += s->stride - 4;\n\n            // switch to right half\n\n            if (y == 7) s->pixel_ptr -= 8 * s->stride - 4;\n\n        }\n\n\n\n    } else {\n\n        // vertical split?\n\n        int vert = s->stream_ptr[12] <= s->stream_ptr[13];\n\n        uint64_t flags = 0;\n\n\n\n        /* 4-color encoding for either left and right or top and bottom\n\n         * halves */\n\n\n\n        for (y = 0; y < 16; y++) {\n\n            // load values for each half\n\n            if (!(y & 7)) {\n\n                memcpy(P, s->stream_ptr, 4);\n\n                s->stream_ptr += 4;\n\n                flags = bytestream_get_le64(&s->stream_ptr);\n\n            }\n\n\n\n            for (x = 0; x < 4; x++, flags >>= 2)\n\n                *s->pixel_ptr++ = P[flags & 0x03];\n\n\n\n            if (vert) {\n\n                s->pixel_ptr += s->stride - 4;\n\n                // switch to right half\n\n                if (y == 7) s->pixel_ptr -= 8 * s->stride - 4;\n\n            } else if (y & 1) s->pixel_ptr += s->line_inc;\n\n        }\n\n    }\n\n\n\n    /* report success */\n\n    return 0;\n\n}\n", "idx": 1441}
{"project": "qemu", "commit_id": "fff895dfdbe41965f7b0430e3d9e8b7bd8fc8eda", "target": 1, "func": "static bool adding_first_cpu(void)\n\n{\n\n    CPUState *cpu;\n\n    size_t count = 0;\n\n    CPU_FOREACH(cpu) {\n\n        count++;\n\n        if (count > 1) {\n\n            return false;\n\n        }\n\n    }\n\n    return true;\n\n}\n", "idx": 1451}
{"project": "FFmpeg", "commit_id": "3ba105029279bf43e6338849f360f1ce9a2973a0", "target": 1, "func": "static void imc_get_coeffs(AVCodecContext *avctx,\n\n                           IMCContext *q, IMCChannel *chctx)\n\n{\n\n    int i, j, cw_len, cw;\n\n\n\n    for (i = 0; i < BANDS; i++) {\n\n        if (!chctx->sumLenArr[i])\n\n            continue;\n\n        if (chctx->bandFlagsBuf[i] || chctx->bandWidthT[i]) {\n\n            for (j = band_tab[i]; j < band_tab[i + 1]; j++) {\n\n                cw_len = chctx->CWlengthT[j];\n\n                cw = 0;\n\n\n\n                if (cw_len && (!chctx->bandFlagsBuf[i] || !chctx->skipFlags[j])) {\n\n                    if (get_bits_count(&q->gb) + cw_len > 512) {\n\n                        av_log(avctx, AV_LOG_WARNING,\n\n                            \"Potential problem on band %i, coefficient %i\"\n\n                            \": cw_len=%i\\n\", i, j, cw_len);\n\n                    }\n\n\n\n                    cw = get_bits(&q->gb, cw_len);\n\n                }\n\n\n\n                chctx->codewords[j] = cw;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 1459}
{"project": "qemu", "commit_id": "b1b1dad31f3a092e046b09795f4476705c4e564e", "target": 1, "func": "static int aio_write_f(int argc, char **argv)\n\n{\n\n    int nr_iov, c;\n\n    int pattern = 0xcd;\n\n    struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n\n    BlockDriverAIOCB *acb;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            ctx->Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            ctx->qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n\n            return command_usage(&aio_write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n\n        return command_usage(&aio_write_cmd);\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, pattern);\n\n\n\n    gettimeofday(&ctx->t1, NULL);\n\n    acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n                          ctx->qiov.size >> 9, aio_write_done, ctx);\n\n    if (!acb) {\n\n        free(ctx->buf);\n\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 1509}
{"project": "qemu", "commit_id": "924e8a2bbc7cc62b3996efe9a2a460f541c04520", "target": 1, "func": "static coroutine_fn int quorum_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVQuorumState *s = bs->opaque;\n\n    QuorumVoteVersion *winner = NULL;\n\n    QuorumVotes error_votes;\n\n    QuorumVoteValue result_value;\n\n    int i;\n\n    int result = 0;\n\n\n\n    QLIST_INIT(&error_votes.vote_list);\n\n    error_votes.compare = quorum_64bits_compare;\n\n\n\n    for (i = 0; i < s->num_children; i++) {\n\n        result = bdrv_co_flush(s->children[i]->bs);\n\n        result_value.l = result;\n\n        quorum_count_vote(&error_votes, &result_value, i);\n\n    }\n\n\n\n    winner = quorum_get_vote_winner(&error_votes);\n\n    result = winner->value.l;\n\n\n\n    quorum_free_vote_list(&error_votes);\n\n\n\n    return result;\n\n}\n", "idx": 1528}
{"project": "qemu", "commit_id": "9456c2fbcd82dd82328ac6e7602a815582b1043e", "target": 0, "func": "void r4k_helper_tlbr(CPUMIPSState *env)\n\n{\n\n    r4k_tlb_t *tlb;\n\n    uint8_t ASID;\n\n    int idx;\n\n\n\n    ASID = env->CP0_EntryHi & 0xFF;\n\n    idx = (env->CP0_Index & ~0x80000000) % env->tlb->nb_tlb;\n\n    tlb = &env->tlb->mmu.r4k.tlb[idx];\n\n\n\n    /* If this will change the current ASID, flush qemu's TLB.  */\n\n    if (ASID != tlb->ASID)\n\n        cpu_mips_tlb_flush (env, 1);\n\n\n\n    r4k_mips_tlb_flush_extra(env, env->tlb->nb_tlb);\n\n\n\n    env->CP0_EntryHi = tlb->VPN | tlb->ASID;\n\n    env->CP0_PageMask = tlb->PageMask;\n\n    env->CP0_EntryLo0 = tlb->G | (tlb->V0 << 1) | (tlb->D0 << 2) |\n\n                        ((target_ulong)tlb->RI0 << CP0EnLo_RI) |\n\n                        ((target_ulong)tlb->XI0 << CP0EnLo_XI) |\n\n                        (tlb->C0 << 3) | (tlb->PFN[0] >> 6);\n\n    env->CP0_EntryLo1 = tlb->G | (tlb->V1 << 1) | (tlb->D1 << 2) |\n\n                        ((target_ulong)tlb->RI1 << CP0EnLo_RI) |\n\n                        ((target_ulong)tlb->XI1 << CP0EnLo_XI) |\n\n                        (tlb->C1 << 3) | (tlb->PFN[1] >> 6);\n\n}\n", "idx": 1565}
{"project": "qemu", "commit_id": "0ce470cd4ca88e84e547a3b95159d23ce6be419e", "target": 0, "func": "int kvmppc_fixup_cpu(PowerPCCPU *cpu)\n\n{\n\n    CPUState *cs = CPU(cpu);\n\n    int smt;\n\n\n\n    /* Adjust cpu index for SMT */\n\n    smt = kvmppc_smt_threads();\n\n    cs->cpu_index = (cs->cpu_index / smp_threads) * smt\n\n        + (cs->cpu_index % smp_threads);\n\n\n\n    return 0;\n\n}\n", "idx": 1572}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_flush(void *opaque)\n\n{\n\n    int16_t tag;\n\n    size_t offset = 7;\n\n    V9fsPDU *cancel_pdu;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"w\", &tag);\n\n\n\n\n    QLIST_FOREACH(cancel_pdu, &s->active_list, next) {\n\n        if (cancel_pdu->tag == tag) {\n\n            break;\n\n        }\n\n    }\n\n    if (cancel_pdu) {\n\n        cancel_pdu->cancelled = 1;\n\n        /*\n\n         * Wait for pdu to complete.\n\n         */\n\n        qemu_co_queue_wait(&cancel_pdu->complete);\n\n        cancel_pdu->cancelled = 0;\n\n        free_pdu(pdu->s, cancel_pdu);\n\n    }\n\n    complete_pdu(s, pdu, 7);\n\n    return;\n\n}", "idx": 1673}
{"project": "qemu", "commit_id": "e8ca1db29b349e780743c504cb735c8e1d542a8c", "target": 1, "func": "void qemu_savevm_send_postcopy_advise(QEMUFile *f)\n\n{\n\n    uint64_t tmp[2];\n\n    tmp[0] = cpu_to_be64(getpagesize());\n\n    tmp[1] = cpu_to_be64(1ul << qemu_target_page_bits());\n\n\n\n    trace_qemu_savevm_send_postcopy_advise();\n\n    qemu_savevm_command_send(f, MIG_CMD_POSTCOPY_ADVISE, 16, (uint8_t *)tmp);\n\n}\n", "idx": 1675}
{"project": "qemu", "commit_id": "4bac52f5c4b3dd5d0bd7568377ad7e957d5e3c6a", "target": 1, "func": "static void add_qemu_cpu_model_features(S390FeatBitmap fbm)\n\n{\n\n    static const int feats[] = {\n\n        S390_FEAT_DAT_ENH,\n\n        S390_FEAT_IDTE_SEGMENT,\n\n        S390_FEAT_STFLE,\n\n        S390_FEAT_SENSE_RUNNING_STATUS,\n\n        S390_FEAT_EXTENDED_IMMEDIATE,\n\n        S390_FEAT_EXTENDED_TRANSLATION_2,\n\n        S390_FEAT_MSA,\n\n        S390_FEAT_EXTENDED_TRANSLATION_3,\n\n        S390_FEAT_LONG_DISPLACEMENT,\n\n        S390_FEAT_LONG_DISPLACEMENT_FAST,\n\n        S390_FEAT_ETF2_ENH,\n\n        S390_FEAT_STORE_CLOCK_FAST,\n\n        S390_FEAT_MOVE_WITH_OPTIONAL_SPEC,\n\n        S390_FEAT_ETF3_ENH,\n\n\n        S390_FEAT_COMPARE_AND_SWAP_AND_STORE,\n\n        S390_FEAT_COMPARE_AND_SWAP_AND_STORE_2,\n\n        S390_FEAT_GENERAL_INSTRUCTIONS_EXT,\n\n        S390_FEAT_EXECUTE_EXT,\n\n        S390_FEAT_FLOATING_POINT_SUPPPORT_ENH,\n\n        S390_FEAT_STFLE_45,\n\n        S390_FEAT_STFLE_49,\n\n        S390_FEAT_LOCAL_TLB_CLEARING,\n\n        S390_FEAT_INTERLOCKED_ACCESS_2,\n\n        S390_FEAT_STFLE_53,\n\n        S390_FEAT_MSA_EXT_5,\n\n        S390_FEAT_MSA_EXT_3,\n\n        S390_FEAT_MSA_EXT_4,\n\n    };\n\n    int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(feats); i++) {\n\n        set_bit(feats[i], fbm);\n\n    }\n\n}", "idx": 1677}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_decr (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return cpu_ppc_load_decr(env);\n\n}\n", "idx": 1683}
{"project": "qemu", "commit_id": "91479dd0b5bd3b087b92ddd7bc3f2c54982cfe17", "target": 0, "func": "START_TEST(qobject_to_qlist_test)\n\n{\n\n    QList *qlist;\n\n\n\n    qlist = qlist_new();\n\n\n\n    fail_unless(qobject_to_qlist(QOBJECT(qlist)) == qlist);\n\n\n\n    // destroy doesn't exist yet\n\n    g_free(qlist);\n\n}\n", "idx": 1688}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "CharDriverState *qemu_chr_find(const char *name)\n\n{\n\n    CharDriverState *chr;\n\n\n\n    TAILQ_FOREACH(chr, &chardevs, next) {\n\n        if (strcmp(chr->label, name) != 0)\n\n            continue;\n\n        return chr;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 1701}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "static void vm_completion(ReadLineState *rs, const char *str)\n\n{\n\n    size_t len;\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    len = strlen(str);\n\n    readline_set_completion_index(rs, len);\n\n\n\n    while ((it = bdrv_next(it, &bs))) {\n\n        SnapshotInfoList *snapshots, *snapshot;\n\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n        bool ok = false;\n\n\n\n        aio_context_acquire(ctx);\n\n        if (bdrv_can_snapshot(bs)) {\n\n            ok = bdrv_query_snapshot_info_list(bs, &snapshots, NULL) == 0;\n\n        }\n\n        aio_context_release(ctx);\n\n        if (!ok) {\n\n            continue;\n\n        }\n\n\n\n        snapshot = snapshots;\n\n        while (snapshot) {\n\n            char *completion = snapshot->value->name;\n\n            if (!strncmp(str, completion, len)) {\n\n                readline_add_completion(rs, completion);\n\n            }\n\n            completion = snapshot->value->id;\n\n            if (!strncmp(str, completion, len)) {\n\n                readline_add_completion(rs, completion);\n\n            }\n\n            snapshot = snapshot->next;\n\n        }\n\n        qapi_free_SnapshotInfoList(snapshots);\n\n    }\n\n\n\n}\n", "idx": 1750}
{"project": "qemu", "commit_id": "229609dd45ee572fb343366a5bf440afb25cf614", "target": 1, "func": "static int check_for_evdev(void)\n\n{\n\n    SDL_SysWMinfo info;\n\n    XkbDescPtr desc;\n\n    int has_evdev = 0;\n\n    const char *keycodes;\n\n\n\n    SDL_VERSION(&info.version);\n\n    if (!SDL_GetWMInfo(&info))\n\n        return 0;\n\n\n\n    desc = XkbGetKeyboard(info.info.x11.display,\n\n                          XkbGBN_AllComponentsMask,\n\n                          XkbUseCoreKbd);\n\n    if (desc == NULL || desc->names == NULL)\n\n        return 0;\n\n\n\n    keycodes = XGetAtomName(info.info.x11.display, desc->names->keycodes);\n\n    if (keycodes == NULL)\n\n        fprintf(stderr, \"could not lookup keycode name\\n\");\n\n    else if (strstart(keycodes, \"evdev\", NULL))\n\n        has_evdev = 1;\n\n    else if (!strstart(keycodes, \"xfree86\", NULL))\n\n        fprintf(stderr,\n\n                \"unknown keycodes `%s', please report to qemu-devel@nongnu.org\\n\",\n\n                keycodes);\n\n\n\n    XkbFreeClientMap(desc, XkbGBN_AllComponentsMask, True);\n\n\n\n    return has_evdev;\n\n}\n", "idx": 1787}
{"project": "qemu", "commit_id": "f2d089425d43735b5369f70f3a36b712440578e5", "target": 1, "func": "static MemTxResult memory_region_oldmmio_read_accessor(MemoryRegion *mr,\n\n                                                       hwaddr addr,\n\n                                                       uint64_t *value,\n\n                                                       unsigned size,\n\n                                                       unsigned shift,\n\n                                                       uint64_t mask,\n\n                                                       MemTxAttrs attrs)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = mr->ops->old_mmio.read[ctz32(size)](mr->opaque, addr);\n\n    if (mr->subpage) {\n\n        trace_memory_region_subpage_read(get_cpu_index(), mr, addr, tmp, size);\n\n\n\n\n\n\n    } else if (TRACE_MEMORY_REGION_OPS_READ_ENABLED) {\n\n        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);\n\n        trace_memory_region_ops_read(get_cpu_index(), mr, abs_addr, tmp, size);\n\n    }\n\n    *value |= (tmp & mask) << shift;\n\n    return MEMTX_OK;\n\n}", "idx": 1798}
{"project": "FFmpeg", "commit_id": "b0a043f51b8cc3b420dc3ceaa38fe9aa344799aa", "target": 1, "func": "static int dcstr_read_header(AVFormatContext *s)\n\n{\n\n    unsigned codec, align;\n\n    AVStream *st;\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    st->codecpar->channels    = avio_rl32(s->pb);\n\n    st->codecpar->sample_rate = avio_rl32(s->pb);\n\n    codec                  = avio_rl32(s->pb);\n\n    align                  = avio_rl32(s->pb);\n\n    avio_skip(s->pb, 4);\n\n    st->duration           = avio_rl32(s->pb);\n\n    st->codecpar->channels   *= avio_rl32(s->pb);\n\n    if (!align || align > INT_MAX / st->codecpar->channels)\n\n        return AVERROR_INVALIDDATA;\n\n    st->codecpar->block_align = align * st->codecpar->channels;\n\n\n\n    switch (codec) {\n\n    case  4: st->codecpar->codec_id = AV_CODEC_ID_ADPCM_AICA;       break;\n\n    case 16: st->codecpar->codec_id = AV_CODEC_ID_PCM_S16LE_PLANAR; break;\n\n    default: avpriv_request_sample(s, \"codec %X\", codec);\n\n             return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    avio_skip(s->pb, 0x800 - avio_tell(s->pb));\n\n    avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);\n\n\n\n    return 0;\n\n}\n", "idx": 1826}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static uint32_t bonito_spciconf_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t pciaddr;\n\n    uint16_t status;\n\n\n\n    DPRINTF(\"bonito_spciconf_readb \"TARGET_FMT_plx\"  \\n\", addr);\n\n    pciaddr = bonito_sbridge_pciaddr(s, addr);\n\n\n\n    if (pciaddr == 0xffffffff) {\n\n        return 0xff;\n\n    }\n\n\n\n    /* set the pci address in s->config_reg */\n\n    s->pcihost->config_reg = (pciaddr) | (1u << 31);\n\n\n\n    /* clear PCI_STATUS_REC_MASTER_ABORT and PCI_STATUS_REC_TARGET_ABORT */\n\n    status = pci_get_word(s->dev.config + PCI_STATUS);\n\n    status &= ~(PCI_STATUS_REC_MASTER_ABORT | PCI_STATUS_REC_TARGET_ABORT);\n\n    pci_set_word(s->dev.config + PCI_STATUS, status);\n\n\n\n    return pci_data_read(s->pcihost->bus, s->pcihost->config_reg, 1);\n\n}\n", "idx": 1851}
{"project": "qemu", "commit_id": "e3cb6ba65d265f2cc1313ee26e879407ff24663c", "target": 0, "func": "static void qdev_get_legacy_property(DeviceState *dev, Visitor *v, void *opaque,\n\n                                     const char *name, Error **errp)\n\n{\n\n    Property *prop = opaque;\n\n\n\n    if (prop->info->print) {\n\n        char buffer[1024];\n\n        char *ptr = buffer;\n\n\n\n        prop->info->print(dev, prop, buffer, sizeof(buffer));\n\n        visit_type_str(v, &ptr, name, errp);\n\n    } else {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n    }\n\n}\n", "idx": 1856}
{"project": "FFmpeg", "commit_id": "7992814920d3a07a0bacfe45abd2183e81ef95f9", "target": 0, "func": "static char *value_string(char *buf, int buf_size, struct unit_value uv)\n\n{\n\n    double vald;\n\n    int show_float = 0;\n\n\n\n    if (uv.unit == unit_second_str) {\n\n        vald = uv.val.d;\n\n        show_float = 1;\n\n    } else {\n\n        vald = uv.val.i;\n\n    }\n\n\n\n    if (uv.unit == unit_second_str && use_value_sexagesimal_format) {\n\n        double secs;\n\n        int hours, mins;\n\n        secs  = vald;\n\n        mins  = (int)secs / 60;\n\n        secs  = secs - mins * 60;\n\n        hours = mins / 60;\n\n        mins %= 60;\n\n        snprintf(buf, buf_size, \"%d:%02d:%09.6f\", hours, mins, secs);\n\n    } else {\n\n        const char *prefix_string = \"\";\n\n        int l;\n\n\n\n        if (use_value_prefix && vald > 1) {\n\n            long long int index;\n\n\n\n            if (uv.unit == unit_byte_str && use_byte_value_binary_prefix) {\n\n                index = (long long int) (log2(vald)) / 10;\n\n                index = av_clip(index, 0, FF_ARRAY_ELEMS(binary_unit_prefixes) - 1);\n\n                vald /= exp2(index * 10);\n\n                prefix_string = binary_unit_prefixes[index];\n\n            } else {\n\n                index = (long long int) (log10(vald)) / 3;\n\n                index = av_clip(index, 0, FF_ARRAY_ELEMS(decimal_unit_prefixes) - 1);\n\n                vald /= pow(10, index * 3);\n\n                prefix_string = decimal_unit_prefixes[index];\n\n            }\n\n        }\n\n\n\n        if (show_float || (use_value_prefix && vald != (long long int)vald))\n\n            l = snprintf(buf, buf_size, \"%f\", vald);\n\n        else\n\n            l = snprintf(buf, buf_size, \"%lld\", (long long int)vald);\n\n        snprintf(buf+l, buf_size-l, \"%s%s%s\", *prefix_string || show_value_unit ? \" \" : \"\",\n\n                 prefix_string, show_value_unit ? uv.unit : \"\");\n\n    }\n\n\n\n    return buf;\n\n}\n", "idx": 1871}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int mjpeg_decode_dht(MJpegDecodeContext *s)\n\n{\n\n    int len, index, i, class, n, v, code_max;\n\n    uint8_t bits_table[17];\n\n    uint8_t val_table[256];\n\n    \n\n    len = get_bits(&s->gb, 16) - 2;\n\n\n\n    while (len > 0) {\n\n        if (len < 17)\n\n            return -1;\n\n        class = get_bits(&s->gb, 4);\n\n        if (class >= 2)\n\n            return -1;\n\n        index = get_bits(&s->gb, 4);\n\n        if (index >= 4)\n\n            return -1;\n\n        n = 0;\n\n        for(i=1;i<=16;i++) {\n\n            bits_table[i] = get_bits(&s->gb, 8);\n\n            n += bits_table[i];\n\n        }\n\n        len -= 17;\n\n        if (len < n || n > 256)\n\n            return -1;\n\n\n\n        code_max = 0;\n\n        for(i=0;i<n;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            if (v > code_max)\n\n                code_max = v;\n\n            val_table[i] = v;\n\n        }\n\n        len -= n;\n\n\n\n        /* build VLC and flush previous vlc if present */\n\n        free_vlc(&s->vlcs[class][index]);\n\n        dprintf(\"class=%d index=%d nb_codes=%d\\n\",\n\n               class, index, code_max + 1);\n\n        if(build_vlc(&s->vlcs[class][index], bits_table, val_table, code_max + 1) < 0){\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 1872}
{"project": "qemu", "commit_id": "6ee5920243cc5fe35d219fa2883a673b91808c0f", "target": 0, "func": "START_TEST(escaped_string)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        const char *decoded;\n\n    } test_cases[] = {\n\n        { \"\\\"\\\\\\\"\\\"\", \"\\\"\" },\n\n        { \"\\\"hello world \\\\\\\"embedded string\\\\\\\"\\\"\",\n\n          \"hello world \\\"embedded string\\\"\" },\n\n        { \"\\\"hello world\\\\nwith new line\\\"\", \"hello world\\nwith new line\" },\n\n        { \"\\\"single byte utf-8 \\\\u0020\\\"\", \"single byte utf-8  \" },\n\n        { \"\\\"double byte utf-8 \\\\u00A2\\\"\", \"double byte utf-8 \\xc2\\xa2\" },\n\n        { \"\\\"triple byte utf-8 \\\\u20AC\\\"\", \"triple byte utf-8 \\xe2\\x82\\xac\" },\n\n        {}\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QSTRING);\n\n        \n\n        str = qobject_to_qstring(obj);\n\n        fail_unless(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n\n\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 1914}
{"project": "qemu", "commit_id": "fea505221eaf87889000378d4d33ad0dfd5f4d9d", "target": 0, "func": "static void handle_mrs(DisasContext *s, uint32_t insn, unsigned int op0,\n\n                       unsigned int op1, unsigned int op2,\n\n                       unsigned int crn, unsigned int crm, unsigned int rt)\n\n{\n\n    unsupported_encoding(s, insn);\n\n}\n", "idx": 1915}
{"project": "qemu", "commit_id": "0fbc20740342713f282b118b4a446c4c43df3f4a", "target": 1, "func": "int kvm_irqchip_add_msi_route(KVMState *s, MSIMessage msg)\n\n{\n\n    struct kvm_irq_routing_entry kroute;\n\n    int virq;\n\n\n\n    if (!kvm_gsi_routing_enabled()) {\n\n        return -ENOSYS;\n\n    }\n\n\n\n    virq = kvm_irqchip_get_virq(s);\n\n    if (virq < 0) {\n\n        return virq;\n\n    }\n\n\n\n    kroute.gsi = virq;\n\n    kroute.type = KVM_IRQ_ROUTING_MSI;\n\n    kroute.flags = 0;\n\n    kroute.u.msi.address_lo = (uint32_t)msg.address;\n\n    kroute.u.msi.address_hi = msg.address >> 32;\n\n    kroute.u.msi.data = le32_to_cpu(msg.data);\n\n\n\n    kvm_add_routing_entry(s, &kroute);\n\n    kvm_irqchip_commit_routes(s);\n\n\n\n    return virq;\n\n}\n", "idx": 1956}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "long do_sigreturn(CPUS390XState *env)\n\n{\n\n    sigframe *frame;\n\n    abi_ulong frame_addr = env->regs[15];\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n\n\n    trace_user_do_sigreturn(env, frame_addr);\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n    __get_user(target_set.sig[0], &frame->sc.oldmask[0]);\n\n\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    set_sigmask(&set); /* ~_BLOCKABLE? */\n\n\n\n    if (restore_sigregs(env, &frame->sregs)) {\n\n        goto badframe;\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return -TARGET_QEMU_ESIGRETURN;\n\n\n\nbadframe:\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 2014}
{"project": "FFmpeg", "commit_id": "68f8d33becbd73b4d0aa277f472a6e8e72ea6849", "target": 0, "func": "static inline int get_symbol_inline(RangeCoder *c, uint8_t *state, int is_signed){\n\n    if(get_rac(c, state+0))\n\n        return 0;\n\n    else{\n\n        int i, e, a;\n\n        e= 0;\n\n        while(get_rac(c, state+1 + e) && e<9){ //1..10\n\n            e++;\n\n        }\n\n\n\n        a= 1;\n\n        for(i=e-1; i>=0; i--){\n\n            a += a + get_rac(c, state+22 + i); //22..31\n\n        }\n\n\n\n        e= -(is_signed && get_rac(c, state+11 + e)); //11..21\n\n        return (a^e)-e;\n\n    }\n\n}\n", "idx": 2017}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST(qobject_to_qint_test)\n\n{\n\n    QInt *qi;\n\n\n\n    qi = qint_from_int(0);\n\n    fail_unless(qobject_to_qint(QOBJECT(qi)) == qi);\n\n\n\n    QDECREF(qi);\n\n}\n", "idx": 2034}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_label(TCGContext *s, TCGLabel *l, tcg_insn_unit *ptr)\n\n{\n\n    intptr_t value = (intptr_t)ptr;\n\n    TCGRelocation *r;\n\n\n\n    assert(!l->has_value);\n\n\n\n    for (r = l->u.first_reloc; r != NULL; r = r->next) {\n\n        patch_reloc(r->ptr, r->type, value, r->addend);\n\n    }\n\n\n\n    l->has_value = 1;\n\n    l->u.value_ptr = ptr;\n\n}\n", "idx": 2055}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockDriverState *bdrv_lookup_bs(const char *device,\n\n                                 const char *node_name,\n\n                                 Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n\n\n    if (device) {\n\n        blk = blk_by_name(device);\n\n\n\n        if (blk) {\n\n            return blk_bs(blk);\n\n        }\n\n    }\n\n\n\n    if (node_name) {\n\n        bs = bdrv_find_node(node_name);\n\n\n\n        if (bs) {\n\n            return bs;\n\n        }\n\n    }\n\n\n\n    error_setg(errp, \"Cannot find device=%s nor node_name=%s\",\n\n                     device ? device : \"\",\n\n                     node_name ? node_name : \"\");\n\n    return NULL;\n\n}\n", "idx": 2068}
{"project": "qemu", "commit_id": "4652b8f3e1ec91bb9d6f00e40df7f96d1f1aafee", "target": 1, "func": "static int qcow2_set_up_encryption(BlockDriverState *bs, const char *encryptfmt,\n\n                                   QemuOpts *opts, Error **errp)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    QCryptoBlockCreateOptions *cryptoopts = NULL;\n\n    QCryptoBlock *crypto = NULL;\n\n    int ret = -EINVAL;\n\n    QDict *options, *encryptopts;\n\n\n\n    options = qemu_opts_to_qdict(opts, NULL);\n\n    qdict_extract_subqdict(options, &encryptopts, \"encrypt.\");\n\n    QDECREF(options);\n\n\n\n    if (!g_str_equal(encryptfmt, \"aes\")) {\n\n        error_setg(errp, \"Unknown encryption format '%s', expected 'aes'\",\n\n                   encryptfmt);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    cryptoopts = block_crypto_create_opts_init(\n\n        Q_CRYPTO_BLOCK_FORMAT_QCOW, encryptopts, errp);\n\n    if (!cryptoopts) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    s->crypt_method_header = QCOW_CRYPT_AES;\n\n\n\n    crypto = qcrypto_block_create(cryptoopts,\n\n                                  NULL, NULL,\n\n                                  bs, errp);\n\n    if (!crypto) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    ret = qcow2_update_header(bs);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not write encryption header\");\n\n        goto out;\n\n    }\n\n\n\n out:\n\n    QDECREF(encryptopts);\n\n    qcrypto_block_free(crypto);\n\n    qapi_free_QCryptoBlockCreateOptions(cryptoopts);\n\n    return ret;\n\n}\n", "idx": 2143}
{"project": "qemu", "commit_id": "4c315c27661502a0813b129e41c0bf640c34a8d6", "target": 1, "func": "static void tilegx_cpu_class_init(ObjectClass *oc, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(oc);\n    CPUClass *cc = CPU_CLASS(oc);\n    TileGXCPUClass *tcc = TILEGX_CPU_CLASS(oc);\n    tcc->parent_realize = dc->realize;\n    dc->realize = tilegx_cpu_realizefn;\n    tcc->parent_reset = cc->reset;\n    cc->reset = tilegx_cpu_reset;\n    cc->has_work = tilegx_cpu_has_work;\n    cc->do_interrupt = tilegx_cpu_do_interrupt;\n    cc->cpu_exec_interrupt = tilegx_cpu_exec_interrupt;\n    cc->dump_state = tilegx_cpu_dump_state;\n    cc->set_pc = tilegx_cpu_set_pc;\n    cc->handle_mmu_fault = tilegx_cpu_handle_mmu_fault;\n    cc->gdb_num_core_regs = 0;\n}", "idx": 2147}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_2f_1r_to_stereo(float *samples)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        samples[i] += samples[i + 512];\n\n        samples[i + 256] += samples[i + 512];\n\n        samples[i + 512] = 0;\n\n    }\n\n}\n", "idx": 2158}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "static PayloadContext *h264_new_extradata(void)\n\n{\n\n    PayloadContext *data =\n\n        av_mallocz(sizeof(PayloadContext) +\n\n                   FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n    if (data) {\n\n        data->cookie = MAGIC_COOKIE;\n\n    }\n\n\n\n    return data;\n\n}\n", "idx": 2160}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void dma_complete(DMAAIOCB *dbs, int ret)\n\n{\n\n    trace_dma_complete(dbs, ret, dbs->common.cb);\n\n\n\n    dma_bdrv_unmap(dbs);\n\n    if (dbs->common.cb) {\n\n        dbs->common.cb(dbs->common.opaque, ret);\n\n    }\n\n    qemu_iovec_destroy(&dbs->iov);\n\n    if (dbs->bh) {\n\n        qemu_bh_delete(dbs->bh);\n\n        dbs->bh = NULL;\n\n    }\n\n    qemu_aio_unref(dbs);\n\n}\n", "idx": 2183}
{"project": "qemu", "commit_id": "da4bc86c540991902e32e4e840c6ada573240254", "target": 1, "func": "static int proxy_mkdir(FsContext *fs_ctx, V9fsPath *dir_path,\n\n                       const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_MKDIR, NULL, &fullname,\n\n                          credp->fc_mode, credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    v9fs_string_free(&fullname);\n\n    return retval;\n\n}\n", "idx": 2209}
{"project": "FFmpeg", "commit_id": "a06b0b1295c51d100101e0ca0434e199ad6de6b5", "target": 1, "func": "static int decode_init_thread_copy(AVCodecContext *avctx)\n\n{\n\n    H264Context *h = avctx->priv_data;\n\n\n\n    if (!avctx->internal->is_copy)\n\n        return 0;\n\n    memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n\n    memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n\n\n\n\n    h->rbsp_buffer[0]      = NULL;\n\n    h->rbsp_buffer[1]      = NULL;\n\n    h->rbsp_buffer_size[0] = 0;\n\n    h->rbsp_buffer_size[1] = 0;\n\n    h->context_initialized = 0;\n\n\n\n    return 0;\n\n}", "idx": 2235}
{"project": "FFmpeg", "commit_id": "c842aa378db6c9da156bd245b8f8d05d889e3d7e", "target": 1, "func": "static int dvvideo_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 uint8_t *buf, int buf_size)\n\n{\n\n    DVVideoContext *s = avctx->priv_data;\n\n\n\n    s->sys = dv_frame_profile(buf);\n\n    if (!s->sys || buf_size < s->sys->frame_size)\n\n        return -1; /* NOTE: we only accept several full frames */\n\n\n\n    if(s->picture.data[0])\n\n        avctx->release_buffer(avctx, &s->picture);\n\n\n\n    s->picture.reference = 0;\n\n    s->picture.key_frame = 1;\n\n    s->picture.pict_type = FF_I_TYPE;\n\n    avctx->pix_fmt = s->sys->pix_fmt;\n\n    avcodec_set_dimensions(avctx, s->sys->width, s->sys->height);\n\n    if(avctx->get_buffer(avctx, &s->picture) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n    s->picture.interlaced_frame = 1;\n\n    s->picture.top_field_first = 0;\n\n\n\n    s->buf = buf;\n\n    avctx->execute(avctx, dv_decode_mt, (void**)&dv_anchor[0], NULL,\n\n                   s->sys->difseg_size * 27);\n\n\n\n    emms_c();\n\n\n\n    /* return image */\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data= s->picture;\n\n\n\n    return s->sys->frame_size;\n\n}\n", "idx": 2238}
{"project": "qemu", "commit_id": "ef4760626e88bc3e7a1b46c7370378cbd12d379f", "target": 1, "func": "static uint32_t eepro100_read4(EEPRO100State * s, uint32_t addr)\n\n{\n\n    uint32_t val;\n\n    if (addr <= sizeof(s->mem) - sizeof(val)) {\n\n        memcpy(&val, &s->mem[addr], sizeof(val));\n\n    }\n\n\n\n    switch (addr) {\n\n    case SCBStatus:\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%08x\\n\", regname(addr), val));\n\n        break;\n\n    case SCBPointer:\n\n#if 0\n\n        val = eepro100_read_pointer(s);\n\n#endif\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%08x\\n\", regname(addr), val));\n\n        break;\n\n    case SCBPort:\n\n        val = eepro100_read_port(s);\n\n        TRACE(OTHER, logout(\"addr=%s val=0x%08x\\n\", regname(addr), val));\n\n        break;\n\n    case SCBCtrlMDI:\n\n        val = eepro100_read_mdi(s);\n\n        break;\n\n    default:\n\n        logout(\"addr=%s val=0x%08x\\n\", regname(addr), val);\n\n        missing(\"unknown longword read\");\n\n    }\n\n    return val;\n\n}\n", "idx": 2253}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void mpeg_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,\n\n                              int (*mv)[2][4][2],\n\n                              int mb_x, int mb_y, int mb_intra, int mb_skipped)\n\n{\n\n    MpegEncContext *s = opaque;\n\n\n\n    s->mv_dir     = mv_dir;\n\n    s->mv_type    = mv_type;\n\n    s->mb_intra   = mb_intra;\n\n    s->mb_skipped = mb_skipped;\n\n    s->mb_x       = mb_x;\n\n    s->mb_y       = mb_y;\n\n    memcpy(s->mv, mv, sizeof(*mv));\n\n\n\n    ff_init_block_index(s);\n\n    ff_update_block_index(s);\n\n\n\n    s->dsp.clear_blocks(s->block[0]);\n\n\n\n    s->dest[0] = s->current_picture.f.data[0] + (s->mb_y *  16                       * s->linesize)   + s->mb_x *  16;\n\n    s->dest[1] = s->current_picture.f.data[1] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift);\n\n    s->dest[2] = s->current_picture.f.data[2] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift);\n\n\n\n    assert(ref == 0);\n\n    ff_MPV_decode_mb(s, s->block);\n\n}\n", "idx": 2260}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "void vty_putchars(VIOsPAPRDevice *sdev, uint8_t *buf, int len)\n\n{\n\n    VIOsPAPRVTYDevice *dev = VIO_SPAPR_VTY_DEVICE(sdev);\n\n\n\n    /* FIXME: should check the qemu_chr_fe_write() return value */\n\n    qemu_chr_fe_write(dev->chardev, buf, len);\n\n}\n", "idx": 2326}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_addc_m(int a, const int *b)\n\n{\n\n\tasm volatile (\"addc [%1], %0\\n\" : \"+r\" (a) : \"r\" (b));\n\n\treturn a;\n\n}\n", "idx": 2330}
{"project": "qemu", "commit_id": "bd69fe8448024258d046e2a15d4cf5c498188144", "target": 1, "func": "QEMUOptionParameter *append_option_parameters(QEMUOptionParameter *dest,\n\n    QEMUOptionParameter *list)\n\n{\n\n    size_t num_options, num_dest_options;\n\n\n\n    num_options = count_option_parameters(dest);\n\n    num_dest_options = num_options;\n\n\n\n    num_options += count_option_parameters(list);\n\n\n\n    dest = qemu_realloc(dest, (num_options + 1) * sizeof(QEMUOptionParameter));\n\n\n\n\n    while (list && list->name) {\n\n        if (get_option_parameter(dest, list->name) == NULL) {\n\n            dest[num_dest_options++] = *list;\n\n\n        }\n\n        list++;\n\n    }\n\n\n\n    return dest;\n\n}", "idx": 2350}
{"project": "qemu", "commit_id": "525989a50a70ea0ffa2b1cdf56279765bb2b7de0", "target": 1, "func": "void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n    BlockDriverState *iter;\n\n    int orig_bs_flags;\n\n\n\n    /* Make sure that the image is opened in read-write mode */\n\n    orig_bs_flags = bdrv_get_flags(bs);\n\n    if (!(orig_bs_flags & BDRV_O_RDWR)) {\n\n        if (bdrv_reopen(bs, orig_bs_flags | BDRV_O_RDWR, errp) != 0) {\n\n            return;\n\n        }\n\n    }\n\n\n\n    /* Prevent concurrent jobs trying to modify the graph structure here, we\n\n     * already have our own plans. Also don't allow resize as the image size is\n\n     * queried only at the job start and then cached. */\n\n    s = block_job_create(job_id, &stream_job_driver, bs,\n\n                         BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED |\n\n                         BLK_PERM_GRAPH_MOD,\n\n                         BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED |\n\n                         BLK_PERM_WRITE,\n\n                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);\n\n    if (!s) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Block all intermediate nodes between bs and base, because they will\n\n     * disappear from the chain after this operation. The streaming job reads\n\n     * every block only once, assuming that it doesn't change, so block writes\n\n     * and resizes. */\n\n    for (iter = backing_bs(bs); iter && iter != base; iter = backing_bs(iter)) {\n\n        block_job_add_bdrv(&s->common, \"intermediate node\", iter, 0,\n\n                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED,\n\n                           &error_abort);\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n    s->bs_flags = orig_bs_flags;\n\n\n\n    s->on_error = on_error;\n\n    trace_stream_start(bs, base, s);\n\n    block_job_start(&s->common);\n\n    return;\n\n\n\nfail:\n\n    if (orig_bs_flags != bdrv_get_flags(bs)) {\n\n        bdrv_reopen(bs, s->bs_flags, NULL);\n\n    }\n\n}\n", "idx": 2352}
{"project": "qemu", "commit_id": "ea15fb067212bb79291f9b76c5c76d45b62f58e1", "target": 1, "func": "static void tcg_target_qemu_prologue(TCGContext *s)\n\n{\n\n    int i, frame_size;\n\n\n\n    /* reserve some stack space */\n\n    frame_size = ARRAY_SIZE(tcg_target_callee_save_regs) * 4\n\n                 + TCG_STATIC_CALL_ARGS_SIZE;\n\n    frame_size = (frame_size + TCG_TARGET_STACK_ALIGN - 1) &\n\n                 ~(TCG_TARGET_STACK_ALIGN - 1);\n\n\n\n    /* TB prologue */\n\n    tcg_out_addi(s, TCG_REG_SP, -frame_size);\n\n    for(i = 0 ; i < ARRAY_SIZE(tcg_target_callee_save_regs) ; i++) {\n\n        tcg_out_st(s, TCG_TYPE_I32, tcg_target_callee_save_regs[i],\n\n                   TCG_REG_SP, TCG_STATIC_CALL_ARGS_SIZE + i * 4);\n\n    }\n\n\n\n    /* Call generated code */\n\n    tcg_out_opc_reg(s, OPC_JR, 0, tcg_target_call_iarg_regs[1]), 0);\n\n    tcg_out_mov(s, TCG_TYPE_PTR, TCG_AREG0, tcg_target_call_iarg_regs[0]);\n\n    tb_ret_addr = s->code_ptr;\n\n\n\n    /* TB epilogue */\n\n    for(i = 0 ; i < ARRAY_SIZE(tcg_target_callee_save_regs) ; i++) {\n\n        tcg_out_ld(s, TCG_TYPE_I32, tcg_target_callee_save_regs[i],\n\n                   TCG_REG_SP, TCG_STATIC_CALL_ARGS_SIZE + i * 4);\n\n    }\n\n\n\n    tcg_out_opc_reg(s, OPC_JR, 0, TCG_REG_RA, 0);\n\n    tcg_out_addi(s, TCG_REG_SP, frame_size);\n\n}\n", "idx": 2367}
{"project": "qemu", "commit_id": "4020db0475b3e527b3bdc97dff873c2be9da2698", "target": 1, "func": "static void virtio_scsi_vring_teardown(VirtIOSCSI *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);\n\n    int i;\n\n\n\n    if (s->ctrl_vring) {\n\n        vring_teardown(&s->ctrl_vring->vring, vdev, 0);\n\n\n\n    }\n\n    if (s->event_vring) {\n\n        vring_teardown(&s->event_vring->vring, vdev, 1);\n\n\n\n    }\n\n    if (s->cmd_vrings) {\n\n        for (i = 0; i < vs->conf.num_queues && s->cmd_vrings[i]; i++) {\n\n            vring_teardown(&s->cmd_vrings[i]->vring, vdev, 2 + i);\n\n\n\n        }\n\n        free(s->cmd_vrings);\n\n        s->cmd_vrings = NULL;\n\n    }\n\n}", "idx": 2376}
{"project": "FFmpeg", "commit_id": "90da2b50865549e086d4491cbb2bdc54af38ea4f", "target": 1, "func": "static void opt_frame_pix_fmt(const char *arg)\n\n{\n\n    if (strcmp(arg, \"list\"))\n\n        frame_pix_fmt = avcodec_get_pix_fmt(arg);\n\n    else {\n\n        list_fmts(avcodec_pix_fmt_string, PIX_FMT_NB);\n\n        av_exit(0);\n\n    }\n\n}\n", "idx": 2385}
{"project": "qemu", "commit_id": "e5b8b0d4ba29fe1268ba049519a1b0cf8552a21a", "target": 0, "func": "set_rdt(E1000State *s, int index, uint32_t val)\n\n{\n\n    s->check_rxov = 0;\n\n    s->mac_reg[index] = val & 0xffff;\n\n    if (e1000_has_rxbufs(s, 1)) {\n\n        qemu_flush_queued_packets(&s->nic->nc);\n\n    }\n\n}\n", "idx": 2483}
{"project": "qemu", "commit_id": "c9e659c9ee75d33ff11a8573cea738ad26bb6f86", "target": 1, "func": "unsigned int s390_cpu_set_state(uint8_t cpu_state, S390CPU *cpu)\n\n {\n\n    trace_cpu_set_state(CPU(cpu)->cpu_index, cpu_state);\n\n\n\n    switch (cpu_state) {\n\n    case CPU_STATE_STOPPED:\n\n    case CPU_STATE_CHECK_STOP:\n\n        /* halt the cpu for common infrastructure */\n\n        s390_cpu_halt(cpu);\n\n        break;\n\n    case CPU_STATE_OPERATING:\n\n    case CPU_STATE_LOAD:\n\n        /* unhalt the cpu for common infrastructure */\n\n        s390_cpu_unhalt(cpu);\n\n        break;\n\n    default:\n\n        error_report(\"Requested CPU state is not a valid S390 CPU state: %u\",\n\n                     cpu_state);\n\n        exit(1);\n\n\n\n\n\n    cpu->env.cpu_state = cpu_state;\n\n\n\n    return s390_count_running_cpus();\n", "idx": 2493}
{"project": "FFmpeg", "commit_id": "7c7e7464e3f49e9a1fa98b06c4261e75ce71290b", "target": 1, "func": "static int mmap_read_frame(struct video_data *s, void *frame, int64_t *ts)\n\n{\n\n    struct v4l2_buffer buf;\n\n    int res;\n\n\n\n    memset(&buf, 0, sizeof(struct v4l2_buffer));\n\n    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n    buf.memory = V4L2_MEMORY_MMAP;\n\n\n\n    /* FIXME: Some special treatment might be needed in case of loss of signal... */\n\n    while ((res = ioctl(s->fd, VIDIOC_DQBUF, &buf)) < 0 &&\n\n           ((errno == EAGAIN) || (errno == EINTR)));\n\n    if (res < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"ioctl(VIDIOC_DQBUF): %s\\n\", strerror(errno));\n\n\n\n        return -1;\n\n    }\n\n    assert (buf.index < s->buffers);\n\n    assert(buf.bytesused == s->frame_size);\n\n    /* Image is at s->buff_start[buf.index] */\n\n    memcpy(frame, s->buf_start[buf.index], buf.bytesused);\n\n    *ts = buf.timestamp.tv_sec * int64_t_C(1000000) + buf.timestamp.tv_usec;\n\n\n\n    res = ioctl (s->fd, VIDIOC_QBUF, &buf);\n\n    if (res < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"ioctl(VIDIOC_QBUF)\\n\");\n\n\n\n        return -1;\n\n    }\n\n\n\n    return s->buf_len[buf.index];\n\n}\n", "idx": 2496}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void e1000_io_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    (void)s;\n\n}\n", "idx": 2507}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_clkm_init(MemoryRegion *memory, target_phys_addr_t mpu_base,\n\n                target_phys_addr_t dsp_base, struct omap_mpu_state_s *s)\n\n{\n\n    memory_region_init_io(&s->clkm_iomem, &omap_clkm_ops, s,\n\n                          \"omap-clkm\", 0x100);\n\n    memory_region_init_io(&s->clkdsp_iomem, &omap_clkdsp_ops, s,\n\n                          \"omap-clkdsp\", 0x1000);\n\n\n\n    s->clkm.arm_idlect1 = 0x03ff;\n\n    s->clkm.arm_idlect2 = 0x0100;\n\n    s->clkm.dsp_idlect1 = 0x0002;\n\n    omap_clkm_reset(s);\n\n    s->clkm.cold_start = 0x3a;\n\n\n\n    memory_region_add_subregion(memory, mpu_base, &s->clkm_iomem);\n\n    memory_region_add_subregion(memory, dsp_base, &s->clkdsp_iomem);\n\n}\n", "idx": 2508}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t bonito_pciconf_readl(void *opaque, target_phys_addr_t addr,\n\n                                     unsigned size)\n\n{\n\n\n\n    PCIBonitoState *s = opaque;\n\n    PCIDevice *d = PCI_DEVICE(s);\n\n\n\n    DPRINTF(\"bonito_pciconf_readl \"TARGET_FMT_plx\"\\n\", addr);\n\n    return d->config_read(d, addr, 4);\n\n}\n", "idx": 2521}
{"project": "qemu", "commit_id": "17cce735780f0ff6a2ef173c34614bd47acd56e5", "target": 1, "func": "static void vdi_close(BlockDriverState *bs)\n\n{\n\n    BDRVVdiState *s = bs->opaque;\n\n\n\n    g_free(s->bmap);\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n", "idx": 2529}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static int handle_instruction(S390CPU *cpu, struct kvm_run *run)\n\n{\n\n    unsigned int ipa0 = (run->s390_sieic.ipa & 0xff00);\n\n    uint8_t ipa1 = run->s390_sieic.ipa & 0x00ff;\n\n    int r = -1;\n\n\n\n    DPRINTF(\"handle_instruction 0x%x 0x%x\\n\",\n\n            run->s390_sieic.ipa, run->s390_sieic.ipb);\n\n    switch (ipa0) {\n\n    case IPA0_B2:\n\n        r = handle_b2(cpu, run, ipa1);\n\n        break;\n\n    case IPA0_B9:\n\n        r = handle_b9(cpu, run, ipa1);\n\n        break;\n\n    case IPA0_EB:\n\n        r = handle_eb(cpu, run, run->s390_sieic.ipb & 0xff);\n\n        break;\n\n    case IPA0_E3:\n\n        r = handle_e3(cpu, run, run->s390_sieic.ipb & 0xff);\n\n        break;\n\n    case IPA0_DIAG:\n\n        r = handle_diag(cpu, run, run->s390_sieic.ipb);\n\n        break;\n\n    case IPA0_SIGP:\n\n        r = handle_sigp(cpu, ipa1, run->s390_sieic.ipb);\n\n        break;\n\n    }\n\n\n\n    if (r < 0) {\n\n        r = 0;\n\n        kvm_s390_program_interrupt(cpu, PGM_OPERATION);\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 2548}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_fstat(FsContext *fs_ctx, int fid_type,\n\n                            V9fsFidOpenState *fs, struct stat *stbuf)\n\n{\n\n    V9fsSynthOpenState *synth_open = fs->private;\n\n    v9fs_synth_fill_statbuf(synth_open->node, stbuf);\n\n    return 0;\n\n}\n", "idx": 2559}
{"project": "qemu", "commit_id": "8172539d21a03e982aa7f139ddc1607dc1422045", "target": 0, "func": "static uint32_t virtio_balloon_get_features(VirtIODevice *vdev)\n\n{\n\n    return 0;\n\n}\n", "idx": 2560}
{"project": "qemu", "commit_id": "4fc9af53d88c0a2a810704a06cb39a7182982e4e", "target": 0, "func": "BlockDriverAIOCB *bdrv_aio_write(BlockDriverState *bs, int64_t sector_num,\n\n                                 const uint8_t *buf, int nb_sectors,\n\n                                 BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bs->read_only)\n\n        return NULL;\n\n    if (sector_num == 0 && bs->boot_sector_enabled && nb_sectors > 0) {\n\n        memcpy(bs->boot_sector_data, buf, 512);\n\n    }\n\n\n\n    ret = drv->bdrv_aio_write(bs, sector_num, buf, nb_sectors, cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->wr_bytes += (unsigned) nb_sectors * SECTOR_SIZE;\n\n\tbs->wr_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 2561}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t icp_pic_read(void *opaque, target_phys_addr_t offset,\n\n                             unsigned size)\n\n{\n\n    icp_pic_state *s = (icp_pic_state *)opaque;\n\n\n\n    switch (offset >> 2) {\n\n    case 0: /* IRQ_STATUS */\n\n        return s->level & s->irq_enabled;\n\n    case 1: /* IRQ_RAWSTAT */\n\n        return s->level;\n\n    case 2: /* IRQ_ENABLESET */\n\n        return s->irq_enabled;\n\n    case 4: /* INT_SOFTSET */\n\n        return s->level & 1;\n\n    case 8: /* FRQ_STATUS */\n\n        return s->level & s->fiq_enabled;\n\n    case 9: /* FRQ_RAWSTAT */\n\n        return s->level;\n\n    case 10: /* FRQ_ENABLESET */\n\n        return s->fiq_enabled;\n\n    case 3: /* IRQ_ENABLECLR */\n\n    case 5: /* INT_SOFTCLR */\n\n    case 11: /* FRQ_ENABLECLR */\n\n    default:\n\n        printf (\"icp_pic_read: Bad register offset 0x%x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n", "idx": 2582}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static int vmsvga_post_load(void *opaque, int version_id)\n\n{\n\n    struct vmsvga_state_s *s = opaque;\n\n\n\n    s->invalidated = 1;\n\n    if (s->config)\n\n        s->fifo = (uint32_t *) s->fifo_ptr;\n\n\n\n    return 0;\n\n}\n", "idx": 2584}
{"project": "qemu", "commit_id": "8d2f850a5ab7579a852f23b28273940a47dfd7ff", "target": 0, "func": "static inline void check_alignment(CPUS390XState *env, uint64_t v,\n\n                                   int wordsize, uintptr_t ra)\n\n{\n\n    if (v % wordsize) {\n\n        CPUState *cs = CPU(s390_env_get_cpu(env));\n\n        cpu_restore_state(cs, ra);\n\n        program_interrupt(env, PGM_SPECIFICATION, 6);\n\n    }\n\n}\n", "idx": 2596}
{"project": "qemu", "commit_id": "40f08e87f613273f9dcc8df7d6a0f574b7d28d05", "target": 1, "func": "static int mm_start_timer(struct qemu_alarm_timer *t)\n\n{\n\n    TIMECAPS tc;\n\n\n\n    memset(&tc, 0, sizeof(tc));\n\n    timeGetDevCaps(&tc, sizeof(tc));\n\n\n\n    mm_period = tc.wPeriodMin;\n\n    timeBeginPeriod(mm_period);\n\n\n\n    mm_timer = timeSetEvent(1,                  /* interval (ms) */\n\n                            mm_period,          /* resolution */\n\n                            mm_alarm_handler,   /* function */\n\n                            (DWORD_PTR)t,       /* parameter */\n\n                            TIME_ONESHOT | TIME_CALLBACK_FUNCTION);\n\n\n\n    if (!mm_timer) {\n\n        fprintf(stderr, \"Failed to initialize win32 alarm timer: %ld\\n\",\n\n                GetLastError());\n\n        timeEndPeriod(mm_period);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2651}
{"project": "qemu", "commit_id": "b18f1141d0afa00de11a8e079f4f5305c9e36893", "target": 1, "func": "static void test_validate_fail_union_native_list(TestInputVisitorData *data,\n\n                                                 const void *unused)\n\n{\n\n    UserDefNativeListUnion *tmp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data,\n\n                           \"{ 'type': 'integer', 'data' : [ 'string' ] }\");\n\n\n\n    visit_type_UserDefNativeListUnion(v, &tmp, NULL, &err);\n\n    g_assert(err);\n\n\n    qapi_free_UserDefNativeListUnion(tmp);\n\n}", "idx": 2669}
{"project": "FFmpeg", "commit_id": "4cd0bdae9a62d1f0366e60603222762af31e5289", "target": 1, "func": "static int read_uncompressed_sgi(unsigned char* out_buf, uint8_t* out_end,\n\n                const uint8_t *in_buf, const uint8_t *in_end, SgiState* s)\n\n{\n\n    int x, y, z;\n\n    const uint8_t *ptr;\n\n    unsigned int offset = s->height * s->width * s->bytes_per_channel;\n\n\n\n    /* Test buffer size. */\n\n    if (offset * s->depth > in_end - in_buf) {\n\n       return -1;\n\n    }\n\n\n\n    for (y = s->height - 1; y >= 0; y--) {\n\n        out_end = out_buf + (y * s->linesize);\n\n        for (x = s->width; x > 0; x--) {\n\n            ptr = in_buf += s->bytes_per_channel;\n\n            for(z = 0; z < s->depth; z ++) {\n\n                memcpy(out_end, ptr, s->bytes_per_channel);\n\n                out_end += s->bytes_per_channel;\n\n                ptr += offset;\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 2676}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static int send_mono_rect(VncState *vs, int w, int h, uint32_t bg, uint32_t fg)\n\n{\n\n    size_t bytes;\n\n    int stream = 1;\n\n    int level = tight_conf[vs->tight_compression].mono_zlib_level;\n\n\n\n    bytes = ((w + 7) / 8) * h;\n\n\n\n    vnc_write_u8(vs, (stream | VNC_TIGHT_EXPLICIT_FILTER) << 4);\n\n    vnc_write_u8(vs, VNC_TIGHT_FILTER_PALETTE);\n\n    vnc_write_u8(vs, 1);\n\n\n\n    switch(vs->clientds.pf.bytes_per_pixel) {\n\n    case 4:\n\n    {\n\n        uint32_t buf[2] = {bg, fg};\n\n        size_t ret = sizeof (buf);\n\n\n\n        if (vs->tight_pixel24) {\n\n            tight_pack24(vs, (unsigned char*)buf, 2, &ret);\n\n        }\n\n        vnc_write(vs, buf, ret);\n\n\n\n        tight_encode_mono_rect32(vs->tight.buffer, w, h, bg, fg);\n\n        break;\n\n    }\n\n    case 2:\n\n        vnc_write(vs, &bg, 2);\n\n        vnc_write(vs, &fg, 2);\n\n        tight_encode_mono_rect16(vs->tight.buffer, w, h, bg, fg);\n\n        break;\n\n    default:\n\n        vnc_write_u8(vs, bg);\n\n        vnc_write_u8(vs, fg);\n\n        tight_encode_mono_rect8(vs->tight.buffer, w, h, bg, fg);\n\n        break;\n\n    }\n\n    vs->tight.offset = bytes;\n\n\n\n    bytes = tight_compress_data(vs, stream, bytes, level, Z_DEFAULT_STRATEGY);\n\n    return (bytes >= 0);\n\n}\n", "idx": 2713}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "void qmp_screendump(const char *filename, Error **errp)\n\n{\n\n    QemuConsole *previous_active_console;\n\n    bool cswitch;\n\n\n\n    previous_active_console = active_console;\n\n    cswitch = previous_active_console && previous_active_console->index != 0;\n\n\n\n    /* There is currently no way of specifying which screen we want to dump,\n\n       so always dump the first one.  */\n\n    if (cswitch) {\n\n        console_select(0);\n\n    }\n\n    if (consoles[0] && consoles[0]->hw_screen_dump) {\n\n        consoles[0]->hw_screen_dump(consoles[0]->hw, filename, cswitch, errp);\n\n    } else {\n\n        error_setg(errp, \"device doesn't support screendump\");\n\n    }\n\n\n\n    if (cswitch) {\n\n        console_select(previous_active_console->index);\n\n    }\n\n}\n", "idx": 2763}
{"project": "qemu", "commit_id": "f0ddf11b23260f0af84fb529486a8f9ba2d19401", "target": 0, "func": "DISAS_INSN(cas2l)\n\n{\n\n    uint16_t ext1, ext2;\n\n    TCGv addr1, addr2, regs;\n\n\n\n    /* cas2 Dc1:Dc2,Du1:Du2,(Rn1):(Rn2) */\n\n\n\n    ext1 = read_im16(env, s);\n\n\n\n    if (ext1 & 0x8000) {\n\n        /* Address Register */\n\n        addr1 = AREG(ext1, 12);\n\n    } else {\n\n        /* Data Register */\n\n        addr1 = DREG(ext1, 12);\n\n    }\n\n\n\n    ext2 = read_im16(env, s);\n\n    if (ext2 & 0x8000) {\n\n        /* Address Register */\n\n        addr2 = AREG(ext2, 12);\n\n    } else {\n\n        /* Data Register */\n\n        addr2 = DREG(ext2, 12);\n\n    }\n\n\n\n    /* if (R1) == Dc1 && (R2) == Dc2 then\n\n     *     (R1) = Du1\n\n     *     (R2) = Du2\n\n     * else\n\n     *     Dc1 = (R1)\n\n     *     Dc2 = (R2)\n\n     */\n\n\n\n    regs = tcg_const_i32(REG(ext2, 6) |\n\n                         (REG(ext1, 6) << 3) |\n\n                         (REG(ext2, 0) << 6) |\n\n                         (REG(ext1, 0) << 9));\n\n    gen_helper_cas2l(cpu_env, regs, addr1, addr2);\n\n    tcg_temp_free(regs);\n\n\n\n    /* Note that cas2l also assigned to env->cc_op.  */\n\n    s->cc_op = CC_OP_CMPL;\n\n    s->cc_op_synced = 1;\n\n}\n", "idx": 2795}
{"project": "qemu", "commit_id": "026aeffcb4752054830ba203020ed6eb05bcaba8", "target": 0, "func": "static void cirrus_bitblt_rop_nop(CirrusVGAState *s,\n\n                                  uint8_t *dst,const uint8_t *src,\n\n                                  int dstpitch,int srcpitch,\n\n                                  int bltwidth,int bltheight)\n\n{\n\n}\n", "idx": 2797}
{"project": "qemu", "commit_id": "03f4995781a64e106e6f73864a1e9c4163dac53b", "target": 0, "func": "static void page_flush_tb(void)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < V_L1_SIZE; i++) {\n\n        page_flush_tb_1(V_L1_SHIFT / L2_BITS - 1, l1_map + i);\n\n    }\n\n}\n", "idx": 2800}
{"project": "qemu", "commit_id": "12f8def0e02232d7c6416ad9b66640f973c531d1", "target": 1, "func": "void qemu_cond_wait(QemuCond *cond, QemuMutex *mutex)\n\n{\n\n    /*\n\n     * This access is protected under the mutex.\n\n     */\n\n    cond->waiters++;\n\n\n\n    /*\n\n     * Unlock external mutex and wait for signal.\n\n     * NOTE: we've held mutex locked long enough to increment\n\n     * waiters count above, so there's no problem with\n\n     * leaving mutex unlocked before we wait on semaphore.\n\n     */\n\n    qemu_mutex_unlock(mutex);\n\n    WaitForSingleObject(cond->sema, INFINITE);\n\n\n\n    /* Now waiters must rendez-vous with the signaling thread and\n\n     * let it continue.  For cond_broadcast this has heavy contention\n\n     * and triggers thundering herd.  So goes life.\n\n     *\n\n     * Decrease waiters count.  The mutex is not taken, so we have\n\n     * to do this atomically.\n\n     *\n\n     * All waiters contend for the mutex at the end of this function\n\n     * until the signaling thread relinquishes it.  To ensure\n\n     * each waiter consumes exactly one slice of the semaphore,\n\n     * the signaling thread stops until it is told by the last\n\n     * waiter that it can go on.\n\n     */\n\n    if (InterlockedDecrement(&cond->waiters) == cond->target) {\n\n        SetEvent(cond->continue_event);\n\n    }\n\n\n\n    qemu_mutex_lock(mutex);\n\n}\n", "idx": 2844}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int connect_namedsocket(const char *path)\n\n{\n\n    int sockfd, size;\n\n    struct sockaddr_un helper;\n\n\n\n    if (strlen(path) >= sizeof(helper.sun_path)) {\n\n        fprintf(stderr, \"Socket name too large\\n\");\n\n        return -1;\n\n    }\n\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n    if (sockfd < 0) {\n\n        fprintf(stderr, \"failed to create socket: %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    strcpy(helper.sun_path, path);\n\n    helper.sun_family = AF_UNIX;\n\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n\n        fprintf(stderr, \"failed to connect to %s: %s\\n\", path, strerror(errno));\n\n        close(sockfd);\n\n        return -1;\n\n    }\n\n\n\n    /* remove the socket for security reasons */\n\n    unlink(path);\n\n    return sockfd;\n\n}\n", "idx": 2871}
{"project": "qemu", "commit_id": "b4fe97c8230c34ebd407a9f23894b9c614807540", "target": 0, "func": "static void guest_file_init(void)\n\n{\n\n    QTAILQ_INIT(&guest_file_state.filehandles);\n\n}\n", "idx": 2892}
{"project": "qemu", "commit_id": "6d74ca5aa83b83fb52332f7735c61ecb7a5328c1", "target": 1, "func": "static uint32_t virtio_ioport_read(VirtIOPCIProxy *proxy, uint32_t addr)\n\n{\n\n    VirtIODevice *vdev = proxy->vdev;\n\n    uint32_t ret = 0xFFFFFFFF;\n\n\n\n    switch (addr) {\n\n    case VIRTIO_PCI_HOST_FEATURES:\n\n        ret = vdev->get_features(vdev);\n\n        ret |= (1 << VIRTIO_F_NOTIFY_ON_EMPTY);\n\n        ret |= (1 << VIRTIO_RING_F_INDIRECT_DESC);\n\n        ret |= (1 << VIRTIO_F_BAD_FEATURE);\n\n        break;\n\n    case VIRTIO_PCI_GUEST_FEATURES:\n\n        ret = vdev->features;\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_PFN:\n\n        ret = virtio_queue_get_addr(vdev, vdev->queue_sel)\n\n              >> VIRTIO_PCI_QUEUE_ADDR_SHIFT;\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_NUM:\n\n        ret = virtio_queue_get_num(vdev, vdev->queue_sel);\n\n        break;\n\n    case VIRTIO_PCI_QUEUE_SEL:\n\n        ret = vdev->queue_sel;\n\n        break;\n\n    case VIRTIO_PCI_STATUS:\n\n        ret = vdev->status;\n\n        break;\n\n    case VIRTIO_PCI_ISR:\n\n        /* reading from the ISR also clears it. */\n\n        ret = vdev->isr;\n\n        vdev->isr = 0;\n\n        qemu_set_irq(proxy->pci_dev.irq[0], 0);\n\n        break;\n\n    case VIRTIO_MSI_CONFIG_VECTOR:\n\n        ret = vdev->config_vector;\n\n        break;\n\n    case VIRTIO_MSI_QUEUE_VECTOR:\n\n        ret = virtio_queue_vector(vdev, vdev->queue_sel);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 2948}
{"project": "FFmpeg", "commit_id": "debf4d6e67dfb29f3d71683add429c588828f8e8", "target": 0, "func": "static int dvbsub_parse_display_definition_segment(AVCodecContext *avctx,\n\n                                                   const uint8_t *buf,\n\n                                                   int buf_size)\n\n{\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n    DVBSubDisplayDefinition *display_def = ctx->display_definition;\n\n    int dds_version, info_byte;\n\n\n\n    if (buf_size < 5)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    info_byte   = bytestream_get_byte(&buf);\n\n    dds_version = info_byte >> 4;\n\n    if (display_def && display_def->version == dds_version)\n\n        return 0; // already have this display definition version\n\n\n\n    if (!display_def) {\n\n        display_def             = av_mallocz(sizeof(*display_def));\n\n        if (!display_def)\n\n            return AVERROR(ENOMEM);\n\n        ctx->display_definition = display_def;\n\n    }\n\n\n\n    display_def->version = dds_version;\n\n    display_def->x       = 0;\n\n    display_def->y       = 0;\n\n    display_def->width   = bytestream_get_be16(&buf) + 1;\n\n    display_def->height  = bytestream_get_be16(&buf) + 1;\n\n    if (!avctx->width || !avctx->height) {\n\n        avctx->width  = display_def->width;\n\n        avctx->height = display_def->height;\n\n    }\n\n\n\n    if (buf_size < 13)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (info_byte & 1<<3) { // display_window_flag\n\n        display_def->x = bytestream_get_be16(&buf);\n\n        display_def->width  = bytestream_get_be16(&buf) - display_def->x + 1;\n\n        display_def->y = bytestream_get_be16(&buf);\n\n        display_def->height = bytestream_get_be16(&buf) - display_def->y + 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2964}
{"project": "qemu", "commit_id": "7696414729b2d0f870c80ad1dd637d854bc78847", "target": 1, "func": "static void gen_st (DisasContext *ctx, uint32_t opc, int rt,\n\n                    int base, int16_t offset)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_new();\n\n    int mem_idx = ctx->mem_idx;\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n    gen_load_gpr(t1, rt);\n\n    switch (opc) {\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_SD:\n\n        tcg_gen_qemu_st_tl(t1, t0, mem_idx, MO_TEQ |\n\n                           ctx->default_tcg_memop_mask);\n\n        break;\n\n    case OPC_SDL:\n\n        gen_helper_0e2i(sdl, t1, t0, mem_idx);\n\n        break;\n\n    case OPC_SDR:\n\n        gen_helper_0e2i(sdr, t1, t0, mem_idx);\n\n        break;\n\n#endif\n\n\n\n\n    case OPC_SW:\n\n        tcg_gen_qemu_st_tl(t1, t0, mem_idx, MO_TEUL |\n\n                           ctx->default_tcg_memop_mask);\n\n        break;\n\n\n\n\n    case OPC_SH:\n\n        tcg_gen_qemu_st_tl(t1, t0, mem_idx, MO_TEUW |\n\n                           ctx->default_tcg_memop_mask);\n\n        break;\n\n\n\n\n    case OPC_SB:\n\n        tcg_gen_qemu_st_tl(t1, t0, mem_idx, MO_8);\n\n        break;\n\n\n\n\n    case OPC_SWL:\n\n        gen_helper_0e2i(swl, t1, t0, mem_idx);\n\n        break;\n\n\n\n\n    case OPC_SWR:\n\n        gen_helper_0e2i(swr, t1, t0, mem_idx);\n\n        break;\n\n    }\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}", "idx": 2965}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void *qpa_audio_init (void)\n\n{\n\n    return &conf;\n\n}\n", "idx": 2973}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void timer_deinit(QEMUTimer *ts)\n\n{\n\n    assert(ts->expire_time == -1);\n\n    ts->timer_list = NULL;\n\n}\n", "idx": 2978}
{"project": "qemu", "commit_id": "ca6b6e1e68ac44b2e8895da10dd1c80dc03d08b7", "target": 0, "func": "static QDict *qmp_check_input_obj(QObject *input_obj, Error **errp)\n\n{\n\n    const QDictEntry *ent;\n\n    int has_exec_key = 0;\n\n    QDict *input_dict;\n\n\n\n    if (qobject_type(input_obj) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"object\");\n\n        return NULL;\n\n    }\n\n\n\n    input_dict = qobject_to_qdict(input_obj);\n\n\n\n    for (ent = qdict_first(input_dict); ent; ent = qdict_next(input_dict, ent)){\n\n        const char *arg_name = qdict_entry_key(ent);\n\n        const QObject *arg_obj = qdict_entry_value(ent);\n\n\n\n        if (!strcmp(arg_name, \"execute\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER,\n\n                           \"execute\", \"string\");\n\n                return NULL;\n\n            }\n\n            has_exec_key = 1;\n\n        } else if (!strcmp(arg_name, \"arguments\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QDICT) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER,\n\n                           \"arguments\", \"object\");\n\n                return NULL;\n\n            }\n\n        } else if (!strcmp(arg_name, \"id\")) {\n\n            /* Any string is acceptable as \"id\", so nothing to check */\n\n        } else {\n\n            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (!has_exec_key) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n        return NULL;\n\n    }\n\n\n\n    return input_dict;\n\n}\n", "idx": 2982}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_read(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    int i;\n\n    for(i = 0; i < size; i++)\n\n        term_handle_byte(buf[i]);\n\n}\n", "idx": 2985}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_validate_fail_struct_missing(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n    QObject *any;\n\n    GenericAlternate *alt;\n\n    bool present;\n\n    int en;\n\n    int64_t i64;\n\n    uint32_t u32;\n\n    int8_t i8;\n\n    char *str;\n\n    double dbl;\n\n\n\n    v = validate_test_init(data, \"{}\");\n\n    visit_start_struct(v, NULL, NULL, 0, &error_abort);\n\n    visit_start_struct(v, \"struct\", NULL, 0, &err);\n\n    error_free_or_abort(&err);\n\n    visit_start_list(v, \"list\", NULL, 0, &err);\n\n    error_free_or_abort(&err);\n\n    visit_start_alternate(v, \"alternate\", &alt, sizeof(*alt), false, &err);\n\n    error_free_or_abort(&err);\n\n    visit_optional(v, \"optional\", &present);\n\n    g_assert(!present);\n\n    visit_type_enum(v, \"enum\", &en, EnumOne_lookup, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_int(v, \"i64\", &i64, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_uint32(v, \"u32\", &u32, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_int8(v, \"i8\", &i8, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_str(v, \"i8\", &str, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_number(v, \"dbl\", &dbl, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_any(v, \"any\", &any, &err);\n\n    error_free_or_abort(&err);\n\n    visit_type_null(v, \"null\", &err);\n\n    error_free_or_abort(&err);\n\n    visit_end_struct(v, NULL);\n\n}\n", "idx": 3013}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void dma_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie,\n\n                    QEMUSGList *sg, enum BlockAcctType type)\n\n{\n\n    block_acct_start(bdrv_get_stats(bs), cookie, sg->size, type);\n\n}\n", "idx": 3019}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "xilinx_axienet_data_stream_push(StreamSlave *obj, uint8_t *buf, size_t size,\n\n                                uint32_t *hdr)\n\n{\n\n    XilinxAXIEnetStreamSlave *ds = XILINX_AXI_ENET_DATA_STREAM(obj);\n\n    XilinxAXIEnet *s = ds->enet;\n\n\n\n    /* TX enable ?  */\n\n    if (!(s->tc & TC_TX)) {\n\n        return size;\n\n    }\n\n\n\n    /* Jumbo or vlan sizes ?  */\n\n    if (!(s->tc & TC_JUM)) {\n\n        if (size > 1518 && size <= 1522 && !(s->tc & TC_VLAN)) {\n\n            return size;\n\n        }\n\n    }\n\n\n\n    if (hdr[0] & 1) {\n\n        unsigned int start_off = hdr[1] >> 16;\n\n        unsigned int write_off = hdr[1] & 0xffff;\n\n        uint32_t tmp_csum;\n\n        uint16_t csum;\n\n\n\n        tmp_csum = net_checksum_add(size - start_off,\n\n                                    (uint8_t *)buf + start_off);\n\n        /* Accumulate the seed.  */\n\n        tmp_csum += hdr[2] & 0xffff;\n\n\n\n        /* Fold the 32bit partial checksum.  */\n\n        csum = net_checksum_finish(tmp_csum);\n\n\n\n        /* Writeback.  */\n\n        buf[write_off] = csum >> 8;\n\n        buf[write_off + 1] = csum & 0xff;\n\n    }\n\n\n\n    qemu_send_packet(qemu_get_queue(s->nic), buf, size);\n\n\n\n    s->stats.tx_bytes += size;\n\n    s->regs[R_IS] |= IS_TX_COMPLETE;\n\n    enet_update_irq(s);\n\n\n\n    return size;\n\n}\n", "idx": 3039}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_set_a20(CPUX86State *env, int a20_state)\n\n{\n\n    a20_state = (a20_state != 0);\n\n    if (a20_state != a20_enabled) {\n\n#if defined(DEBUG_MMU)\n\n        printf(\"A20 update: a20=%d\\n\", a20_state);\n\n#endif\n\n        /* if the cpu is currently executing code, we must unlink it and\n\n           all the potentially executing TB */\n\n        cpu_interrupt(env, 0);\n\n\n\n        /* when a20 is changed, all the MMU mappings are invalid, so\n\n           we must flush everything */\n\n        tlb_flush(env);\n\n        a20_enabled = a20_state;\n\n        if (a20_enabled)\n\n            a20_mask = 0xffffffff;\n\n        else\n\n            a20_mask = 0xffefffff;\n\n    }\n\n}\n", "idx": 3047}
{"project": "qemu", "commit_id": "92f2b4e71e988ad2751c71717e9fe3387753442a", "target": 0, "func": "uint64_t HELPER(cvd)(int32_t bin)\n\n{\n\n    /* positive 0 */\n\n    uint64_t dec = 0x0c;\n\n    int shift = 4;\n\n\n\n    if (bin < 0) {\n\n        bin = -bin;\n\n        dec = 0x0d;\n\n    }\n\n\n\n    for (shift = 4; (shift < 64) && bin; shift += 4) {\n\n        int current_number = bin % 10;\n\n\n\n        dec |= (current_number) << shift;\n\n        bin /= 10;\n\n    }\n\n\n\n    return dec;\n\n}\n", "idx": 3059}
{"project": "qemu", "commit_id": "cc05c43ad942165ecc6ffd39e41991bee43af044", "target": 1, "func": "bool io_mem_read(MemoryRegion *mr, hwaddr addr, uint64_t *pval, unsigned size)\n\n{\n\n    return memory_region_dispatch_read(mr, addr, pval, size);\n\n}\n", "idx": 3071}
{"project": "FFmpeg", "commit_id": "308429e124b97337a768839c1d5091900e974e7e", "target": 0, "func": "static void peak_write_chunk(AVFormatContext *s)\n\n{\n\n    WAVMuxContext *wav = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVCodecContext *enc = s->streams[0]->codec;\n\n    int64_t peak = ff_start_tag(s->pb, \"levl\");\n\n    int64_t now0;\n\n    time_t now_secs;\n\n    char timestamp[28];\n\n\n\n    /* Peak frame of incomplete block at end */\n\n    if (wav->peak_block_pos)\n\n        peak_write_frame(s);\n\n\n\n    memset(timestamp, 0, sizeof(timestamp));\n\n    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {\n\n        struct tm tmpbuf;\n\n        av_log(s, AV_LOG_INFO, \"Writing local time and date to Peak Envelope Chunk\\n\");\n\n        now0 = av_gettime();\n\n        now_secs = now0 / 1000000;\n\n        strftime(timestamp, sizeof(timestamp), \"%Y:%m:%d:%H:%M:%S:\", localtime_r(&now_secs, &tmpbuf));\n\n        av_strlcatf(timestamp, sizeof(timestamp), \"%03d\", (int)((now0 / 1000) % 1000));\n\n    }\n\n\n\n    avio_wl32(pb, 1);                           /* version */\n\n    avio_wl32(pb, wav->peak_format);            /* 8 or 16 bit */\n\n    avio_wl32(pb, wav->peak_ppv);               /* positive and negative */\n\n    avio_wl32(pb, wav->peak_block_size);        /* frames per value */\n\n    avio_wl32(pb, enc->channels);               /* number of channels */\n\n    avio_wl32(pb, wav->peak_num_frames);        /* number of peak frames */\n\n    avio_wl32(pb, wav->peak_pos_pop);           /* audio sample frame index */\n\n    avio_wl32(pb, 128);                         /* equal to size of header */\n\n    avio_write(pb, timestamp, 28);              /* ASCII time stamp */\n\n    ffio_fill(pb, 0, 60);\n\n\n\n    avio_write(pb, wav->peak_output, wav->peak_outbuf_bytes);\n\n\n\n    ff_end_tag(pb, peak);\n\n\n\n    if (!wav->data)\n\n        wav->data = peak;\n\n}\n", "idx": 3189}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qmp_input_end_list(Visitor *v)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n\n\n    qmp_input_pop(qiv, &error_abort);\n\n}\n", "idx": 3192}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint32(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint32_t *v = pv;\n\n    qemu_get_be32s(f, v);\n\n    return 0;\n\n}\n", "idx": 3195}
{"project": "qemu", "commit_id": "cd7fdfe59f4f965665dcd9868fe3764f5256d6aa", "target": 1, "func": "static void *data_plane_thread(void *opaque)\n\n{\n\n    VirtIOBlockDataPlane *s = opaque;\n\n\n\n    do {\n\n        event_poll(&s->event_poll);\n\n    } while (s->started || s->num_reqs > 0);\n\n    return NULL;\n\n}\n", "idx": 3207}
{"project": "qemu", "commit_id": "ca9bd24cf1d53775169ba9adc17e265554d1afed", "target": 1, "func": "void bdrv_close_all(void)\n\n{\n\n    BlockDriverState *bs;\n\n\n\n    QTAILQ_FOREACH(bs, &bdrv_states, device_list) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n        bdrv_close(bs);\n\n        aio_context_release(aio_context);\n\n    }\n\n}\n", "idx": 3215}
{"project": "qemu", "commit_id": "06ac27f683c52890a6d174adba8c92354fa1eceb", "target": 1, "func": "void monitor_init(CharDriverState *chr, int flags)\n\n{\n\n    static int is_first_init = 1;\n\n    Monitor *mon;\n\n\n\n    if (is_first_init) {\n\n        monitor_qapi_event_init();\n\n        sortcmdlist();\n\n        is_first_init = 0;\n\n    }\n\n\n\n    mon = g_malloc(sizeof(*mon));\n\n    monitor_data_init(mon);\n\n\n\n    mon->chr = chr;\n\n    mon->flags = flags;\n\n    if (flags & MONITOR_USE_READLINE) {\n\n        mon->rs = readline_init(monitor_readline_printf,\n\n                                monitor_readline_flush,\n\n                                mon,\n\n                                monitor_find_completion);\n\n        monitor_read_command(mon, 0);\n\n    }\n\n\n\n    if (monitor_is_qmp(mon)) {\n\n        qemu_chr_add_handlers(chr, monitor_can_read, monitor_qmp_read,\n\n                              monitor_qmp_event, mon);\n\n        qemu_chr_fe_set_echo(chr, true);\n\n        json_message_parser_init(&mon->qmp.parser, handle_qmp_command);\n\n    } else {\n\n        qemu_chr_add_handlers(chr, monitor_can_read, monitor_read,\n\n                              monitor_event, mon);\n\n    }\n\n\n\n    qemu_mutex_lock(&monitor_lock);\n\n    QLIST_INSERT_HEAD(&mon_list, mon, entry);\n\n    qemu_mutex_unlock(&monitor_lock);\n\n\n\n    if (!default_mon || (flags & MONITOR_IS_DEFAULT))\n\n        default_mon = mon;\n\n}\n", "idx": 3219}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static sPAPRDRConnector *spapr_phb_get_pci_drc(sPAPRPHBState *phb,\n\n                                               PCIDevice *pdev)\n\n{\n\n    uint32_t busnr = pci_bus_num(PCI_BUS(qdev_get_parent_bus(DEVICE(pdev))));\n\n    return spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_PCI,\n\n                                    (phb->index << 16) |\n\n                                    (busnr << 8) |\n\n                                    pdev->devfn);\n\n}\n", "idx": 3224}
{"project": "FFmpeg", "commit_id": "6ff3f3e7cec7cd78a01d0bf76cbccfbe68dc0894", "target": 0, "func": "int ff_socket_nonblock(int socket, int enable)\n\n{\n\n#ifdef __MINGW32__\n\n   return ioctlsocket(socket, FIONBIO, &enable);\n\n#else\n\n   if (enable)\n\n      return fcntl(socket, F_SETFL, fcntl(socket, F_GETFL) | O_NONBLOCK);\n\n   else\n\n      return fcntl(socket, F_SETFL, fcntl(socket, F_GETFL) & ~O_NONBLOCK);\n\n#endif\n\n}\n", "idx": 3232}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_kbd_put_keycode(void *opaque, int keycode)\n\n{\n\n    KBDState *s = opaque;\n\n\n\n    if (s->count < sizeof(s->data)) {\n\n        s->data[s->wptr] = keycode;\n\n        if (++s->wptr == sizeof(s->data))\n\n            s->wptr = 0;\n\n        s->count++;\n\n    }\n\n}\n", "idx": 3234}
{"project": "qemu", "commit_id": "c8e6c93857885a19e959ec622d92a256d1cd98eb", "target": 1, "func": "static void nvdimm_build_nfit(GSList *device_list, GArray *table_offsets,\n\n                              GArray *table_data, GArray *linker)\n\n{\n\n    GArray *structures = nvdimm_build_device_structure(device_list);\n\n    void *header;\n\n\n\n    acpi_add_table(table_offsets, table_data);\n\n\n\n    /* NFIT header. */\n\n    header = acpi_data_push(table_data, sizeof(NvdimmNfitHeader));\n\n    /* NVDIMM device structures. */\n\n    g_array_append_vals(table_data, structures->data, structures->len);\n\n\n\n    build_header(linker, table_data, header, \"NFIT\",\n\n                 sizeof(NvdimmNfitHeader) + structures->len, 1, NULL);\n\n    g_array_free(structures, true);\n\n}\n", "idx": 3249}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static int v9fs_do_mksock(V9fsState *s, V9fsString *path)\n\n{\n\n    return s->ops->mksock(&s->ctx, path->data);\n\n}\n", "idx": 3255}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static void make_dirty(uint8_t device)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n    uint8_t status;\n\n    size_t len = 512;\n\n    uintptr_t guest_buf;\n\n    void* buf;\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    guest_buf = guest_alloc(guest_malloc, len);\n\n    buf = g_malloc(len);\n\n    memset(buf, rand() % 255 + 1, len);\n\n    g_assert(guest_buf);\n\n    g_assert(buf);\n\n\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = cpu_to_le32(guest_buf),\n\n            .size = cpu_to_le32(len | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_bar, reg_status), DF | ERR);\n\n\n\n    g_free(buf);\n\n\n}", "idx": 3284}
{"project": "qemu", "commit_id": "49f676a00ab540fac1d2008be26434cf85607722", "target": 0, "func": "unsigned long find_next_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t    unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp &= (~0UL << offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if ((tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp &= (~0UL >> (BITS_PER_LONG - size));\n\n    if (tmp == 0UL) {\t\t/* Are any bits set? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ctzl(tmp);\n\n}\n", "idx": 3302}
{"project": "qemu", "commit_id": "5f2a80adc6fd2b2e4e0579a6613a9913e3cc9a05", "target": 0, "func": "uint64_t helper_cmpbge(uint64_t op1, uint64_t op2)\n\n{\n\n    uint8_t opa, opb, res;\n\n    int i;\n\n\n\n    res = 0;\n\n    for (i = 0; i < 8; i++) {\n\n        opa = op1 >> (i * 8);\n\n        opb = op2 >> (i * 8);\n\n        if (opa >= opb) {\n\n            res |= 1 << i;\n\n        }\n\n    }\n\n    return res;\n\n}\n", "idx": 3309}
{"project": "qemu", "commit_id": "81cf8d8adc64203567e03326c13ea4abec9fe5df", "target": 0, "func": "void helper_check_iol(CPUX86State *env, uint32_t t0)\n\n{\n\n    check_io(env, t0, 4);\n\n}\n", "idx": 3312}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "static inline uint64_t do_fri(CPUPPCState *env, uint64_t arg,\n\n                              int rounding_mode)\n\n{\n\n    CPU_DoubleU farg;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN round */\n\n        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN |\n\n                                        POWERPC_EXCP_FP_VXCVI);\n\n    } else if (unlikely(float64_is_quiet_nan(farg.d) ||\n\n                        float64_is_infinity(farg.d))) {\n\n        /* qNan / infinity round */\n\n        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXCVI);\n\n    } else {\n\n        set_float_rounding_mode(rounding_mode, &env->fp_status);\n\n        farg.ll = float64_round_to_int(farg.d, &env->fp_status);\n\n        /* Restore rounding mode from FPSCR */\n\n        fpscr_set_rounding_mode(env);\n\n    }\n\n    return farg.ll;\n\n}\n", "idx": 3339}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int DMA_write_memory (int nchan, void *buf, int pos, int len)\n\n{\n\n    struct dma_regs *r = &dma_controllers[nchan > 3].regs[nchan & 3];\n\n    target_phys_addr_t addr = ((r->pageh & 0x7f) << 24) | (r->page << 16) | r->now[ADDR];\n\n\n\n    if (r->mode & 0x20) {\n\n        int i;\n\n        uint8_t *p = buf;\n\n\n\n        cpu_physical_memory_write (addr - pos - len, buf, len);\n\n        /* What about 16bit transfers? */\n\n        for (i = 0; i < len; i++) {\n\n            uint8_t b = p[len - i - 1];\n\n            p[i] = b;\n\n        }\n\n    }\n\n    else\n\n        cpu_physical_memory_write (addr + pos, buf, len);\n\n\n\n    return len;\n\n}\n", "idx": 3344}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "LinuxAioState *aio_get_linux_aio(AioContext *ctx)\n\n{\n\n    if (!ctx->linux_aio) {\n\n        ctx->linux_aio = laio_init();\n\n        laio_attach_aio_context(ctx->linux_aio, ctx);\n\n    }\n\n    return ctx->linux_aio;\n\n}\n", "idx": 3365}
{"project": "FFmpeg", "commit_id": "ae43c10e36197000de2f3cc99ea35727ce98a796", "target": 0, "func": "static int replaygain_export(AVStream *st,\n\n                             const uint8_t *track_gain, const uint8_t *track_peak,\n\n                             const uint8_t *album_gain, const uint8_t *album_peak)\n\n{\n\n    AVPacketSideData *sd, *tmp;\n\n    AVReplayGain *replaygain;\n\n    int32_t tg, ag;\n\n    uint32_t tp, ap;\n\n\n\n    tg = parse_value(track_gain, INT32_MIN);\n\n    ag = parse_value(album_gain, INT32_MIN);\n\n    tp = parse_value(track_peak, 0);\n\n    ap = parse_value(album_peak, 0);\n\n\n\n    if (tg == INT32_MIN && ag == INT32_MIN)\n\n        return 0;\n\n\n\n    replaygain = av_mallocz(sizeof(*replaygain));\n\n    if (!replaygain)\n\n        return AVERROR(ENOMEM);\n\n\n\n    tmp = av_realloc_array(st->side_data, st->nb_side_data + 1, sizeof(*tmp));\n\n    if (!tmp) {\n\n        av_freep(&replaygain);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    st->side_data = tmp;\n\n    st->nb_side_data++;\n\n\n\n    sd = &st->side_data[st->nb_side_data - 1];\n\n    sd->type = AV_PKT_DATA_REPLAYGAIN;\n\n    sd->data = (uint8_t*)replaygain;\n\n    sd->size = sizeof(*replaygain);\n\n\n\n    replaygain->track_gain = tg;\n\n    replaygain->track_peak = tp;\n\n    replaygain->album_gain = ag;\n\n    replaygain->album_peak = ap;\n\n\n\n    return 0;\n\n}\n", "idx": 3368}
{"project": "qemu", "commit_id": "30fd3e27907dfd1c0c66cc1339657af1a2ce1d4b", "target": 0, "func": "static ssize_t qio_channel_command_readv(QIOChannel *ioc,\n\n                                         const struct iovec *iov,\n\n                                         size_t niov,\n\n                                         int **fds,\n\n                                         size_t *nfds,\n\n                                         Error **errp)\n\n{\n\n    QIOChannelCommand *cioc = QIO_CHANNEL_COMMAND(ioc);\n\n    ssize_t ret;\n\n\n\n retry:\n\n    ret = readv(cioc->readfd, iov, niov);\n\n    if (ret < 0) {\n\n        if (errno == EAGAIN ||\n\n            errno == EWOULDBLOCK) {\n\n            return QIO_CHANNEL_ERR_BLOCK;\n\n        }\n\n        if (errno == EINTR) {\n\n            goto retry;\n\n        }\n\n\n\n        error_setg_errno(errp, errno,\n\n                         \"Unable to read from command\");\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3436}
{"project": "qemu", "commit_id": "016f5cf6ff465411733878a17c8f8febb7668321", "target": 1, "func": "void bdrv_flush(BlockDriverState *bs)\n{\n    if (bs->drv && bs->drv->bdrv_flush)\n        bs->drv->bdrv_flush(bs);", "idx": 3461}
{"project": "qemu", "commit_id": "fa4478d5c8b74a5f0c8b93cc00590ec007be5016", "target": 1, "func": "void block_job_cancel_sync(BlockJob *job)\n\n{\n\n    BlockDriverState *bs = job->bs;\n\n\n\n    assert(bs->job == job);\n\n    block_job_cancel(job);\n\n    while (bs->job != NULL && bs->job->busy) {\n\n        qemu_aio_wait();\n\n    }\n\n}\n", "idx": 3464}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "void parse_options(void *optctx, int argc, char **argv, const OptionDef *options,\n\n                   void (*parse_arg_function)(void *, const char*))\n\n{\n\n    const char *opt;\n\n    int optindex, handleoptions = 1, ret;\n\n\n\n    /* perform system-dependent conversions for arguments list */\n\n    prepare_app_arguments(&argc, &argv);\n\n\n\n    /* parse options */\n\n    optindex = 1;\n\n    while (optindex < argc) {\n\n        opt = argv[optindex++];\n\n\n\n        if (handleoptions && opt[0] == '-' && opt[1] != '\\0') {\n\n            if (opt[1] == '-' && opt[2] == '\\0') {\n\n                handleoptions = 0;\n\n                continue;\n\n            }\n\n            opt++;\n\n\n\n            if ((ret = parse_option(optctx, opt, argv[optindex], options)) < 0)\n\n                exit(1);\n\n            optindex += ret;\n\n        } else {\n\n            if (parse_arg_function)\n\n                parse_arg_function(optctx, opt);\n\n        }\n\n    }\n\n}\n", "idx": 3472}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void vtd_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    X86IOMMUClass *x86_class = X86_IOMMU_CLASS(klass);\n\n\n\n    dc->reset = vtd_reset;\n\n    dc->vmsd = &vtd_vmstate;\n\n    dc->props = vtd_properties;\n\n    dc->hotpluggable = false;\n\n    x86_class->realize = vtd_realize;\n\n    x86_class->int_remap = vtd_int_remap;\n\n\n\n\n\n\n}", "idx": 3477}
{"project": "qemu", "commit_id": "e2b72cb6e0443d90d7ab037858cb6834b6cca852", "target": 1, "func": "static void audio_capture(void *opaque, void *buf, int size)\n\n{\n\n    VncState *vs = opaque;\n\n\n\n    vnc_lock_output(vs);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);\n\n    vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);\n\n    vnc_write_u32(vs, size);\n\n    vnc_write(vs, buf, size);\n\n    vnc_unlock_output(vs);\n\n    vnc_flush(vs);\n\n}\n", "idx": 3494}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "void av_opencl_buffer_release(cl_mem *cl_buf)\n\n{\n\n    cl_int status = 0;\n\n    if (!cl_buf)\n\n        return;\n\n    status = clReleaseMemObject(*cl_buf);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not release OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n    }\n\n    memset(cl_buf, 0, sizeof(*cl_buf));\n\n}\n", "idx": 3530}
{"project": "FFmpeg", "commit_id": "774239be717150909219ad2c0696bfb6a50cf2cb", "target": 0, "func": "static int get_preset_file_2(const char *preset_name, const char *codec_name, AVIOContext **s)\n\n{\n\n    int i, ret = 1;\n\n    char filename[1000];\n\n    const char *base[3] = { getenv(\"AVCONV_DATADIR\"),\n\n                            getenv(\"HOME\"),\n\n                            AVCONV_DATADIR,\n\n                            };\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(base) && ret; i++) {\n\n        if (!base[i])\n\n            continue;\n\n        if (codec_name) {\n\n            snprintf(filename, sizeof(filename), \"%s%s/%s-%s.avpreset\", base[i],\n\n                     i != 1 ? \"\" : \"/.avconv\", codec_name, preset_name);\n\n            ret = avio_open2(s, filename, AVIO_FLAG_READ, &int_cb, NULL);\n\n        }\n\n        if (ret) {\n\n            snprintf(filename, sizeof(filename), \"%s%s/%s.avpreset\", base[i],\n\n                     i != 1 ? \"\" : \"/.avconv\", preset_name);\n\n            ret = avio_open2(s, filename, AVIO_FLAG_READ, &int_cb, NULL);\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 3566}
{"project": "FFmpeg", "commit_id": "ac7ff0963bf353ffd951ae8d51444b82b7ea69c1", "target": 0, "func": "static void apply_tns(float coef[1024], TemporalNoiseShaping *tns,\n\n                      IndividualChannelStream *ics, int decode)\n\n{\n\n    const int mmm = FFMIN(ics->tns_max_bands, ics->max_sfb);\n\n    int w, filt, m, i;\n\n    int bottom, top, order, start, end, size, inc;\n\n    float lpc[TNS_MAX_ORDER];\n\n    float tmp[TNS_MAX_ORDER];\n\n\n\n    for (w = 0; w < ics->num_windows; w++) {\n\n        bottom = ics->num_swb;\n\n        for (filt = 0; filt < tns->n_filt[w]; filt++) {\n\n            top    = bottom;\n\n            bottom = FFMAX(0, top - tns->length[w][filt]);\n\n            order  = tns->order[w][filt];\n\n            if (order == 0)\n\n                continue;\n\n\n\n            // tns_decode_coef\n\n            compute_lpc_coefs(tns->coef[w][filt], order, lpc, 0, 0, 0);\n\n\n\n            start = ics->swb_offset[FFMIN(bottom, mmm)];\n\n            end   = ics->swb_offset[FFMIN(   top, mmm)];\n\n            if ((size = end - start) <= 0)\n\n                continue;\n\n            if (tns->direction[w][filt]) {\n\n                inc = -1;\n\n                start = end - 1;\n\n            } else {\n\n                inc = 1;\n\n            }\n\n            start += w * 128;\n\n\n\n            if (decode) {\n\n                // ar filter\n\n                for (m = 0; m < size; m++, start += inc)\n\n                    for (i = 1; i <= FFMIN(m, order); i++)\n\n                        coef[start] -= coef[start - i * inc] * lpc[i - 1];\n\n            } else {\n\n                // ma filter\n\n                for (m = 0; m < size; m++, start += inc) {\n\n                    tmp[0] = coef[start];\n\n                    for (i = 1; i <= FFMIN(m, order); i++)\n\n                        coef[start] += tmp[i] * lpc[i - 1];\n\n                    for (i = order; i > 0; i--)\n\n                        tmp[i] = tmp[i - 1];\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 3569}
{"project": "FFmpeg", "commit_id": "821a5938d100458f4d09d634041b05c860554ce0", "target": 0, "func": "static int g2m_init_buffers(G2MContext *c)\n\n{\n\n    int aligned_height;\n\n\n\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n\n        aligned_height     = FFALIGN(c->height,    16);\n\n        av_free(c->framebuf);\n\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n\n        if (!c->framebuf)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    if (!c->synth_tile || !c->jpeg_tile ||\n\n        c->old_tile_w < c->tile_width ||\n\n        c->old_tile_h < c->tile_height) {\n\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n\n        aligned_height = FFALIGN(c->tile_height,    16);\n\n        av_free(c->synth_tile);\n\n        av_free(c->jpeg_tile);\n\n        av_free(c->kempf_buf);\n\n        av_free(c->kempf_flags);\n\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n\n        if (!c->synth_tile || !c->jpeg_tile ||\n\n            !c->kempf_buf || !c->kempf_flags)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3585}
{"project": "qemu", "commit_id": "4abf12f4ea866779b493ecf4606bd0b6d35f8348", "target": 1, "func": "static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)\n\n{\n\n    RTL8139State *s = opaque;\n\n    int ret;\n\n\n\n    addr &= 0xff;\n\n\n\n    switch (addr)\n\n    {\n\n        case MAC0 ... MAC0+5:\n\n            ret = s->phys[addr - MAC0];\n\n            break;\n\n        case MAC0+6 ... MAC0+7:\n\n            ret = 0;\n\n            break;\n\n        case MAR0 ... MAR0+7:\n\n            ret = s->mult[addr - MAR0];\n\n            break;\n\n        case ChipCmd:\n\n            ret = rtl8139_ChipCmd_read(s);\n\n            break;\n\n        case Cfg9346:\n\n            ret = rtl8139_Cfg9346_read(s);\n\n            break;\n\n        case Config0:\n\n            ret = rtl8139_Config0_read(s);\n\n            break;\n\n        case Config1:\n\n            ret = rtl8139_Config1_read(s);\n\n            break;\n\n        case Config3:\n\n            ret = rtl8139_Config3_read(s);\n\n            break;\n\n        case Config4:\n\n            ret = rtl8139_Config4_read(s);\n\n            break;\n\n        case Config5:\n\n            ret = rtl8139_Config5_read(s);\n\n            break;\n\n\n\n        case MediaStatus:\n\n            ret = 0xd0;\n\n            DPRINTF(\"MediaStatus read 0x%x\\n\", ret);\n\n            break;\n\n\n\n        case HltClk:\n\n            ret = s->clock_enabled;\n\n            DPRINTF(\"HltClk read 0x%x\\n\", ret);\n\n            break;\n\n\n\n        case PCIRevisionID:\n\n            ret = RTL8139_PCI_REVID;\n\n            DPRINTF(\"PCI Revision ID read 0x%x\\n\", ret);\n\n            break;\n\n\n\n        case TxThresh:\n\n            ret = s->TxThresh;\n\n            DPRINTF(\"C+ TxThresh read(b) val=0x%02x\\n\", ret);\n\n            break;\n\n\n\n        case 0x43: /* Part of TxConfig register. Windows driver tries to read it */\n\n            ret = s->TxConfig >> 24;\n\n            DPRINTF(\"RTL8139C TxConfig at 0x43 read(b) val=0x%02x\\n\", ret);\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"not implemented read(b) addr=0x%x\\n\", addr);\n\n            ret = 0;\n\n            break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3600}
{"project": "FFmpeg", "commit_id": "db9aee6ccf183508835acc325f5ad87d595eacc4", "target": 0, "func": "static int oma_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    OMAContext *oc = s->priv_data;\n\n    int packet_size = s->streams[0]->codec->block_align;\n\n    int ret = av_get_packet(s->pb, pkt, packet_size);\n\n\n\n    if (ret <= 0)\n\n        return AVERROR(EIO);\n\n\n\n    pkt->stream_index = 0;\n\n\n\n    if (oc->encrypted) {\n\n        /* previous unencrypted block saved in IV for\n\n         * the next packet (CBC mode) */\n\n        av_des_crypt(&oc->av_des, pkt->data, pkt->data,\n\n                     (packet_size >> 3), oc->iv, 1);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 3620}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "rtsp_open_transport_ctx(AVFormatContext *s, RTSPStream *rtsp_st)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    AVStream *st = NULL;\n\n\n\n    /* open the RTP context */\n\n    if (rtsp_st->stream_index >= 0)\n\n        st = s->streams[rtsp_st->stream_index];\n\n    if (!st)\n\n        s->ctx_flags |= AVFMTCTX_NOHEADER;\n\n\n\n    if (rt->transport == RTSP_TRANSPORT_RDT)\n\n        rtsp_st->transport_priv = ff_rdt_parse_open(s, st->index,\n\n                                            rtsp_st->dynamic_protocol_context,\n\n                                            rtsp_st->dynamic_handler);\n\n    else\n\n        rtsp_st->transport_priv = rtp_parse_open(s, st, rtsp_st->rtp_handle,\n\n                                         rtsp_st->sdp_payload_type,\n\n                                         &rtsp_st->rtp_payload_data);\n\n\n\n    if (!rtsp_st->transport_priv) {\n\n         return AVERROR(ENOMEM);\n\n    } else if (rt->transport != RTSP_TRANSPORT_RDT) {\n\n        if(rtsp_st->dynamic_handler) {\n\n            rtp_parse_set_dynamic_protocol(rtsp_st->transport_priv,\n\n                                           rtsp_st->dynamic_protocol_context,\n\n                                           rtsp_st->dynamic_handler);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3638}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "void net_tx_pkt_update_ip_checksums(struct NetTxPkt *pkt)\n\n{\n\n    uint16_t csum;\n\n    uint32_t ph_raw_csum;\n\n    assert(pkt);\n\n    uint8_t gso_type = pkt->virt_hdr.gso_type & ~VIRTIO_NET_HDR_GSO_ECN;\n\n    struct ip_header *ip_hdr;\n\n\n\n    if (VIRTIO_NET_HDR_GSO_TCPV4 != gso_type &&\n\n        VIRTIO_NET_HDR_GSO_UDP != gso_type) {\n\n        return;\n\n    }\n\n\n\n    ip_hdr = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n\n\n\n    if (pkt->payload_len + pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len >\n\n        ETH_MAX_IP_DGRAM_LEN) {\n\n        return;\n\n    }\n\n\n\n    ip_hdr->ip_len = cpu_to_be16(pkt->payload_len +\n\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n\n\n\n    /* Calculate IP header checksum                    */\n\n    ip_hdr->ip_sum = 0;\n\n    csum = net_raw_checksum((uint8_t *)ip_hdr,\n\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n\n    ip_hdr->ip_sum = cpu_to_be16(csum);\n\n\n\n    /* Calculate IP pseudo header checksum             */\n\n    ph_raw_csum = eth_calc_pseudo_hdr_csum(ip_hdr, pkt->payload_len);\n\n    csum = cpu_to_be16(~net_checksum_finish(ph_raw_csum));\n\n    iov_from_buf(&pkt->vec[NET_TX_PKT_PL_START_FRAG], pkt->payload_frags,\n\n                 pkt->virt_hdr.csum_offset, &csum, sizeof(csum));\n\n}\n", "idx": 3662}
{"project": "FFmpeg", "commit_id": "cb036f905f6ffa7b0dfdb9c35471a8280e00214e", "target": 1, "func": "static void alloc_picture(void *opaque)\n\n{\n\n    VideoState *is = opaque;\n\n    VideoPicture *vp;\n\n\n\n    vp = &is->pictq[is->pictq_windex];\n\n\n\n    if (vp->bmp)\n\n        SDL_FreeYUVOverlay(vp->bmp);\n\n\n\n#if CONFIG_AVFILTER\n\n    if (vp->picref)\n\n        avfilter_unref_buffer(vp->picref);\n\n    vp->picref = NULL;\n\n\n\n    vp->width   = is->out_video_filter->inputs[0]->w;\n\n    vp->height  = is->out_video_filter->inputs[0]->h;\n\n    vp->pix_fmt = is->out_video_filter->inputs[0]->format;\n\n#else\n\n    vp->width   = is->video_st->codec->width;\n\n    vp->height  = is->video_st->codec->height;\n\n    vp->pix_fmt = is->video_st->codec->pix_fmt;\n\n#endif\n\n\n\n    vp->bmp = SDL_CreateYUVOverlay(vp->width, vp->height,\n\n                                   SDL_YV12_OVERLAY,\n\n                                   screen);\n\n\n\n\n\n\n\n\n\n\n\n    SDL_LockMutex(is->pictq_mutex);\n\n    vp->allocated = 1;\n\n    SDL_CondSignal(is->pictq_cond);\n\n    SDL_UnlockMutex(is->pictq_mutex);\n", "idx": 3690}
{"project": "qemu", "commit_id": "882b3b97697affb36ca3d174f42f846232008979", "target": 1, "func": "int css_create_css_image(uint8_t cssid, bool default_image)\n\n{\n\n    trace_css_new_image(cssid, default_image ? \"(default)\" : \"\");\n\n    if (cssid > MAX_CSSID) {\n\n        return -EINVAL;\n\n    }\n\n    if (channel_subsys.css[cssid]) {\n\n        return -EBUSY;\n\n    }\n\n    channel_subsys.css[cssid] = g_malloc0(sizeof(CssImage));\n\n    if (default_image) {\n\n        channel_subsys.default_cssid = cssid;\n\n    }\n\n    return 0;\n\n}\n", "idx": 3698}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "static void pxa2xx_pic_save(QEMUFile *f, void *opaque)\n\n{\n\n    PXA2xxPICState *s = (PXA2xxPICState *) opaque;\n\n    int i;\n\n\n\n    for (i = 0; i < 2; i ++)\n\n        qemu_put_be32s(f, &s->int_enabled[i]);\n\n    for (i = 0; i < 2; i ++)\n\n        qemu_put_be32s(f, &s->int_pending[i]);\n\n    for (i = 0; i < 2; i ++)\n\n        qemu_put_be32s(f, &s->is_fiq[i]);\n\n    qemu_put_be32s(f, &s->int_idle);\n\n    for (i = 0; i < PXA2XX_PIC_SRCS; i ++)\n\n        qemu_put_be32s(f, &s->priority[i]);\n\n}\n", "idx": 3747}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "static int nbd_co_send_request(BDRVNBDState *s, struct nbd_request *request,\n\n                               struct iovec *iov, int offset)\n\n{\n\n    int rc, ret;\n\n\n\n    qemu_co_mutex_lock(&s->send_mutex);\n\n    s->send_coroutine = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, nbd_restart_write,\n\n                            nbd_have_request, NULL, s);\n\n    rc = nbd_send_request(s->sock, request);\n\n    if (rc >= 0 && iov) {\n\n        ret = qemu_co_sendv(s->sock, iov, request->len, offset);\n\n        if (ret != request->len) {\n\n            errno = -EIO;\n\n            rc = -1;\n\n        }\n\n    }\n\n    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,\n\n                            nbd_have_request, NULL, s);\n\n    s->send_coroutine = NULL;\n\n    qemu_co_mutex_unlock(&s->send_mutex);\n\n    return rc;\n\n}\n", "idx": 3757}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "void replay_save_input_event(InputEvent *evt)\n\n{\n\n    InputKeyEvent *key;\n\n    InputBtnEvent *btn;\n\n    InputMoveEvent *move;\n\n    replay_put_dword(evt->type);\n\n\n\n    switch (evt->type) {\n\n    case INPUT_EVENT_KIND_KEY:\n\n        key = evt->u.key;\n\n        replay_put_dword(key->key->type);\n\n\n\n        switch (key->key->type) {\n\n        case KEY_VALUE_KIND_NUMBER:\n\n            replay_put_qword(key->key->u.number);\n\n            replay_put_byte(key->down);\n\n            break;\n\n        case KEY_VALUE_KIND_QCODE:\n\n            replay_put_dword(key->key->u.qcode);\n\n            replay_put_byte(key->down);\n\n            break;\n\n        case KEY_VALUE_KIND__MAX:\n\n            /* keep gcc happy */\n\n            break;\n\n        }\n\n        break;\n\n    case INPUT_EVENT_KIND_BTN:\n\n        btn = evt->u.btn;\n\n        replay_put_dword(btn->button);\n\n        replay_put_byte(btn->down);\n\n        break;\n\n    case INPUT_EVENT_KIND_REL:\n\n        move = evt->u.rel;\n\n        replay_put_dword(move->axis);\n\n        replay_put_qword(move->value);\n\n        break;\n\n    case INPUT_EVENT_KIND_ABS:\n\n        move = evt->u.abs;\n\n        replay_put_dword(move->axis);\n\n        replay_put_qword(move->value);\n\n        break;\n\n    case INPUT_EVENT_KIND__MAX:\n\n        /* keep gcc happy */\n\n        break;\n\n    }\n\n}\n", "idx": 3761}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "void qdev_set_parent_bus(DeviceState *dev, BusState *bus)\n\n{\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        assert(bus->allow_hotplug);\n\n    }\n\n\n\n    dev->parent_bus = bus;\n\n    QTAILQ_INSERT_HEAD(&bus->children, dev, sibling);\n\n\n\n    qdev_prop_set_defaults(dev, dev->parent_bus->info->props);\n\n    for (prop = qdev_get_bus_info(dev)->props; prop && prop->name; prop++) {\n\n        qdev_property_add_legacy(dev, prop, NULL);\n\n        qdev_property_add_static(dev, prop, NULL);\n\n    }\n\n}\n", "idx": 3774}
{"project": "qemu", "commit_id": "e7ca56562990991bc614a43b9351ee0737f3045d", "target": 0, "func": "int object_property_get_enum(Object *obj, const char *name,\n\n                             const char *typename, Error **errp)\n\n{\n\n    Error *err = NULL;\n\n    StringOutputVisitor *sov;\n\n    Visitor *v;\n\n    char *str;\n\n    int ret;\n\n    ObjectProperty *prop = object_property_find(obj, name, errp);\n\n    EnumProperty *enumprop;\n\n\n\n    if (prop == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    if (!g_str_equal(prop->type, typename)) {\n\n        error_setg(errp, \"Property %s on %s is not '%s' enum type\",\n\n                   name, object_class_get_name(\n\n                       object_get_class(obj)), typename);\n\n        return 0;\n\n    }\n\n\n\n    enumprop = prop->opaque;\n\n\n\n    sov = string_output_visitor_new(false);\n\n    object_property_get(obj, string_output_get_visitor(sov), name, &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        string_output_visitor_cleanup(sov);\n\n        return 0;\n\n    }\n\n    str = string_output_get_string(sov);\n\n    string_output_visitor_cleanup(sov);\n\n    v = string_input_visitor_new(str);\n\n    visit_type_enum(v, name, &ret, enumprop->strings, errp);\n\n\n\n    g_free(str);\n\n    visit_free(v);\n\n\n\n    return ret;\n\n}\n", "idx": 3786}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_sti_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    struct omap_sti_s *s = (struct omap_sti_s *) opaque;\n\n\n\n    if (size != 4) {\n\n        return omap_badwidth_read32(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x00:\t/* STI_REVISION */\n\n        return 0x10;\n\n\n\n    case 0x10:\t/* STI_SYSCONFIG */\n\n        return s->sysconfig;\n\n\n\n    case 0x14:\t/* STI_SYSSTATUS / STI_RX_STATUS / XTI_SYSSTATUS */\n\n        return 0x00;\n\n\n\n    case 0x18:\t/* STI_IRQSTATUS */\n\n        return s->irqst;\n\n\n\n    case 0x1c:\t/* STI_IRQSETEN / STI_IRQCLREN */\n\n        return s->irqen;\n\n\n\n    case 0x24:\t/* STI_ER / STI_DR / XTI_TRACESELECT */\n\n    case 0x28:\t/* STI_RX_DR / XTI_RXDATA */\n\n        /* TODO */\n\n        return 0;\n\n\n\n    case 0x2c:\t/* STI_CLK_CTRL / XTI_SCLKCRTL */\n\n        return s->clkcontrol;\n\n\n\n    case 0x30:\t/* STI_SERIAL_CFG / XTI_SCONFIG */\n\n        return s->serial_config;\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 3789}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static int pollfds_fill(GArray *pollfds, fd_set *rfds, fd_set *wfds,\n\n                        fd_set *xfds)\n\n{\n\n    int nfds = -1;\n\n    int i;\n\n\n\n    for (i = 0; i < pollfds->len; i++) {\n\n        GPollFD *pfd = &g_array_index(pollfds, GPollFD, i);\n\n        int fd = pfd->fd;\n\n        int events = pfd->events;\n\n        if (events & G_IO_IN) {\n\n            FD_SET(fd, rfds);\n\n            nfds = MAX(nfds, fd);\n\n        }\n\n        if (events & G_IO_OUT) {\n\n            FD_SET(fd, wfds);\n\n            nfds = MAX(nfds, fd);\n\n        }\n\n        if (events & G_IO_PRI) {\n\n            FD_SET(fd, xfds);\n\n            nfds = MAX(nfds, fd);\n\n        }\n\n    }\n\n    return nfds;\n\n}\n", "idx": 3799}
{"project": "qemu", "commit_id": "dcc772e2f2b7c2a68644133fea2b874f6751a57b", "target": 0, "func": "void qemu_bh_schedule_idle(QEMUBH *bh)\n\n{\n\n    if (bh->scheduled)\n\n        return;\n\n    bh->scheduled = 1;\n\n    bh->idle = 1;\n\n}\n", "idx": 3800}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stl_phys(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    stl_phys_internal(addr, val, DEVICE_NATIVE_ENDIAN);\n\n}\n", "idx": 3814}
{"project": "FFmpeg", "commit_id": "d2779ecd8b1fb9dc8a8f37a75ff8c3b077f3143e", "target": 0, "func": "static inline int vc1_i_pred_dc(MpegEncContext *s, int overlap, int pq, int n,\n\n                              int16_t **dc_val_ptr, int *dir_ptr)\n\n{\n\n    int a, b, c, wrap, pred, scale;\n\n    int16_t *dc_val;\n\n    static const uint16_t dcpred[32] = {\n\n    -1, 1024,  512,  341,  256,  205,  171,  146,  128,\n\n         114,  102,   93,   85,   79,   73,   68,   64,\n\n          60,   57,   54,   51,   49,   47,   45,   43,\n\n          41,   39,   38,   37,   35,   34,   33\n\n    };\n\n\n\n    /* find prediction - wmv3_dc_scale always used here in fact */\n\n    if (n < 4)     scale = s->y_dc_scale;\n\n    else           scale = s->c_dc_scale;\n\n\n\n    wrap = s->block_wrap[n];\n\n    dc_val= s->dc_val[0] + s->block_index[n];\n\n\n\n    /* B A\n\n     * C X\n\n     */\n\n    c = dc_val[ - 1];\n\n    b = dc_val[ - 1 - wrap];\n\n    a = dc_val[ - wrap];\n\n\n\n    if (pq < 9 || !overlap)\n\n    {\n\n        /* Set outer values */\n\n        if (!s->mb_y && (n!=2 && n!=3)) b=a=dcpred[scale];\n\n        if (s->mb_x == 0 && (n!=1 && n!=3)) b=c=dcpred[scale];\n\n    }\n\n    else\n\n    {\n\n        /* Set outer values */\n\n        if (!s->mb_y && (n!=2 && n!=3)) b=a=0;\n\n        if (s->mb_x == 0 && (n!=1 && n!=3)) b=c=0;\n\n    }\n\n\n\n    if (abs(a - b) <= abs(b - c)) {\n\n        pred = c;\n\n        *dir_ptr = 1;//left\n\n    } else {\n\n        pred = a;\n\n        *dir_ptr = 0;//top\n\n    }\n\n\n\n    /* update predictor */\n\n    *dc_val_ptr = &dc_val[0];\n\n    return pred;\n\n}\n", "idx": 3820}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static void multiwrite_user_cb(MultiwriteCB *mcb)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < mcb->num_callbacks; i++) {\n\n        mcb->callbacks[i].cb(mcb->callbacks[i].opaque, mcb->error);\n\n        if (mcb->callbacks[i].free_qiov) {\n\n            qemu_iovec_destroy(mcb->callbacks[i].free_qiov);\n\n        }\n\n        g_free(mcb->callbacks[i].free_qiov);\n\n    }\n\n}\n", "idx": 3858}
{"project": "qemu", "commit_id": "4fd37a98d1248bae54a9f71ee1c252d2b2f1efd5", "target": 0, "func": "char *get_boot_devices_list(uint32_t *size)\n\n{\n\n    FWBootEntry *i;\n\n    uint32_t total = 0;\n\n    char *list = NULL;\n\n\n\n    QTAILQ_FOREACH(i, &fw_boot_order, link) {\n\n        char *devpath = NULL, *bootpath;\n\n        int len;\n\n\n\n        if (i->dev) {\n\n            devpath = qdev_get_fw_dev_path(i->dev);\n\n            assert(devpath);\n\n        }\n\n\n\n        if (i->suffix && devpath) {\n\n            bootpath = qemu_malloc(strlen(devpath) + strlen(i->suffix) + 1);\n\n            sprintf(bootpath, \"%s%s\", devpath, i->suffix);\n\n            qemu_free(devpath);\n\n        } else if (devpath) {\n\n            bootpath = devpath;\n\n        } else {\n\n            bootpath = strdup(i->suffix);\n\n            assert(bootpath);\n\n        }\n\n\n\n        if (total) {\n\n            list[total-1] = '\\n';\n\n        }\n\n        len = strlen(bootpath) + 1;\n\n        list = qemu_realloc(list, total + len);\n\n        memcpy(&list[total], bootpath, len);\n\n        total += len;\n\n        qemu_free(bootpath);\n\n    }\n\n\n\n    *size = total;\n\n\n\n    return list;\n\n}\n", "idx": 3859}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void framebuffer_update_request(VncState *vs, int incremental,\n\n                                       int x_position, int y_position,\n\n                                       int w, int h)\n\n{\n\n    int i;\n\n    const size_t width = surface_width(vs->vd->ds) / VNC_DIRTY_PIXELS_PER_BIT;\n\n    const size_t height = surface_height(vs->vd->ds);\n\n\n\n    if (y_position > height) {\n\n        y_position = height;\n\n    }\n\n    if (y_position + h >= height) {\n\n        h = height - y_position;\n\n    }\n\n\n\n    vs->need_update = 1;\n\n    if (!incremental) {\n\n        vs->force_update = 1;\n\n        for (i = 0; i < h; i++) {\n\n            bitmap_set(vs->dirty[y_position + i], 0, width);\n\n            bitmap_clear(vs->dirty[y_position + i], width,\n\n                         VNC_DIRTY_BITS - width);\n\n        }\n\n    }\n\n}\n", "idx": 3907}
{"project": "FFmpeg", "commit_id": "7d09a993d14c420ce53070312e77a224dbb4bc99", "target": 1, "func": "static void sdp_parse_fmtp_config(AVCodecContext *codec, char *attr, char *value)\n\n{\n\n    switch (codec->codec_id) {\n\n        case CODEC_ID_MPEG4:\n\n        case CODEC_ID_AAC:\n\n            if (!strcmp(attr, \"config\")) {\n\n                /* decode the hexa encoded parameter */\n\n                int len = hex_to_data(NULL, value);\n\n\n\n                codec->extradata = av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if (!codec->extradata)\n\n                    return;\n\n                codec->extradata_size = len;\n\n                hex_to_data(codec->extradata, value);\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n    }\n\n    return;\n\n}", "idx": 3909}
{"project": "qemu", "commit_id": "e7658fcc4c29a29c578acde26f7714023b93b46e", "target": 1, "func": "static int tpm_passthrough_unix_write(int fd, const uint8_t *buf, uint32_t len)\n\n{\n\n    int ret, remain;\n\n\n\n    remain = len;\n\n    while (len > 0) {\n\n        ret = write(fd, buf, remain);\n\n        if (ret < 0) {\n\n            if (errno != EINTR && errno != EAGAIN) {\n\n                return -1;\n\n            }\n\n        } else if (ret == 0) {\n\n            break;\n\n        } else {\n\n            buf += ret;\n\n            remain -= ret;\n\n        }\n\n    }\n\n    return len - remain;\n\n}\n", "idx": 3917}
{"project": "qemu", "commit_id": "7eff518b6c91bdd62710dd9868ec7a17bd6f1434", "target": 1, "func": "static struct iovec *lock_iovec(int type, abi_ulong target_addr,\n\n                                int count, int copy)\n\n{\n\n    struct target_iovec *target_vec;\n\n    struct iovec *vec;\n\n    abi_ulong total_len, max_len;\n\n    int i;\n\n    int err = 0;\n\n    bool bad_address = false;\n\n\n\n    if (count == 0) {\n\n        errno = 0;\n\n        return NULL;\n\n\n    if (count < 0 || count > IOV_MAX) {\n\n        errno = EINVAL;\n\n        return NULL;\n\n\n\n\n    vec = calloc(count, sizeof(struct iovec));\n\n    if (vec == NULL) {\n\n        errno = ENOMEM;\n\n        return NULL;\n\n\n\n\n    target_vec = lock_user(VERIFY_READ, target_addr,\n\n                           count * sizeof(struct target_iovec), 1);\n\n    if (target_vec == NULL) {\n\n        err = EFAULT;\n\n        goto fail2;\n\n\n\n\n    /* ??? If host page size > target page size, this will result in a\n\n       value larger than what we can actually support.  */\n\n    max_len = 0x7fffffff & TARGET_PAGE_MASK;\n\n    total_len = 0;\n\n\n\n    for (i = 0; i < count; i++) {\n\n        abi_ulong base = tswapal(target_vec[i].iov_base);\n\n        abi_long len = tswapal(target_vec[i].iov_len);\n\n\n\n        if (len < 0) {\n\n            err = EINVAL;\n\n            goto fail;\n\n        } else if (len == 0) {\n\n            /* Zero length pointer is ignored.  */\n\n            vec[i].iov_base = 0;\n\n        } else {\n\n            vec[i].iov_base = lock_user(type, base, len, copy);\n\n            /* If the first buffer pointer is bad, this is a fault.  But\n\n             * subsequent bad buffers will result in a partial write; this\n\n             * is realized by filling the vector with null pointers and\n\n             * zero lengths. */\n\n            if (!vec[i].iov_base) {\n\n                if (i == 0) {\n\n                    err = EFAULT;\n\n                    goto fail;\n\n                } else {\n\n                    bad_address = true;\n\n\n\n            if (bad_address) {\n\n                len = 0;\n\n\n            if (len > max_len - total_len) {\n\n                len = max_len - total_len;\n\n\n\n        vec[i].iov_len = len;\n\n        total_len += len;\n\n\n\n\n    unlock_user(target_vec, target_addr, 0);\n\n    return vec;\n\n\n\n fail:\n\n\n\n\n\n\n    unlock_user(target_vec, target_addr, 0);\n\n fail2:\n\n    free(vec);\n\n    errno = err;\n\n    return NULL;\n", "idx": 3955}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void cris_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    CRISCPU *cpu = CRIS_CPU(obj);\n\n    CRISCPUClass *ccc = CRIS_CPU_GET_CLASS(obj);\n\n    CPUCRISState *env = &cpu->env;\n\n    static bool tcg_initialized;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    env->pregs[PR_VR] = ccc->vr;\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    /* IRQ and NMI lines.  */\n\n    qdev_init_gpio_in(DEVICE(cpu), cris_cpu_set_irq, 2);\n\n#endif\n\n\n\n    if (tcg_enabled() && !tcg_initialized) {\n\n        tcg_initialized = true;\n\n        if (env->pregs[PR_VR] < 32) {\n\n            cris_initialize_crisv10_tcg();\n\n        } else {\n\n            cris_initialize_tcg();\n\n        }\n\n    }\n\n}\n", "idx": 3968}
{"project": "FFmpeg", "commit_id": "0b42631641d998e509cde6fa344edc6ab5cb4ac8", "target": 0, "func": "static int get_cod(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n\n                   uint8_t *properties)\n\n{\n\n    Jpeg2000CodingStyle tmp;\n\n    int compno;\n\n\n\n    if (s->buf_end - s->buf < 5)\n\n        return AVERROR(EINVAL);\n\n\n\n    tmp.log2_prec_width  =\n\n    tmp.log2_prec_height = 15;\n\n\n\n    tmp.csty = bytestream_get_byte(&s->buf);\n\n\n\n    // get progression order\n\n    tmp.prog_order = bytestream_get_byte(&s->buf);\n\n\n\n    tmp.nlayers = bytestream_get_be16(&s->buf);\n\n    tmp.mct     = bytestream_get_byte(&s->buf); // multiple component transformation\n\n\n\n    get_cox(s, &tmp);\n\n    for (compno = 0; compno < s->ncomponents; compno++)\n\n        if (!(properties[compno] & HAD_COC))\n\n            memcpy(c + compno, &tmp, sizeof(tmp));\n\n    return 0;\n\n}\n", "idx": 3969}
{"project": "FFmpeg", "commit_id": "9ca16bdd3f0461b40d369080647747ae70715daf", "target": 1, "func": "static int32_t scalarproduct_and_madd_int16_c(int16_t *v1, const int16_t *v2,\n\n                                              const int16_t *v3,\n\n                                              int order, int mul)\n\n{\n\n    int res = 0;\n\n\n\n    while (order--) {\n\n        res   += *v1 * *v2++;\n\n        *v1++ += mul * *v3++;\n\n    }\n\n    return res;\n\n}\n", "idx": 3974}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void exec_start_incoming_migration(const char *command, Error **errp)\n\n{\n\n    QEMUFile *f;\n\n\n\n    DPRINTF(\"Attempting to start an incoming migration\\n\");\n\n    f = qemu_popen_cmd(command, \"r\");\n\n    if(f == NULL) {\n\n        error_setg_errno(errp, errno, \"failed to popen the migration source\");\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(qemu_get_fd(f), NULL,\n\n\t\t\t exec_accept_incoming_migration, NULL, f);\n\n}\n", "idx": 3992}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "static void io_mem_init(void)\n\n{\n\n    cpu_register_io_memory(IO_MEM_ROM >> IO_MEM_SHIFT, error_mem_read, unassigned_mem_write, NULL);\n\n    cpu_register_io_memory(IO_MEM_UNASSIGNED >> IO_MEM_SHIFT, unassigned_mem_read, unassigned_mem_write, NULL);\n\n    cpu_register_io_memory(IO_MEM_NOTDIRTY >> IO_MEM_SHIFT, error_mem_read, notdirty_mem_write, NULL);\n\n    io_mem_nb = 5;\n\n\n\n\n\n\n\n    /* alloc dirty bits array */\n\n    phys_ram_dirty = qemu_vmalloc(phys_ram_size >> TARGET_PAGE_BITS);\n\n    memset(phys_ram_dirty, 0xff, phys_ram_size >> TARGET_PAGE_BITS);\n\n}", "idx": 3994}
{"project": "qemu", "commit_id": "46abb8124006887d071921c5e657eeec3c50a9e2", "target": 1, "func": "static void virtio_balloon_device_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOBalloon *s = VIRTIO_BALLOON(dev);\n\n    int ret;\n\n\n\n    virtio_init(vdev, \"virtio-balloon\", VIRTIO_ID_BALLOON,\n\n                sizeof(struct virtio_balloon_config));\n\n\n\n    ret = qemu_add_balloon_handler(virtio_balloon_to_target,\n\n                                   virtio_balloon_stat, s);\n\n\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Adding balloon handler failed\");\n\n        virtio_cleanup(vdev);\n\n        return;\n\n    }\n\n\n\n    s->ivq = virtio_add_queue(vdev, 128, virtio_balloon_handle_output);\n\n    s->dvq = virtio_add_queue(vdev, 128, virtio_balloon_handle_output);\n\n    s->svq = virtio_add_queue(vdev, 128, virtio_balloon_receive_stats);\n\n\n\n    reset_stats(s);\n\n\n\n    register_savevm(dev, \"virtio-balloon\", -1, 1,\n\n                    virtio_balloon_save, virtio_balloon_load, s);\n\n\n\n    object_property_add(OBJECT(dev), \"guest-stats\", \"guest statistics\",\n\n                        balloon_stats_get_all, NULL, NULL, s, NULL);\n\n\n\n    object_property_add(OBJECT(dev), \"guest-stats-polling-interval\", \"int\",\n\n                        balloon_stats_get_poll_interval,\n\n                        balloon_stats_set_poll_interval,\n\n                        NULL, s, NULL);\n\n}\n", "idx": 4061}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(LEToUV)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"mov                    %0, %%\"REG_a\"       \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq    (%1, %%\"REG_a\",2), %%mm0           \\n\\t\"\n\n        \"movq   8(%1, %%\"REG_a\",2), %%mm1           \\n\\t\"\n\n        \"movq    (%2, %%\"REG_a\",2), %%mm2           \\n\\t\"\n\n        \"movq   8(%2, %%\"REG_a\",2), %%mm3           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"psrlw                  $8, %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm2           \\n\\t\"\n\n        \"psrlw                  $8, %%mm3           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm0           \\n\\t\"\n\n        \"packuswb            %%mm3, %%mm2           \\n\\t\"\n\n        \"movq                %%mm0, (%3, %%\"REG_a\") \\n\\t\"\n\n        \"movq                %%mm2, (%4, %%\"REG_a\") \\n\\t\"\n\n        \"add                    $8, %%\"REG_a\"       \\n\\t\"\n\n        \" js                    1b                  \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src1+width*2), \"r\" (src2+width*2), \"r\" (dstU+width), \"r\" (dstV+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        dstU[i]= src1[2*i + 1];\n\n        dstV[i]= src2[2*i + 1];\n\n    }\n\n#endif\n\n}\n", "idx": 4071}
{"project": "qemu", "commit_id": "cd9953f720e1d57cfa86bc0882abced45ba96d3c", "target": 1, "func": "static int resize_peers(IVShmemState *s, int new_min_size)\n\n{\n\n\n\n    int j, old_size;\n\n\n\n    /* limit number of max peers */\n\n    if (new_min_size <= 0 || new_min_size > IVSHMEM_MAX_PEERS) {\n\n        return -1;\n\n    }\n\n    if (new_min_size <= s->nb_peers) {\n\n        return 0;\n\n    }\n\n\n\n    old_size = s->nb_peers;\n\n    s->nb_peers = new_min_size;\n\n\n\n    IVSHMEM_DPRINTF(\"bumping storage to %d peers\\n\", s->nb_peers);\n\n\n\n    s->peers = g_realloc(s->peers, s->nb_peers * sizeof(Peer));\n\n\n\n    for (j = old_size; j < s->nb_peers; j++) {\n\n        s->peers[j].eventfds = g_new0(EventNotifier, s->vectors);\n\n        s->peers[j].nb_eventfds = 0;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4076}
{"project": "qemu", "commit_id": "caffdac363801cd2cf2bf01ad013a8c1e1e43800", "target": 1, "func": "static int s390_virtio_blk_init(VirtIOS390Device *s390_dev)\n\n{\n\n    VirtIOBlkS390 *dev = VIRTIO_BLK_S390(s390_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n    virtio_blk_set_conf(vdev, &(dev->blk));\n\n    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));\n\n}\n", "idx": 4081}
{"project": "qemu", "commit_id": "52e60cdd342dc48116edb81b443ba8c0a0c6f1a3", "target": 1, "func": "static void aarch64_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n\n\n\n    cc->dump_state = aarch64_cpu_dump_state;\n\n    cc->set_pc = aarch64_cpu_set_pc;\n\n    cc->gdb_read_register = aarch64_cpu_gdb_read_register;\n\n    cc->gdb_write_register = aarch64_cpu_gdb_write_register;\n\n    cc->gdb_num_core_regs = 34;\n\n    cc->gdb_core_xml_file = \"aarch64-core.xml\";\n\n}", "idx": 4090}
{"project": "FFmpeg", "commit_id": "0273ceebbd01f9fd5238558e6151e0b9aa3305ab", "target": 0, "func": "static int mjpeg_decode_dht(MJpegDecodeContext *s)\n\n{\n\n    int len, index, i, class, n, v, code_max;\n\n    uint8_t bits_table[17];\n\n    uint8_t val_table[256];\n\n    \n\n    len = get_bits(&s->gb, 16) - 2;\n\n\n\n    while (len > 0) {\n\n        if (len < 17)\n\n            return -1;\n\n        class = get_bits(&s->gb, 4);\n\n        if (class >= 2)\n\n            return -1;\n\n        index = get_bits(&s->gb, 4);\n\n        if (index >= 4)\n\n            return -1;\n\n        n = 0;\n\n        for(i=1;i<=16;i++) {\n\n            bits_table[i] = get_bits(&s->gb, 8);\n\n            n += bits_table[i];\n\n        }\n\n        len -= 17;\n\n        if (len < n || n > 256)\n\n            return -1;\n\n\n\n        code_max = 0;\n\n        for(i=0;i<n;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            if (v > code_max)\n\n                code_max = v;\n\n            val_table[i] = v;\n\n        }\n\n        len -= n;\n\n\n\n        /* build VLC and flush previous vlc if present */\n\n        free_vlc(&s->vlcs[class][index]);\n\n        dprintf(\"class=%d index=%d nb_codes=%d\\n\",\n\n               class, index, code_max + 1);\n\n        build_vlc(&s->vlcs[class][index], bits_table, val_table, code_max + 1);\n\n    }\n\n    return 0;\n\n}\n", "idx": 4111}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "static int usb_net_handle_dataout(USBNetState *s, USBPacket *p)\n\n{\n\n    int ret = p->len;\n\n    int sz = sizeof(s->out_buf) - s->out_ptr;\n\n    struct rndis_packet_msg_type *msg =\n\n            (struct rndis_packet_msg_type *) s->out_buf;\n\n    uint32_t len;\n\n\n\n#ifdef TRAFFIC_DEBUG\n\n    fprintf(stderr, \"usbnet: data out len %u\\n\", p->len);\n\n    {\n\n        int i;\n\n        fprintf(stderr, \":\");\n\n        for (i = 0; i < p->len; i++) {\n\n            if (!(i & 15))\n\n                fprintf(stderr, \"\\n%04x:\", i);\n\n            fprintf(stderr, \" %02x\", p->data[i]);\n\n        }\n\n        fprintf(stderr, \"\\n\\n\");\n\n    }\n\n#endif\n\n\n\n    if (sz > ret)\n\n        sz = ret;\n\n    memcpy(&s->out_buf[s->out_ptr], p->data, sz);\n\n    s->out_ptr += sz;\n\n\n\n    if (!s->rndis) {\n\n        if (ret < 64) {\n\n            qemu_send_packet(&s->nic->nc, s->out_buf, s->out_ptr);\n\n            s->out_ptr = 0;\n\n        }\n\n        return ret;\n\n    }\n\n    len = le32_to_cpu(msg->MessageLength);\n\n    if (s->out_ptr < 8 || s->out_ptr < len)\n\n        return ret;\n\n    if (le32_to_cpu(msg->MessageType) == RNDIS_PACKET_MSG) {\n\n        uint32_t offs = 8 + le32_to_cpu(msg->DataOffset);\n\n        uint32_t size = le32_to_cpu(msg->DataLength);\n\n        if (offs + size <= len)\n\n            qemu_send_packet(&s->nic->nc, s->out_buf + offs, size);\n\n    }\n\n    s->out_ptr -= len;\n\n    memmove(s->out_buf, &s->out_buf[len], s->out_ptr);\n\n\n\n    return ret;\n\n}\n", "idx": 4112}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_get_backing_file_depth(BlockDriverState *bs)\n\n{\n\n    if (!bs->drv) {\n\n        return 0;\n\n    }\n\n\n\n    if (!bs->backing_hd) {\n\n        return 0;\n\n    }\n\n\n\n    return 1 + bdrv_get_backing_file_depth(bs->backing_hd);\n\n}\n", "idx": 4118}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "static void hmp_change_read_arg(Monitor *mon, const char *password,\n\n                                void *opaque)\n\n{\n\n    qmp_change_vnc_password(password, NULL);\n\n    monitor_read_command(mon, 1);\n\n}\n", "idx": 4137}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static bool pcie_has_upstream_port(PCIDevice *dev)\n\n{\n\n    PCIDevice *parent_dev = pci_bridge_get_device(dev->bus);\n\n\n\n    /* Device associated with an upstream port.\n\n     * As there are several types of these, it's easier to check the\n\n     * parent device: upstream ports are always connected to\n\n     * root or downstream ports.\n\n     */\n\n    return parent_dev &&\n\n        pci_is_express(parent_dev) &&\n\n        parent_dev->exp.exp_cap &&\n\n        (pcie_cap_get_type(parent_dev) == PCI_EXP_TYPE_ROOT_PORT ||\n\n         pcie_cap_get_type(parent_dev) == PCI_EXP_TYPE_DOWNSTREAM);\n\n}\n", "idx": 4194}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_gtdt(GArray *table_data, GArray *linker)\n\n{\n\n    int gtdt_start = table_data->len;\n\n    AcpiGenericTimerTable *gtdt;\n\n\n\n    gtdt = acpi_data_push(table_data, sizeof *gtdt);\n\n    /* The interrupt values are the same with the device tree when adding 16 */\n\n    gtdt->secure_el1_interrupt = ARCH_TIMER_S_EL1_IRQ + 16;\n\n    gtdt->secure_el1_flags = ACPI_EDGE_SENSITIVE;\n\n\n\n    gtdt->non_secure_el1_interrupt = ARCH_TIMER_NS_EL1_IRQ + 16;\n\n    gtdt->non_secure_el1_flags = ACPI_EDGE_SENSITIVE;\n\n\n\n    gtdt->virtual_timer_interrupt = ARCH_TIMER_VIRT_IRQ + 16;\n\n    gtdt->virtual_timer_flags = ACPI_EDGE_SENSITIVE;\n\n\n\n    gtdt->non_secure_el2_interrupt = ARCH_TIMER_NS_EL2_IRQ + 16;\n\n    gtdt->non_secure_el2_flags = ACPI_EDGE_SENSITIVE;\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + gtdt_start), \"GTDT\",\n\n                 table_data->len - gtdt_start, 2, NULL);\n\n}\n", "idx": 4219}
{"project": "qemu", "commit_id": "f1a6cf3ef734aab142d5f7ce52e219474ababf6b", "target": 1, "func": "static target_ulong h_random(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                             target_ulong opcode, target_ulong *args)\n\n{\n\n    sPAPRRngState *rngstate;\n\n    HRandomData hrdata;\n\n\n\n    rngstate = SPAPR_RNG(object_resolve_path_type(\"\", TYPE_SPAPR_RNG, NULL));\n\n\n\n    if (!rngstate || !rngstate->backend) {\n\n        return H_HARDWARE;\n\n    }\n\n\n\n    qemu_sem_init(&hrdata.sem, 0);\n\n    hrdata.val.v64 = 0;\n\n    hrdata.received = 0;\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    while (hrdata.received < 8) {\n\n        rng_backend_request_entropy(rngstate->backend, 8 - hrdata.received,\n\n                                    random_recv, &hrdata);\n\n        qemu_sem_wait(&hrdata.sem);\n\n    }\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_sem_destroy(&hrdata.sem);\n\n    args[0] = hrdata.val.v64;\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 4232}
{"project": "FFmpeg", "commit_id": "431f8af8242c41ef922f9daf791b0be26dc0bba4", "target": 0, "func": "static int normalize_bits(int num, int width)\n\n{\n\n    int i = 0;\n\n    int bits = (width) ? 31 : 15;\n\n    int limit = 1 << (bits - 1);\n\n\n\n    if (num) {\n\n        if (num == -1)\n\n            return bits;\n\n        if (num < 0)\n\n            num = ~num;\n\n        for (i = 0; num < limit; i++)\n\n            num <<= 1;\n\n    }\n\n    return i;\n\n}\n", "idx": 4239}
{"project": "qemu", "commit_id": "02e57e1c14a32aa1ed64e79d349d8e0e37cfaa27", "target": 1, "func": "static void sdhci_sysbus_realize(DeviceState *dev, Error ** errp)\n\n{\n\n    SDHCIState *s = SYSBUS_SDHCI(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n\n\n    sdhci_common_realize(s, errp);\n\n    if (errp && *errp) {\n\n        return;\n\n    }\n\n\n\n    if (s->dma_mr) {\n\n\n        address_space_init(s->dma_as, s->dma_mr, \"sdhci-dma\");\n\n    } else {\n\n        /* use system_memory() if property \"dma\" not set */\n\n        s->dma_as = &address_space_memory;\n\n    }\n\n\n\n    sysbus_init_irq(sbd, &s->irq);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n}", "idx": 4242}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void *rndis_queue_response(USBNetState *s, unsigned int length)\n\n{\n\n    struct rndis_response *r =\n\n            qemu_mallocz(sizeof(struct rndis_response) + length);\n\n\n\n    TAILQ_INSERT_TAIL(&s->rndis_resp, r, entries);\n\n    r->length = length;\n\n\n\n    return &r->buf[0];\n\n}\n", "idx": 4270}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "static char *visitor_get(TestOutputVisitorData *data)\n\n{\n\n    data->str = string_output_get_string(data->sov);\n\n    g_assert(data->str);\n\n    return data->str;\n\n}\n", "idx": 4273}
{"project": "qemu", "commit_id": "2569da0cb64506ea05323544c26f3aaffbf3f9fe", "target": 0, "func": "static void do_change_vnc(const char *target)\n\n{\n\n    if (strcmp(target, \"passwd\") == 0 ||\n\n\tstrcmp(target, \"password\") == 0) {\n\n\tchar password[9];\n\n\tmonitor_readline(\"Password: \", 1, password, sizeof(password));\n\n\tif (vnc_display_password(NULL, password) < 0)\n\n\t    term_printf(\"could not set VNC server password\\n\");\n\n    } else {\n\n\tif (vnc_display_open(NULL, target) < 0)\n\n\t    term_printf(\"could not start VNC server on %s\\n\", target);\n\n    }\n\n}\n", "idx": 4294}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int rom_add_blob(const char *name, const void *blob, size_t len,\n\n                 target_phys_addr_t addr)\n\n{\n\n    Rom *rom;\n\n\n\n    rom = g_malloc0(sizeof(*rom));\n\n    rom->name    = g_strdup(name);\n\n    rom->addr    = addr;\n\n    rom->romsize = len;\n\n    rom->data    = g_malloc0(rom->romsize);\n\n    memcpy(rom->data, blob, len);\n\n    rom_insert(rom);\n\n    return 0;\n\n}\n", "idx": 4321}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "static const AVClass *filter_child_class_next(const AVClass *prev)\n\n{\n\n    AVFilter **f = NULL;\n\n\n\n    while (prev && *(f = av_filter_next(f)))\n\n        if ((*f)->priv_class == prev)\n\n            break;\n\n\n\n    while (*(f = av_filter_next(f)))\n\n        if ((*f)->priv_class)\n\n            return (*f)->priv_class;\n\n\n\n    return NULL;\n\n}\n", "idx": 4346}
{"project": "qemu", "commit_id": "f24582d6ad8a080e008974c000bf0ae635d036ac", "target": 1, "func": "void qmp_output_visitor_cleanup(QmpOutputVisitor *v)\n\n{\n\n    QStackEntry *e, *tmp;\n\n\n\n    QTAILQ_FOREACH_SAFE(e, &v->stack, node, tmp) {\n\n        QTAILQ_REMOVE(&v->stack, e, node);\n\n        if (e->value) {\n\n            qobject_decref(e->value);\n\n        }\n\n        g_free(e);\n\n    }\n\n\n\n    g_free(v);\n\n}\n", "idx": 4351}
{"project": "qemu", "commit_id": "1f51470d044852592922f91000e741c381582cdc", "target": 1, "func": "static int qemu_chr_open_udp(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    CharDriverState *chr = NULL;\n\n    NetCharDriver *s = NULL;\n\n    int fd = -1;\n\n    int ret;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(NetCharDriver));\n\n\n\n    fd = inet_dgram_opts(opts);\n\n    if (fd < 0) {\n\n        fprintf(stderr, \"inet_dgram_opts failed\\n\");\n\n        ret = -errno;\n\n        goto return_err;\n\n    }\n\n\n\n    s->fd = fd;\n\n    s->bufcnt = 0;\n\n    s->bufptr = 0;\n\n    chr->opaque = s;\n\n    chr->chr_write = udp_chr_write;\n\n    chr->chr_update_read_handler = udp_chr_update_read_handler;\n\n    chr->chr_close = udp_chr_close;\n\n\n\n    *_chr = chr;\n\n    return 0;\n\n\n\nreturn_err:\n\n    g_free(chr);\n\n    g_free(s);\n\n    if (fd >= 0) {\n\n        closesocket(fd);\n\n    }\n\n    return ret;\n\n}\n", "idx": 4352}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "void helper_wrpsr(CPUSPARCState *env, target_ulong new_psr)\n\n{\n\n    if ((new_psr & PSR_CWP) >= env->nwindows) {\n\n        cpu_raise_exception_ra(env, TT_ILL_INSN, GETPC());\n\n    } else {\n\n\n\n        cpu_put_psr(env, new_psr);\n\n\n    }\n\n}", "idx": 4354}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "void helper_wrpstate(CPUSPARCState *env, target_ulong new_state)\n\n{\n\n    cpu_change_pstate(env, new_state & 0xf3f);\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    if (cpu_interrupts_enabled(env)) {\n\n\n        cpu_check_irqs(env);\n\n\n    }\n\n#endif\n\n}", "idx": 4373}
{"project": "qemu", "commit_id": "135a972b45203ba992afc99ef4f061be8a5acae0", "target": 1, "func": "void tb_flush(CPUState *cpu)\n\n{\n\n\n\n\n#if defined(DEBUG_FLUSH)\n\n    printf(\"qemu: flush code_size=%ld nb_tbs=%d avg_tb_size=%ld\\n\",\n\n           (unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer),\n\n           tcg_ctx.tb_ctx.nb_tbs, tcg_ctx.tb_ctx.nb_tbs > 0 ?\n\n           ((unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer)) /\n\n           tcg_ctx.tb_ctx.nb_tbs : 0);\n\n#endif\n\n    if ((unsigned long)(tcg_ctx.code_gen_ptr - tcg_ctx.code_gen_buffer)\n\n        > tcg_ctx.code_gen_buffer_size) {\n\n        cpu_abort(cpu, \"Internal error: code buffer overflow\\n\");\n\n\n    tcg_ctx.tb_ctx.nb_tbs = 0;\n\n\n\n    CPU_FOREACH(cpu) {\n\n        memset(cpu->tb_jmp_cache, 0, sizeof(cpu->tb_jmp_cache));\n\n        cpu->tb_flushed = true;\n\n\n\n\n    qht_reset_size(&tcg_ctx.tb_ctx.htable, CODE_GEN_HTABLE_SIZE);\n\n    page_flush_tb();\n\n\n\n    tcg_ctx.code_gen_ptr = tcg_ctx.code_gen_buffer;\n\n    /* XXX: flush processor icache at this point if cache flush is\n\n       expensive */\n\n    tcg_ctx.tb_ctx.tb_flush_count++;\n", "idx": 4380}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "int register_savevm(DeviceState *dev,\n\n                    const char *idstr,\n\n                    int instance_id,\n\n                    int version_id,\n\n                    SaveStateHandler *save_state,\n\n                    LoadStateHandler *load_state,\n\n                    void *opaque)\n\n{\n\n    SaveVMHandlers *ops = g_malloc0(sizeof(SaveVMHandlers));\n\n    ops->save_state = save_state;\n\n    ops->load_state = load_state;\n\n    return register_savevm_live(dev, idstr, instance_id, version_id,\n\n                                ops, opaque);\n\n}\n", "idx": 4381}
{"project": "qemu", "commit_id": "805017b7791200f1b72deef17dc98fd272b941eb", "target": 0, "func": "static void test_validate_union(TestInputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    UserDefUnion *tmp = NULL;\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n\n\n    v = validate_test_init(data, \"{ 'type': 'b', 'integer': 41, 'data' : { 'integer': 42 } }\");\n\n\n\n    visit_type_UserDefUnion(v, &tmp, NULL, &err);\n\n    g_assert(!err);\n\n    qapi_free_UserDefUnion(tmp);\n\n}\n", "idx": 4408}
{"project": "FFmpeg", "commit_id": "50833c9f7b4e1922197a8955669f8ab3589c8cef", "target": 1, "func": "static int encode_slice_plane(AVCodecContext *avctx, int mb_count,\n\n        uint8_t *src, int src_stride, uint8_t *buf, unsigned buf_size,\n\n        int *qmat, int chroma)\n\n{\n\n    ProresContext* ctx = avctx->priv_data;\n\n    FDCTDSPContext *fdsp = &ctx->fdsp;\n\n    DECLARE_ALIGNED(16, int16_t, blocks)[DEFAULT_SLICE_MB_WIDTH << 8], *block;\n\n    int i, blocks_per_slice;\n\n    PutBitContext pb;\n\n\n\n    block = blocks;\n\n    for (i = 0; i < mb_count; i++) {\n\n        fdct_get(fdsp, src,                  src_stride, block + (0 << 6));\n\n        fdct_get(fdsp, src + 8 * src_stride, src_stride, block + ((2 - chroma) << 6));\n\n        if (!chroma) {\n\n            fdct_get(fdsp, src + 16,                  src_stride, block + (1 << 6));\n\n            fdct_get(fdsp, src + 16 + 8 * src_stride, src_stride, block + (3 << 6));\n\n        }\n\n\n\n        block += (256 >> chroma);\n\n        src   += (32  >> chroma);\n\n    }\n\n\n\n    blocks_per_slice = mb_count << (2 - chroma);\n\n    init_put_bits(&pb, buf, buf_size << 3);\n\n\n\n    encode_dc_coeffs(&pb, blocks, blocks_per_slice, qmat);\n\n    encode_ac_coeffs(avctx, &pb, blocks, blocks_per_slice, qmat);\n\n\n\n    flush_put_bits(&pb);\n\n    return put_bits_ptr(&pb) - pb.buf;\n\n}\n", "idx": 4421}
{"project": "FFmpeg", "commit_id": "7149fce2cac0474a5fbc5b47add1158cd8bb283e", "target": 1, "func": "static inline void render_line_unrolled(intptr_t x, intptr_t y, int x1,\n\n                                        intptr_t sy, int ady, int adx,\n\n                                        float *buf)\n\n{\n\n    int err = -adx;\n\n    x -= x1 - 1;\n\n    buf += x1 - 1;\n\n    while (++x < 0) {\n\n        err += ady;\n\n        if (err >= 0) {\n\n            err += ady - adx;\n\n            y   += sy;\n\n            buf[x++] = ff_vorbis_floor1_inverse_db_table[y];\n\n        }\n\n        buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n    }\n\n    if (x <= 0) {\n\n        if (err + ady >= 0)\n\n            y += sy;\n\n        buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n    }\n\n}\n", "idx": 4424}
{"project": "FFmpeg", "commit_id": "1c37848f9029985d1271da9a0d161c2ebf0aca81", "target": 1, "func": "static int webm_dash_manifest_write_trailer(AVFormatContext *s)\n\n{\n\n    WebMDashMuxContext *w = s->priv_data;\n\n    int i;\n\n    for (i = 0; i < w->nb_as; i++) {\n\n        av_freep(&w->as[i].streams);\n\n    }\n\n    av_freep(&w->as);\n\n    return 0;\n\n}\n", "idx": 4427}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "VMChangeStateEntry *qemu_add_vm_change_state_handler(VMChangeStateHandler *cb,\n\n                                                     void *opaque)\n\n{\n\n    VMChangeStateEntry *e;\n\n\n\n    e = qemu_mallocz(sizeof (*e));\n\n\n\n    e->cb = cb;\n\n    e->opaque = opaque;\n\n    LIST_INSERT_HEAD(&vm_change_state_head, e, entries);\n\n    return e;\n\n}\n", "idx": 4461}
{"project": "qemu", "commit_id": "88045ac55592cacc92567aa46cb6917854bf7241", "target": 0, "func": "static void rtas_read_pci_config(sPAPREnvironment *spapr,\n\n                                 uint32_t token, uint32_t nargs,\n\n                                 target_ulong args,\n\n                                 uint32_t nret, target_ulong rets)\n\n{\n\n    uint32_t val, size, addr;\n\n    PCIDevice *dev = find_dev(spapr, 0, rtas_ld(args, 0));\n\n\n\n    if (!dev) {\n\n        rtas_st(rets, 0, -1);\n\n        return;\n\n    }\n\n    size = rtas_ld(args, 1);\n\n    addr = rtas_pci_cfgaddr(rtas_ld(args, 0));\n\n    val = pci_host_config_read_common(dev, addr, pci_config_size(dev), size);\n\n    rtas_st(rets, 0, 0);\n\n    rtas_st(rets, 1, val);\n\n}\n", "idx": 4494}
{"project": "qemu", "commit_id": "5ee163e8ea2fb6610339f494e039159e08a69066", "target": 0, "func": "void qmp_dump_guest_memory(bool paging, const char *file, bool has_begin,\n\n                           int64_t begin, bool has_length, int64_t length,\n\n                           Error **errp)\n\n{\n\n    const char *p;\n\n    int fd = -1;\n\n    DumpState *s;\n\n    int ret;\n\n\n\n    if (has_begin && !has_length) {\n\n        error_set(errp, QERR_MISSING_PARAMETER, \"length\");\n\n        return;\n\n    }\n\n    if (!has_begin && has_length) {\n\n        error_set(errp, QERR_MISSING_PARAMETER, \"begin\");\n\n        return;\n\n    }\n\n\n\n#if !defined(WIN32)\n\n    if (strstart(file, \"fd:\", &p)) {\n\n        fd = monitor_get_fd(cur_mon, p, errp);\n\n        if (fd == -1) {\n\n            return;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if  (strstart(file, \"file:\", &p)) {\n\n        fd = qemu_open(p, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, S_IRUSR);\n\n        if (fd < 0) {\n\n            error_setg_file_open(errp, errno, p);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (fd == -1) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, \"protocol\");\n\n        return;\n\n    }\n\n\n\n    s = g_malloc(sizeof(DumpState));\n\n\n\n    ret = dump_init(s, fd, paging, has_begin, begin, length, errp);\n\n    if (ret < 0) {\n\n        g_free(s);\n\n        return;\n\n    }\n\n\n\n    if (create_vmcore(s) < 0 && !error_is_set(s->errp)) {\n\n        error_set(errp, QERR_IO_ERROR);\n\n    }\n\n\n\n    g_free(s);\n\n}\n", "idx": 4495}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static bool bdrv_requests_pending(BlockDriverState *bs)\n\n{\n\n    if (!QLIST_EMPTY(&bs->tracked_requests)) {\n\n        return true;\n\n    }\n\n    if (!qemu_co_queue_empty(&bs->throttled_reqs[0])) {\n\n        return true;\n\n    }\n\n    if (!qemu_co_queue_empty(&bs->throttled_reqs[1])) {\n\n        return true;\n\n    }\n\n    if (bs->file && bdrv_requests_pending(bs->file)) {\n\n        return true;\n\n    }\n\n    if (bs->backing_hd && bdrv_requests_pending(bs->backing_hd)) {\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 4511}
{"project": "FFmpeg", "commit_id": "93dc1c1221856e88ac9df560a1b4f77dd5f5395d", "target": 0, "func": "void checkasm_check_fixed_dsp(void)\n\n{\n\n    LOCAL_ALIGNED_32(int32_t, src0, [BUF_SIZE]);\n\n    LOCAL_ALIGNED_32(int32_t, src1, [BUF_SIZE]);\n\n    LOCAL_ALIGNED_32(int32_t, src2, [BUF_SIZE]);\n\n    AVFixedDSPContext *fdsp = avpriv_alloc_fixed_dsp(1);\n\n\n\n    randomize_buffers();\n\n    if (check_func(fdsp->vector_fmul, \"vector_fmul\"))\n\n        check_vector_fmul(src0, src1);\n\n    if (check_func(fdsp->vector_fmul_add, \"vector_fmul_add\"))\n\n        check_vector_fmul_add(src0, src1, src2);\n\n    if (check_func(fdsp->vector_fmul_reverse, \"vector_fmul_reverse\"))\n\n        check_vector_fmul(src0, src1);\n\n    if (check_func(fdsp->vector_fmul_window, \"vector_fmul_window\"))\n\n        check_vector_fmul_window(src0, src1, src2);\n\n    if (check_func(fdsp->vector_fmul_window_scaled, \"vector_fmul_window_scaled\"))\n\n        check_vector_fmul_window_scaled(src0, src1, src2);\n\n    report(\"vector_fmul\");\n\n    if (check_func(fdsp->butterflies_fixed, \"butterflies_fixed\"))\n\n        check_butterflies(src0, src1);\n\n    report(\"butterflies_fixed\");\n\n    if (check_func(fdsp->scalarproduct_fixed, \"scalarproduct_fixed\"))\n\n        check_scalarproduct_fixed(src0, src1);\n\n    report(\"scalarproduct_fixed\");\n\n\n\n    av_freep(&fdsp);\n\n}\n", "idx": 4514}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void etsec_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = etsec_realize;\n\n    dc->reset = etsec_reset;\n\n    dc->props = etsec_properties;\n\n\n\n}", "idx": 4522}
{"project": "FFmpeg", "commit_id": "a8343bfb6a3f00777943b94ff2969422f578f246", "target": 0, "func": "int ff_read_riff_info(AVFormatContext *s, int64_t size)\n\n{\n\n    int64_t start, end, cur;\n\n    AVIOContext *pb = s->pb;\n\n\n\n    start = avio_tell(pb);\n\n    end = start + size;\n\n\n\n    while ((cur = avio_tell(pb)) >= 0 && cur <= end - 8 /* = tag + size */) {\n\n        uint32_t chunk_code;\n\n        int64_t chunk_size;\n\n        char key[5] = {0};\n\n        char *value;\n\n\n\n        chunk_code = avio_rl32(pb);\n\n        chunk_size = avio_rl32(pb);\n\n\n\n        if (chunk_size > end || end - chunk_size < cur || chunk_size == UINT_MAX) {\n\n            avio_seek(pb, -9, SEEK_CUR);\n\n            chunk_code = avio_rl32(pb);\n\n            chunk_size = avio_rl32(pb);\n\n            if (chunk_size > end || end - chunk_size < cur || chunk_size == UINT_MAX) {\n\n                av_log(s, AV_LOG_WARNING, \"too big INFO subchunk\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n        chunk_size += (chunk_size & 1);\n\n\n\n        if (!chunk_code) {\n\n            if (chunk_size)\n\n                avio_skip(pb, chunk_size);\n\n            continue;\n\n        }\n\n\n\n        value = av_mallocz(chunk_size + 1);\n\n        if (!value) {\n\n            av_log(s, AV_LOG_ERROR, \"out of memory, unable to read INFO tag\\n\");\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        AV_WL32(key, chunk_code);\n\n\n\n        if (avio_read(pb, value, chunk_size) != chunk_size) {\n\n            av_log(s, AV_LOG_WARNING, \"premature end of file while reading INFO tag\\n\");\n\n        }\n\n\n\n        av_dict_set(&s->metadata, key, value, AV_DICT_DONT_STRDUP_VAL);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4525}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "void ff_mpeg_flush(AVCodecContext *avctx){\n\n    int i;\n\n    MpegEncContext *s = avctx->priv_data;\n\n\n\n    if(s==NULL || s->picture==NULL)\n\n        return;\n\n\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++)\n\n        ff_mpeg_unref_picture(s, &s->picture[i]);\n\n    s->current_picture_ptr = s->last_picture_ptr = s->next_picture_ptr = NULL;\n\n\n\n    ff_mpeg_unref_picture(s, &s->current_picture);\n\n    ff_mpeg_unref_picture(s, &s->last_picture);\n\n    ff_mpeg_unref_picture(s, &s->next_picture);\n\n\n\n    s->mb_x= s->mb_y= 0;\n\n\n\n    s->parse_context.state= -1;\n\n    s->parse_context.frame_start_found= 0;\n\n    s->parse_context.overread= 0;\n\n    s->parse_context.overread_index= 0;\n\n    s->parse_context.index= 0;\n\n    s->parse_context.last_index= 0;\n\n    s->bitstream_buffer_size=0;\n\n    s->pp_time=0;\n\n}\n", "idx": 4530}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "static int bdrv_qed_is_allocated(BlockDriverState *bs, int64_t sector_num,\n\n                                  int nb_sectors, int *pnum)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n    uint64_t pos = (uint64_t)sector_num * BDRV_SECTOR_SIZE;\n\n    size_t len = (size_t)nb_sectors * BDRV_SECTOR_SIZE;\n\n    QEDIsAllocatedCB cb = {\n\n        .is_allocated = -1,\n\n        .pnum = pnum,\n\n    };\n\n    QEDRequest request = { .l2_table = NULL };\n\n\n\n    async_context_push();\n\n\n\n    qed_find_cluster(s, &request, pos, len, qed_is_allocated_cb, &cb);\n\n\n\n    while (cb.is_allocated == -1) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\n    async_context_pop();\n\n\n\n    qed_unref_l2_cache_entry(request.l2_table);\n\n\n\n    return cb.is_allocated;\n\n}\n", "idx": 4557}
{"project": "FFmpeg", "commit_id": "7e10145976866fc6227d3ccc697a7c9fee862a77", "target": 0, "func": "static int rwpipe_read_ppm_header( rwpipe *rw, int *width, int *height )\n\n{\n\n    char line[ 3 ];\n\n    FILE *in = rwpipe_reader( rw );\n\n    int max;\n\n\n\n    fgets( line, 3, in );\n\n    if ( !strncmp( line, \"P6\", 2 ) )\n\n    {\n\n        *width = rwpipe_read_number( rw );\n\n        *height = rwpipe_read_number( rw );\n\n        max = rwpipe_read_number( rw );\n\n        return max != 255 || *width <= 0 || *height <= 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 4575}
{"project": "qemu", "commit_id": "7f4a930e64b9e69cd340395a7e4f0494aef4fcdd", "target": 1, "func": "static int vhost_user_get_u64(struct vhost_dev *dev, int request, uint64_t *u64)\n\n{\n\n    VhostUserMsg msg = {\n\n        .request = request,\n\n        .flags = VHOST_USER_VERSION,\n\n    };\n\n\n\n    if (vhost_user_one_time_request(request) && dev->vq_index != 0) {\n\n        return 0;\n\n    }\n\n\n\n    vhost_user_write(dev, &msg, NULL, 0);\n\n\n\n    if (vhost_user_read(dev, &msg) < 0) {\n\n        return 0;\n\n    }\n\n\n\n    if (msg.request != request) {\n\n        error_report(\"Received unexpected msg type. Expected %d received %d\",\n\n                     request, msg.request);\n\n        return -1;\n\n    }\n\n\n\n    if (msg.size != sizeof(m.u64)) {\n\n        error_report(\"Received bad msg size.\");\n\n        return -1;\n\n    }\n\n\n\n    *u64 = msg.u64;\n\n\n\n    return 0;\n\n}\n", "idx": 4578}
{"project": "FFmpeg", "commit_id": "ee9f36a88eb3e2706ea659acb0ca80c414fa5d8a", "target": 0, "func": "static int crc_write_header(struct AVFormatContext *s)\n\n{\n\n    CRCState *crc = s->priv_data;\n\n\n\n    /* init CRC */\n\n    crc->crcval = adler32(0, NULL, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 4580}
{"project": "qemu", "commit_id": "fa131d94a5c00c6bbea39358d4bca7bf98f6c1f5", "target": 1, "func": "ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,\n\n                                              const char *typename,\n\n                                              const char *file, int line,\n\n                                              const char *func)\n\n{\n\n    ObjectClass *ret = object_class_dynamic_cast(class, typename);\n\n\n\n    if (!ret && class) {\n\n        fprintf(stderr, \"%s:%d:%s: Object %p is not an instance of type %s\\n\",\n\n                file, line, func, class, typename);\n\n        abort();\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 4583}
{"project": "qemu", "commit_id": "a907ec52cc1aefc820768b6e341b56f8f3caaca7", "target": 1, "func": "static void nvme_set_bootindex(Object *obj, Visitor *v, void *opaque,\n\n                                  const char *name, Error **errp)\n\n{\n\n    NvmeCtrl *s = NVME(obj);\n\n    int32_t boot_index;\n\n    Error *local_err = NULL;\n\n\n\n    visit_type_int32(v, &boot_index, name, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n    /* check whether bootindex is present in fw_boot_order list  */\n\n    check_boot_index(boot_index, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n    /* change bootindex to a new one */\n\n    s->conf.bootindex = boot_index;\n\n\n\nout:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n    }\n\n}\n", "idx": 4594}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(divwu)\n\n{\n\n    if (T1 == 0) {\n\n        T0 = 0;\n\n    } else {\n\n        T0 /= T1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 4598}
{"project": "qemu", "commit_id": "ad5b88b1f198182642b6cbf3dacb4cade0c80fb9", "target": 1, "func": "void *rom_add_blob(const char *name, const void *blob, size_t len,\n\n                   hwaddr addr, const char *fw_file_name,\n\n                   FWCfgReadCallback fw_callback, void *callback_opaque)\n\n{\n\n    Rom *rom;\n\n    void *data = NULL;\n\n\n\n    rom           = g_malloc0(sizeof(*rom));\n\n    rom->name     = g_strdup(name);\n\n    rom->addr     = addr;\n\n    rom->romsize  = len;\n\n    rom->datasize = len;\n\n    rom->data     = g_malloc0(rom->datasize);\n\n    memcpy(rom->data, blob, len);\n\n    rom_insert(rom);\n\n    if (fw_file_name && fw_cfg) {\n\n        char devpath[100];\n\n\n\n        snprintf(devpath, sizeof(devpath), \"/rom@%s\", fw_file_name);\n\n\n\n        if (rom_file_has_mr) {\n\n            data = rom_set_mr(rom, OBJECT(fw_cfg), devpath);\n\n        } else {\n\n            data = rom->data;\n\n        }\n\n\n\n        fw_cfg_add_file_callback(fw_cfg, fw_file_name,\n\n                                 fw_callback, callback_opaque,\n\n                                 data, rom->romsize);\n\n    }\n\n    return data;\n\n}\n", "idx": 4600}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static int qed_write_table(BDRVQEDState *s, uint64_t offset, QEDTable *table,\n\n                           unsigned int index, unsigned int n, bool flush)\n\n{\n\n    unsigned int sector_mask = BDRV_SECTOR_SIZE / sizeof(uint64_t) - 1;\n\n    unsigned int start, end, i;\n\n    QEDTable *new_table;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n    size_t len_bytes;\n\n    int ret;\n\n\n\n    trace_qed_write_table(s, offset, table, index, n);\n\n\n\n    /* Calculate indices of the first and one after last elements */\n\n    start = index & ~sector_mask;\n\n    end = (index + n + sector_mask) & ~sector_mask;\n\n\n\n    len_bytes = (end - start) * sizeof(uint64_t);\n\n\n\n    new_table = qemu_blockalign(s->bs, len_bytes);\n\n    iov = (struct iovec) {\n\n        .iov_base = new_table->offsets,\n\n        .iov_len = len_bytes,\n\n    };\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    /* Byteswap table */\n\n    for (i = start; i < end; i++) {\n\n        uint64_t le_offset = cpu_to_le64(table->offsets[i]);\n\n        new_table->offsets[i - start] = le_offset;\n\n    }\n\n\n\n    /* Adjust for offset into table */\n\n    offset += start * sizeof(uint64_t);\n\n\n\n    ret = bdrv_pwritev(s->bs->file, offset, &qiov);\n\n    trace_qed_write_table_cb(s, table, flush, ret);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    if (flush) {\n\n        qed_acquire(s);\n\n        ret = bdrv_flush(s->bs);\n\n        qed_release(s);\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    qemu_vfree(new_table);\n\n    return ret;\n\n}\n", "idx": 4606}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void vnc_init_basic_info(SocketAddress *addr,\n\n                                VncBasicInfo *info,\n\n                                Error **errp)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_KIND_INET:\n\n        info->host = g_strdup(addr->u.inet->host);\n\n        info->service = g_strdup(addr->u.inet->port);\n\n        if (addr->u.inet->ipv6) {\n\n            info->family = NETWORK_ADDRESS_FAMILY_IPV6;\n\n        } else {\n\n            info->family = NETWORK_ADDRESS_FAMILY_IPV4;\n\n        }\n\n        break;\n\n\n\n    case SOCKET_ADDRESS_KIND_UNIX:\n\n        info->host = g_strdup(\"\");\n\n        info->service = g_strdup(addr->u.q_unix->path);\n\n        info->family = NETWORK_ADDRESS_FAMILY_UNIX;\n\n        break;\n\n\n\n    default:\n\n        error_setg(errp, \"Unsupported socket kind %d\",\n\n                   addr->type);\n\n        break;\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 4612}
{"project": "qemu", "commit_id": "273a2142176098fe2c27f263d86ad66b133b43cb", "target": 0, "func": "static void disable_interrupt(EEPRO100State * s)\n\n{\n\n    if (s->int_stat) {\n\n        logout(\"interrupt disabled\\n\");\n\n        qemu_irq_lower(s->pci_dev->irq[0]);\n\n        s->int_stat = 0;\n\n    }\n\n}\n", "idx": 4636}
{"project": "FFmpeg", "commit_id": "5d590d87b30c59dfb853ebde6276d36f8a8bbc58", "target": 1, "func": "static int av_dict_set_fxp(AVDictionary **pm, const char *key, uint64_t value, unsigned int digits,\n\n                int flags)\n\n{\n\n    char valuestr[44];\n\n    snprintf(valuestr, sizeof(valuestr), \"%\"PRId64\".%0*\"PRId64,\n\n             value / PRECISION, digits, ( value % PRECISION ) / ( PRECISION / uintpow(10,digits) ));\n\n    return av_dict_set(pm, key, valuestr, flags);\n\n}\n", "idx": 4647}
{"project": "FFmpeg", "commit_id": "f077ad69c682c13ab75a72aec11a61cac53f0c91", "target": 1, "func": "int av_packet_ref(AVPacket *dst, const AVPacket *src)\n\n{\n\n    int ret;\n\n\n\n    ret = av_packet_copy_props(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!src->buf) {\n\n        ret = packet_alloc(&dst->buf, src->size);\n\n        if (ret < 0)\n\n            goto fail;\n\n        memcpy(dst->buf->data, src->data, src->size);\n\n\n\n        dst->data = dst->buf->data;\n\n    } else {\n\n        dst->buf = av_buffer_ref(src->buf);\n\n        if (!dst->buf) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        dst->data = src->data;\n\n    }\n\n\n\n    dst->size = src->size;\n\n\n\n    return 0;\n\nfail:\n\n    av_packet_free_side_data(dst);\n\n    return ret;\n\n}\n", "idx": 4650}
{"project": "FFmpeg", "commit_id": "b1b0baa3d6a30942b258dddfdd04b4b24c713879", "target": 0, "func": "static void kempf_restore_buf(const uint8_t *src, int len,\n\n                              uint8_t *dst, int stride,\n\n                              const uint8_t *jpeg_tile, int tile_stride,\n\n                              int width, int height,\n\n                              const uint8_t *pal, int npal, int tidx)\n\n{\n\n    GetBitContext gb;\n\n    int i, j, nb, col;\n\n\n\n    init_get_bits8(&gb, src, len);\n\n\n\n    if (npal <= 2)       nb = 1;\n\n    else if (npal <= 4)  nb = 2;\n\n    else if (npal <= 16) nb = 4;\n\n    else                 nb = 8;\n\n\n\n    for (j = 0; j < height; j++, dst += stride, jpeg_tile += tile_stride) {\n\n        if (get_bits(&gb, 8))\n\n            continue;\n\n        for (i = 0; i < width; i++) {\n\n            col = get_bits(&gb, nb);\n\n            if (col != tidx)\n\n                memcpy(dst + i * 3, pal + col * 3, 3);\n\n            else\n\n                memcpy(dst + i * 3, jpeg_tile + i * 3, 3);\n\n        }\n\n    }\n\n}\n", "idx": 4679}
{"project": "FFmpeg", "commit_id": "33d69a90085d30af8a292d9364b835a26565d6b9", "target": 0, "func": "static JavaVM *get_java_vm(const char *name, void *log_ctx)\n\n{\n\n    JavaVM *vm = NULL;\n\n    jsize nb_vm = 0;\n\n\n\n    void *handle = NULL;\n\n    jint (*get_created_java_vms) (JavaVM ** vmBuf, jsize bufLen, jsize *nVMs) = NULL;\n\n\n\n    handle = dlopen(name, RTLD_LOCAL);\n\n    if (!handle) {\n\n        return NULL;\n\n    }\n\n\n\n    get_created_java_vms = (jint (*)(JavaVM **, jsize, jsize *)) dlsym(handle, \"JNI_GetCreatedJavaVMs\");\n\n    if (!get_created_java_vms) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find JNI_GetCreatedJavaVMs symbol in library '%s'\\n\", name);\n\n        goto done;\n\n    }\n\n\n\n    if (get_created_java_vms(&vm, 1, &nb_vm) != JNI_OK) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not get created Java virtual machines\\n\");\n\n        goto done;\n\n    }\n\n\n\ndone:\n\n    if (handle) {\n\n        dlclose(handle);\n\n    }\n\n\n\n    return vm;\n\n}\n", "idx": 4686}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_fstat(FsContext *fs_ctx, int fid_type,\n\n                       V9fsFidOpenState *fs, struct stat *stbuf)\n\n{\n\n    int fd;\n\n\n\n    if (fid_type == P9_FID_DIR) {\n\n        fd = dirfd(fs->dir);\n\n    } else {\n\n        fd = fs->fd;\n\n    }\n\n    return fstat(fd, stbuf);\n\n}\n", "idx": 4708}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t cmd646_data_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    CMD646BAR *cmd646bar = opaque;\n\n\n\n    if (size == 1) {\n\n        return ide_ioport_read(cmd646bar->bus, addr);\n\n    } else if (addr == 0) {\n\n        if (size == 2) {\n\n            return ide_data_readw(cmd646bar->bus, addr);\n\n        } else {\n\n            return ide_data_readl(cmd646bar->bus, addr);\n\n        }\n\n    }\n\n    return ((uint64_t)1 << (size * 8)) - 1;\n\n}\n", "idx": 4713}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "int kvm_arch_insert_sw_breakpoint(CPUState *env, struct kvm_sw_breakpoint *bp)\n\n{\n\n    static const uint8_t int3 = 0xcc;\n\n\n\n    if (cpu_memory_rw_debug(env, bp->pc, (uint8_t *)&bp->saved_insn, 1, 0) ||\n\n        cpu_memory_rw_debug(env, bp->pc, (uint8_t *)&int3, 1, 1))\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 4723}
{"project": "FFmpeg", "commit_id": "1bc1cfdddf7ab8ef50d0fc888808d6b609eb5d8d", "target": 1, "func": "static int compute_send_delay(HTTPContext *c)\n\n{\n\n    int datarate = 8 * get_longterm_datarate(&c->datarate, c->data_count); \n\n\n\n    if (datarate > c->stream->bandwidth * 2000) {\n\n        return 1000;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4734}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void OPPROTO op_check_addo (void)\n\n{\n\n    if (likely(!(((uint32_t)T2 ^ (uint32_t)T1 ^ UINT32_MAX) &\n\n                 ((uint32_t)T2 ^ (uint32_t)T0) & (1UL << 31)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 4757}
{"project": "qemu", "commit_id": "b6b2c9628084f1672b92393cf84039a075a95301", "target": 1, "func": "static gpointer writeout_thread(gpointer opaque)\n\n{\n\n    TraceRecord *recordptr;\n\n    union {\n\n        TraceRecord rec;\n\n        uint8_t bytes[sizeof(TraceRecord) + sizeof(uint64_t)];\n\n    } dropped;\n\n    unsigned int idx = 0;\n\n    int dropped_count;\n\n    size_t unused __attribute__ ((unused));\n\n\n\n    for (;;) {\n\n        wait_for_trace_records_available();\n\n\n\n        if (g_atomic_int_get(&dropped_events)) {\n\n            dropped.rec.event = DROPPED_EVENT_ID,\n\n            dropped.rec.timestamp_ns = get_clock();\n\n            dropped.rec.length = sizeof(TraceRecord) + sizeof(uint64_t),\n\n            dropped.rec.reserved = 0;\n\n            while (1) {\n\n                dropped_count = g_atomic_int_get(&dropped_events);\n\n                if (g_atomic_int_compare_and_exchange(&dropped_events,\n\n                                                      dropped_count, 0)) {\n\n                    break;\n\n                }\n\n            }\n\n            dropped.rec.arguments[0] = dropped_count;\n\n            unused = fwrite(&dropped.rec, dropped.rec.length, 1, trace_fp);\n\n        }\n\n\n\n        while (get_trace_record(idx, &recordptr)) {\n\n            unused = fwrite(recordptr, recordptr->length, 1, trace_fp);\n\n            writeout_idx += recordptr->length;\n\n            free(recordptr); /* dont use g_free, can deadlock when traced */\n\n            idx = writeout_idx % TRACE_BUF_LEN;\n\n        }\n\n\n\n        fflush(trace_fp);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 4767}
{"project": "qemu", "commit_id": "e0dadc1e9ef1f35208e5d2af9c7740c18a0b769f", "target": 1, "func": "AUXBus *aux_init_bus(DeviceState *parent, const char *name)\n\n{\n\n    AUXBus *bus;\n\n\n\n    bus = AUX_BUS(qbus_create(TYPE_AUX_BUS, parent, name));\n\n    bus->bridge = AUXTOI2C(qdev_create(BUS(bus), TYPE_AUXTOI2C));\n\n\n\n    /* Memory related. */\n\n    bus->aux_io = g_malloc(sizeof(*bus->aux_io));\n\n    memory_region_init(bus->aux_io, OBJECT(bus), \"aux-io\", (1 << 20));\n\n    address_space_init(&bus->aux_addr_space, bus->aux_io, \"aux-io\");\n\n    return bus;\n\n}\n", "idx": 4794}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void qdev_print_devinfo(DeviceClass *dc)\n\n{\n\n    error_printf(\"name \\\"%s\\\"\", object_class_get_name(OBJECT_CLASS(dc)));\n\n    if (dc->bus_type) {\n\n        error_printf(\", bus %s\", dc->bus_type);\n\n    }\n\n    if (qdev_class_has_alias(dc)) {\n\n        error_printf(\", alias \\\"%s\\\"\", qdev_class_get_alias(dc));\n\n    }\n\n    if (dc->desc) {\n\n        error_printf(\", desc \\\"%s\\\"\", dc->desc);\n\n    }\n\n    if (dc->no_user) {\n\n        error_printf(\", no-user\");\n\n    }\n\n    error_printf(\"\\n\");\n\n}\n", "idx": 4818}
{"project": "qemu", "commit_id": "cab565c412a5634ce26f4d24ae65907c3108bdb0", "target": 0, "func": "uint32_t HELPER(neon_acgt_f32)(uint32_t a, uint32_t b)\n\n{\n\n    float32 f0 = float32_abs(make_float32(a));\n\n    float32 f1 = float32_abs(make_float32(b));\n\n    if (float32_compare_quiet(f0, f1, NFS) == float_relation_greater) {\n\n        return ~0;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4832}
{"project": "qemu", "commit_id": "5379229a2708df3a1506113315214c3ce5325859", "target": 0, "func": "sosendto(struct socket *so, struct mbuf *m)\n\n{\n\n\tSlirp *slirp = so->slirp;\n\n\tint ret;\n\n\tstruct sockaddr_in addr;\n\n\n\n\tDEBUG_CALL(\"sosendto\");\n\n\tDEBUG_ARG(\"so = %p\", so);\n\n\tDEBUG_ARG(\"m = %p\", m);\n\n\n\n        addr.sin_family = AF_INET;\n\n\tif ((so->so_faddr.s_addr & slirp->vnetwork_mask.s_addr) ==\n\n\t    slirp->vnetwork_addr.s_addr) {\n\n\t  /* It's an alias */\n\n\t  if (so->so_faddr.s_addr == slirp->vnameserver_addr.s_addr) {\n\n\t    if (get_dns_addr(&addr.sin_addr) < 0)\n\n\t      addr.sin_addr = loopback_addr;\n\n\t  } else {\n\n\t    addr.sin_addr = loopback_addr;\n\n\t  }\n\n\t} else\n\n\t  addr.sin_addr = so->so_faddr;\n\n\taddr.sin_port = so->so_fport;\n\n\n\n\tDEBUG_MISC((dfd, \" sendto()ing, addr.sin_port=%d, addr.sin_addr.s_addr=%.16s\\n\", ntohs(addr.sin_port), inet_ntoa(addr.sin_addr)));\n\n\n\n\t/* Don't care what port we get */\n\n\tret = sendto(so->s, m->m_data, m->m_len, 0,\n\n\t\t     (struct sockaddr *)&addr, sizeof (struct sockaddr));\n\n\tif (ret < 0)\n\n\t\treturn -1;\n\n\n\n\t/*\n\n\t * Kill the socket if there's no reply in 4 minutes,\n\n\t * but only if it's an expirable socket\n\n\t */\n\n\tif (so->so_expire)\n\n\t\tso->so_expire = curtime + SO_EXPIRE;\n\n\tso->so_state &= SS_PERSISTENT_MASK;\n\n\tso->so_state |= SS_ISFCONNECTED; /* So that it gets select()ed */\n\n\treturn 0;\n\n}\n", "idx": 4847}
{"project": "FFmpeg", "commit_id": "5e55c7e1bcb767e6af17c29f6aaebff4d6fd0703", "target": 0, "func": "void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)\n\n{\n\n    deblocking_filter_CTB(s, x, y);\n\n    if (s->sps->sao_enabled) {\n\n        int x_end = x >= s->sps->width  - ctb_size;\n\n        int y_end = y >= s->sps->height - ctb_size;\n\n        if (y && x)\n\n            sao_filter_CTB(s, x - ctb_size, y - ctb_size);\n\n        if (x && y_end)\n\n            sao_filter_CTB(s, x - ctb_size, y);\n\n        if (y && x_end) {\n\n            sao_filter_CTB(s, x, y - ctb_size);\n\n            if (s->threads_type & FF_THREAD_FRAME )\n\n                ff_thread_report_progress(&s->ref->tf, y - ctb_size, 0);\n\n        }\n\n        if (x_end && y_end) {\n\n            sao_filter_CTB(s, x , y);\n\n            if (s->threads_type & FF_THREAD_FRAME )\n\n                ff_thread_report_progress(&s->ref->tf, y, 0);\n\n        }\n\n    } else {\n\n        if (y && x >= s->sps->width - ctb_size)\n\n            if (s->threads_type & FF_THREAD_FRAME )\n\n                ff_thread_report_progress(&s->ref->tf, y, 0);\n\n    }\n\n}\n", "idx": 4848}
{"project": "FFmpeg", "commit_id": "68aefbe81cb3b9dd002108782bb8d798e1c12806", "target": 1, "func": "static double get_video_clock(VideoState *is)\n\n{\n\n    if (is->paused) {\n\n        return is->video_current_pts;\n\n    } else {\n\n        return is->video_current_pts + (av_gettime() - is->video_current_pts_time) / 1000000.0;\n\n    }\n\n}\n", "idx": 4876}
{"project": "qemu", "commit_id": "ba41249678f8c1504bf07706ddb0eda0d36cccc2", "target": 0, "func": "long do_rt_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_rt_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_ulong r0;\n\n\n\n    frame_addr = regs->gregs[15];\n\n    trace_user_do_rt_sigreturn(regs, frame_addr);\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n\n\n    target_to_host_sigset(&blocked, &frame->uc.tuc_sigmask);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    restore_sigcontext(regs, &frame->uc.tuc_mcontext, &r0);\n\n\n\n    if (do_sigaltstack(frame_addr +\n\n                       offsetof(struct target_rt_sigframe, uc.tuc_stack),\n\n                       0, get_sp_from_cpustate(regs)) == -EFAULT) {\n\n        goto badframe;\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 4886}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static void patch_reloc(uint8_t *code_ptr, int type,\n\n                        intptr_t value, intptr_t addend)\n\n{\n\n    uint32_t insn;\n\n    value += addend;\n\n    switch (type) {\n\n    case R_SPARC_32:\n\n        if (value != (uint32_t)value) {\n\n            tcg_abort();\n\n        }\n\n        *(uint32_t *)code_ptr = value;\n\n        break;\n\n    case R_SPARC_WDISP16:\n\n        value -= (intptr_t)code_ptr;\n\n        if (!check_fit_tl(value >> 2, 16)) {\n\n            tcg_abort();\n\n        }\n\n        insn = *(uint32_t *)code_ptr;\n\n        insn &= ~INSN_OFF16(-1);\n\n        insn |= INSN_OFF16(value);\n\n        *(uint32_t *)code_ptr = insn;\n\n        break;\n\n    case R_SPARC_WDISP19:\n\n        value -= (intptr_t)code_ptr;\n\n        if (!check_fit_tl(value >> 2, 19)) {\n\n            tcg_abort();\n\n        }\n\n        insn = *(uint32_t *)code_ptr;\n\n        insn &= ~INSN_OFF19(-1);\n\n        insn |= INSN_OFF19(value);\n\n        *(uint32_t *)code_ptr = insn;\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n}\n", "idx": 4891}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_unlinkat(FsContext *ctx, V9fsPath *dir,\n\n                               const char *name, int flags)\n\n{\n\n    errno = EPERM;\n\n    return -1;\n\n}\n", "idx": 4903}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "void json_start_object(QJSON *json, const char *name)\n\n{\n\n    json_emit_element(json, name);\n\n    qstring_append(json->str, \"{ \");\n\n    json->omit_comma = true;\n\n}\n", "idx": 4909}
{"project": "qemu", "commit_id": "ac531cb6e542b1e61d668604adf9dc5306a948c0", "target": 0, "func": "START_TEST(qdict_get_int_test)\n\n{\n\n    int ret;\n\n    const int value = 100;\n\n    const char *key = \"int\";\n\n\n\n    qdict_put(tests_dict, key, qint_from_int(value));\n\n\n\n    ret = qdict_get_int(tests_dict, key);\n\n    fail_unless(ret == value);\n\n}\n", "idx": 4913}
{"project": "qemu", "commit_id": "806c9d71abbcd283c0a6d8250e5a6db951ba9494", "target": 0, "func": "static void float64_maddsub_update_excp(CPUPPCState *env, float64 arg1,\n\n                                        float64 arg2, float64 arg3,\n\n                                        unsigned int madd_flags)\n\n{\n\n    if (unlikely((float64_is_infinity(arg1) && float64_is_zero(arg2)) ||\n\n                 (float64_is_zero(arg1) && float64_is_infinity(arg2)))) {\n\n        /* Multiplication of zero by infinity */\n\n        arg1 = float_invalid_op_excp(env, POWERPC_EXCP_FP_VXIMZ, 1);\n\n    } else if (unlikely(float64_is_signaling_nan(arg1, &env->fp_status) ||\n\n                        float64_is_signaling_nan(arg2, &env->fp_status) ||\n\n                        float64_is_signaling_nan(arg3, &env->fp_status))) {\n\n        /* sNaN operation */\n\n        float_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN, 1);\n\n    } else if ((float64_is_infinity(arg1) || float64_is_infinity(arg2)) &&\n\n               float64_is_infinity(arg3)) {\n\n        uint8_t aSign, bSign, cSign;\n\n\n\n        aSign = float64_is_neg(arg1);\n\n        bSign = float64_is_neg(arg2);\n\n        cSign = float64_is_neg(arg3);\n\n        if (madd_flags & float_muladd_negate_c) {\n\n            cSign ^= 1;\n\n        }\n\n        if (aSign ^ bSign ^ cSign) {\n\n            float_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI, 1);\n\n        }\n\n    }\n\n}\n", "idx": 4916}
{"project": "qemu", "commit_id": "00cf57747db98c6a9e4219cea39ac3113dde6993", "target": 0, "func": "static uint32_t check_alarm(RTCState *s)\n\n{\n\n    uint8_t alarm_hour, alarm_min, alarm_sec;\n\n    uint8_t cur_hour, cur_min, cur_sec;\n\n\n\n    alarm_sec = rtc_from_bcd(s, s->cmos_data[RTC_SECONDS_ALARM]);\n\n    alarm_min = rtc_from_bcd(s, s->cmos_data[RTC_MINUTES_ALARM]);\n\n    alarm_hour = rtc_from_bcd(s, s->cmos_data[RTC_HOURS_ALARM]);\n\n    alarm_hour = convert_hour(s, alarm_hour);\n\n\n\n    cur_sec = rtc_from_bcd(s, s->cmos_data[RTC_SECONDS]);\n\n    cur_min = rtc_from_bcd(s, s->cmos_data[RTC_MINUTES]);\n\n    cur_hour = rtc_from_bcd(s, s->cmos_data[RTC_HOURS]);\n\n    cur_hour = convert_hour(s, cur_hour);\n\n\n\n    if (((s->cmos_data[RTC_SECONDS_ALARM] & 0xc0) == 0xc0\n\n                || alarm_sec == cur_sec) &&\n\n            ((s->cmos_data[RTC_MINUTES_ALARM] & 0xc0) == 0xc0\n\n             || alarm_min == cur_min) &&\n\n            ((s->cmos_data[RTC_HOURS_ALARM] & 0xc0) == 0xc0\n\n             || alarm_hour == cur_hour)) {\n\n        return 1;\n\n    }\n\n    return 0;\n\n\n\n}\n", "idx": 4930}
{"project": "qemu", "commit_id": "ce0bd027df9c62766a5417521d0f08f27359d43f", "target": 0, "func": "static int get_dns_addr(struct in_addr *pdns_addr)\n\n{\n\n    char buff[512];\n\n    char buff2[257];\n\n    FILE *f;\n\n    int found = 0;\n\n    struct in_addr tmp_addr;\n\n\n\n    f = fopen(\"/etc/resolv.conf\", \"r\");\n\n    if (!f)\n\n        return -1;\n\n\n\n#ifdef DEBUG\n\n    lprint(\"IP address of your DNS(s): \");\n\n#endif\n\n    while (fgets(buff, 512, f) != NULL) {\n\n        if (sscanf(buff, \"nameserver%*[ \\t]%256s\", buff2) == 1) {\n\n            if (!inet_aton(buff2, &tmp_addr))\n\n                continue;\n\n            if (tmp_addr.s_addr == loopback_addr.s_addr)\n\n                tmp_addr = our_addr;\n\n            /* If it's the first one, set it to dns_addr */\n\n            if (!found)\n\n                *pdns_addr = tmp_addr;\n\n#ifdef DEBUG\n\n            else\n\n                lprint(\", \");\n\n#endif\n\n            if (++found > 3) {\n\n#ifdef DEBUG\n\n                lprint(\"(more)\");\n\n#endif\n\n                break;\n\n            }\n\n#ifdef DEBUG\n\n            else\n\n                lprint(\"%s\", inet_ntoa(tmp_addr));\n\n#endif\n\n        }\n\n    }\n\n    fclose(f);\n\n    if (!found)\n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 4937}
{"project": "qemu", "commit_id": "2bbf11d753761ca537333c2bd7ddadb06758f62c", "target": 0, "func": "static bool aio_epoll_try_enable(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    struct epoll_event event;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        int r;\n\n        if (node->deleted || !node->pfd.events) {\n\n            continue;\n\n        }\n\n        event.events = epoll_events_from_pfd(node->pfd.events);\n\n        event.data.ptr = node;\n\n        r = epoll_ctl(ctx->epollfd, EPOLL_CTL_ADD, node->pfd.fd, &event);\n\n        if (r) {\n\n            return false;\n\n        }\n\n    }\n\n    ctx->epoll_enabled = true;\n\n    return true;\n\n}\n", "idx": 4945}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int bt_parse(const char *opt)\n\n{\n\n    const char *endp, *p;\n\n    int vlan;\n\n\n\n    if (strstart(opt, \"hci\", &endp)) {\n\n        if (!*endp || *endp == ',') {\n\n            if (*endp)\n\n                if (!strstart(endp, \",vlan=\", 0))\n\n                    opt = endp + 1;\n\n\n\n            return bt_hci_parse(opt);\n\n       }\n\n    } else if (strstart(opt, \"vhci\", &endp)) {\n\n        if (!*endp || *endp == ',') {\n\n            if (*endp) {\n\n                if (strstart(endp, \",vlan=\", &p)) {\n\n                    vlan = strtol(p, (char **) &endp, 0);\n\n                    if (*endp) {\n\n                        fprintf(stderr, \"qemu: bad scatternet '%s'\\n\", p);\n\n                        return 1;\n\n                    }\n\n                } else {\n\n                    fprintf(stderr, \"qemu: bad parameter '%s'\\n\", endp + 1);\n\n                    return 1;\n\n                }\n\n            } else\n\n                vlan = 0;\n\n\n\n            bt_vhci_add(vlan);\n\n            return 0;\n\n        }\n\n    } else if (strstart(opt, \"device:\", &endp))\n\n        return !bt_device_add(endp);\n\n\n\n    fprintf(stderr, \"qemu: bad bluetooth parameter '%s'\\n\", opt);\n\n    return 1;\n\n}\n", "idx": 4948}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_mpui_io_write(void *opaque, target_phys_addr_t addr,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    /* FIXME: infinite loop */\n\n    omap_badwidth_write16(opaque, addr, value);\n\n}\n", "idx": 4949}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xC(IpvideoContext *s)\n\n{\n\n    int x, y;\n\n\n\n    /* 16-color block encoding: each 2x2 block is a different color */\n\n    CHECK_STREAM_PTR(16);\n\n\n\n    for (y = 0; y < 8; y += 2) {\n\n        for (x = 0; x < 8; x += 2) {\n\n            s->pixel_ptr[x                ] =\n\n            s->pixel_ptr[x + 1            ] =\n\n            s->pixel_ptr[x +     s->stride] =\n\n            s->pixel_ptr[x + 1 + s->stride] = *s->stream_ptr++;\n\n        }\n\n        s->pixel_ptr += s->stride * 2;\n\n    }\n\n\n\n    /* report success */\n\n    return 0;\n\n}\n", "idx": 4958}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void term_handle_command(char *cmdline)\n\n{\n\n    char *p, *pstart;\n\n    int argc;\n\n    const char *args[MAX_ARGS + 1];\n\n    term_cmd_t *cmd;\n\n\n\n#ifdef DEBUG\n\n    term_printf(\"command='%s'\\n\", cmdline);\n\n#endif\n\n    \n\n    /* split command in words */\n\n    argc = 0;\n\n    p = cmdline;\n\n    for(;;) {\n\n        while (isspace(*p))\n\n            p++;\n\n        if (*p == '\\0')\n\n            break;\n\n        pstart = p;\n\n        while (*p != '\\0' && !isspace(*p))\n\n            p++;\n\n        args[argc] = pstart;\n\n        argc++;\n\n        if (argc >= MAX_ARGS)\n\n            break;\n\n        if (*p == '\\0')\n\n            break;\n\n        *p++ = '\\0';\n\n    }\n\n    args[argc] = NULL;\n\n#ifdef DEBUG\n\n    for(i=0;i<argc;i++) {\n\n        term_printf(\" '%s'\", args[i]);\n\n    }\n\n    term_printf(\"\\n\");\n\n#endif\n\n    if (argc <= 0)\n\n        return;\n\n    for(cmd = term_cmds; cmd->name != NULL; cmd++) {\n\n        if (compare_cmd(args[0], cmd->name)) \n\n            goto found;\n\n    }\n\n    term_printf(\"unknown command: '%s'\\n\", args[0]);\n\n    return;\n\n found:\n\n    cmd->handler(argc, args);\n\n}\n", "idx": 4960}
{"project": "qemu", "commit_id": "a32354e206895400d17c3de9a8df1de96d3df289", "target": 1, "func": "static void m5206_mbar_writew(void *opaque, target_phys_addr_t offset,\n\n                              uint32_t value)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    int width;\n\n    offset &= 0x3ff;\n\n    if (offset > 0x200) {\n\n        hw_error(\"Bad MBAR write offset 0x%x\", (int)offset);\n\n    }\n\n    width = m5206_mbar_width[offset >> 2];\n\n    if (width > 2) {\n\n        uint32_t tmp;\n\n        tmp = m5206_mbar_readl(opaque, offset & ~3);\n\n        if (offset & 3) {\n\n            tmp = (tmp & 0xffff0000) | value;\n\n        } else {\n\n            tmp = (tmp & 0x0000ffff) | (value << 16);\n\n        }\n\n        m5206_mbar_writel(opaque, offset & ~3, tmp);\n\n        return;\n\n    } else if (width < 2) {\n\n        m5206_mbar_writeb(opaque, offset, value >> 8);\n\n        m5206_mbar_writeb(opaque, offset + 1, value & 0xff);\n\n        return;\n\n    }\n\n    m5206_mbar_write(s, offset, value, 2);\n\n}\n", "idx": 4971}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int qemu_peek_byte(QEMUFile *f, int offset)\n\n{\n\n    int index = f->buf_index + offset;\n\n\n\n    assert(!qemu_file_is_writable(f));\n\n    assert(offset < IO_BUF_SIZE);\n\n\n\n    if (index >= f->buf_size) {\n\n        qemu_fill_buffer(f);\n\n        index = f->buf_index + offset;\n\n        if (index >= f->buf_size) {\n\n            return 0;\n\n        }\n\n    }\n\n    return f->buf[index];\n\n}\n", "idx": 4976}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC(pred8x8_horizontal)(uint8_t *_src, int stride){\n\n    int i;\n\n    pixel *src = (pixel*)_src;\n\n    stride /= sizeof(pixel);\n\n\n\n    for(i=0; i<8; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= PIXEL_SPLAT_X4(src[-1+i*stride]);\n\n    }\n\n}\n", "idx": 4991}
{"project": "qemu", "commit_id": "c20b7fa4b2fedd979bcb0cc974bb5d08a10e3448", "target": 1, "func": "monitor_protocol_event_queue(MonitorEvent event,\n\n                             QObject *data)\n\n{\n\n    MonitorEventState *evstate;\n\n    int64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    assert(event < QEVENT_MAX);\n\n\n\n    qemu_mutex_lock(&monitor_event_state_lock);\n\n    evstate = &(monitor_event_state[event]);\n\n    trace_monitor_protocol_event_queue(event,\n\n                                       data,\n\n                                       evstate->rate,\n\n                                       evstate->last,\n\n                                       now);\n\n\n\n    /* Rate limit of 0 indicates no throttling */\n\n    if (!evstate->rate) {\n\n        monitor_protocol_event_emit(event, data);\n\n        evstate->last = now;\n\n    } else {\n\n        int64_t delta = now - evstate->last;\n\n        if (evstate->data ||\n\n            delta < evstate->rate) {\n\n            /* If there's an existing event pending, replace\n\n             * it with the new event, otherwise schedule a\n\n             * timer for delayed emission\n\n             */\n\n            if (evstate->data) {\n\n                qobject_decref(evstate->data);\n\n            } else {\n\n                int64_t then = evstate->last + evstate->rate;\n\n                timer_mod_ns(evstate->timer, then);\n\n            }\n\n            evstate->data = data;\n\n            qobject_incref(evstate->data);\n\n        } else {\n\n            monitor_protocol_event_emit(event, data);\n\n            evstate->last = now;\n\n        }\n\n    }\n\n    qemu_mutex_unlock(&monitor_event_state_lock);\n\n}\n", "idx": 4992}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "static int qemu_gluster_create(const char *filename,\n\n                               QemuOpts *opts, Error **errp)\n\n{\n\n    struct glfs *glfs;\n\n    struct glfs_fd *fd;\n\n    int ret = 0;\n\n    int prealloc = 0;\n\n    int64_t total_size = 0;\n\n    char *tmp = NULL;\n\n    GlusterConf *gconf = g_malloc0(sizeof(GlusterConf));\n\n\n\n    glfs = qemu_gluster_init(gconf, filename, errp);\n\n    if (!glfs) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n\n\n    total_size =\n\n        qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / BDRV_SECTOR_SIZE;\n\n\n\n    tmp = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);\n\n    if (!tmp || !strcmp(tmp, \"off\")) {\n\n        prealloc = 0;\n\n    } else if (!strcmp(tmp, \"full\") &&\n\n               gluster_supports_zerofill()) {\n\n        prealloc = 1;\n\n    } else {\n\n        error_setg(errp, \"Invalid preallocation mode: '%s'\"\n\n            \" or GlusterFS doesn't support zerofill API\",\n\n            tmp);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    fd = glfs_creat(glfs, gconf->image,\n\n        O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, S_IRUSR | S_IWUSR);\n\n    if (!fd) {\n\n        ret = -errno;\n\n    } else {\n\n        if (!glfs_ftruncate(fd, total_size * BDRV_SECTOR_SIZE)) {\n\n            if (prealloc && qemu_gluster_zerofill(fd, 0,\n\n                    total_size * BDRV_SECTOR_SIZE)) {\n\n                ret = -errno;\n\n            }\n\n        } else {\n\n            ret = -errno;\n\n        }\n\n\n\n        if (glfs_close(fd) != 0) {\n\n            ret = -errno;\n\n        }\n\n    }\n\nout:\n\n    g_free(tmp);\n\n    qemu_gluster_gconf_free(gconf);\n\n    if (glfs) {\n\n        glfs_fini(glfs);\n\n    }\n\n    return ret;\n\n}\n", "idx": 4996}
{"project": "qemu", "commit_id": "cd245a19329edfcd968b00d05ad92de7a0e2daa1", "target": 1, "func": "void *qemu_memalign(size_t alignment, size_t size)\n\n{\n\n    if (!size) {\n\n        abort();\n\n    }\n\n    return oom_check(VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE));\n\n}\n", "idx": 5002}
{"project": "FFmpeg", "commit_id": "c79d2a20bad59298188171f1316a830d563a41ee", "target": 0, "func": "static void decode_parameters(SiprParameters* parms, GetBitContext *pgb,\n\n                              const SiprModeParam *p)\n\n{\n\n    int i, j;\n\n\n\n    parms->ma_pred_switch           = get_bits(pgb, p->ma_predictor_bits);\n\n\n\n    for (i = 0; i < 5; i++)\n\n        parms->vq_indexes[i]        = get_bits(pgb, p->vq_indexes_bits[i]);\n\n\n\n    for (i = 0; i < p->subframe_count; i++) {\n\n        parms->pitch_delay[i]       = get_bits(pgb, p->pitch_delay_bits[i]);\n\n        parms->gp_index[i]          = get_bits(pgb, p->gp_index_bits);\n\n\n\n        for (j = 0; j < p->number_of_fc_indexes; j++)\n\n            parms->fc_indexes[i][j] = get_bits(pgb, p->fc_index_bits[j]);\n\n\n\n        parms->gc_index[i]          = get_bits(pgb, p->gc_index_bits);\n\n    }\n\n}\n", "idx": 5006}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void slow_bar_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    AssignedDevRegion *d = opaque;\n\n    uint32_t *out = (uint32_t *)(d->u.r_virtbase + addr);\n\n\n\n    DEBUG(\"slow_bar_writel addr=0x\" TARGET_FMT_plx \" val=0x%08x\\n\", addr, val);\n\n    *out = val;\n\n}\n", "idx": 5008}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, DriveInfo *dinfo, int unit)\n\n{\n\n    const char *driver;\n\n    DeviceState *dev;\n\n\n\n    driver = bdrv_is_sg(dinfo->bdrv) ? \"scsi-generic\" : \"scsi-disk\";\n\n    dev = qdev_create(&bus->qbus, driver);\n\n    qdev_prop_set_uint32(dev, \"scsi-id\", unit);\n\n    qdev_prop_set_drive(dev, \"drive\", dinfo);\n\n    if (qdev_init(dev) < 0)\n\n        return NULL;\n\n    return DO_UPCAST(SCSIDevice, qdev, dev);\n\n}\n", "idx": 5020}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void xen_log_stop(MemoryListener *listener, MemoryRegionSection *section)\n\n{\n\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n\n\n\n    state->log_for_dirtybit = NULL;\n\n    /* Disable dirty bit tracking */\n\n    xc_hvm_track_dirty_vram(xen_xc, xen_domid, 0, 0, NULL);\n\n}\n", "idx": 5027}
{"project": "qemu", "commit_id": "ede9c94acf6cd1968de4188c0228b714ab871a86", "target": 0, "func": "static int vtd_int_remap(X86IOMMUState *iommu, MSIMessage *src,\n\n                         MSIMessage *dst, uint16_t sid)\n\n{\n\n    return vtd_interrupt_remap_msi(INTEL_IOMMU_DEVICE(iommu), src, dst);\n\n}\n", "idx": 5036}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "static void core_region_nop(MemoryListener *listener,\n\n                            MemoryRegionSection *section)\n\n{\n\n    cpu_register_physical_memory_log(section, section->readonly);\n\n}\n", "idx": 5041}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float32 uint64_to_float32( uint64 a STATUS_PARAM )\n\n{\n\n    int8 shiftCount;\n\n\n\n    if ( a == 0 ) return 0;\n\n    shiftCount = countLeadingZeros64( a ) - 40;\n\n    if ( 0 <= shiftCount ) {\n\n        return packFloat32( 1 > 0, 0x95 - shiftCount, a<<shiftCount );\n\n    }\n\n    else {\n\n        shiftCount += 7;\n\n        if ( shiftCount < 0 ) {\n\n            shift64RightJamming( a, - shiftCount, &a );\n\n        }\n\n        else {\n\n            a <<= shiftCount;\n\n        }\n\n        return roundAndPackFloat32( 1 > 0, 0x9C - shiftCount, a STATUS_VAR );\n\n    }\n\n}\n", "idx": 5048}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static void do_change_vnc(const char *target, const char *arg)\n\n{\n\n    if (strcmp(target, \"passwd\") == 0 ||\n\n\tstrcmp(target, \"password\") == 0) {\n\n\tchar password[9];\n\n\tif (arg) {\n\n\t    strncpy(password, arg, sizeof(password));\n\n\t    password[sizeof(password) - 1] = '\\0';\n\n\t} else\n\n\t    monitor_readline(\"Password: \", 1, password, sizeof(password));\n\n\tif (vnc_display_password(NULL, password) < 0)\n\n\t    term_printf(\"could not set VNC server password\\n\");\n\n    } else {\n\n\tif (vnc_display_open(NULL, target) < 0)\n\n\t    term_printf(\"could not start VNC server on %s\\n\", target);\n\n    }\n\n}\n", "idx": 5051}
{"project": "qemu", "commit_id": "24d3bd67aca958c8ea103646d9d326de00056e4d", "target": 0, "func": "static struct scsi_task *iscsi_do_inquiry(struct iscsi_context *iscsi, int lun,\n\n                                          int evpd, int pc, Error **errp)\n\n{\n\n    int full_size;\n\n    struct scsi_task *task = NULL;\n\n    task = iscsi_inquiry_sync(iscsi, lun, evpd, pc, 64);\n\n    if (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\n        goto fail;\n\n    }\n\n    full_size = scsi_datain_getfullsize(task);\n\n    if (full_size > task->datain.size) {\n\n        scsi_free_scsi_task(task);\n\n\n\n        /* we need more data for the full list */\n\n        task = iscsi_inquiry_sync(iscsi, lun, evpd, pc, full_size);\n\n        if (task == NULL || task->status != SCSI_STATUS_GOOD) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    return task;\n\n\n\nfail:\n\n    error_setg(errp, \"iSCSI: Inquiry command failed : %s\",\n\n               iscsi_get_error(iscsi));\n\n    if (task) {\n\n        scsi_free_scsi_task(task);\n\n        return NULL;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 5052}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void rgb2rgb_init_x86(void)\n\n{\n\n#if HAVE_INLINE_ASM\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (cpu_flags & AV_CPU_FLAG_MMX)\n\n        rgb2rgb_init_MMX();\n\n    if (HAVE_AMD3DNOW && cpu_flags & AV_CPU_FLAG_3DNOW)\n\n        rgb2rgb_init_3DNOW();\n\n    if (HAVE_MMXEXT   && cpu_flags & AV_CPU_FLAG_MMXEXT)\n\n        rgb2rgb_init_MMX2();\n\n    if (HAVE_SSE      && cpu_flags & AV_CPU_FLAG_SSE2)\n\n        rgb2rgb_init_SSE2();\n\n#endif /* HAVE_INLINE_ASM */\n\n}\n", "idx": 5055}
{"project": "FFmpeg", "commit_id": "eea784dab00d9f123c508d3e0c6b16e4f3123bb0", "target": 0, "func": "static int mp3_header_compress(AVBitStreamFilterContext *bsfc, AVCodecContext *avctx, const char *args,\n\n                     uint8_t **poutbuf, int *poutbuf_size,\n\n                     const uint8_t *buf, int buf_size, int keyframe){\n\n    uint32_t header;\n\n    int mode_extension;\n\n\n\n    if(avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL){\n\n        av_log(avctx, AV_LOG_ERROR, \"not standards compliant\\n\");\n\n        return -1;\n\n    }\n\n\n\n    header = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];\n\n    mode_extension= (header>>4)&3;\n\n\n\n    if(ff_mpa_check_header(header) < 0 || (header&0x70000) != 0x30000){\n\n        *poutbuf= (uint8_t *) buf;\n\n        *poutbuf_size= buf_size;\n\n\n\n        av_log(avctx, AV_LOG_INFO, \"cannot compress %08X\\n\", header);\n\n        return 0;\n\n    }\n\n\n\n    *poutbuf_size= buf_size - 4;\n\n    *poutbuf= av_malloc(buf_size - 4 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    memcpy(*poutbuf, buf + 4, buf_size - 4 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n    if(avctx->channels==2){\n\n        if((header & (3<<19)) != 3<<19){\n\n            (*poutbuf)[1] &= 0x3F;\n\n            (*poutbuf)[1] |= mode_extension<<6;\n\n            FFSWAP(int, (*poutbuf)[1], (*poutbuf)[2]);\n\n        }else{\n\n            (*poutbuf)[1] &= 0x8F;\n\n            (*poutbuf)[1] |= mode_extension<<4;\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 5066}
{"project": "qemu", "commit_id": "1c0fbfa3dedf49115e194e533a7b6a640a28447c", "target": 1, "func": "static void virtio_net_add_queue(VirtIONet *n, int index)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n\n\n    n->vqs[index].rx_vq = virtio_add_queue(vdev, 256, virtio_net_handle_rx);\n\n    if (n->net_conf.tx && !strcmp(n->net_conf.tx, \"timer\")) {\n\n        n->vqs[index].tx_vq =\n\n            virtio_add_queue(vdev, 256, virtio_net_handle_tx_timer);\n\n        n->vqs[index].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                                              virtio_net_tx_timer,\n\n                                              &n->vqs[index]);\n\n    } else {\n\n        n->vqs[index].tx_vq =\n\n            virtio_add_queue(vdev, 256, virtio_net_handle_tx_bh);\n\n        n->vqs[index].tx_bh = qemu_bh_new(virtio_net_tx_bh, &n->vqs[index]);\n\n    }\n\n\n\n    n->vqs[index].tx_waiting = 0;\n\n    n->vqs[index].n = n;\n\n}\n", "idx": 5072}
{"project": "qemu", "commit_id": "a614f52dc70fd4c424a6248ae98c42494b9a89e7", "target": 0, "func": "static int grackle_pci_host_init(PCIDevice *d)\n\n{\n\n    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_MOTOROLA);\n\n    pci_config_set_device_id(d->config, PCI_DEVICE_ID_MOTOROLA_MPC106);\n\n    d->config[0x08] = 0x00; // revision\n\n    d->config[0x09] = 0x01;\n\n    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);\n\n    return 0;\n\n}\n", "idx": 5081}
{"project": "qemu", "commit_id": "100f738850639a108d6767316ce4dcc1d1ea4ae4", "target": 0, "func": "static void icp_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ICPState *icp = ICP(dev);\n\n    ICPStateClass *icpc = ICP_GET_CLASS(dev);\n\n    Object *obj;\n\n    Error *err = NULL;\n\n\n\n    obj = object_property_get_link(OBJECT(dev), ICP_PROP_XICS, &err);\n\n    if (!obj) {\n\n        error_setg(errp, \"%s: required link '\" ICP_PROP_XICS \"' not found: %s\",\n\n                   __func__, error_get_pretty(err));\n\n        return;\n\n    }\n\n\n\n    icp->xics = XICS_FABRIC(obj);\n\n\n\n    if (icpc->realize) {\n\n        icpc->realize(dev, errp);\n\n    }\n\n\n\n    qemu_register_reset(icp_reset, dev);\n\n}\n", "idx": 5085}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int(TestInputVisitorData *data,\n\n                                            const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_INTEGER);\n\n}\n", "idx": 5087}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_max(void)\n\n{\n\n    char *str = g_strdup_printf(\"%llu\", ULLONG_MAX);\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, ULLONG_MAX);\n\n    g_assert(endptr == str + strlen(str));\n\n    g_free(str);\n\n}\n", "idx": 5091}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static inline void* array_get_next(array_t* array) {\n\n    unsigned int next = array->next;\n\n    void* result;\n\n\n\n    if (array_ensure_allocated(array, next) < 0)\n\n\treturn NULL;\n\n\n\n    array->next = next + 1;\n\n    result = array_get(array, next);\n\n\n\n    return result;\n\n}\n", "idx": 5098}
{"project": "qemu", "commit_id": "d8b7e0adf562277180f96ecbd7f1777a384a0308", "target": 0, "func": "static int raw_read(BlockDriverState *bs, int64_t sector_num,\n\n                    uint8_t *buf, int nb_sectors)\n\n{\n\n    return bdrv_read(bs->file, sector_num, buf, nb_sectors);\n\n}\n", "idx": 5101}
{"project": "qemu", "commit_id": "e1556ad5b8143a15c26067c3862fe20631c0053f", "target": 1, "func": "static uint32_t omap2_gpio_module_readp(void *opaque, target_phys_addr_t addr)\n\n{\n\n    return omap2_gpio_module_readp(opaque, addr) >> ((addr & 3) << 3);\n\n}\n", "idx": 5116}
{"project": "qemu", "commit_id": "6f6867493cc00974de594a509cee5a3be61c64aa", "target": 1, "func": "static void guest_fsfreeze_cleanup(void)\n\n{\n\n    int64_t ret;\n\n    Error *err = NULL;\n\n\n\n    if (ga_is_frozen(ga_state) == GUEST_FSFREEZE_STATUS_FROZEN) {\n\n        ret = qmp_guest_fsfreeze_thaw(&err);\n\n        if (ret < 0 || err) {\n\n            slog(\"failed to clean up frozen filesystems\");\n\n        }\n\n    }\n\n}\n", "idx": 5122}
{"project": "FFmpeg", "commit_id": "93d336fb076a8abe33e37251af5475673e716f6d", "target": 1, "func": "static int set_segment_filename(AVFormatContext *s)\n\n{\n\n    SegmentContext *seg = s->priv_data;\n\n    AVFormatContext *oc = seg->avf;\n\n    size_t size;\n\n\n\n    if (seg->segment_idx_wrap)\n\n        seg->segment_idx %= seg->segment_idx_wrap;\n\n    if (seg->use_strftime) {\n\n        time_t now0;\n\n        struct tm *tm, tmpbuf;\n\n        time(&now0);\n\n        tm = localtime_r(&now0, &tmpbuf);\n\n        if (!strftime(oc->filename, sizeof(oc->filename), s->filename, tm)) {\n\n            av_log(oc, AV_LOG_ERROR, \"Could not get segment filename with strftime\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n    } else if (av_get_frame_filename(oc->filename, sizeof(oc->filename),\n\n                                     s->filename, seg->segment_idx) < 0) {\n\n        av_log(oc, AV_LOG_ERROR, \"Invalid segment filename template '%s'\\n\", s->filename);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    /* copy modified name in list entry */\n\n    size = strlen(av_basename(oc->filename)) + 1;\n\n    if (seg->entry_prefix)\n\n        size += strlen(seg->entry_prefix);\n\n\n\n    seg->cur_entry.filename = av_mallocz(size);\n\n    if (!seg->cur_entry.filename)\n\n        return AVERROR(ENOMEM);\n\n    snprintf(seg->cur_entry.filename, size, \"%s%s\",\n\n             seg->entry_prefix ? seg->entry_prefix : \"\",\n\n             av_basename(oc->filename));\n\n\n\n    return 0;\n\n}\n", "idx": 5137}
{"project": "qemu", "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a", "target": 1, "func": "static ssize_t flush_buf(VirtIOSerialPort *port,\n                         const uint8_t *buf, ssize_t len)\n{\n    VirtConsole *vcon = VIRTIO_CONSOLE(port);\n    ssize_t ret;\n    if (!vcon->chr) {\n        /* If there's no backend, we can just say we consumed all data. */\n        return len;\n    }\n    ret = qemu_chr_fe_write(vcon->chr, buf, len);\n    trace_virtio_console_flush_buf(port->id, len, ret);\n    if (ret < len) {\n        VirtIOSerialPortClass *k = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n        /*\n         * Ideally we'd get a better error code than just -1, but\n         * that's what the chardev interface gives us right now.  If\n         * we had a finer-grained message, like -EPIPE, we could close\n         * this connection.\n        if (ret < 0)\n            ret = 0;\n        if (!k->is_console) {\n            virtio_serial_throttle_port(port, true);\n            if (!vcon->watch) {\n                vcon->watch = qemu_chr_fe_add_watch(vcon->chr,\n                                                    G_IO_OUT|G_IO_HUP,\n                                                    chr_write_unblocked, vcon);\n            }\n        }\n    }\n    return ret;\n}", "idx": 5157}
{"project": "qemu", "commit_id": "e53f27b9d9df73461308618151fa6e6392aebd85", "target": 1, "func": "static void tcp_chr_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    TCPCharDriver *s = chr->opaque;\n\n    uint8_t buf[READ_BUF_LEN];\n\n    int len, size;\n\n\n\n    if (!s->connected || s->max_size <= 0)\n\n        return;\n\n    len = sizeof(buf);\n\n    if (len > s->max_size)\n\n        len = s->max_size;\n\n    size = tcp_chr_recv(chr, (void *)buf, len);\n\n    if (size == 0) {\n\n        /* connection closed */\n\n        s->connected = 0;\n\n        if (s->listen_fd >= 0) {\n\n            qemu_set_fd_handler(s->listen_fd, tcp_chr_accept, NULL, chr);\n\n        }\n\n        qemu_set_fd_handler(s->fd, NULL, NULL, NULL);\n\n        closesocket(s->fd);\n\n        s->fd = -1;\n\n        qemu_chr_event(chr, CHR_EVENT_CLOSED);\n\n    } else if (size > 0) {\n\n        if (s->do_telnetopt)\n\n            tcp_chr_process_IAC_bytes(chr, s, buf, &size);\n\n        if (size > 0)\n\n            qemu_chr_read(chr, buf, size);\n\n        if (s->msgfd != -1) {\n\n            close(s->msgfd);\n\n            s->msgfd = -1;\n\n        }\n\n    }\n\n}\n", "idx": 5158}
{"project": "FFmpeg", "commit_id": "d81be0a60a6dea2bc48ec29f9466eee63984ed34", "target": 1, "func": "static int hwmap_filter_frame(AVFilterLink *link, AVFrame *input)\n\n{\n\n    AVFilterContext *avctx = link->dst;\n\n    AVFilterLink  *outlink = avctx->outputs[0];\n\n    HWMapContext      *ctx = avctx->priv;\n\n    AVFrame *map = NULL;\n\n    int err;\n\n\n\n    av_log(ctx, AV_LOG_DEBUG, \"Filter input: %s, %ux%u (%\"PRId64\").\\n\",\n\n           av_get_pix_fmt_name(input->format),\n\n           input->width, input->height, input->pts);\n\n\n\n    map = av_frame_alloc();\n\n    if (!map) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    map->format = outlink->format;\n\n    map->hw_frames_ctx = av_buffer_ref(ctx->hwframes_ref);\n\n    if (!map->hw_frames_ctx) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    if (ctx->map_backwards && !input->hw_frames_ctx) {\n\n        // If we mapped backwards from hardware to software, we need\n\n        // to attach the hardware frame context to the input frame to\n\n        // make the mapping visible to av_hwframe_map().\n\n        input->hw_frames_ctx = av_buffer_ref(ctx->hwframes_ref);\n\n        if (!input->hw_frames_ctx) {\n\n            err = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    err = av_hwframe_map(map, input, ctx->mode);\n\n    if (err < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to map frame: %d.\\n\", err);\n\n        goto fail;\n\n    }\n\n\n\n    err = av_frame_copy_props(map, input);\n\n    if (err < 0)\n\n        goto fail;\n\n\n\n    av_frame_free(&input);\n\n\n\n    av_log(ctx, AV_LOG_DEBUG, \"Filter output: %s, %ux%u (%\"PRId64\").\\n\",\n\n           av_get_pix_fmt_name(map->format),\n\n           map->width, map->height, map->pts);\n\n\n\n    return ff_filter_frame(outlink, map);\n\n\n\nfail:\n\n    av_frame_free(&input);\n\n    av_frame_free(&map);\n\n    return err;\n\n}\n", "idx": 5176}
{"project": "qemu", "commit_id": "c9262e8a84a29f22fbb5edde5d17f4f6166d5ae1", "target": 1, "func": "void virtio_panic(const char *string)\n\n{\n\n    sclp_print(string);\n\n    disabled_wait();\n\n    while (1) { }\n\n}\n", "idx": 5177}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "bool migrate_zero_blocks(void)\n\n{\n\n    MigrationState *s;\n\n\n\n    s = migrate_get_current();\n\n\n\n    return s->enabled_capabilities[MIGRATION_CAPABILITY_ZERO_BLOCKS];\n\n}\n", "idx": 5180}
{"project": "qemu", "commit_id": "574ef17191f5ec5a3cc4782c1f59dc5eb8279654", "target": 0, "func": "static int ehci_state_executing(EHCIQueue *q)\n\n{\n\n    EHCIPacket *p = QTAILQ_FIRST(&q->packets);\n\n    int again = 0;\n\n\n\n    assert(p != NULL);\n\n    assert(p->qtdaddr == q->qtdaddr);\n\n\n\n    ehci_execute_complete(q);\n\n    if (p->usb_status == USB_RET_ASYNC) {\n\n        goto out;\n\n    }\n\n    if (p->usb_status == USB_RET_PROCERR) {\n\n        again = -1;\n\n        goto out;\n\n    }\n\n\n\n    // 4.10.3\n\n    if (!q->async) {\n\n        int transactCtr = get_field(q->qh.epcap, QH_EPCAP_MULT);\n\n        transactCtr--;\n\n        set_field(&q->qh.epcap, transactCtr, QH_EPCAP_MULT);\n\n        // 4.10.3, bottom of page 82, should exit this state when transaction\n\n        // counter decrements to 0\n\n    }\n\n\n\n    /* 4.10.5 */\n\n    if (p->usb_status == USB_RET_NAK) {\n\n        ehci_set_state(q->ehci, q->async, EST_HORIZONTALQH);\n\n    } else {\n\n        ehci_set_state(q->ehci, q->async, EST_WRITEBACK);\n\n    }\n\n\n\n    again = 1;\n\n\n\nout:\n\n    ehci_flush_qh(q);\n\n    return again;\n\n}\n", "idx": 5197}
{"project": "FFmpeg", "commit_id": "90901860c21468d6e9ae437c2bacb099c7bd3acf", "target": 0, "func": "static int vorbis_parse_setup_hdr_modes(vorbis_context *vc) {\n\n    GetBitContext *gb=&vc->gb;\n\n    uint_fast8_t i;\n\n\n\n    vc->mode_count=get_bits(gb, 6)+1;\n\n    vc->modes=(vorbis_mode *)av_mallocz(vc->mode_count * sizeof(vorbis_mode));\n\n\n\n    AV_DEBUG(\" There are %d modes.\\n\", vc->mode_count);\n\n\n\n    for(i=0;i<vc->mode_count;++i) {\n\n        vorbis_mode *mode_setup=&vc->modes[i];\n\n\n\n        mode_setup->blockflag=get_bits1(gb);\n\n        mode_setup->windowtype=get_bits(gb, 16); //FIXME check\n\n        mode_setup->transformtype=get_bits(gb, 16); //FIXME check\n\n        mode_setup->mapping=get_bits(gb, 8); //FIXME check\n\n\n\n        AV_DEBUG(\" %d mode: blockflag %d, windowtype %d, transformtype %d, mapping %d \\n\", i, mode_setup->blockflag, mode_setup->windowtype, mode_setup->transformtype, mode_setup->mapping);\n\n    }\n\n    return 0;\n\n}\n", "idx": 5248}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void check_exception(sPAPREnvironment *spapr,\n\n                            uint32_t token, uint32_t nargs,\n\n                            target_ulong args,\n\n                            uint32_t nret, target_ulong rets)\n\n{\n\n    uint32_t mask, buf, len;\n\n    uint64_t xinfo;\n\n\n\n    if ((nargs < 6) || (nargs > 7) || nret != 1) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    xinfo = rtas_ld(args, 1);\n\n    mask = rtas_ld(args, 2);\n\n    buf = rtas_ld(args, 4);\n\n    len = rtas_ld(args, 5);\n\n    if (nargs == 7) {\n\n        xinfo |= (uint64_t)rtas_ld(args, 6) << 32;\n\n    }\n\n\n\n    if ((mask & EVENT_MASK_EPOW) && pending_epow) {\n\n        if (sizeof(*pending_epow) < len) {\n\n            len = sizeof(*pending_epow);\n\n        }\n\n\n\n        cpu_physical_memory_write(buf, pending_epow, len);\n\n        g_free(pending_epow);\n\n        pending_epow = NULL;\n\n        rtas_st(rets, 0, 0);\n\n    } else {\n\n        rtas_st(rets, 0, 1);\n\n    }\n\n}\n", "idx": 5252}
{"project": "qemu", "commit_id": "75b0713e189a981e5bfd087d5f35705446bbb12a", "target": 1, "func": "static void nvdimm_build_nfit(GSList *device_list, GArray *table_offsets,\n\n                              GArray *table_data, BIOSLinker *linker)\n\n{\n\n    GArray *structures = nvdimm_build_device_structure(device_list);\n\n    unsigned int header;\n\n\n\n    acpi_add_table(table_offsets, table_data);\n\n\n\n    /* NFIT header. */\n\n    header = table_data->len;\n\n    acpi_data_push(table_data, sizeof(NvdimmNfitHeader));\n\n    /* NVDIMM device structures. */\n\n    g_array_append_vals(table_data, structures->data, structures->len);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + header), \"NFIT\",\n\n                 sizeof(NvdimmNfitHeader) + structures->len, 1, NULL, NULL);\n\n    g_array_free(structures, true);\n\n}\n", "idx": 5255}
{"project": "qemu", "commit_id": "9adea5f7f7a23ef4a1231289a36a94c52347b142", "target": 0, "func": "do_send_recv(int sockfd, struct iovec *iov, unsigned iov_cnt, bool do_send)\n\n{\n\n#if defined CONFIG_IOVEC && defined CONFIG_POSIX\n\n    ssize_t ret;\n\n    struct msghdr msg;\n\n    memset(&msg, 0, sizeof(msg));\n\n    msg.msg_iov = iov;\n\n    msg.msg_iovlen = iov_cnt;\n\n    do {\n\n        ret = do_send\n\n            ? sendmsg(sockfd, &msg, 0)\n\n            : recvmsg(sockfd, &msg, 0);\n\n    } while (ret < 0 && errno == EINTR);\n\n    return ret;\n\n#else\n\n    /* else send piece-by-piece */\n\n    /*XXX Note: windows has WSASend() and WSARecv() */\n\n    unsigned i = 0;\n\n    ssize_t ret = 0;\n\n    while (i < iov_cnt) {\n\n        ssize_t r = do_send\n\n            ? send(sockfd, iov[i].iov_base, iov[i].iov_len, 0)\n\n            : recv(sockfd, iov[i].iov_base, iov[i].iov_len, 0);\n\n        if (r > 0) {\n\n            ret += r;\n\n        } else if (!r) {\n\n            break;\n\n        } else if (errno == EINTR) {\n\n            continue;\n\n        } else {\n\n            /* else it is some \"other\" error,\n\n             * only return if there was no data processed. */\n\n            if (ret == 0) {\n\n                ret = -1;\n\n            }\n\n            break;\n\n        }\n\n        i++;\n\n    }\n\n    return ret;\n\n#endif\n\n}\n", "idx": 5289}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(keyword_literal)\n\n{\n\n    QObject *obj;\n\n    QBool *qbool;\n\n    QString *str;\n\n\n\n    obj = qobject_from_json(\"true\");\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QBOOL);\n\n\n\n    qbool = qobject_to_qbool(obj);\n\n    fail_unless(qbool_get_int(qbool) != 0);\n\n\n\n    str = qobject_to_json(obj);\n\n    fail_unless(strcmp(qstring_get_str(str), \"true\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"false\");\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QBOOL);\n\n\n\n    qbool = qobject_to_qbool(obj);\n\n    fail_unless(qbool_get_int(qbool) == 0);\n\n\n\n    str = qobject_to_json(obj);\n\n    fail_unless(strcmp(qstring_get_str(str), \"false\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_jsonf(\"%i\", false);\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QBOOL);\n\n\n\n    qbool = qobject_to_qbool(obj);\n\n    fail_unless(qbool_get_int(qbool) == 0);\n\n\n\n    QDECREF(qbool);\n\n    \n\n    obj = qobject_from_jsonf(\"%i\", true);\n\n    fail_unless(obj != NULL);\n\n    fail_unless(qobject_type(obj) == QTYPE_QBOOL);\n\n\n\n    qbool = qobject_to_qbool(obj);\n\n    fail_unless(qbool_get_int(qbool) != 0);\n\n\n\n    QDECREF(qbool);\n\n}\n", "idx": 5290}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_rt_sigreturn(CPUAlphaState *env)\n\n{\n\n    abi_ulong frame_addr = env->ir[IR_A0];\n\n    struct target_rt_sigframe *frame;\n\n    sigset_t set;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {\n\n        goto badframe;\n\n    }\n\n    target_to_host_sigset(&set, &frame->uc.tuc_sigmask);\n\n    do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    if (restore_sigcontext(env, &frame->uc.tuc_mcontext)) {\n\n        goto badframe;\n\n    }\n\n    if (do_sigaltstack(frame_addr + offsetof(struct target_rt_sigframe,\n\n                                             uc.tuc_stack),\n\n                       0, env->ir[IR_SP]) == -EFAULT) {\n\n        goto badframe;\n\n    }\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return env->ir[IR_V0];\n\n\n\n\n\n badframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 5359}
{"project": "qemu", "commit_id": "f7838b5290de03f7cb2dbee5bd1ceae67b4a5ef0", "target": 0, "func": "static void cortex_a9_initfn(Object *obj)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(obj);\n\n\n\n    cpu->dtb_compatible = \"arm,cortex-a9\";\n\n    set_feature(&cpu->env, ARM_FEATURE_V7);\n\n    set_feature(&cpu->env, ARM_FEATURE_VFP3);\n\n    set_feature(&cpu->env, ARM_FEATURE_VFP_FP16);\n\n    set_feature(&cpu->env, ARM_FEATURE_NEON);\n\n    set_feature(&cpu->env, ARM_FEATURE_THUMB2EE);\n\n    /* Note that A9 supports the MP extensions even for\n\n     * A9UP and single-core A9MP (which are both different\n\n     * and valid configurations; we don't model A9UP).\n\n     */\n\n    set_feature(&cpu->env, ARM_FEATURE_V7MP);\n\n    set_feature(&cpu->env, ARM_FEATURE_CBAR);\n\n    cpu->midr = 0x410fc090;\n\n    cpu->reset_fpsid = 0x41033090;\n\n    cpu->mvfr0 = 0x11110222;\n\n    cpu->mvfr1 = 0x01111111;\n\n    cpu->ctr = 0x80038003;\n\n    cpu->reset_sctlr = 0x00c50078;\n\n    cpu->id_pfr0 = 0x1031;\n\n    cpu->id_pfr1 = 0x11;\n\n    cpu->id_dfr0 = 0x000;\n\n    cpu->id_afr0 = 0;\n\n    cpu->id_mmfr0 = 0x00100103;\n\n    cpu->id_mmfr1 = 0x20000000;\n\n    cpu->id_mmfr2 = 0x01230000;\n\n    cpu->id_mmfr3 = 0x00002111;\n\n    cpu->id_isar0 = 0x00101111;\n\n    cpu->id_isar1 = 0x13112111;\n\n    cpu->id_isar2 = 0x21232041;\n\n    cpu->id_isar3 = 0x11112131;\n\n    cpu->id_isar4 = 0x00111142;\n\n    cpu->dbgdidr = 0x35141000;\n\n    cpu->clidr = (1 << 27) | (1 << 24) | 3;\n\n    cpu->ccsidr[0] = 0xe00fe015; /* 16k L1 dcache. */\n\n    cpu->ccsidr[1] = 0x200fe015; /* 16k L1 icache. */\n\n    define_arm_cp_regs(cpu, cortexa9_cp_reginfo);\n\n}\n", "idx": 5366}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "static void bt_hci_reset(struct bt_hci_s *hci)\n\n{\n\n    hci->acl_len = 0;\n\n    hci->last_cmd = 0;\n\n    hci->lm.connecting = 0;\n\n\n\n    hci->event_mask[0] = 0xff;\n\n    hci->event_mask[1] = 0xff;\n\n    hci->event_mask[2] = 0xff;\n\n    hci->event_mask[3] = 0xff;\n\n    hci->event_mask[4] = 0xff;\n\n    hci->event_mask[5] = 0x1f;\n\n    hci->event_mask[6] = 0x00;\n\n    hci->event_mask[7] = 0x00;\n\n    hci->device.inquiry_scan = 0;\n\n    hci->device.page_scan = 0;\n\n    if (hci->device.lmp_name)\n\n        g_free((void *) hci->device.lmp_name);\n\n    hci->device.lmp_name = NULL;\n\n    hci->device.class[0] = 0x00;\n\n    hci->device.class[1] = 0x00;\n\n    hci->device.class[2] = 0x00;\n\n    hci->voice_setting = 0x0000;\n\n    hci->conn_accept_tout = 0x1f40;\n\n    hci->lm.inquiry_mode = 0x00;\n\n\n\n    hci->psb_handle = 0x000;\n\n    hci->asb_handle = 0x000;\n\n\n\n    /* XXX: timer_del(sl->acl_mode_timer); for all links */\n\n    timer_del(hci->lm.inquiry_done);\n\n    timer_del(hci->lm.inquiry_next);\n\n    timer_del(hci->conn_accept_timer);\n\n}\n", "idx": 5379}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static void net_tx_pkt_do_sw_csum(struct NetTxPkt *pkt)\n\n{\n\n    struct iovec *iov = &pkt->vec[NET_TX_PKT_L2HDR_FRAG];\n\n    uint32_t csum_cntr;\n\n    uint16_t csum = 0;\n\n    /* num of iovec without vhdr */\n\n    uint32_t iov_len = pkt->payload_frags + NET_TX_PKT_PL_START_FRAG - 1;\n\n    uint16_t csl;\n\n    struct ip_header *iphdr;\n\n    size_t csum_offset = pkt->virt_hdr.csum_start + pkt->virt_hdr.csum_offset;\n\n\n\n    /* Put zero to checksum field */\n\n    iov_from_buf(iov, iov_len, csum_offset, &csum, sizeof csum);\n\n\n\n    /* Calculate L4 TCP/UDP checksum */\n\n    csl = pkt->payload_len;\n\n\n\n    /* data checksum */\n\n    csum_cntr =\n\n        net_checksum_add_iov(iov, iov_len, pkt->virt_hdr.csum_start, csl);\n\n    /* add pseudo header to csum */\n\n    iphdr = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n\n    csum_cntr += eth_calc_pseudo_hdr_csum(iphdr, csl);\n\n\n\n    /* Put the checksum obtained into the packet */\n\n    csum = cpu_to_be16(net_checksum_finish(csum_cntr));\n\n    iov_from_buf(iov, iov_len, csum_offset, &csum, sizeof csum);\n\n}\n", "idx": 5380}
{"project": "qemu", "commit_id": "9bcec938aab22a1b7ced916a6895e5029d4ed04f", "target": 1, "func": "void apic_reset_irq_delivered(void)\n\n{\n\n    trace_apic_reset_irq_delivered(apic_irq_delivered);\n\n\n\n    apic_irq_delivered = 0;\n\n}\n", "idx": 5402}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static TAPState *net_tap_fd_init(VLANState *vlan, int fd)\n\n{\n\n    TAPState *s;\n\n\n\n    s = qemu_mallocz(sizeof(TAPState));\n\n    if (!s)\n\n        return NULL;\n\n    s->fd = fd;\n\n    s->vc = qemu_new_vlan_client(vlan, tap_receive, s);\n\n    qemu_set_fd_handler(s->fd, tap_send, NULL, s);\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str), \"tap: fd=%d\", fd);\n\n    return s;\n\n}\n", "idx": 5403}
{"project": "qemu", "commit_id": "74c85296dc880568005b8e7572e08a39d66bcdca", "target": 0, "func": "static ram_addr_t s390_virtio_device_num_vq(VirtIOS390Device *dev)\n\n{\n\n    VirtIODevice *vdev = dev->vdev;\n\n    int num_vq;\n\n\n\n    for (num_vq = 0; num_vq < VIRTIO_PCI_QUEUE_MAX; num_vq++) {\n\n        if (!virtio_queue_get_num(vdev, num_vq)) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return num_vq;\n\n}\n", "idx": 5459}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static int jazz_led_init(SysBusDevice *dev)\n\n{\n\n    LedState *s = FROM_SYSBUS(LedState, dev);\n\n\n\n    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    s->con = graphic_console_init(jazz_led_update_display,\n\n                                  jazz_led_invalidate_display,\n\n                                  NULL,\n\n                                  jazz_led_text_update, s);\n\n\n\n    return 0;\n\n}\n", "idx": 5464}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t hpet_ram_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    printf(\"qemu: hpet_read b at %\" PRIx64 \"\\n\", addr);\n\n    return 0;\n\n}\n", "idx": 5467}
{"project": "qemu", "commit_id": "60e68042cf70f271308dc6b4b22b609d054af929", "target": 0, "func": "static bool x86_cpu_has_work(CPUState *cs)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n\n\n    return ((cs->interrupt_request & (CPU_INTERRUPT_HARD |\n\n                                      CPU_INTERRUPT_POLL)) &&\n\n            (env->eflags & IF_MASK)) ||\n\n           (cs->interrupt_request & (CPU_INTERRUPT_NMI |\n\n                                     CPU_INTERRUPT_INIT |\n\n                                     CPU_INTERRUPT_SIPI |\n\n                                     CPU_INTERRUPT_MCE));\n\n}\n", "idx": 5484}
{"project": "qemu", "commit_id": "16b781aaef69c90d5f4f5456615f0c26a4f45740", "target": 0, "func": "static void sd_reset(SDState *sd, BlockBackend *blk)\n\n{\n\n    uint64_t size;\n\n    uint64_t sect;\n\n\n\n    if (blk) {\n\n        blk_get_geometry(blk, &sect);\n\n    } else {\n\n        sect = 0;\n\n    }\n\n    size = sect << 9;\n\n\n\n    sect = sd_addr_to_wpnum(size) + 1;\n\n\n\n    sd->state = sd_idle_state;\n\n    sd->rca = 0x0000;\n\n    sd_set_ocr(sd);\n\n    sd_set_scr(sd);\n\n    sd_set_cid(sd);\n\n    sd_set_csd(sd, size);\n\n    sd_set_cardstatus(sd);\n\n    sd_set_sdstatus(sd);\n\n\n\n    sd->blk = blk;\n\n\n\n    if (sd->wp_groups)\n\n        g_free(sd->wp_groups);\n\n    sd->wp_switch = blk ? blk_is_read_only(blk) : false;\n\n    sd->wpgrps_size = sect;\n\n    sd->wp_groups = bitmap_new(sd->wpgrps_size);\n\n    memset(sd->function_group, 0, sizeof(sd->function_group));\n\n    sd->erase_start = 0;\n\n    sd->erase_end = 0;\n\n    sd->size = size;\n\n    sd->blk_len = 0x200;\n\n    sd->pwd_len = 0;\n\n    sd->expecting_acmd = false;\n\n}\n", "idx": 5487}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "struct GuestAgentInfo *qmp_guest_info(Error **errp)\n\n{\n\n    GuestAgentInfo *info = g_malloc0(sizeof(GuestAgentInfo));\n\n\n\n    info->version = g_strdup(QEMU_VERSION);\n\n    qmp_for_each_command(qmp_command_info, info);\n\n    return info;\n\n}\n", "idx": 5510}
{"project": "qemu", "commit_id": "d9d3aaea0b3fbb5028e20316bdb93359487cd01f", "target": 1, "func": "void replay_configure(QemuOpts *opts)\n\n{\n\n    const char *fname;\n\n    const char *rr;\n\n    ReplayMode mode = REPLAY_MODE_NONE;\n\n    Location loc;\n\n\n\n    if (!opts) {\n\n        return;\n\n    }\n\n\n\n    loc_push_none(&loc);\n\n    qemu_opts_loc_restore(opts);\n\n\n\n    rr = qemu_opt_get(opts, \"rr\");\n\n    if (!rr) {\n\n        /* Just enabling icount */\n\n        return;\n\n    } else if (!strcmp(rr, \"record\")) {\n\n        mode = REPLAY_MODE_RECORD;\n\n    } else if (!strcmp(rr, \"replay\")) {\n\n        mode = REPLAY_MODE_PLAY;\n\n    } else {\n\n        error_report(\"Invalid icount rr option: %s\", rr);\n\n        exit(1);\n\n    }\n\n\n\n    fname = qemu_opt_get(opts, \"rrfile\");\n\n    if (!fname) {\n\n        error_report(\"File name not specified for replay\");\n\n        exit(1);\n\n    }\n\n\n\n    replay_enable(fname, mode);\n\n\n\n    loc_pop(&loc);\n\n}\n", "idx": 5521}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "void scsi_req_dequeue(SCSIRequest *req)\n\n{\n\n    trace_scsi_req_dequeue(req->dev->id, req->lun, req->tag);\n\n    if (req->enqueued) {\n\n        QTAILQ_REMOVE(&req->dev->requests, req, next);\n\n        req->enqueued = false;\n\n        scsi_req_unref(req);\n\n    }\n\n}\n", "idx": 5526}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_test_bit(int64_t bitnum, const uint8_t *bitmap)\n\n{\n\n    return (bitmap[bitnum / 8] & (1 << (bitnum & 7))) != 0;\n\n}\n", "idx": 5566}
{"project": "qemu", "commit_id": "40fda982f2e887f7d5cc36b8a7e3b5a07a1e6704", "target": 0, "func": "static void kvmppc_host_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    uint32_t vmx = kvmppc_get_vmx();\n\n    uint32_t dfp = kvmppc_get_dfp();\n\n    uint32_t dcache_size = kvmppc_read_int_cpu_dt(\"d-cache-size\");\n\n    uint32_t icache_size = kvmppc_read_int_cpu_dt(\"i-cache-size\");\n\n\n\n    /* Now fix up the class with information we can query from the host */\n\n    pcc->pvr = mfpvr();\n\n\n\n    if (vmx != -1) {\n\n        /* Only override when we know what the host supports */\n\n        alter_insns(&pcc->insns_flags, PPC_ALTIVEC, vmx > 0);\n\n        alter_insns(&pcc->insns_flags2, PPC2_VSX, vmx > 1);\n\n    }\n\n    if (dfp != -1) {\n\n        /* Only override when we know what the host supports */\n\n        alter_insns(&pcc->insns_flags2, PPC2_DFP, dfp);\n\n    }\n\n\n\n    if (dcache_size != -1) {\n\n        pcc->l1_dcache_size = dcache_size;\n\n    }\n\n\n\n    if (icache_size != -1) {\n\n        pcc->l1_icache_size = icache_size;\n\n    }\n\n\n\n    /* Reason: kvmppc_host_cpu_initfn() dies when !kvm_enabled() */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 5573}
{"project": "qemu", "commit_id": "53333801e7bb41487147599e1b16b60ebea74695", "target": 1, "func": "static void test_acpi_one(const char *params)\n\n{\n\n    char *args;\n\n    uint8_t signature_low;\n\n    uint8_t signature_high;\n\n    uint16_t signature;\n\n    int i;\n\n    uint32_t off;\n\n\n\n\n\n    args = g_strdup_printf(\"-net none -display none %s %s\",\n\n                           params ? params : \"\", disk);\n\n    qtest_start(args);\n\n\n\n   /* Wait at most 1 minute */\n\n#define TEST_DELAY (1 * G_USEC_PER_SEC / 10)\n\n#define TEST_CYCLES MAX((60 * G_USEC_PER_SEC / TEST_DELAY), 1)\n\n\n\n    /* Poll until code has run and modified memory.  Once it has we know BIOS\n\n     * initialization is done.  TODO: check that IP reached the halt\n\n     * instruction.\n\n     */\n\n    for (i = 0; i < TEST_CYCLES; ++i) {\n\n        signature_low = readb(BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET);\n\n        signature_high = readb(BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET + 1);\n\n        signature = (signature_high << 8) | signature_low;\n\n        if (signature == SIGNATURE) {\n\n            break;\n\n        }\n\n        g_usleep(TEST_DELAY);\n\n    }\n\n    g_assert_cmphex(signature, ==, SIGNATURE);\n\n\n\n    /* OK, now find RSDP */\n\n    for (off = 0xf0000; off < 0x100000; off += 0x10)\n\n    {\n\n        uint8_t sig[] = \"RSD PTR \";\n\n        int i;\n\n\n\n        for (i = 0; i < sizeof sig - 1; ++i) {\n\n            sig[i] = readb(off + i);\n\n        }\n\n\n\n        if (!memcmp(sig, \"RSD PTR \", sizeof sig)) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    g_assert_cmphex(off, <, 0x100000);\n\n\n\n    qtest_quit(global_qtest);\n\n    g_free(args);\n\n}\n", "idx": 5601}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_dpll_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t value, unsigned size)\n\n{\n\n    struct dpll_ctl_s *s = (struct dpll_ctl_s *) opaque;\n\n    uint16_t diff;\n\n    static const int bypass_div[4] = { 1, 2, 4, 4 };\n\n    int div, mult;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_write16(opaque, addr, value);\n\n    }\n\n\n\n    if (addr == 0x00) {\t/* CTL_REG */\n\n        /* See omap_ulpd_pm_write() too */\n\n        diff = s->mode & value;\n\n        s->mode = value & 0x2fff;\n\n        if (diff & (0x3ff << 2)) {\n\n            if (value & (1 << 4)) {\t\t\t/* PLL_ENABLE */\n\n                div = ((value >> 5) & 3) + 1;\t\t/* PLL_DIV */\n\n                mult = MIN((value >> 7) & 0x1f, 1);\t/* PLL_MULT */\n\n            } else {\n\n                div = bypass_div[((value >> 2) & 3)];\t/* BYPASS_DIV */\n\n                mult = 1;\n\n            }\n\n            omap_clk_setrate(s->dpll, div, mult);\n\n        }\n\n\n\n        /* Enter the desired mode.  */\n\n        s->mode = (s->mode & 0xfffe) | ((s->mode >> 4) & 1);\n\n\n\n        /* Act as if the lock is restored.  */\n\n        s->mode |= 2;\n\n    } else {\n\n        OMAP_BAD_REG(addr);\n\n    }\n\n}\n", "idx": 5638}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evfsneg(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);\n\n#else\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);\n\n    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 5640}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void qmp_input_start_list(Visitor *v, const char *name, Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true);\n\n\n\n    if (!qobj || qobject_type(qobj) != QTYPE_QLIST) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"list\");\n\n        return;\n\n    }\n\n\n\n    qmp_input_push(qiv, qobj, errp);\n\n}\n", "idx": 5648}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void nvic_sysreg_write(void *opaque, target_phys_addr_t addr,\n\n                              uint64_t value, unsigned size)\n\n{\n\n    uint32_t offset = addr;\n\n    if (size == 4) {\n\n        nvic_writel(opaque, offset, value);\n\n        return;\n\n    }\n\n    hw_error(\"NVIC: Bad write of size %d at offset 0x%x\\n\", size, offset);\n\n}\n", "idx": 5660}
{"project": "qemu", "commit_id": "3716d5902d743e9a395b7d82f48df4fa56ed1ad3", "target": 0, "func": "static void pci_init_bus_master(PCIDevice *pci_dev)\n\n{\n\n    AddressSpace *dma_as = pci_device_iommu_address_space(pci_dev);\n\n\n\n    memory_region_init_alias(&pci_dev->bus_master_enable_region,\n\n                             OBJECT(pci_dev), \"bus master\",\n\n                             dma_as->root, 0, memory_region_size(dma_as->root));\n\n    memory_region_set_enabled(&pci_dev->bus_master_enable_region, false);\n\n    address_space_init(&pci_dev->bus_master_as,\n\n                       &pci_dev->bus_master_enable_region, pci_dev->name);\n\n}\n", "idx": 5666}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_set_event_notifier_poll(AioContext *ctx,\n\n                                 EventNotifier *notifier,\n\n                                 EventNotifierHandler *io_poll_begin,\n\n                                 EventNotifierHandler *io_poll_end)\n\n{\n\n    aio_set_fd_poll(ctx, event_notifier_get_fd(notifier),\n\n                    (IOHandler *)io_poll_begin,\n\n                    (IOHandler *)io_poll_end);\n\n}\n", "idx": 5674}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t m5208_sys_read(void *opaque, target_phys_addr_t addr,\n\n                               unsigned size)\n\n{\n\n    switch (addr) {\n\n    case 0x110: /* SDCS0 */\n\n        {\n\n            int n;\n\n            for (n = 0; n < 32; n++) {\n\n                if (ram_size < (2u << n))\n\n                    break;\n\n            }\n\n            return (n - 1)  | 0x40000000;\n\n        }\n\n    case 0x114: /* SDCS1 */\n\n        return 0;\n\n\n\n    default:\n\n        hw_error(\"m5208_sys_read: Bad offset 0x%x\\n\", (int)addr);\n\n        return 0;\n\n    }\n\n}\n", "idx": 5682}
{"project": "qemu", "commit_id": "c4843a45e3d4f3698b214275ab5e78cdb6a3d212", "target": 1, "func": "static int vhost_user_set_vring_addr(struct vhost_dev *dev,\n\n                                     struct vhost_vring_addr *addr)\n\n{\n\n    VhostUserMsg msg = {\n\n        .request = VHOST_USER_SET_VRING_ADDR,\n\n        .flags = VHOST_USER_VERSION,\n\n        .payload.addr = *addr,\n\n        .size = sizeof(msg.payload.addr),\n\n    };\n\n\n\n    vhost_user_write(dev, &msg, NULL, 0);\n\n\n\n    return 0;\n\n}\n", "idx": 5713}
{"project": "FFmpeg", "commit_id": "f015e411d78d9e9ae179170beafe4951b778ac50", "target": 1, "func": "static int amr_read_packet(AVFormatContext *s,\n\n                          AVPacket *pkt)\n\n{\n\n    AVCodecContext *enc = s->streams[0]->codec;\n\n    int read, size, toc, mode;\n\n\n\n    if (url_feof(&s->pb))\n\n    {\n\n        return AVERROR_IO;\n\n    }\n\n\n\n//FIXME this is wrong, this should rather be in a AVParset\n\n    toc=get_byte(&s->pb);\n\n    mode = (toc >> 3) & 0x0F;\n\n\n\n    if (enc->codec_id == CODEC_ID_AMR_NB)\n\n    {\n\n        static const uint8_t packed_size[16] = {12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0};\n\n\n\n        size=packed_size[mode]+1;\n\n    }\n\n    else if(enc->codec_id == CODEC_ID_AMR_WB)\n\n    {\n\n        static uint8_t packed_size[16] = {18, 24, 33, 37, 41, 47, 51, 59, 61, 6, 6, 0, 0, 0, 1, 1};\n\n\n\n        size=packed_size[mode];\n\n    }\n\n    else\n\n    {\n\n        assert(0);\n\n    }\n\n\n\n    if ( (size==0) || av_new_packet(pkt, size))\n\n    {\n\n        return AVERROR_IO;\n\n    }\n\n\n\n    pkt->stream_index = 0;\n\n    pkt->pos= url_ftell(&s->pb);\n\n    pkt->data[0]=toc;\n\n    pkt->duration= enc->codec_id == CODEC_ID_AMR_NB ? 160 : 320;\n\n    read = get_buffer(&s->pb, pkt->data+1, size-1);\n\n\n\n    if (read != size-1)\n\n    {\n\n        av_free_packet(pkt);\n\n        return AVERROR_IO;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5715}
{"project": "FFmpeg", "commit_id": "575d494de561049f36f9c5492e05c7d83dd78e75", "target": 1, "func": "static void park_frame_worker_threads(FrameThreadContext *fctx, int thread_count)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < thread_count; i++) {\n\n        PerThreadContext *p = &fctx->threads[i];\n\n\n\n        if (p->state != STATE_INPUT_READY) {\n\n            pthread_mutex_lock(&p->progress_mutex);\n\n            while (p->state != STATE_INPUT_READY)\n\n                pthread_cond_wait(&p->output_cond, &p->progress_mutex);\n\n            pthread_mutex_unlock(&p->progress_mutex);\n\n        }\n\n\n    }\n\n}", "idx": 5729}
{"project": "FFmpeg", "commit_id": "559fd1e79524ca47efde195e28feb4499dd48761", "target": 1, "func": "static int nut_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    NUTContext *nut = s->priv_data;\n\n    ByteIOContext *bc = &s->pb;\n\n    int i, frame_code=0, ret, skip;\n\n    int64_t ts, back_ptr;\n\n\n\n    for(;;){\n\n        int64_t pos= url_ftell(bc);\n\n        uint64_t tmp= nut->next_startcode;\n\n        nut->next_startcode=0;\n\n\n\n        if (url_feof(bc))\n\n            return -1;\n\n\n\n        if(tmp){\n\n            pos-=8;\n\n        }else{\n\n            frame_code = get_byte(bc);\n\n            if(frame_code == 'N'){\n\n                tmp= frame_code;\n\n                for(i=1; i<8; i++)\n\n                    tmp = (tmp<<8) + get_byte(bc);\n\n            }\n\n        }\n\n        switch(tmp){\n\n        case MAIN_STARTCODE:\n\n        case STREAM_STARTCODE:\n\n        case INDEX_STARTCODE:\n\n            skip= get_packetheader(nut, bc, 0);\n\n            url_fseek(bc, skip, SEEK_CUR);\n\n            break;\n\n        case INFO_STARTCODE:\n\n            if(decode_info_header(nut)<0)\n\n                goto resync;\n\n            break;\n\n        case SYNCPOINT_STARTCODE:\n\n            if(decode_syncpoint(nut, &ts, &back_ptr)<0)\n\n                goto resync;\n\n            frame_code = get_byte(bc);\n\n        case 0:\n\n            ret= decode_frame(nut, pkt, frame_code);\n\n            if(ret==0)\n\n                return 0;\n\n            else if(ret==1) //ok but discard packet\n\n                break;\n\n        default:\n\nresync:\n\nav_log(s, AV_LOG_DEBUG, \"syncing from %\"PRId64\"\\n\", pos);\n\n            tmp= find_any_startcode(bc, nut->last_syncpoint_pos+1);\n\n            if(tmp==0)\n\n                return -1;\n\nav_log(s, AV_LOG_DEBUG, \"sync\\n\");\n\n            nut->next_startcode= tmp;\n\n        }\n\n    }\n\n}\n", "idx": 5741}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void rgb8tobgr8(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tlong i;\n\n\tlong num_pixels = src_size;\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint8_t rgb;\n\n\t    rgb = src[i];\n\n\t    r = (rgb&0x07);\n\n\t    g = (rgb&0x38)>>3;\n\n\t    b = (rgb&0xC0)>>6;\n\n\t    dst[i] = ((b<<1)&0x07) | ((g&0x07)<<3) | ((r&0x03)<<6);\n\n\t}\n\n}\n", "idx": 5757}
{"project": "qemu", "commit_id": "3da9eebda96780ead8ba44b8140c54f4a54c61f6", "target": 1, "func": "static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,\n\n                                    void *opaque)\n\n{\n\n    const VMStateSubsection *sub = vmsd->subsections;\n\n\n\n    while (sub && sub->needed) {\n\n        if (sub->needed(opaque)) {\n\n            const VMStateDescription *vmsd = sub->vmsd;\n\n            uint8_t len;\n\n\n\n            qemu_put_byte(f, QEMU_VM_SUBSECTION);\n\n            len = strlen(vmsd->name);\n\n            qemu_put_byte(f, len);\n\n            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);\n\n            qemu_put_be32(f, vmsd->version_id);\n\n            assert(!vmsd->subsections);\n\n            vmstate_save_state(f, vmsd, opaque);\n\n        }\n\n        sub++;\n\n    }\n\n}\n", "idx": 5768}
{"project": "FFmpeg", "commit_id": "981e99ab99986935affad7c164ebdfe28e8ea7f8", "target": 1, "func": "static void sbr_hf_g_filt_c(int (*Y)[2], const int (*X_high)[40][2],\n\n                          const SoftFloat *g_filt, int m_max, intptr_t ixh)\n\n{\n\n    int m;\n\n    int64_t accu;\n\n\n\n    for (m = 0; m < m_max; m++) {\n\n        int64_t r = 1LL << (22-g_filt[m].exp);\n\n        accu = (int64_t)X_high[m][ixh][0] * ((g_filt[m].mant + 0x40)>>7);\n\n        Y[m][0] = (int)((accu + r) >> (23-g_filt[m].exp));\n\n\n\n        accu = (int64_t)X_high[m][ixh][1] * ((g_filt[m].mant + 0x40)>>7);\n\n        Y[m][1] = (int)((accu + r) >> (23-g_filt[m].exp));\n\n    }\n\n}\n", "idx": 5790}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static const char *token_get_value(QObject *obj)\n\n{\n\n    return qdict_get_str(qobject_to_qdict(obj), \"token\");\n\n}\n", "idx": 5816}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void channel_store_d(struct fs_dma_ctrl *ctrl, int c)\n\n{\n\n\ttarget_phys_addr_t addr = channel_reg(ctrl, c, RW_SAVED_DATA);\n\n\n\n\t/* Encode and store. FIXME: handle endianness.  */\n\n\tD(printf(\"%s ch=%d addr=\" TARGET_FMT_plx \"\\n\", __func__, c, addr));\n\n\tcpu_physical_memory_write (addr,\n\n\t\t\t\t  (void *) &ctrl->channels[c].current_d, \n\n\t\t\t\t  sizeof ctrl->channels[c].current_d);\n\n}\n", "idx": 5825}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_ulpd_pm_init(MemoryRegion *system_memory,\n\n                target_phys_addr_t base,\n\n                struct omap_mpu_state_s *mpu)\n\n{\n\n    memory_region_init_io(&mpu->ulpd_pm_iomem, &omap_ulpd_pm_ops, mpu,\n\n                          \"omap-ulpd-pm\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &mpu->ulpd_pm_iomem);\n\n    omap_ulpd_pm_reset(mpu);\n\n}\n", "idx": 5827}
{"project": "qemu", "commit_id": "891fb2cd4592b6fe76106a69e0ca40efbf82726a", "target": 0, "func": "int usb_device_detach(USBDevice *dev)\n\n{\n\n    USBBus *bus = usb_bus_from_device(dev);\n\n    USBPort *port;\n\n\n\n    if (!dev->attached) {\n\n        error_report(\"Error: tried to detach unattached usb device %s\\n\",\n\n                dev->product_desc);\n\n        return -1;\n\n    }\n\n    dev->attached--;\n\n\n\n    QTAILQ_FOREACH(port, &bus->used, next) {\n\n        if (port->dev == dev)\n\n            break;\n\n    }\n\n    assert(port != NULL);\n\n\n\n    QTAILQ_REMOVE(&bus->used, port, next);\n\n    bus->nused--;\n\n\n\n    usb_attach(port, NULL);\n\n\n\n    QTAILQ_INSERT_TAIL(&bus->free, port, next);\n\n    bus->nfree++;\n\n    return 0;\n\n}\n", "idx": 5831}
{"project": "FFmpeg", "commit_id": "edcc51fb8e15b704955d742559215697598927bb", "target": 1, "func": "static int add_metadata(int count, int type,\n\n                        const char *name, const char *sep, TiffContext *s)\n\n{\n\n    switch(type) {\n\n    case TIFF_DOUBLE: return add_doubles_metadata(count, name, sep, s);\n\n    case TIFF_SHORT : return add_shorts_metadata(count, name, sep, s);\n\n    case TIFF_STRING: return add_string_metadata(count, name, s);\n\n    default         : return AVERROR_INVALIDDATA;\n\n    };\n\n}\n", "idx": 5847}
{"project": "FFmpeg", "commit_id": "655b6dcb34b25d591e15ede17673ea6cb8074711", "target": 0, "func": "real_parse_asm_rule(AVStream *st, const char *p, const char *end)\n\n{\n\n    do {\n\n        /* can be either averagebandwidth= or AverageBandwidth= */\n\n#if AV_HAVE_INCOMPATIBLE_LIBAV_ABI\n\n        if (sscanf(p, \" %*1[Aa]verage%*1[Bb]andwidth=%d\", &st->codec->bit_rate) == 1)\n\n#else\n\n        if (sscanf(p, \" %*1[Aa]verage%*1[Bb]andwidth=%\"SCNd64, &st->codec->bit_rate) == 1)\n\n#endif\n\n            break;\n\n        if (!(p = strchr(p, ',')) || p > end)\n\n            p = end;\n\n        p++;\n\n    } while (p < end);\n\n}\n", "idx": 5860}
{"project": "qemu", "commit_id": "09aaa1602f9381c0e0fb539390b1793e51bdfc7b", "target": 1, "func": "int select_watchdog(const char *p)\n\n{\n\n    WatchdogTimerModel *model;\n\n\n\n    if (watchdog) {\n\n        fprintf(stderr,\n\n                 \"qemu: only one watchdog option may be given\\n\");\n\n        return 1;\n\n    }\n\n\n\n    /* -watchdog ? lists available devices and exits cleanly. */\n\n    if (strcmp(p, \"?\") == 0) {\n\n        LIST_FOREACH(model, &watchdog_list, entry) {\n\n            fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                     model->wdt_name, model->wdt_description);\n\n        }\n\n        return 2;\n\n    }\n\n\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        if (strcasecmp(model->wdt_name, p) == 0) {\n\n            watchdog = model;\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Unknown -watchdog device. Supported devices are:\\n\");\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                 model->wdt_name, model->wdt_description);\n\n    }\n\n    return 1;\n\n}\n", "idx": 5867}
{"project": "qemu", "commit_id": "f7b9358e2cf12a5eb07f5f9301fdadc932f9ee03", "target": 0, "func": "static void gicv3_cpuif_el_change_hook(ARMCPU *cpu, void *opaque)\n\n{\n\n    /* Do nothing for now. */\n\n}\n", "idx": 5880}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int dxva2_vc1_end_frame(AVCodecContext *avctx)\n\n{\n\n    VC1Context *v = avctx->priv_data;\n\n    struct dxva2_picture_context *ctx_pic = v->s.current_picture_ptr->hwaccel_picture_private;\n\n    int ret;\n\n\n\n    if (ctx_pic->bitstream_size <= 0)\n\n        return -1;\n\n\n\n    ret = ff_dxva2_common_end_frame(avctx, &v->s.current_picture_ptr->f,\n\n                                    &ctx_pic->pp, sizeof(ctx_pic->pp),\n\n                                    NULL, 0,\n\n                                    commit_bitstream_and_slice_buffer);\n\n    if (!ret)\n\n        ff_mpeg_draw_horiz_band(&v->s, 0, avctx->height);\n\n    return ret;\n\n}\n", "idx": 5910}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static char *vnc_socket_remote_addr(const char *format, int fd) {\n\n    struct sockaddr_storage sa;\n\n    socklen_t salen;\n\n\n\n    salen = sizeof(sa);\n\n    if (getpeername(fd, (struct sockaddr*)&sa, &salen) < 0)\n\n        return NULL;\n\n\n\n    return addr_to_string(format, &sa, salen);\n\n}\n", "idx": 5913}
{"project": "qemu", "commit_id": "2e29bd04786003561303dcad940b38afe790fb9b", "target": 1, "func": "static uint32_t pci_unin_main_config_readl (void *opaque,\n\n                                            target_phys_addr_t addr)\n\n{\n\n    UNINState *s = opaque;\n\n    uint32_t val;\n\n\n\n    val = s->config_reg;\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n    UNIN_DPRINTF(\"config_readl addr \" TARGET_FMT_plx \" val %x\\n\", addr, val);\n\n\n\n    return val;\n\n}\n", "idx": 5928}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_dma_read_prp(NvmeCtrl *n, uint8_t *ptr, uint32_t len,\n\n    uint64_t prp1, uint64_t prp2)\n\n{\n\n    QEMUSGList qsg;\n\n    QEMUIOVector iov;\n\n    uint16_t status = NVME_SUCCESS;\n\n\n\n    if (nvme_map_prp(&qsg, &iov, prp1, prp2, len, n)) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    if (qsg.nsg > 0) {\n\n        if (dma_buf_read(ptr, len, &qsg)) {\n\n            status = NVME_INVALID_FIELD | NVME_DNR;\n\n        }\n\n        qemu_sglist_destroy(&qsg);\n\n    } else {\n\n        if (qemu_iovec_to_buf(&iov, 0, ptr, len) != len) {\n\n            status = NVME_INVALID_FIELD | NVME_DNR;\n\n        }\n\n        qemu_iovec_destroy(&iov);\n\n    }\n\n    return status;\n\n}\n", "idx": 5937}
{"project": "FFmpeg", "commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "target": 1, "func": "static int asf_read_metadata_obj(AVFormatContext *s, const GUIDParseTable *g)\n\n{\n\n    ASFContext *asf   = s->priv_data;\n\n    AVIOContext *pb   = s->pb;\n\n    uint64_t size     = avio_rl64(pb);\n\n    uint16_t nb_recs  = avio_rl16(pb); // number of records in the Description Records list\n\n    int i, ret;\n\n\n\n    for (i = 0; i < nb_recs; i++) {\n\n        uint16_t name_len, buflen, type, val_len, st_num;\n\n        uint8_t *name = NULL;\n\n\n\n        avio_skip(pb, 2); // skip reserved field\n\n        st_num   = avio_rl16(pb);\n\n        name_len = avio_rl16(pb);\n\n        buflen   = 2 * name_len + 1;\n\n        if (!name_len)\n\n            break;\n\n        type     = avio_rl16(pb);\n\n        val_len  = avio_rl32(pb);\n\n        name     = av_malloc(name_len);\n\n        if (!name)\n\n            return AVERROR(ENOMEM);\n\n        avio_get_str16le(pb, name_len, name,\n\n                         buflen);\n\n\n\n        if (!strcmp(name, \"AspectRatioX\") || !strcmp(name, \"AspectRatioY\")) {\n\n            asf_store_aspect_ratio(s, st_num, name);\n\n        } else {\n\n            if (st_num < ASF_MAX_STREAMS) {\n\n                if ((ret = process_metadata(s, name, name_len, val_len, type,\n\n                                            &asf->asf_sd[st_num].asf_met)) < 0)\n\n                    break;\n\n            } else\n\n                av_freep(&name);\n\n        }\n\n    }\n\n\n\n    align_position(pb, asf->offset, size);\n\n    return 0;\n\n}\n", "idx": 5948}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "DeviceState *i2c_create_slave(i2c_bus *bus, const char *name, uint8_t addr)\n\n{\n\n    DeviceState *dev;\n\n\n\n    dev = qdev_create(&bus->qbus, name);\n\n    qdev_prop_set_uint8(dev, \"address\", addr);\n\n    qdev_init(dev);\n\n    return dev;\n\n}\n", "idx": 5970}
{"project": "qemu", "commit_id": "92335a0d4021a3b44ccc88c9fc6c0fd2113f1882", "target": 1, "func": "static void strongarm_gpio_write(void *opaque, hwaddr offset,\n\n                                 uint64_t value, unsigned size)\n\n{\n\n    StrongARMGPIOInfo *s = opaque;\n\n\n\n    switch (offset) {\n\n    case GPDR:        /* GPIO Pin-Direction registers */\n\n        s->dir = value;\n\n        strongarm_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GPSR:        /* GPIO Pin-Output Set registers */\n\n        s->olevel |= value;\n\n        strongarm_gpio_handler_update(s);\n\n        s->gpsr = value;\n\n        break;\n\n\n\n    case GPCR:        /* GPIO Pin-Output Clear registers */\n\n        s->olevel &= ~value;\n\n        strongarm_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GRER:        /* GPIO Rising-Edge Detect Enable registers */\n\n        s->rising = value;\n\n        break;\n\n\n\n    case GFER:        /* GPIO Falling-Edge Detect Enable registers */\n\n        s->falling = value;\n\n        break;\n\n\n\n    case GAFR:        /* GPIO Alternate Function registers */\n\n        s->gafr = value;\n\n        break;\n\n\n\n    case GEDR:        /* GPIO Edge Detect Status registers */\n\n        s->status &= ~value;\n\n        strongarm_gpio_irq_update(s);\n\n        break;\n\n\n\n    default:\n\n        printf(\"%s: Bad offset 0x\" TARGET_FMT_plx \"\\n\", __func__, offset);\n\n    }\n\n}\n", "idx": 5983}
{"project": "qemu", "commit_id": "e3c9d76acc984218264bbc6435b0c09f959ed9b8", "target": 1, "func": "static int vhost_scsi_exit(DeviceState *qdev)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);\n\n    VHostSCSI *s = VHOST_SCSI(qdev);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n\n\n    /* This will stop vhost backend. */\n\n    vhost_scsi_set_status(vdev, 0);\n\n\n\n    g_free(s->dev.vqs);\n\n    return virtio_scsi_common_exit(vs);\n\n}\n", "idx": 5996}
{"project": "qemu", "commit_id": "2d9907a3332888e43bc73fe9b98a32f8de662526", "target": 0, "func": "void pmac_format_nvram_partition (MacIONVRAMState *nvr, int len)\n\n{\n\n    unsigned int i;\n\n    uint32_t start = 0, end;\n\n    struct OpenBIOS_nvpart_v1 *part_header;\n\n\n\n    // OpenBIOS nvram variables\n\n    // Variable partition\n\n    part_header = (struct OpenBIOS_nvpart_v1 *)nvr->data;\n\n    part_header->signature = OPENBIOS_PART_SYSTEM;\n\n    pstrcpy(part_header->name, sizeof(part_header->name), \"system\");\n\n\n\n    end = start + sizeof(struct OpenBIOS_nvpart_v1);\n\n    for (i = 0; i < nb_prom_envs; i++)\n\n        end = OpenBIOS_set_var(nvr->data, end, prom_envs[i]);\n\n\n\n    // End marker\n\n    nvr->data[end++] = '\\0';\n\n\n\n    end = start + ((end - start + 15) & ~15);\n\n    /* XXX: OpenBIOS is not able to grow up a partition. Leave some space for\n\n       new variables. */\n\n    if (end < DEF_SYSTEM_SIZE)\n\n        end = DEF_SYSTEM_SIZE;\n\n    OpenBIOS_finish_partition(part_header, end - start);\n\n\n\n    // free partition\n\n    start = end;\n\n    part_header = (struct OpenBIOS_nvpart_v1 *)&nvr->data[start];\n\n    part_header->signature = OPENBIOS_PART_FREE;\n\n    pstrcpy(part_header->name, sizeof(part_header->name), \"free\");\n\n\n\n    end = len;\n\n    OpenBIOS_finish_partition(part_header, end - start);\n\n}\n", "idx": 6005}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_slq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_new();\n\n    tcg_gen_andi_tl(t1, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_shl_tl(t0, cpu_gpr[rS(ctx->opcode)], t1);\n\n    tcg_gen_subfi_tl(t1, 32, t1);\n\n    tcg_gen_shr_tl(t1, cpu_gpr[rS(ctx->opcode)], t1);\n\n    tcg_gen_or_tl(t1, t0, t1);\n\n    gen_store_spr(SPR_MQ, t1);\n\n    tcg_gen_andi_tl(t1, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_mov_tl(cpu_gpr[rA(ctx->opcode)], t0);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n    tcg_gen_movi_tl(cpu_gpr[rA(ctx->opcode)], 0);\n\n    gen_set_label(l1);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 6012}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "vmxnet3_pop_rxc_descr(VMXNET3State *s, int qidx, uint32_t *descr_gen)\n\n{\n\n    uint8_t ring_gen;\n\n    struct Vmxnet3_RxCompDesc rxcd;\n\n\n\n    hwaddr daddr =\n\n        vmxnet3_ring_curr_cell_pa(&s->rxq_descr[qidx].comp_ring);\n\n\n\n    pci_dma_read(PCI_DEVICE(s), daddr,\n\n                 &rxcd, sizeof(struct Vmxnet3_RxCompDesc));\n\n\n\n    ring_gen = vmxnet3_ring_curr_gen(&s->rxq_descr[qidx].comp_ring);\n\n\n\n    if (rxcd.gen != ring_gen) {\n\n        *descr_gen = ring_gen;\n\n        vmxnet3_inc_rx_completion_counter(s, qidx);\n\n        return daddr;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6027}
{"project": "FFmpeg", "commit_id": "6bed20f45a484f5709fec4c97a238240161b1797", "target": 0, "func": "matroska_parse_blockgroup (MatroskaDemuxContext *matroska,\n\n                           uint64_t              cluster_time)\n\n{\n\n    int res = 0;\n\n    uint32_t id;\n\n    AVPacket *pkt = NULL;\n\n    int is_keyframe = PKT_FLAG_KEY, last_num_packets = matroska->num_packets;\n\n    uint64_t duration = AV_NOPTS_VALUE;\n\n    int track = -1;\n\n    uint8_t *data;\n\n    int size = 0;\n\n    int64_t pos = 0;\n\n\n\n    av_log(matroska->ctx, AV_LOG_DEBUG, \"parsing blockgroup...\\n\");\n\n\n\n    while (res == 0) {\n\n        if (!(id = ebml_peek_id(matroska, &matroska->level_up))) {\n\n            res = AVERROR_IO;\n\n            break;\n\n        } else if (matroska->level_up) {\n\n            matroska->level_up--;\n\n            break;\n\n        }\n\n\n\n        switch (id) {\n\n            /* one block inside the group. Note, block parsing is one\n\n             * of the harder things, so this code is a bit complicated.\n\n             * See http://www.matroska.org/ for documentation. */\n\n            case MATROSKA_ID_BLOCK: {\n\n                pos = url_ftell(&matroska->ctx->pb);\n\n                res = ebml_read_binary(matroska, &id, &data, &size);\n\n                break;\n\n            }\n\n\n\n            case MATROSKA_ID_BLOCKDURATION: {\n\n                if ((res = ebml_read_uint(matroska, &id, &duration)) < 0)\n\n                    break;\n\n                break;\n\n            }\n\n\n\n            case MATROSKA_ID_BLOCKREFERENCE:\n\n                /* We've found a reference, so not even the first frame in\n\n                 * the lace is a key frame. */\n\n                is_keyframe = 0;\n\n                if (last_num_packets != matroska->num_packets)\n\n                    matroska->packets[last_num_packets]->flags = 0;\n\n                res = ebml_read_skip(matroska);\n\n                break;\n\n\n\n            default:\n\n                av_log(matroska->ctx, AV_LOG_INFO,\n\n                       \"Unknown entry 0x%x in blockgroup data\\n\", id);\n\n                /* fall-through */\n\n\n\n            case EBML_ID_VOID:\n\n                res = ebml_read_skip(matroska);\n\n                break;\n\n        }\n\n\n\n        if (matroska->level_up) {\n\n            matroska->level_up--;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (res)\n\n        return res;\n\n\n\n    if (size > 0)\n\n        res = matroska_parse_block(matroska, data, size, pos, cluster_time,\n\n                                   is_keyframe, &track, &pkt);\n\n\n\n    if (pkt)\n\n    {\n\n        if (duration != AV_NOPTS_VALUE)\n\n            pkt->duration = duration;\n\n        else if (track >= 0 && track < matroska->num_tracks)\n\n            pkt->duration = matroska->tracks[track]->default_duration / matroska->time_scale;\n\n    }\n\n\n\n    return res;\n\n}\n", "idx": 6040}
{"project": "qemu", "commit_id": "51941e4695c6f6c1f786bacef7e8c3a477570e04", "target": 0, "func": "void vncws_tls_handshake_peek(void *opaque)\n\n{\n\n    VncState *vs = opaque;\n\n    long ret;\n\n\n\n    if (!vs->ws_tls.session) {\n\n        char peek[4];\n\n        ret = qemu_recv(vs->csock, peek, sizeof(peek), MSG_PEEK);\n\n        if (ret && (strncmp(peek, \"\\x16\", 1) == 0\n\n                    || strncmp(peek, \"\\x80\", 1) == 0)) {\n\n            VNC_DEBUG(\"TLS Websocket connection recognized\");\n\n            vnc_tls_client_setup(vs, 1);\n\n            vncws_start_tls_handshake(vs);\n\n        } else {\n\n            vncws_handshake_read(vs);\n\n        }\n\n    } else {\n\n        qemu_set_fd_handler2(vs->csock, NULL, vncws_handshake_read, NULL, vs);\n\n    }\n\n}\n", "idx": 6047}
{"project": "qemu", "commit_id": "dd941cdcfec536aad6a310a153778142ed9f3e92", "target": 0, "func": "bool check_hw_breakpoints(CPUX86State *env, bool force_dr6_update)\n\n{\n\n    target_ulong dr6;\n\n    int reg;\n\n    bool hit_enabled = false;\n\n\n\n    dr6 = env->dr[6] & ~0xf;\n\n    for (reg = 0; reg < DR7_MAX_BP; reg++) {\n\n        bool bp_match = false;\n\n        bool wp_match = false;\n\n\n\n        switch (hw_breakpoint_type(env->dr[7], reg)) {\n\n        case DR7_TYPE_BP_INST:\n\n            if (env->dr[reg] == env->eip) {\n\n                bp_match = true;\n\n            }\n\n            break;\n\n        case DR7_TYPE_DATA_WR:\n\n        case DR7_TYPE_DATA_RW:\n\n            if (env->cpu_watchpoint[reg] &&\n\n                env->cpu_watchpoint[reg]->flags & BP_WATCHPOINT_HIT) {\n\n                wp_match = true;\n\n            }\n\n            break;\n\n        case DR7_TYPE_IO_RW:\n\n            break;\n\n        }\n\n        if (bp_match || wp_match) {\n\n            dr6 |= 1 << reg;\n\n            if (hw_breakpoint_enabled(env->dr[7], reg)) {\n\n                hit_enabled = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (hit_enabled || force_dr6_update) {\n\n        env->dr[6] = dr6;\n\n    }\n\n\n\n    return hit_enabled;\n\n}\n", "idx": 6053}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0x7(IpvideoContext *s)\n\n{\n\n    int x, y;\n\n    unsigned char P[2];\n\n    unsigned int flags;\n\n\n\n    /* 2-color encoding */\n\n    CHECK_STREAM_PTR(2);\n\n\n\n    P[0] = *s->stream_ptr++;\n\n    P[1] = *s->stream_ptr++;\n\n\n\n    if (P[0] <= P[1]) {\n\n\n\n        /* need 8 more bytes from the stream */\n\n        CHECK_STREAM_PTR(8);\n\n\n\n        for (y = 0; y < 8; y++) {\n\n            flags = *s->stream_ptr++ | 0x100;\n\n            for (; flags != 1; flags >>= 1)\n\n                *s->pixel_ptr++ = P[flags & 1];\n\n            s->pixel_ptr += s->line_inc;\n\n        }\n\n\n\n    } else {\n\n\n\n        /* need 2 more bytes from the stream */\n\n        CHECK_STREAM_PTR(2);\n\n\n\n        flags = bytestream_get_le16(&s->stream_ptr);\n\n        for (y = 0; y < 8; y += 2) {\n\n            for (x = 0; x < 8; x += 2, flags >>= 1) {\n\n                s->pixel_ptr[x                ] =\n\n                s->pixel_ptr[x + 1            ] =\n\n                s->pixel_ptr[x +     s->stride] =\n\n                s->pixel_ptr[x + 1 + s->stride] = P[flags & 1];\n\n            }\n\n            s->pixel_ptr += s->stride * 2;\n\n        }\n\n    }\n\n\n\n    /* report success */\n\n    return 0;\n\n}\n", "idx": 6059}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "void arm_translate_init(void)\n\n{\n\n    cpu_env = tcg_global_reg_new(TCG_TYPE_PTR, TCG_AREG0, \"env\");\n\n\n\n    cpu_T[0] = tcg_global_reg_new(TCG_TYPE_I32, TCG_AREG1, \"T0\");\n\n    cpu_T[1] = tcg_global_reg_new(TCG_TYPE_I32, TCG_AREG2, \"T1\");\n\n}\n", "idx": 6072}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "void virtio_9p_push_and_notify(V9fsPDU *pdu)\n\n{\n\n    V9fsState *s = pdu->s;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = &v->elems[pdu->idx];\n\n\n\n    /* push onto queue and notify */\n\n    virtqueue_push(v->vq, elem, pdu->size);\n\n\n\n    /* FIXME: we should batch these completions */\n\n    virtio_notify(VIRTIO_DEVICE(v), v->vq);\n\n}\n", "idx": 6074}
{"project": "qemu", "commit_id": "2b147555f78c3c20080b201fd1506467fa0ddf43", "target": 0, "func": "static int kvm_s390_check_clear_cmma(KVMState *s)\n\n{\n\n    struct kvm_device_attr attr = {\n\n        .group = KVM_S390_VM_MEM_CTRL,\n\n        .attr = KVM_S390_VM_MEM_CLR_CMMA,\n\n    };\n\n\n\n    return kvm_vm_ioctl(s, KVM_HAS_DEVICE_ATTR, &attr);\n\n}\n", "idx": 6087}
{"project": "qemu", "commit_id": "7e486f7577764a07aa35588e119903c80a5c30a2", "target": 1, "func": "static inline uint32_t vmsvga_fifo_read_raw(struct vmsvga_state_s *s)\n\n{\n\n    uint32_t cmd = s->fifo[CMD(stop) >> 2];\n\n\n\n    s->cmd->stop = cpu_to_le32(CMD(stop) + 4);\n\n    if (CMD(stop) >= CMD(max)) {\n\n        s->cmd->stop = s->cmd->min;\n\n    }\n\n    return cmd;\n\n}\n", "idx": 6107}
{"project": "FFmpeg", "commit_id": "16c91d2b233fe04697ba8f7ab6d1bad12a4ad69f", "target": 0, "func": "static void do_rematrixing(AC3DecodeContext *s)\n\n{\n\n    int bnd, i;\n\n    int end, bndend;\n\n    int tmp0, tmp1;\n\n\n\n    end = FFMIN(s->end_freq[1], s->end_freq[2]);\n\n\n\n    for(bnd=0; bnd<s->num_rematrixing_bands; bnd++) {\n\n        if(s->rematrixing_flags[bnd]) {\n\n            bndend = FFMIN(end, ff_ac3_rematrix_band_tab[bnd+1]);\n\n            for(i=ff_ac3_rematrix_band_tab[bnd]; i<bndend; i++) {\n\n                tmp0 = s->fixed_coeffs[1][i];\n\n                tmp1 = s->fixed_coeffs[2][i];\n\n                s->fixed_coeffs[1][i] = tmp0 + tmp1;\n\n                s->fixed_coeffs[2][i] = tmp0 - tmp1;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 6129}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void dead_tmp(TCGv tmp)\n\n{\n\n    tcg_temp_free(tmp);\n\n    num_temps--;\n\n}\n", "idx": 6133}
{"project": "qemu", "commit_id": "3ac216270a62418519c08e88c17005a8f1539cf2", "target": 1, "func": "int bdrv_has_zero_init(BlockDriverState *bs)\n\n{\n\n    assert(bs->drv);\n\n\n\n    if (bs->drv->bdrv_has_zero_init) {\n\n        return bs->drv->bdrv_has_zero_init(bs);\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 6153}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_mux(CharDriverState *drv)\n\n{\n\n    CharDriverState *chr;\n\n    MuxDriver *d;\n\n\n\n    chr = qemu_chr_alloc();\n\n    d = g_malloc0(sizeof(MuxDriver));\n\n\n\n    chr->opaque = d;\n\n    d->drv = drv;\n\n    d->focus = -1;\n\n    chr->chr_write = mux_chr_write;\n\n    chr->chr_update_read_handler = mux_chr_update_read_handler;\n\n    chr->chr_accept_input = mux_chr_accept_input;\n\n    /* Frontend guest-open / -close notification is not support with muxes */\n\n    chr->chr_set_fe_open = NULL;\n\n    if (drv->chr_add_watch) {\n\n        chr->chr_add_watch = mux_chr_add_watch;\n\n    }\n\n    /* only default to opened state if we've realized the initial\n\n     * set of muxes\n\n     */\n\n    chr->explicit_be_open = muxes_realized ? 0 : 1;\n\n    chr->is_mux = 1;\n\n\n\n    return chr;\n\n}\n", "idx": 6155}
{"project": "qemu", "commit_id": "d3b12f5dec4b27ebab58fb5797cb67bacced773b", "target": 0, "func": "static void dummy_event_handler(void *opaque)\n\n{\n\n}\n", "idx": 6185}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void cpu_watchpoint_remove_by_ref(CPUState *env, CPUWatchpoint *watchpoint)\n\n{\n\n    TAILQ_REMOVE(&env->watchpoints, watchpoint, entry);\n\n\n\n    tlb_flush_page(env, watchpoint->vaddr);\n\n\n\n    qemu_free(watchpoint);\n\n}\n", "idx": 6197}
{"project": "qemu", "commit_id": "80ac2390358c906215a849670ca5b7a3d1d112a3", "target": 0, "func": "void armv7m_nvic_set_pending(void *opaque, int irq, bool secure)\n\n{\n\n    NVICState *s = (NVICState *)opaque;\n\n    bool banked = exc_is_banked(irq);\n\n    VecInfo *vec;\n\n\n\n    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);\n\n    assert(!secure || banked);\n\n\n\n    vec = (banked && secure) ? &s->sec_vectors[irq] : &s->vectors[irq];\n\n\n\n    trace_nvic_set_pending(irq, secure, vec->enabled, vec->prio);\n\n\n\n    if (irq >= ARMV7M_EXCP_HARD && irq < ARMV7M_EXCP_PENDSV) {\n\n        /* If a synchronous exception is pending then it may be\n\n         * escalated to HardFault if:\n\n         *  * it is equal or lower priority to current execution\n\n         *  * it is disabled\n\n         * (ie we need to take it immediately but we can't do so).\n\n         * Asynchronous exceptions (and interrupts) simply remain pending.\n\n         *\n\n         * For QEMU, we don't have any imprecise (asynchronous) faults,\n\n         * so we can assume that PREFETCH_ABORT and DATA_ABORT are always\n\n         * synchronous.\n\n         * Debug exceptions are awkward because only Debug exceptions\n\n         * resulting from the BKPT instruction should be escalated,\n\n         * but we don't currently implement any Debug exceptions other\n\n         * than those that result from BKPT, so we treat all debug exceptions\n\n         * as needing escalation.\n\n         *\n\n         * This all means we can identify whether to escalate based only on\n\n         * the exception number and don't (yet) need the caller to explicitly\n\n         * tell us whether this exception is synchronous or not.\n\n         */\n\n        int running = nvic_exec_prio(s);\n\n        bool escalate = false;\n\n\n\n        if (vec->prio >= running) {\n\n            trace_nvic_escalate_prio(irq, vec->prio, running);\n\n            escalate = true;\n\n        } else if (!vec->enabled) {\n\n            trace_nvic_escalate_disabled(irq);\n\n            escalate = true;\n\n        }\n\n\n\n        if (escalate) {\n\n            if (running < 0) {\n\n                /* We want to escalate to HardFault but we can't take a\n\n                 * synchronous HardFault at this point either. This is a\n\n                 * Lockup condition due to a guest bug. We don't model\n\n                 * Lockup, so report via cpu_abort() instead.\n\n                 */\n\n                cpu_abort(&s->cpu->parent_obj,\n\n                          \"Lockup: can't escalate %d to HardFault \"\n\n                          \"(current priority %d)\\n\", irq, running);\n\n            }\n\n\n\n            /* We can do the escalation, so we take HardFault instead.\n\n             * If BFHFNMINS is set then we escalate to the banked HF for\n\n             * the target security state of the original exception; otherwise\n\n             * we take a Secure HardFault.\n\n             */\n\n            irq = ARMV7M_EXCP_HARD;\n\n            if (arm_feature(&s->cpu->env, ARM_FEATURE_M_SECURITY) &&\n\n                (secure ||\n\n                 !(s->cpu->env.v7m.aircr & R_V7M_AIRCR_BFHFNMINS_MASK))) {\n\n                vec = &s->sec_vectors[irq];\n\n            } else {\n\n                vec = &s->vectors[irq];\n\n            }\n\n            /* HF may be banked but there is only one shared HFSR */\n\n            s->cpu->env.v7m.hfsr |= R_V7M_HFSR_FORCED_MASK;\n\n        }\n\n    }\n\n\n\n    if (!vec->pending) {\n\n        vec->pending = 1;\n\n        nvic_irq_update(s);\n\n    }\n\n}\n", "idx": 6198}
{"project": "qemu", "commit_id": "b40acf99bef69fa8ab0f9092ff162fde945eec12", "target": 0, "func": "void portio_list_init(PortioList *piolist,\n\n                      const MemoryRegionPortio *callbacks,\n\n                      void *opaque, const char *name)\n\n{\n\n    unsigned n = 0;\n\n\n\n    while (callbacks[n].size) {\n\n        ++n;\n\n    }\n\n\n\n    piolist->ports = callbacks;\n\n    piolist->nr = 0;\n\n    piolist->regions = g_new0(MemoryRegion *, n);\n\n    piolist->aliases = g_new0(MemoryRegion *, n);\n\n    piolist->address_space = NULL;\n\n    piolist->opaque = opaque;\n\n    piolist->name = name;\n\n}\n", "idx": 6199}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtsr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    t0 = tcg_const_tl(SR(ctx->opcode));\n\n    gen_helper_store_sr(cpu_env, t0, cpu_gpr[rS(ctx->opcode)]);\n\n    tcg_temp_free(t0);\n\n#endif\n\n}\n", "idx": 6207}
{"project": "qemu", "commit_id": "36cccb8c575b74a691f685911fbb0301af19f924", "target": 1, "func": "static void device_initfn(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    ObjectClass *class;\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        dev->hotplugged = 1;\n\n        qdev_hot_added = true;\n\n    }\n\n\n\n    dev->instance_id_alias = -1;\n\n    dev->realized = false;\n\n\n\n    object_property_add_bool(obj, \"realized\",\n\n                             device_get_realized, device_set_realized, NULL);\n\n    object_property_add_bool(obj, \"hotpluggable\",\n\n                             device_get_hotpluggable, NULL, NULL);\n\n    object_property_add_bool(obj, \"hotplugged\",\n\n                             device_get_hotplugged, device_set_hotplugged,\n\n                             &error_abort);\n\n\n\n    class = object_get_class(OBJECT(dev));\n\n    do {\n\n        for (prop = DEVICE_CLASS(class)->props; prop && prop->name; prop++) {\n\n            qdev_property_add_legacy(dev, prop, &error_abort);\n\n            qdev_property_add_static(dev, prop, &error_abort);\n\n        }\n\n        class = object_class_get_parent(class);\n\n    } while (class != object_class_by_name(TYPE_DEVICE));\n\n\n\n    object_property_add_link(OBJECT(dev), \"parent_bus\", TYPE_BUS,\n\n                             (Object **)&dev->parent_bus, NULL, 0,\n\n                             &error_abort);\n\n    QLIST_INIT(&dev->gpios);\n\n}\n", "idx": 6275}
{"project": "qemu", "commit_id": "a8cf66bb393ff420d40ae172a4c817bf2752918a", "target": 0, "func": "static inline void cris_update_result(DisasContext *dc, TCGv res)\n\n{\n\n\tif (dc->update_cc) {\n\n\t\tif (dc->cc_size == 4 && \n\n\t\t    (dc->cc_op == CC_OP_SUB\n\n\t\t     || dc->cc_op == CC_OP_ADD))\n\n\t\t\treturn;\n\n\t\ttcg_gen_mov_tl(cc_result, res);\n\n\t}\n\n}\n", "idx": 6286}
{"project": "qemu", "commit_id": "6d21e4208f382dd8ca1f7995a6dd9ea7ca281163", "target": 0, "func": "static inline TranslationBlock *tb_find_fast(CPUState *cpu,\n\n                                             TranslationBlock *last_tb,\n\n                                             int tb_exit)\n\n{\n\n    CPUArchState *env = (CPUArchState *)cpu->env_ptr;\n\n    TranslationBlock *tb;\n\n    target_ulong cs_base, pc;\n\n    uint32_t flags;\n\n\n\n    /* we record a subset of the CPU state. It will\n\n       always be the same before a given translated block\n\n       is executed. */\n\n    cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n\n    tb_lock();\n\n    tb = atomic_rcu_read(&cpu->tb_jmp_cache[tb_jmp_cache_hash_func(pc)]);\n\n    if (unlikely(!tb || tb->pc != pc || tb->cs_base != cs_base ||\n\n                 tb->flags != flags)) {\n\n        tb = tb_find_slow(cpu, pc, cs_base, flags);\n\n    }\n\n#ifndef CONFIG_USER_ONLY\n\n    /* We don't take care of direct jumps when address mapping changes in\n\n     * system emulation. So it's not safe to make a direct jump to a TB\n\n     * spanning two pages because the mapping for the second page can change.\n\n     */\n\n    if (tb->page_addr[1] != -1) {\n\n        last_tb = NULL;\n\n    }\n\n#endif\n\n    /* See if we can patch the calling TB. */\n\n    if (last_tb && !qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) {\n\n        /* Check if translation buffer has been flushed */\n\n        if (cpu->tb_flushed) {\n\n            cpu->tb_flushed = false;\n\n        } else {\n\n            tb_add_jump(last_tb, tb_exit, tb);\n\n        }\n\n    }\n\n    tb_unlock();\n\n    return tb;\n\n}\n", "idx": 6287}
{"project": "qemu", "commit_id": "80cba1b71eb9a75404d1effddec8ffa9f0d6d6fb", "target": 1, "func": "static int proxy_init(FsContext *ctx)\n\n{\n\n    V9fsProxy *proxy = g_malloc(sizeof(V9fsProxy));\n\n    int sock_id;\n\n\n\n    if (ctx->export_flags & V9FS_PROXY_SOCK_NAME) {\n\n        sock_id = connect_namedsocket(ctx->fs_root);\n\n    } else {\n\n        sock_id = atoi(ctx->fs_root);\n\n        if (sock_id < 0) {\n\n            fprintf(stderr, \"socket descriptor not initialized\\n\");\n\n\n            return -1;\n\n        }\n\n    }\n\n    g_free(ctx->fs_root);\n\n\n\n\n    proxy->in_iovec.iov_base  = g_malloc(PROXY_MAX_IO_SZ + PROXY_HDR_SZ);\n\n    proxy->in_iovec.iov_len   = PROXY_MAX_IO_SZ + PROXY_HDR_SZ;\n\n    proxy->out_iovec.iov_base = g_malloc(PROXY_MAX_IO_SZ + PROXY_HDR_SZ);\n\n    proxy->out_iovec.iov_len  = PROXY_MAX_IO_SZ + PROXY_HDR_SZ;\n\n\n\n    ctx->private = proxy;\n\n    proxy->sockfd = sock_id;\n\n    qemu_mutex_init(&proxy->mutex);\n\n\n\n    ctx->export_flags |= V9FS_PATHNAME_FSCONTEXT;\n\n    ctx->exops.get_st_gen = proxy_ioc_getversion;\n\n    return 0;\n\n}", "idx": 6308}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "int kvm_arch_init(MachineState *ms, KVMState *s)\n\n{\n\n    MachineClass *mc = MACHINE_GET_CLASS(ms);\n\n\n\n    mc->default_cpu_type = S390_CPU_TYPE_NAME(\"host\");\n\n    cap_sync_regs = kvm_check_extension(s, KVM_CAP_SYNC_REGS);\n\n    cap_async_pf = kvm_check_extension(s, KVM_CAP_ASYNC_PF);\n\n    cap_mem_op = kvm_check_extension(s, KVM_CAP_S390_MEM_OP);\n\n    cap_s390_irq = kvm_check_extension(s, KVM_CAP_S390_INJECT_IRQ);\n\n\n\n    if (!kvm_check_extension(s, KVM_CAP_S390_GMAP)\n\n        || !kvm_check_extension(s, KVM_CAP_S390_COW)) {\n\n        phys_mem_set_alloc(legacy_s390_alloc);\n\n    }\n\n\n\n    kvm_vm_enable_cap(s, KVM_CAP_S390_USER_SIGP, 0);\n\n    kvm_vm_enable_cap(s, KVM_CAP_S390_VECTOR_REGISTERS, 0);\n\n    kvm_vm_enable_cap(s, KVM_CAP_S390_USER_STSI, 0);\n\n    if (ri_allowed()) {\n\n        if (kvm_vm_enable_cap(s, KVM_CAP_S390_RI, 0) == 0) {\n\n            cap_ri = 1;\n\n        }\n\n    }\n\n    if (gs_allowed()) {\n\n        if (kvm_vm_enable_cap(s, KVM_CAP_S390_GS, 0) == 0) {\n\n            cap_gs = 1;\n\n        }\n\n    }\n\n\n\n    /*\n\n     * The migration interface for ais was introduced with kernel 4.13\n\n     * but the capability itself had been active since 4.12. As migration\n\n     * support is considered necessary let's disable ais in the 2.10\n\n     * machine.\n\n     */\n\n    /* kvm_vm_enable_cap(s, KVM_CAP_S390_AIS, 0); */\n\n\n\n    return 0;\n\n}\n", "idx": 6314}
{"project": "qemu", "commit_id": "366d4f7e0007a5540897fbac6e377c57d8c79a73", "target": 1, "func": "static void cg3_reg_write(void *opaque, hwaddr addr, uint64_t val,\n\n                          unsigned size)\n\n{\n\n    CG3State *s = opaque;\n\n    uint8_t regval;\n\n    int i;\n\n\n\n    DPRINTF(\"write %\" PRIx64 \" to reg %\" HWADDR_PRIx \" size %d\\n\",\n\n            val, addr, size);\n\n\n\n    switch (addr) {\n\n    case CG3_REG_BT458_ADDR:\n\n        s->dac_index = val;\n\n        s->dac_state = 0;\n\n        break;\n\n    case CG3_REG_BT458_COLMAP:\n\n        /* This register can be written to as either a long word or a byte */\n\n        if (size == 1) {\n\n            val <<= 24;\n\n        }\n\n\n\n        for (i = 0; i < size; i++) {\n\n            regval = val >> 24;\n\n\n\n            switch (s->dac_state) {\n\n            case 0:\n\n                s->r[s->dac_index] = regval;\n\n                s->dac_state++;\n\n                break;\n\n            case 1:\n\n                s->g[s->dac_index] = regval;\n\n                s->dac_state++;\n\n                break;\n\n            case 2:\n\n                s->b[s->dac_index] = regval;\n\n                /* Index autoincrement */\n\n                s->dac_index = (s->dac_index + 1) & 0xff;\n\n            default:\n\n                s->dac_state = 0;\n\n                break;\n\n            }\n\n            val <<= 8;\n\n        }\n\n        s->full_update = 1;\n\n        break;\n\n    case CG3_REG_FBC_CTRL:\n\n        s->regs[0] = val;\n\n        break;\n\n    case CG3_REG_FBC_STATUS:\n\n        if (s->regs[1] & CG3_SR_PENDING_INT) {\n\n            /* clear interrupt */\n\n            s->regs[1] &= ~CG3_SR_PENDING_INT;\n\n            qemu_irq_lower(s->irq);\n\n        }\n\n        break;\n\n    case CG3_REG_FBC_CURSTART ... CG3_REG_SIZE:\n\n        s->regs[addr - 0x10] = val;\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_UNIMP,\n\n                  \"cg3: Unimplemented register write \"\n\n                  \"reg 0x%\" HWADDR_PRIx \" size 0x%x value 0x%\" PRIx64 \"\\n\",\n\n                  addr, size, val);\n\n        break;\n\n    }\n\n}\n", "idx": 6339}
{"project": "qemu", "commit_id": "c5825ac6c861bfe1a4adfa27517931b56079e298", "target": 1, "func": "static void qxl_dirty_surfaces(PCIQXLDevice *qxl)\n\n{\n\n    intptr_t vram_start;\n\n    int i;\n\n\n\n    if (qxl->mode != QXL_MODE_NATIVE && qxl->mode != QXL_MODE_COMPAT) {\n\n        return;\n\n    }\n\n\n\n    /* dirty the primary surface */\n\n    qxl_set_dirty(&qxl->vga.vram, qxl->shadow_rom.draw_area_offset,\n\n                  qxl->shadow_rom.surface0_area_size);\n\n\n\n    vram_start =  (intptr_t)memory_region_get_ram_ptr(&qxl->vram_bar);\n\n\n\n    /* dirty the off-screen surfaces */\n\n    for (i = 0; i < qxl->ssd.num_surfaces; i++) {\n\n        QXLSurfaceCmd *cmd;\n\n        intptr_t surface_offset;\n\n        int surface_size;\n\n\n\n        if (qxl->guest_surfaces.cmds[i] == 0) {\n\n            continue;\n\n        }\n\n\n\n        cmd = qxl_phys2virt(qxl, qxl->guest_surfaces.cmds[i],\n\n                            MEMSLOT_GROUP_GUEST);\n\n        assert(cmd);\n\n        assert(cmd->type == QXL_SURFACE_CMD_CREATE);\n\n        surface_offset = (intptr_t)qxl_phys2virt(qxl,\n\n                                                 cmd->u.surface_create.data,\n\n                                                 MEMSLOT_GROUP_GUEST);\n\n        assert(surface_offset);\n\n        surface_offset -= vram_start;\n\n        surface_size = cmd->u.surface_create.height *\n\n                       abs(cmd->u.surface_create.stride);\n\n        trace_qxl_surfaces_dirty(qxl->id, i, (int)surface_offset, surface_size);\n\n        qxl_set_dirty(&qxl->vram_bar, surface_offset, surface_size);\n\n    }\n\n}\n", "idx": 6352}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void a9_scu_write(void *opaque, target_phys_addr_t offset,\n\n                         uint64_t value, unsigned size)\n\n{\n\n    a9mp_priv_state *s = (a9mp_priv_state *)opaque;\n\n    uint32_t mask;\n\n    uint32_t shift;\n\n    switch (size) {\n\n    case 1:\n\n        mask = 0xff;\n\n        break;\n\n    case 2:\n\n        mask = 0xffff;\n\n        break;\n\n    case 4:\n\n        mask = 0xffffffff;\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"Invalid size %u in write to a9 scu register %x\\n\",\n\n                size, (unsigned)offset);\n\n        return;\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00: /* Control */\n\n        s->scu_control = value & 1;\n\n        break;\n\n    case 0x4: /* Configuration: RO */\n\n        break;\n\n    case 0x08: case 0x09: case 0x0A: case 0x0B: /* Power Control */\n\n        shift = (offset - 0x8) * 8;\n\n        s->scu_status &= ~(mask << shift);\n\n        s->scu_status |= ((value & mask) << shift);\n\n        break;\n\n    case 0x0c: /* Invalidate All Registers In Secure State */\n\n        /* no-op as we do not implement caches */\n\n        break;\n\n    case 0x40: /* Filtering Start Address Register */\n\n    case 0x44: /* Filtering End Address Register */\n\n        /* RAZ/WI, like an implementation with only one AXI master */\n\n        break;\n\n    case 0x50: /* SCU Access Control Register */\n\n    case 0x54: /* SCU Non-secure Access Control Register */\n\n        /* unimplemented, fall through */\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 6401}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void s390_virtio_net_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtIOS390DeviceClass *k = VIRTIO_S390_DEVICE_CLASS(klass);\n\n\n\n    k->init = s390_virtio_net_init;\n\n    dc->props = s390_virtio_net_properties;\n\n    dc->alias = \"virtio-net\";\n\n}\n", "idx": 6404}
{"project": "FFmpeg", "commit_id": "9d87374ec0f382c8394ad511243db6980afa42af", "target": 0, "func": "static void hb_synthesis(AMRWBContext *ctx, int subframe, float *samples,\n\n                         const float *exc, const float *isf, const float *isf_past)\n\n{\n\n    float hb_lpc[LP_ORDER_16k];\n\n    enum Mode mode = ctx->fr_cur_mode;\n\n\n\n    if (mode == MODE_6k60) {\n\n        float e_isf[LP_ORDER_16k]; // ISF vector for extrapolation\n\n        double e_isp[LP_ORDER_16k];\n\n\n\n        ff_weighted_vector_sumf(e_isf, isf_past, isf, isfp_inter[subframe],\n\n                                1.0 - isfp_inter[subframe], LP_ORDER);\n\n\n\n        extrapolate_isf(e_isf, e_isf);\n\n\n\n        e_isf[LP_ORDER_16k - 1] *= 2.0;\n\n        ff_acelp_lsf2lspd(e_isp, e_isf, LP_ORDER_16k);\n\n        ff_amrwb_lsp2lpc(e_isp, hb_lpc, LP_ORDER_16k);\n\n\n\n        lpc_weighting(hb_lpc, hb_lpc, 0.9, LP_ORDER_16k);\n\n    } else {\n\n        lpc_weighting(hb_lpc, ctx->lp_coef[subframe], 0.6, LP_ORDER);\n\n    }\n\n\n\n    ff_celp_lp_synthesis_filterf(samples, hb_lpc, exc, AMRWB_SFR_SIZE_16k,\n\n                                 (mode == MODE_6k60) ? LP_ORDER_16k : LP_ORDER);\n\n}\n", "idx": 6409}
{"project": "qemu", "commit_id": "24f3902b088cd4f2dbebfd90527b5d81d6a050e9", "target": 1, "func": "static int qemu_savevm_state(QEMUFile *f, Error **errp)\n\n{\n\n    int ret;\n\n    MigrationParams params = {\n\n        .blk = 0,\n\n        .shared = 0\n\n    };\n\n    MigrationState *ms = migrate_init(&params);\n\n    ms->to_dst_file = f;\n\n\n\n    if (qemu_savevm_state_blocked(errp)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    qemu_savevm_state_header(f);\n\n    qemu_savevm_state_begin(f, &params);\n\n    qemu_mutex_lock_iothread();\n\n\n\n    while (qemu_file_get_error(f) == 0) {\n\n        if (qemu_savevm_state_iterate(f, false) > 0) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    ret = qemu_file_get_error(f);\n\n    if (ret == 0) {\n\n        qemu_savevm_state_complete_precopy(f, false);\n\n        ret = qemu_file_get_error(f);\n\n    }\n\n    qemu_savevm_state_cleanup();\n\n    if (ret != 0) {\n\n        error_setg_errno(errp, -ret, \"Error while writing VM state\");\n\n    }\n\n    return ret;\n\n}\n", "idx": 6425}
{"project": "FFmpeg", "commit_id": "c619ff6daf93a8f3c03decf2d3345d2474c3db91", "target": 0, "func": "static always_inline void dv_set_class_number(DCTELEM* blk, EncBlockInfo* bi, \n\n                                              const uint8_t* zigzag_scan, int bias)\n\n{\n\n    int i, area;\n\n    int run;\n\n    int classes[] = {12, 24, 36, 0xffff};\n\n\n\n    run = 0;\n\n    bi->mb[0] = blk[0]; \n\n    bi->cno = 0;\n\n    for (area = 0; area < 4; area++) {\n\n       bi->prev_run[area] = run;\n\n       bi->bit_size[area] = 0;\n\n       for (i=mb_area_start[area]; i<mb_area_start[area+1]; i++) {\n\n          bi->mb[i] = (blk[zigzag_scan[i]] / 16);\n\n          while ((bi->mb[i] ^ (bi->mb[i] >> 8)) > classes[bi->cno])\n\n              bi->cno++;\n\n       \n\n          if (bi->mb[i]) {\n\n              bi->bit_size[area] += dv_rl2vlc_size(run, bi->mb[i]);\n\n\t      run = 0;\n\n          } else\n\n              ++run;\n\n       }\n\n    }\n\n    bi->bit_size[3] += 4; /* EOB marker */\n\n    bi->cno += bias;\n\n    \n\n    if (bi->cno >= 3) { /* FIXME: we have to recreate bit_size[], prev_run[] */\n\n        bi->cno = 3;\n\n\tfor (i=1; i<64; i++)\n\n\t   bi->mb[i] /= 2;\n\n    }\n\n}\n", "idx": 6431}
{"project": "qemu", "commit_id": "44696296d5c2ffccef9d43d37d4f525bba7d9f5c", "target": 1, "func": "static void t_gen_lsl(TCGv d, TCGv a, TCGv b)\n\n{\n\n\tTCGv t0, t_31;\n\n\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tt_31 = tcg_temp_new(TCG_TYPE_TL);\n\n\ttcg_gen_shl_tl(d, a, b);\n\n\n\n\ttcg_gen_movi_tl(t_31, 31);\n\n\ttcg_gen_sub_tl(t0, t_31, b);\n\n\ttcg_gen_sar_tl(t0, t0, t_31);\n\n\ttcg_gen_and_tl(t0, t0, d);\n\n\ttcg_gen_xor_tl(d, d, t0);\n\n\ttcg_temp_free(t0);\n\n\ttcg_temp_free(t_31);\n\n}\n", "idx": 6440}
{"project": "qemu", "commit_id": "71407786054cad26de7ef66718b2a57a4bcb49b5", "target": 1, "func": "bool virtio_scsi_handle_ctrl_vq(VirtIOSCSI *s, VirtQueue *vq)\n\n{\n\n    VirtIOSCSIReq *req;\n\n    bool progress = false;\n\n\n\n    virtio_scsi_acquire(s);\n\n    while ((req = virtio_scsi_pop_req(s, vq))) {\n\n        progress = true;\n\n        virtio_scsi_handle_ctrl_req(s, req);\n\n    }\n\n    virtio_scsi_release(s);\n\n    return progress;\n\n}\n", "idx": 6445}
{"project": "qemu", "commit_id": "e305a16510afa74eec20390479e349402e55ef4c", "target": 1, "func": "static void gus_realizefn (DeviceState *dev, Error **errp)\n\n{\n\n    ISADevice *d = ISA_DEVICE(dev);\n\n    GUSState *s = GUS (dev);\n\n    IsaDmaClass *k;\n\n    struct audsettings as;\n\n\n\n    AUD_register_card (\"gus\", &s->card);\n\n\n\n    as.freq = s->freq;\n\n    as.nchannels = 2;\n\n    as.fmt = AUD_FMT_S16;\n\n    as.endianness = GUS_ENDIANNESS;\n\n\n\n    s->voice = AUD_open_out (\n\n        &s->card,\n\n        NULL,\n\n        \"gus\",\n\n        s,\n\n        GUS_callback,\n\n        &as\n\n        );\n\n\n\n    if (!s->voice) {\n\n        AUD_remove_card (&s->card);\n\n        error_setg(errp, \"No voice\");\n\n        return;\n\n    }\n\n\n\n    s->shift = 2;\n\n    s->samples = AUD_get_buffer_size_out (s->voice) >> s->shift;\n\n    s->mixbuf = g_malloc0 (s->samples << s->shift);\n\n\n\n    isa_register_portio_list (d, s->port, gus_portio_list1, s, \"gus\");\n\n    isa_register_portio_list (d, (s->port + 0x100) & 0xf00,\n\n                              gus_portio_list2, s, \"gus\");\n\n\n\n    s->isa_dma = isa_get_dma(isa_bus_from_device(d), s->emu.gusdma);\n\n    k = ISADMA_GET_CLASS(s->isa_dma);\n\n    k->register_channel(s->isa_dma, s->emu.gusdma, GUS_read_DMA, s);\n\n    s->emu.himemaddr = s->himem;\n\n    s->emu.gusdatapos = s->emu.himemaddr + 1024 * 1024 + 32;\n\n    s->emu.opaque = s;\n\n    isa_init_irq (d, &s->pic, s->emu.gusirq);\n\n\n\n    AUD_set_active_out (s->voice, 1);\n\n}\n", "idx": 6461}
{"project": "qemu", "commit_id": "06b106889a09277617fc8c542397a9f595ee605a", "target": 1, "func": "static inline bool migration_bitmap_clear_dirty(RAMState *rs, ram_addr_t addr)\n\n{\n\n    bool ret;\n\n    int nr = addr >> TARGET_PAGE_BITS;\n\n    unsigned long *bitmap = atomic_rcu_read(&rs->ram_bitmap)->bmap;\n\n\n\n    ret = test_and_clear_bit(nr, bitmap);\n\n\n\n    if (ret) {\n\n        rs->migration_dirty_pages--;\n\n    }\n\n    return ret;\n\n}\n", "idx": 6467}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_vector_fmul_window(AVFloatDSPContext *fdsp, AVFloatDSPContext *cdsp,\n\n                                   const float *v1, const float *v2, const float *v3)\n\n{\n\n    LOCAL_ALIGNED(32, float, cdst, [LEN]);\n\n    LOCAL_ALIGNED(32, float, odst, [LEN]);\n\n    int ret;\n\n\n\n    cdsp->vector_fmul_window(cdst, v1, v2, v3, LEN / 2);\n\n    fdsp->vector_fmul_window(odst, v1, v2, v3, LEN / 2);\n\n\n\n    if (ret = compare_floats(cdst, odst, LEN, ARBITRARY_FMUL_WINDOW_CONST))\n\n        av_log(NULL, AV_LOG_ERROR, \"vector_fmul_window failed\\n\");\n\n\n\n    return ret;\n\n}\n", "idx": 6491}
{"project": "qemu", "commit_id": "e537112b418306229eb74c53de93751dd7b484d0", "target": 1, "func": "static void unassign_storage(SCLPDevice *sclp, SCCB *sccb)\n\n{\n\n    MemoryRegion *mr = NULL;\n\n    AssignStorage *assign_info = (AssignStorage *) sccb;\n\n    sclpMemoryHotplugDev *mhd = get_sclp_memory_hotplug_dev();\n\n    ram_addr_t unassign_addr;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    if (!mhd) {\n\n        sccb->h.response_code = cpu_to_be16(SCLP_RC_INVALID_SCLP_COMMAND);\n\n        return;\n\n    }\n\n    unassign_addr = (assign_info->rn - 1) * mhd->rzm;\n\n\n\n    /* if the addr is a multiple of 256 MB */\n\n    if ((unassign_addr % MEM_SECTION_SIZE == 0) &&\n\n        (unassign_addr >= mhd->padded_ram_size)) {\n\n        mhd->standby_state_map[(unassign_addr -\n\n                           mhd->padded_ram_size) / MEM_SECTION_SIZE] = 0;\n\n\n\n        /* find the specified memory region and destroy it */\n\n        mr = memory_region_find(sysmem, unassign_addr, 1).mr;\n\n        memory_region_unref(mr);\n\n        if (mr) {\n\n            int i;\n\n            int is_removable = 1;\n\n            ram_addr_t map_offset = (unassign_addr - mhd->padded_ram_size -\n\n                                     (unassign_addr - mhd->padded_ram_size)\n\n                                     % mhd->standby_subregion_size);\n\n            /* Mark all affected subregions as 'standby' once again */\n\n            for (i = 0;\n\n                 i < (mhd->standby_subregion_size / MEM_SECTION_SIZE);\n\n                 i++) {\n\n\n\n                if (mhd->standby_state_map[i + map_offset / MEM_SECTION_SIZE]) {\n\n                    is_removable = 0;\n\n                    break;\n\n                }\n\n            }\n\n            if (is_removable) {\n\n                memory_region_del_subregion(sysmem, mr);\n\n                object_unref(OBJECT(mr));\n\n            }\n\n        }\n\n    }\n\n    sccb->h.response_code = cpu_to_be16(SCLP_RC_NORMAL_COMPLETION);\n\n}\n", "idx": 6495}
{"project": "qemu", "commit_id": "46764fe09ca2e0f15c0981a672c166ed8cf57e72", "target": 1, "func": "static void do_flush_queued_data(VirtIOSerialPort *port, VirtQueue *vq,\n\n                                 VirtIODevice *vdev)\n\n{\n\n    VirtIOSerialPortClass *vsc;\n\n\n\n    assert(port);\n\n    assert(virtio_queue_ready(vq));\n\n\n\n    vsc = VIRTIO_SERIAL_PORT_GET_CLASS(port);\n\n\n\n    while (!port->throttled) {\n\n        unsigned int i;\n\n\n\n        /* Pop an elem only if we haven't left off a previous one mid-way */\n\n        if (!port->elem) {\n\n            port->elem = virtqueue_pop(vq, sizeof(VirtQueueElement));\n\n            if (!port->elem) {\n\n                break;\n\n\n            port->iov_idx = 0;\n\n            port->iov_offset = 0;\n\n\n\n\n        for (i = port->iov_idx; i < port->elem->out_num; i++) {\n\n            size_t buf_size;\n\n            ssize_t ret;\n\n\n\n            buf_size = port->elem->out_sg[i].iov_len - port->iov_offset;\n\n            ret = vsc->have_data(port,\n\n                                  port->elem->out_sg[i].iov_base\n\n                                  + port->iov_offset,\n\n                                  buf_size);\n\n\n\n\n            if (port->throttled) {\n\n                port->iov_idx = i;\n\n                if (ret > 0) {\n\n                    port->iov_offset += ret;\n\n\n                break;\n\n\n            port->iov_offset = 0;\n\n\n        if (port->throttled) {\n\n            break;\n\n\n        virtqueue_push(vq, port->elem, 0);\n\n        g_free(port->elem);\n\n        port->elem = NULL;\n\n\n    virtio_notify(vdev, vq);\n", "idx": 6508}
{"project": "FFmpeg", "commit_id": "14de55784dcf0b875dab35896c9e55d5792c6fd4", "target": 1, "func": "yuv2planeX_16_c_template(const int16_t *filter, int filterSize,\n\n                         const int32_t **src, uint16_t *dest, int dstW,\n\n                         int big_endian, int output_bits)\n\n{\n\n    int i;\n\n    int shift = 15;\n\n    av_assert0(output_bits == 16);\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int val = 1 << (shift - 1);\n\n        int j;\n\n\n\n        /* range of val is [0,0x7FFFFFFF], so 31 bits, but with lanczos/spline\n\n         * filters (or anything with negative coeffs, the range can be slightly\n\n         * wider in both directions. To account for this overflow, we subtract\n\n         * a constant so it always fits in the signed range (assuming a\n\n         * reasonable filterSize), and re-add that at the end. */\n\n        val -= 0x40000000;\n\n        for (j = 0; j < filterSize; j++)\n\n            val += src[j][i] * filter[j];\n\n\n\n        output_pixel(&dest[i], val, 0x8000, int);\n\n    }\n\n}\n", "idx": 6515}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static int generate_coupling_coordinates(AC3DecodeContext * ctx)\n\n{\n\n    ac3_audio_block *ab = &ctx->audio_block;\n\n    uint8_t exp, mstrcplco;\n\n    int16_t mant;\n\n    uint32_t cplbndstrc = (1 << ab->ncplsubnd) >> 1;\n\n    int ch, bnd, sbnd;\n\n    float cplco;\n\n\n\n    if (ab->cplcoe)\n\n        for (ch = 0; ch < ctx->bsi.nfchans; ch++)\n\n            if (ab->cplcoe & (1 << ch)) {\n\n                mstrcplco = 3 * ab->mstrcplco[ch];\n\n                sbnd = ab->cplbegf;\n\n                for (bnd = 0; bnd < ab->ncplbnd; bnd++) {\n\n                    exp = ab->cplcoexp[ch][bnd];\n\n                    if (exp == 15)\n\n                        mant = ab->cplcomant[ch][bnd] <<= 14;\n\n                    else\n\n                        mant = (ab->cplcomant[ch][bnd] | 0x10) << 13;\n\n                    cplco = to_float(exp + mstrcplco, mant);\n\n                    if (ctx->bsi.acmod == 0x02 && (ab->flags & AC3_AB_PHSFLGINU) && ch == 1\n\n                            && (ab->phsflg & (1 << bnd)))\n\n                        cplco = -cplco; /* invert the right channel */\n\n                    ab->cplco[ch][sbnd++] = cplco;\n\n                    while (cplbndstrc & ab->cplbndstrc) {\n\n                        cplbndstrc >>= 1;\n\n                        ab->cplco[ch][sbnd++] = cplco;\n\n                    }\n\n                    cplbndstrc >>= 1;\n\n                }\n\n            }\n\n\n\n    return 0;\n\n}\n", "idx": 6517}
{"project": "FFmpeg", "commit_id": "e20e9b9033b75fac32a4a3bc2cdd3fcc3cedb33a", "target": 1, "func": "static void fifo_deinit(AVFormatContext *avf)\n\n{\n\n    FifoContext *fifo = avf->priv_data;\n\n\n\n    av_dict_free(&fifo->format_options);\n\n    avformat_free_context(fifo->avf);\n\n    av_thread_message_queue_free(&fifo->queue);\n\n    pthread_mutex_destroy(&fifo->overflow_flag_lock);\n\n}\n", "idx": 6523}
{"project": "FFmpeg", "commit_id": "4c5e7b27d57dd2be777780e840eef9be63242158", "target": 1, "func": "static int get_metadata_size(const uint8_t *buf, int buf_size)\n\n{\n\n    int metadata_last, metadata_size;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n    buf += 4;\n\n    do {\n\n        ff_flac_parse_block_header(buf, &metadata_last, NULL, &metadata_size);\n\n        buf += 4;\n\n        if (buf + metadata_size > buf_end) {\n\n            /* need more data in order to read the complete header */\n\n            return 0;\n\n        }\n\n        buf += metadata_size;\n\n    } while (!metadata_last);\n\n\n\n    return buf_size - (buf_end - buf);\n\n}\n", "idx": 6557}
{"project": "FFmpeg", "commit_id": "2fed05f53a881b64a02de7a324d67d8c029c6cf1", "target": 1, "func": "static av_cold int msrle_decode_init(AVCodecContext *avctx)\n\n{\n\n    MsrleContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    s->avctx = avctx;\n\n\n\n    switch (avctx->bits_per_coded_sample) {\n\n    case 1:\n\n        avctx->pix_fmt = AV_PIX_FMT_MONOWHITE;\n\n        break;\n\n    case 4:\n\n    case 8:\n\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n        break;\n\n    case 24:\n\n        avctx->pix_fmt = AV_PIX_FMT_BGR24;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported bits per sample\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avcodec_get_frame_defaults(&s->frame);\n\n    s->frame.data[0] = NULL;\n\n\n\n    if (avctx->extradata_size >= AVPALETTE_SIZE)\n\n        for (i = 0; i < AVPALETTE_SIZE/4; i++)\n\n            s->pal[i] = 0xFF<<24 | AV_RL32(avctx->extradata+4*i);\n\n\n\n    return 0;\n\n}\n", "idx": 6569}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void nvme_clear_ctrl(NvmeCtrl *n)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < n->num_queues; i++) {\n\n        if (n->sq[i] != NULL) {\n\n            nvme_free_sq(n->sq[i], n);\n\n        }\n\n    }\n\n    for (i = 0; i < n->num_queues; i++) {\n\n        if (n->cq[i] != NULL) {\n\n            nvme_free_cq(n->cq[i], n);\n\n        }\n\n    }\n\n\n\n    bdrv_flush(n->conf.bs);\n\n    n->bar.cc = 0;\n\n}\n", "idx": 6595}
{"project": "qemu", "commit_id": "eff6ff9431aa9776062a5f4a08d1f6503ca9995a", "target": 0, "func": "void r4k_helper_tlbwi(CPUMIPSState *env)\n\n{\n\n    r4k_tlb_t *tlb;\n\n    int idx;\n\n    target_ulong VPN;\n\n    uint16_t ASID;\n\n    bool G, V0, D0, V1, D1;\n\n\n\n    idx = (env->CP0_Index & ~0x80000000) % env->tlb->nb_tlb;\n\n    tlb = &env->tlb->mmu.r4k.tlb[idx];\n\n    VPN = env->CP0_EntryHi & (TARGET_PAGE_MASK << 1);\n\n#if defined(TARGET_MIPS64)\n\n    VPN &= env->SEGMask;\n\n#endif\n\n    ASID = env->CP0_EntryHi & env->CP0_EntryHi_ASID_mask;\n\n    G = env->CP0_EntryLo0 & env->CP0_EntryLo1 & 1;\n\n    V0 = (env->CP0_EntryLo0 & 2) != 0;\n\n    D0 = (env->CP0_EntryLo0 & 4) != 0;\n\n    V1 = (env->CP0_EntryLo1 & 2) != 0;\n\n    D1 = (env->CP0_EntryLo1 & 4) != 0;\n\n\n\n    /* Discard cached TLB entries, unless tlbwi is just upgrading access\n\n       permissions on the current entry. */\n\n    if (tlb->VPN != VPN || tlb->ASID != ASID || tlb->G != G ||\n\n        (tlb->V0 && !V0) || (tlb->D0 && !D0) ||\n\n        (tlb->V1 && !V1) || (tlb->D1 && !D1)) {\n\n        r4k_mips_tlb_flush_extra(env, env->tlb->nb_tlb);\n\n    }\n\n\n\n    r4k_invalidate_tlb(env, idx, 0);\n\n    r4k_fill_tlb(env, idx);\n\n}\n", "idx": 6609}
{"project": "FFmpeg", "commit_id": "420d1df2e2a857eae45fa947e16eae7494793d57", "target": 0, "func": "static inline int ape_decode_value(APEContext *ctx, APERice *rice)\n\n{\n\n    int x, overflow;\n\n\n\n    if (ctx->fileversion < 3990) {\n\n        int tmpk;\n\n\n\n        overflow = range_get_symbol(ctx, counts_3970, counts_diff_3970);\n\n\n\n        if (overflow == (MODEL_ELEMENTS - 1)) {\n\n            tmpk = range_decode_bits(ctx, 5);\n\n            overflow = 0;\n\n        } else\n\n            tmpk = (rice->k < 1) ? 0 : rice->k - 1;\n\n\n\n        if (tmpk <= 16)\n\n            x = range_decode_bits(ctx, tmpk);\n\n        else {\n\n            x = range_decode_bits(ctx, 16);\n\n            x |= (range_decode_bits(ctx, tmpk - 16) << 16);\n\n        }\n\n        x += overflow << tmpk;\n\n    } else {\n\n        int base, pivot;\n\n\n\n        pivot = rice->ksum >> 5;\n\n        if (pivot == 0)\n\n            pivot = 1;\n\n\n\n        overflow = range_get_symbol(ctx, counts_3980, counts_diff_3980);\n\n\n\n        if (overflow == (MODEL_ELEMENTS - 1)) {\n\n            overflow  = range_decode_bits(ctx, 16) << 16;\n\n            overflow |= range_decode_bits(ctx, 16);\n\n        }\n\n\n\n        if (pivot < 0x10000) {\n\n            base = range_decode_culfreq(ctx, pivot);\n\n            range_decode_update(ctx, 1, base);\n\n        } else {\n\n            int base_hi = pivot, base_lo;\n\n            int bbits = 0;\n\n\n\n            while (base_hi & ~0xFFFF) {\n\n                base_hi >>= 1;\n\n                bbits++;\n\n            }\n\n            base_hi = range_decode_culfreq(ctx, base_hi + 1);\n\n            range_decode_update(ctx, 1, base_hi);\n\n            base_lo = range_decode_culfreq(ctx, 1 << bbits);\n\n            range_decode_update(ctx, 1, base_lo);\n\n\n\n            base = (base_hi << bbits) + base_lo;\n\n        }\n\n\n\n        x = base + overflow * pivot;\n\n    }\n\n\n\n    update_rice(rice, x);\n\n\n\n    /* Convert to signed */\n\n    if (x & 1)\n\n        return (x >> 1) + 1;\n\n    else\n\n        return -(x >> 1);\n\n}\n", "idx": 6618}
{"project": "FFmpeg", "commit_id": "0d4a66ee7f48c65ac67f4d91c8f8f2bfd47afa0d", "target": 0, "func": "int ffio_ensure_seekback(AVIOContext *s, int buf_size)\n\n{\n\n    uint8_t *buffer;\n\n    int max_buffer_size = s->max_packet_size ?\n\n                          s->max_packet_size : IO_BUFFER_SIZE;\n\n\n\n    buf_size += s->buf_ptr - s->buffer + max_buffer_size;\n\n\n\n    if (buf_size < s->buffer_size || s->seekable)\n\n        return 0;\n\n    av_assert0(!s->write_flag);\n\n\n\n    buffer = av_malloc(buf_size);\n\n    if (!buffer)\n\n        return AVERROR(ENOMEM);\n\n\n\n    memcpy(buffer, s->buffer, s->buffer_size);\n\n    av_free(s->buffer);\n\n    s->buf_ptr = buffer + (s->buf_ptr - s->buffer);\n\n    s->buf_end = buffer + (s->buf_end - s->buffer);\n\n    s->buffer = buffer;\n\n    s->buffer_size = buf_size;\n\n    return 0;\n\n}\n", "idx": 6619}
{"project": "FFmpeg", "commit_id": "3e6b7bbce510c53b4d7962f29aaf745c9b729775", "target": 1, "func": "static int film_probe(AVProbeData *p)\n{\n    if (AV_RB32(&p->buf[0]) != FILM_TAG)\n    return AVPROBE_SCORE_MAX;\n}", "idx": 6626}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static uint8_t ide_wait_clear(uint8_t flag)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n    uint8_t data;\n\n    time_t st;\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    /* Wait with a 5 second timeout */\n\n    time(&st);\n\n    while (true) {\n\n        data = qpci_io_readb(dev, ide_bar, reg_status);\n\n        if (!(data & flag)) {\n\n\n            return data;\n\n        }\n\n        if (difftime(time(NULL), st) > 5.0) {\n\n            break;\n\n        }\n\n        nsleep(400);\n\n    }\n\n    g_assert_not_reached();\n\n}", "idx": 6627}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void perf_lifecycle(void)\n\n{\n\n    Coroutine *coroutine;\n\n    unsigned int i, max;\n\n    double duration;\n\n\n\n    max = 1000000;\n\n\n\n    g_test_timer_start();\n\n    for (i = 0; i < max; i++) {\n\n        coroutine = qemu_coroutine_create(empty_coroutine);\n\n        qemu_coroutine_enter(coroutine, NULL);\n\n    }\n\n    duration = g_test_timer_elapsed();\n\n\n\n    g_test_message(\"Lifecycle %u iterations: %f s\\n\", max, duration);\n\n}\n", "idx": 6630}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_4xx_tlbsx_ (void)\n\n{\n\n    int tmp = xer_ov;\n\n\n\n    T0 = ppcemb_tlb_search(env, T0, env->spr[SPR_40x_PID]);\n\n    if (T0 != -1)\n\n        tmp |= 0x02;\n\n    env->crf[0] = tmp;\n\n}\n", "idx": 6644}
{"project": "qemu", "commit_id": "bce6261eb2d879625126485d4ddd28cacb93152e", "target": 1, "func": "static void virtconsole_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIOSerialPort *port = VIRTIO_SERIAL_PORT(dev);\n\n    VirtConsole *vcon = VIRTIO_CONSOLE(dev);\n\n    VirtIOSerialPortClass *k = VIRTIO_SERIAL_PORT_GET_CLASS(dev);\n\n\n\n    if (port->id == 0 && !k->is_console) {\n\n        error_setg(errp, \"Port number 0 on virtio-serial devices reserved \"\n\n                   \"for virtconsole devices for backward compatibility.\");\n\n        return;\n\n    }\n\n\n\n    if (vcon->chr) {\n\n        vcon->chr->explicit_fe_open = 1;\n\n        qemu_chr_add_handlers(vcon->chr, chr_can_read, chr_read, chr_event,\n\n                              vcon);\n\n    }\n\n}\n", "idx": 6661}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "void helper_done(CPUSPARCState *env)\n\n{\n\n    trap_state *tsptr = cpu_tsptr(env);\n\n\n\n    env->pc = tsptr->tnpc;\n\n    env->npc = tsptr->tnpc + 4;\n\n    cpu_put_ccr(env, tsptr->tstate >> 32);\n\n    env->asi = (tsptr->tstate >> 24) & 0xff;\n\n    cpu_change_pstate(env, (tsptr->tstate >> 8) & 0xf3f);\n\n    cpu_put_cwp64(env, tsptr->tstate & 0xff);\n\n    if (cpu_has_hypervisor(env)) {\n\n        uint32_t new_gl = (tsptr->tstate >> 40) & 7;\n\n        env->hpstate = env->htstate[env->tl];\n\n        cpu_gl_switch_gregs(env, new_gl);\n\n        env->gl = new_gl;\n\n    }\n\n    env->tl--;\n\n\n\n    trace_win_helper_done(env->tl);\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    if (cpu_interrupts_enabled(env)) {\n\n\n        cpu_check_irqs(env);\n\n\n    }\n\n#endif\n\n}", "idx": 6682}
{"project": "FFmpeg", "commit_id": "a8de60ba2740185c53cabbee6c00ed67a0d530e2", "target": 1, "func": "static void tqi_calculate_qtable(TqiContext *t, int quant)\n\n{\n\n    const int qscale = (215 - 2*quant)*5;\n\n    int i;\n\n\n\n    t->intra_matrix[0] = (ff_inv_aanscales[0] * ff_mpeg1_default_intra_matrix[0]) >> 11;\n\n    for(i=1; i<64; i++)\n\n        t->intra_matrix[i] = (ff_inv_aanscales[i] * ff_mpeg1_default_intra_matrix[i] * qscale + 32) >> 14;\n\n}\n", "idx": 6697}
{"project": "FFmpeg", "commit_id": "9034b0ed66c8f4a0da13947618503d575fc43957", "target": 0, "func": "static void free_input_threads(void)\n\n{\n\n    int i;\n\n\n\n    if (nb_input_files == 1)\n\n        return;\n\n\n\n    transcoding_finished = 1;\n\n\n\n    for (i = 0; i < nb_input_files; i++) {\n\n        InputFile *f = input_files[i];\n\n        AVPacket pkt;\n\n\n\n        if (f->joined)\n\n            continue;\n\n\n\n        pthread_mutex_lock(&f->fifo_lock);\n\n        while (av_fifo_size(f->fifo)) {\n\n            av_fifo_generic_read(f->fifo, &pkt, sizeof(pkt), NULL);\n\n            av_free_packet(&pkt);\n\n        }\n\n        pthread_cond_signal(&f->fifo_cond);\n\n        pthread_mutex_unlock(&f->fifo_lock);\n\n\n\n        pthread_join(f->thread, NULL);\n\n        f->joined = 1;\n\n\n\n        while (av_fifo_size(f->fifo)) {\n\n            av_fifo_generic_read(f->fifo, &pkt, sizeof(pkt), NULL);\n\n            av_free_packet(&pkt);\n\n        }\n\n        av_fifo_free(f->fifo);\n\n    }\n\n}\n", "idx": 6706}
{"project": "qemu", "commit_id": "5b498459b441f4639fd4c39c35345637bfc6c16c", "target": 1, "func": "static void tcp_chr_disconnect(CharDriverState *chr)\n\n{\n\n    TCPCharDriver *s = chr->opaque;\n\n\n\n    if (!s->connected) {\n\n        return;\n\n    }\n\n\n\n    s->connected = 0;\n\n    if (s->listen_ioc) {\n\n        s->listen_tag = qio_channel_add_watch(\n\n            QIO_CHANNEL(s->listen_ioc), G_IO_IN, tcp_chr_accept, chr, NULL);\n\n    }\n\n    tcp_set_msgfds(chr, NULL, 0);\n\n    remove_fd_in_watch(chr);\n\n    object_unref(OBJECT(s->sioc));\n\n    s->sioc = NULL;\n\n    object_unref(OBJECT(s->ioc));\n\n    s->ioc = NULL;\n\n    g_free(chr->filename);\n\n    chr->filename = SocketAddress_to_str(\"disconnected:\", s->addr,\n\n                                         s->is_listen, s->is_telnet);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n    if (s->reconnect_time) {\n\n        qemu_chr_socket_restart_timer(chr);\n\n    }\n\n}\n", "idx": 6710}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static inline void menelaus_rtc_stop(MenelausState *s)\n\n{\n\n    qemu_del_timer(s->rtc.hz_tm);\n\n    s->rtc.next -= qemu_get_clock(rt_clock);\n\n    if (s->rtc.next < 1)\n\n        s->rtc.next = 1;\n\n}\n", "idx": 6740}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "int ide_get_geometry(BusState *bus, int unit,\n\n                     int16_t *cyls, int8_t *heads, int8_t *secs)\n\n{\n\n    IDEState *s = &DO_UPCAST(IDEBus, qbus, bus)->ifs[unit];\n\n\n\n    if (s->drive_kind != IDE_HD || !s->bs) {\n\n        return -1;\n\n    }\n\n\n\n    *cyls = s->cylinders;\n\n    *heads = s->heads;\n\n    *secs = s->sectors;\n\n    return 0;\n\n}\n", "idx": 6748}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_dcread(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv EA, val;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_CACHE);\n\n    EA = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, EA);\n\n    val = tcg_temp_new();\n\n    gen_qemu_ld32u(ctx, val, EA);\n\n    tcg_temp_free(val);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], EA);\n\n    tcg_temp_free(EA);\n\n#endif\n\n}\n", "idx": 6809}
{"project": "qemu", "commit_id": "b0b6862e5e1a1394e0ab3d5da94ba8b0da8664e2", "target": 1, "func": "uint64_t qcow2_alloc_compressed_cluster_offset(BlockDriverState *bs,\n\n                                               uint64_t offset,\n\n                                               int compressed_size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t *l2_table;\n\n    int64_t cluster_offset;\n\n    int nb_csectors;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return 0;\n\n    }\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n        return 0;\n\n    }\n\n\n\n    if (cluster_offset)\n\n        qcow2_free_any_clusters(bs, cluster_offset, 1);\n\n\n\n    cluster_offset = qcow2_alloc_bytes(bs, compressed_size);\n\n    if (cluster_offset < 0) {\n\n        qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n        return 0;\n\n    }\n\n\n\n    nb_csectors = ((cluster_offset + compressed_size - 1) >> 9) -\n\n                  (cluster_offset >> 9);\n\n\n\n    cluster_offset |= QCOW_OFLAG_COMPRESSED |\n\n                      ((uint64_t)nb_csectors << s->csize_shift);\n\n\n\n    /* update L2 table */\n\n\n\n    /* compressed clusters never have the copied flag */\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L2_UPDATE_COMPRESSED);\n\n    qcow2_cache_entry_mark_dirty(s->l2_table_cache, l2_table);\n\n    l2_table[l2_index] = cpu_to_be64(cluster_offset);\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return 0;\n\n    }\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 6810}
{"project": "qemu", "commit_id": "4cad3867b6df2c0826ae508a9fe15dd0b9d8936a", "target": 1, "func": "int fw_cfg_add_i64(FWCfgState *s, uint16_t key, uint64_t value)\n\n{\n\n    uint64_t *copy;\n\n\n\n    copy = g_malloc(sizeof(value));\n\n    *copy = cpu_to_le64(value);\n\n    return fw_cfg_add_bytes(s, key, (uint8_t *)copy, sizeof(value));\n\n}\n", "idx": 6815}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static uint16_t nvme_del_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeDeleteQ *c = (NvmeDeleteQ *)cmd;\n\n    NvmeRequest *req, *next;\n\n    NvmeSQueue *sq;\n\n    NvmeCQueue *cq;\n\n    uint16_t qid = le16_to_cpu(c->qid);\n\n\n\n    if (!qid || nvme_check_sqid(n, qid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n\n\n    sq = n->sq[qid];\n\n    while (!QTAILQ_EMPTY(&sq->out_req_list)) {\n\n        req = QTAILQ_FIRST(&sq->out_req_list);\n\n        assert(req->aiocb);\n\n        bdrv_aio_cancel(req->aiocb);\n\n    }\n\n    if (!nvme_check_cqid(n, sq->cqid)) {\n\n        cq = n->cq[sq->cqid];\n\n        QTAILQ_REMOVE(&cq->sq_list, sq, entry);\n\n\n\n        nvme_post_cqes(cq);\n\n        QTAILQ_FOREACH_SAFE(req, &cq->req_list, entry, next) {\n\n            if (req->sq == sq) {\n\n                QTAILQ_REMOVE(&cq->req_list, req, entry);\n\n                QTAILQ_INSERT_TAIL(&sq->req_list, req, entry);\n\n            }\n\n        }\n\n    }\n\n\n\n    nvme_free_sq(sq, n);\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 6826}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_multiply(TCGv dst, TCGv src1, TCGv src2, int sign_ext)\n\n{\n\n    TCGv_i32 r_src1, r_src2;\n\n    TCGv_i64 r_temp, r_temp2;\n\n\n\n    r_src1 = tcg_temp_new_i32();\n\n    r_src2 = tcg_temp_new_i32();\n\n\n\n    tcg_gen_trunc_tl_i32(r_src1, src1);\n\n    tcg_gen_trunc_tl_i32(r_src2, src2);\n\n\n\n    r_temp = tcg_temp_new_i64();\n\n    r_temp2 = tcg_temp_new_i64();\n\n\n\n    if (sign_ext) {\n\n        tcg_gen_ext_i32_i64(r_temp, r_src2);\n\n        tcg_gen_ext_i32_i64(r_temp2, r_src1);\n\n    } else {\n\n        tcg_gen_extu_i32_i64(r_temp, r_src2);\n\n        tcg_gen_extu_i32_i64(r_temp2, r_src1);\n\n    }\n\n\n\n    tcg_gen_mul_i64(r_temp2, r_temp, r_temp2);\n\n\n\n    tcg_gen_shri_i64(r_temp, r_temp2, 32);\n\n    tcg_gen_trunc_i64_tl(cpu_tmp0, r_temp);\n\n    tcg_temp_free_i64(r_temp);\n\n    tcg_gen_andi_tl(cpu_y, cpu_tmp0, 0xffffffff);\n\n\n\n    tcg_gen_trunc_i64_tl(dst, r_temp2);\n\n\n\n    tcg_temp_free_i64(r_temp2);\n\n\n\n    tcg_temp_free_i32(r_src1);\n\n    tcg_temp_free_i32(r_src2);\n\n}\n", "idx": 6835}
{"project": "qemu", "commit_id": "2f4dc3c1b2a453a8255d9b97c7cb87860123e495", "target": 0, "func": "AioContext *aio_context_new(void)\n\n{\n\n    return (AioContext *) g_source_new(&aio_source_funcs, sizeof(AioContext));\n\n}\n", "idx": 6839}
{"project": "qemu", "commit_id": "032a7c4e425f1f0b71942768696f53f93947f8fa", "target": 1, "func": "static int lance_init(SysBusDevice *dev)\n\n{\n\n    SysBusPCNetState *d = FROM_SYSBUS(SysBusPCNetState, dev);\n\n    PCNetState *s = &d->state;\n\n\n\n    memory_region_init_io(&s->mmio, &lance_mem_ops, s, \"lance-mmio\", 4);\n\n\n\n    qdev_init_gpio_in(&dev->qdev, parent_lance_reset, 1);\n\n\n\n    sysbus_init_mmio_region(dev, &s->mmio);\n\n\n\n    sysbus_init_irq(dev, &s->irq);\n\n\n\n    s->phys_mem_read = ledma_memory_read;\n\n    s->phys_mem_write = ledma_memory_write;\n\n    return pcnet_common_init(&dev->qdev, s, &net_lance_info);\n\n}\n", "idx": 6886}
{"project": "qemu", "commit_id": "d42cf28837801cd1f835089fe9db2a42a1af55cd", "target": 0, "func": "void bdrv_drained_begin(BlockDriverState *bs)\n\n{\n\n    if (!bs->quiesce_counter++) {\n\n        aio_disable_external(bdrv_get_aio_context(bs));\n\n        bdrv_parent_drained_begin(bs);\n\n    }\n\n\n\n    bdrv_io_unplugged_begin(bs);\n\n    bdrv_drain_recurse(bs);\n\n    if (qemu_in_coroutine()) {\n\n        bdrv_co_yield_to_drain(bs);\n\n    } else {\n\n        bdrv_drain_poll(bs);\n\n    }\n\n    bdrv_io_unplugged_end(bs);\n\n}\n", "idx": 6921}
{"project": "qemu", "commit_id": "e4a3507e86a1ef1453d603031bca27d5ac4cff3c", "target": 0, "func": "static ssize_t block_crypto_init_func(QCryptoBlock *block,\n\n                                      void *opaque,\n\n                                      size_t headerlen,\n\n                                      Error **errp)\n\n{\n\n    struct BlockCryptoCreateData *data = opaque;\n\n    int ret;\n\n\n\n    /* User provided size should reflect amount of space made\n\n     * available to the guest, so we must take account of that\n\n     * which will be used by the crypto header\n\n     */\n\n    data->size += headerlen;\n\n\n\n    qemu_opt_set_number(data->opts, BLOCK_OPT_SIZE, data->size, &error_abort);\n\n    ret = bdrv_create_file(data->filename, data->opts, errp);\n\n    if (ret < 0) {\n\n        return -1;\n\n    }\n\n\n\n    data->blk = blk_new_open(data->filename, NULL, NULL,\n\n                             BDRV_O_RDWR | BDRV_O_PROTOCOL, errp);\n\n    if (!data->blk) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6931}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "void HELPER(ucf64_set_fpscr)(CPUUniCore32State *env, uint32_t val)\n\n{\n\n    int i;\n\n    uint32_t changed;\n\n\n\n    changed = env->ucf64.xregs[UC32_UCF64_FPSCR];\n\n    env->ucf64.xregs[UC32_UCF64_FPSCR] = (val & UCF64_FPSCR_MASK);\n\n\n\n    changed ^= val;\n\n    if (changed & (UCF64_FPSCR_RND_MASK)) {\n\n        i = UCF64_FPSCR_RND(val);\n\n        switch (i) {\n\n        case 0:\n\n            i = float_round_nearest_even;\n\n            break;\n\n        case 1:\n\n            i = float_round_to_zero;\n\n            break;\n\n        case 2:\n\n            i = float_round_up;\n\n            break;\n\n        case 3:\n\n            i = float_round_down;\n\n            break;\n\n        default: /* 100 and 101 not implement */\n\n            cpu_abort(env, \"Unsupported UniCore-F64 round mode\");\n\n        }\n\n        set_float_rounding_mode(i, &env->ucf64.fp_status);\n\n    }\n\n\n\n    i = ucf64_exceptbits_to_host(UCF64_FPSCR_TRAPEN(val));\n\n    set_float_exception_flags(i, &env->ucf64.fp_status);\n\n}\n", "idx": 6941}
{"project": "qemu", "commit_id": "e04fb07fd1676e9facd7f3f878c1bbe03bccd26b", "target": 1, "func": "static void qemu_rbd_close(BlockDriverState *bs)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n\n\n    close(s->fds[0]);\n\n    close(s->fds[1]);\n\n    qemu_aio_set_fd_handler(s->fds[RBD_FD_READ], NULL, NULL, NULL);\n\n\n\n    rbd_close(s->image);\n\n    rados_ioctx_destroy(s->io_ctx);\n\n    g_free(s->snap);\n\n    rados_shutdown(s->cluster);\n\n}\n", "idx": 6960}
{"project": "qemu", "commit_id": "d6cf84e1de0a167963f0803d6e39f6ca03e27eaa", "target": 0, "func": "void slirp_output(const uint8_t *pkt, int pkt_len)\n\n{\n\n#ifdef DEBUG_SLIRP\n\n    printf(\"slirp output:\\n\");\n\n    hex_dump(stdout, pkt, pkt_len);\n\n#endif\n\n    if (!slirp_vc)\n\n        return;\n\n    qemu_send_packet(slirp_vc, pkt, pkt_len);\n\n}\n", "idx": 7021}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void vnc_connect(VncDisplay *vd, int csock, int skipauth, bool websocket)\n\n{\n\n    VncState *vs = g_malloc0(sizeof(VncState));\n\n    int i;\n\n\n\n    vs->csock = csock;\n\n\n\n    if (skipauth) {\n\n\tvs->auth = VNC_AUTH_NONE;\n\n#ifdef CONFIG_VNC_TLS\n\n\tvs->subauth = VNC_AUTH_INVALID;\n\n#endif\n\n    } else {\n\n\tvs->auth = vd->auth;\n\n#ifdef CONFIG_VNC_TLS\n\n\tvs->subauth = vd->subauth;\n\n#endif\n\n    }\n\n\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n\n    }\n\n\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n\n    dcl->idle = 0;\n\n    socket_set_nonblock(vs->csock);\n\n#ifdef CONFIG_VNC_WS\n\n    if (websocket) {\n\n        vs->websocket = 1;\n\n        qemu_set_fd_handler2(vs->csock, NULL, vncws_handshake_read, NULL, vs);\n\n    } else\n\n#endif /* CONFIG_VNC_WS */\n\n    {\n\n        qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n\n    }\n\n\n\n    vnc_client_cache_addr(vs);\n\n    vnc_qmp_event(vs, QEVENT_VNC_CONNECTED);\n\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n\n\n    vs->vd = vd;\n\n\n\n#ifdef CONFIG_VNC_WS\n\n    if (!vs->websocket)\n\n#endif\n\n    {\n\n        vnc_init_state(vs);\n\n    }\n\n}\n", "idx": 7056}
{"project": "qemu", "commit_id": "0ff0fad23d3693ecf7a0c462cdb48f0e60f93808", "target": 0, "func": "static void tcp_chr_disconnect(CharDriverState *chr)\n\n{\n\n    TCPCharDriver *s = chr->opaque;\n\n\n\n    s->connected = 0;\n\n    if (s->listen_chan) {\n\n        s->listen_tag = g_io_add_watch(s->listen_chan, G_IO_IN,\n\n                                       tcp_chr_accept, chr);\n\n    }\n\n    remove_fd_in_watch(chr);\n\n    g_io_channel_unref(s->chan);\n\n    s->chan = NULL;\n\n    closesocket(s->fd);\n\n    s->fd = -1;\n\n    SocketAddress_to_str(chr->filename, CHR_MAX_FILENAME_SIZE,\n\n                         \"disconnected:\", s->addr, s->is_listen, s->is_telnet);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n    if (s->reconnect_time) {\n\n        qemu_chr_socket_restart_timer(chr);\n\n    }\n\n}\n", "idx": 7070}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_si2df)(float32 x, CPUUniCore32State *env)\n\n{\n\n    return int32_to_float64(ucf64_stoi(x), &env->ucf64.fp_status);\n\n}\n", "idx": 7073}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parse_literal(JSONParserContext *ctxt)\n\n{\n\n    QObject *token;\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    assert(token);\n\n\n\n    switch (token_get_type(token)) {\n\n    case JSON_STRING:\n\n        return QOBJECT(qstring_from_escaped_str(ctxt, token));\n\n    case JSON_INTEGER: {\n\n        /* A possibility exists that this is a whole-valued float where the\n\n         * fractional part was left out due to being 0 (.0). It's not a big\n\n         * deal to treat these as ints in the parser, so long as users of the\n\n         * resulting QObject know to expect a QInt in place of a QFloat in\n\n         * cases like these.\n\n         *\n\n         * However, in some cases these values will overflow/underflow a\n\n         * QInt/int64 container, thus we should assume these are to be handled\n\n         * as QFloats/doubles rather than silently changing their values.\n\n         *\n\n         * strtoll() indicates these instances by setting errno to ERANGE\n\n         */\n\n        int64_t value;\n\n\n\n        errno = 0; /* strtoll doesn't set errno on success */\n\n        value = strtoll(token_get_value(token), NULL, 10);\n\n        if (errno != ERANGE) {\n\n            return QOBJECT(qint_from_int(value));\n\n        }\n\n        /* fall through to JSON_FLOAT */\n\n    }\n\n    case JSON_FLOAT:\n\n        /* FIXME dependent on locale */\n\n        return QOBJECT(qfloat_from_double(strtod(token_get_value(token),\n\n                                                 NULL)));\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 7076}
{"project": "qemu", "commit_id": "ff589551c8e8e9e95e211b9d8daafb4ed39f1aec", "target": 0, "func": "uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n\n{\n\n    uint32_t old_val;\n\n\n\n    trace_esp_mem_readb(saddr, s->rregs[saddr]);\n\n    switch (saddr) {\n\n    case ESP_FIFO:\n\n        if (s->ti_size > 0) {\n\n            s->ti_size--;\n\n            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n\n                /* Data out.  */\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"esp: PIO data read not implemented\\n\");\n\n                s->rregs[ESP_FIFO] = 0;\n\n            } else {\n\n                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n\n            }\n\n            esp_raise_irq(s);\n\n        }\n\n        if (s->ti_size == 0) {\n\n            s->ti_rptr = 0;\n\n            s->ti_wptr = 0;\n\n        }\n\n        break;\n\n    case ESP_RINTR:\n\n        /* Clear sequence step, interrupt register and all status bits\n\n           except TC */\n\n        old_val = s->rregs[ESP_RINTR];\n\n        s->rregs[ESP_RINTR] = 0;\n\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n\n        esp_lower_irq(s);\n\n\n\n        return old_val;\n\n    case ESP_TCHI:\n\n        /* Return the unique id if the value has never been written */\n\n        if (!s->tchi_written) {\n\n            return s->chip_id;\n\n        }\n\n    default:\n\n        break;\n\n    }\n\n    return s->rregs[saddr];\n\n}\n", "idx": 7078}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "static void co_test_cb(void *opaque)\n\n{\n\n    WorkerTestData *data = opaque;\n\n\n\n    active = 1;\n\n    data->n = 0;\n\n    data->ret = -EINPROGRESS;\n\n    thread_pool_submit_co(worker_cb, data);\n\n\n\n    /* The test continues in test_submit_co, after qemu_coroutine_enter... */\n\n\n\n    g_assert_cmpint(data->n, ==, 1);\n\n    data->ret = 0;\n\n    active--;\n\n\n\n    /* The test continues in test_submit_co, after qemu_aio_wait_all... */\n\n}\n", "idx": 7083}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "int nbd_client_session_co_flush(NbdClientSession *client)\n\n{\n\n    struct nbd_request request = { .type = NBD_CMD_FLUSH };\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {\n\n        return 0;\n\n    }\n\n\n\n    if (client->nbdflags & NBD_FLAG_SEND_FUA) {\n\n        request.type |= NBD_CMD_FLAG_FUA;\n\n    }\n\n\n\n    request.from = 0;\n\n    request.len = 0;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL, 0);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n}\n", "idx": 7090}
{"project": "qemu", "commit_id": "97a83ec3a9d83f2e86b8b93178d8e8b64ccc7486", "target": 0, "func": "static void i440fx_pcihost_initfn(Object *obj)\n\n{\n\n    PCIHostState *s = PCI_HOST_BRIDGE(obj);\n\n    I440FXState *d = I440FX_PCI_HOST_BRIDGE(obj);\n\n\n\n    memory_region_init_io(&s->conf_mem, obj, &pci_host_conf_le_ops, s,\n\n                          \"pci-conf-idx\", 4);\n\n    memory_region_init_io(&s->data_mem, obj, &pci_host_data_le_ops, s,\n\n                          \"pci-conf-data\", 4);\n\n\n\n    object_property_add(obj, PCI_HOST_PROP_PCI_HOLE_START, \"int\",\n\n                        i440fx_pcihost_get_pci_hole_start,\n\n                        NULL, NULL, NULL, NULL);\n\n\n\n    object_property_add(obj, PCI_HOST_PROP_PCI_HOLE_END, \"int\",\n\n                        i440fx_pcihost_get_pci_hole_end,\n\n                        NULL, NULL, NULL, NULL);\n\n\n\n    object_property_add(obj, PCI_HOST_PROP_PCI_HOLE64_START, \"int\",\n\n                        i440fx_pcihost_get_pci_hole64_start,\n\n                        NULL, NULL, NULL, NULL);\n\n\n\n    object_property_add(obj, PCI_HOST_PROP_PCI_HOLE64_END, \"int\",\n\n                        i440fx_pcihost_get_pci_hole64_end,\n\n                        NULL, NULL, NULL, NULL);\n\n\n\n    d->pci_info.w32.end = IO_APIC_DEFAULT_ADDRESS;\n\n}\n", "idx": 7115}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "int avio_open2(AVIOContext **s, const char *filename, int flags,\n\n               const AVIOInterruptCB *int_cb, AVDictionary **options)\n\n{\n\n    AVIOInternal *internal;\n\n    const URLProtocol **protocols;\n\n    URLContext *h;\n\n    int err;\n\n\n\n    protocols = ffurl_get_protocols(NULL, NULL);\n\n    if (!protocols)\n\n        return AVERROR(ENOMEM);\n\n\n\n    err = ffurl_open(&h, filename, flags, int_cb, options, protocols);\n\n    if (err < 0) {\n\n        av_freep(&protocols);\n\n        return err;\n\n    }\n\n\n\n    err = ffio_fdopen(s, h);\n\n    if (err < 0) {\n\n        ffurl_close(h);\n\n        av_freep(&protocols);\n\n        return err;\n\n    }\n\n\n\n    internal = (*s)->opaque;\n\n    internal->protocols = protocols;\n\n\n\n    return 0;\n\n}\n", "idx": 7138}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_mutex_unlock_iothread(void) {}\n", "idx": 7152}
{"project": "qemu", "commit_id": "e305a16510afa74eec20390479e349402e55ef4c", "target": 1, "func": "static void parallel_isa_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    static int index;\n\n    ISADevice *isadev = ISA_DEVICE(dev);\n\n    ISAParallelState *isa = ISA_PARALLEL(dev);\n\n    ParallelState *s = &isa->state;\n\n    int base;\n\n    uint8_t dummy;\n\n\n\n    if (!s->chr) {\n\n        error_setg(errp, \"Can't create parallel device, empty char device\");\n\n        return;\n\n    }\n\n\n\n    if (isa->index == -1) {\n\n        isa->index = index;\n\n    }\n\n    if (isa->index >= MAX_PARALLEL_PORTS) {\n\n        error_setg(errp, \"Max. supported number of parallel ports is %d.\",\n\n                   MAX_PARALLEL_PORTS);\n\n        return;\n\n    }\n\n    if (isa->iobase == -1) {\n\n        isa->iobase = isa_parallel_io[isa->index];\n\n    }\n\n    index++;\n\n\n\n    base = isa->iobase;\n\n    isa_init_irq(isadev, &s->irq, isa->isairq);\n\n    qemu_register_reset(parallel_reset, s);\n\n\n\n    if (qemu_chr_fe_ioctl(s->chr, CHR_IOCTL_PP_READ_STATUS, &dummy) == 0) {\n\n        s->hw_driver = 1;\n\n        s->status = dummy;\n\n    }\n\n\n\n    isa_register_portio_list(isadev, base,\n\n                             (s->hw_driver\n\n                              ? &isa_parallel_portio_hw_list[0]\n\n                              : &isa_parallel_portio_sw_list[0]),\n\n                             s, \"parallel\");\n\n}\n", "idx": 7157}
{"project": "qemu", "commit_id": "f5aa4bdc766190b95d18be27d5cdf4d80c35b33c", "target": 1, "func": "static void test_bmdma_long_prdt(void)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n    uint8_t status;\n\n\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = 0,\n\n            .size = cpu_to_le32(0x1000 | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    /* Normal request */\n\n    status = send_dma_request(CMD_READ_DMA, 0, 1,\n\n                              prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_ACTIVE | BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_bar, reg_status), DF | ERR);\n\n\n\n    /* Abort the request before it completes */\n\n    status = send_dma_request(CMD_READ_DMA | CMDF_ABORT, 0, 1,\n\n                              prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_bar, reg_status), DF | ERR);\n\n\n}", "idx": 7164}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "static void memory_region_update_coalesced_range(MemoryRegion *mr)\n\n{\n\n    FlatRange *fr;\n\n    CoalescedMemoryRange *cmr;\n\n    AddrRange tmp;\n\n\n\n    FOR_EACH_FLAT_RANGE(fr, &address_space_memory.current_map) {\n\n        if (fr->mr == mr) {\n\n            qemu_unregister_coalesced_mmio(int128_get64(fr->addr.start),\n\n                                           int128_get64(fr->addr.size));\n\n            QTAILQ_FOREACH(cmr, &mr->coalesced, link) {\n\n                tmp = addrrange_shift(cmr->addr,\n\n                                      int128_sub(fr->addr.start,\n\n                                                 int128_make64(fr->offset_in_region)));\n\n                if (!addrrange_intersects(tmp, fr->addr)) {\n\n                    continue;\n\n                }\n\n                tmp = addrrange_intersection(tmp, fr->addr);\n\n                qemu_register_coalesced_mmio(int128_get64(tmp.start),\n\n                                             int128_get64(tmp.size));\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 7169}
{"project": "qemu", "commit_id": "13d1fd44c46629aad672f192abbf02238c6cbf36", "target": 1, "func": "static int qxl_init_secondary(PCIDevice *dev)\n\n{\n\n    static int device_id = 1;\n\n    PCIQXLDevice *qxl = DO_UPCAST(PCIQXLDevice, pci, dev);\n\n\n\n    qxl->id = device_id++;\n\n    qxl_init_ramsize(qxl, 16);\n\n    memory_region_init_ram(&qxl->vga.vram, \"qxl.vgavram\", qxl->vga.vram_size);\n\n    vmstate_register_ram(&qxl->vga.vram, &qxl->pci.qdev);\n\n    qxl->vga.vram_ptr = memory_region_get_ram_ptr(&qxl->vga.vram);\n\n\n\n    return qxl_init_common(qxl);\n\n}\n", "idx": 7171}
{"project": "qemu", "commit_id": "84961407a50bb02d34ab9cca7a21cdb4ff7c25fe", "target": 1, "func": "static void gd_set_keycode_type(GtkDisplayState *s)\n{\n#ifdef GDK_WINDOWING_X11\n    GdkDisplay *display = gtk_widget_get_display(s->window);\n    if (GDK_IS_X11_DISPLAY(display)) {\n        Display *x11_display = gdk_x11_display_get_xdisplay(display);\n        XkbDescPtr desc = XkbGetKeyboard(x11_display, XkbGBN_AllComponentsMask,\n                                         XkbUseCoreKbd);\n        char *keycodes = NULL;\n        if (desc && desc->names) {\n            keycodes = XGetAtomName(x11_display, desc->names->keycodes);\n        if (keycodes == NULL) {\n            fprintf(stderr, \"could not lookup keycode name\\n\");\n        } else if (strstart(keycodes, \"evdev\", NULL)) {\n            s->has_evdev = true;\n        } else if (!strstart(keycodes, \"xfree86\", NULL)) {\n            fprintf(stderr, \"unknown keycodes `%s', please report to \"\n                    \"qemu-devel@nongnu.org\\n\", keycodes);\n#endif", "idx": 7206}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static void kvm_client_set_memory(struct CPUPhysMemoryClient *client,\n\n\t\t\t\t  target_phys_addr_t start_addr,\n\n\t\t\t\t  ram_addr_t size,\n\n\t\t\t\t  ram_addr_t phys_offset)\n\n{\n\n\tkvm_set_phys_mem(start_addr, size, phys_offset);\n\n}\n", "idx": 7211}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static inline int fp_reg_offset(int regno, TCGMemOp size)\n\n{\n\n    int offs = offsetof(CPUARMState, vfp.regs[regno * 2]);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n    offs += (8 - (1 << size));\n\n#endif\n\n    return offs;\n\n}\n", "idx": 7231}
{"project": "qemu", "commit_id": "6e13610aa454beba52944e8df6d93158d68ab911", "target": 1, "func": "static int qcow2_save_vmstate(BlockDriverState *bs, QEMUIOVector *qiov,\n\n                              int64_t pos)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t total_sectors = bs->total_sectors;\n\n    int growable = bs->growable;\n\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_VMSTATE_SAVE);\n\n    bs->growable = 1;\n\n\n    ret = bdrv_pwritev(bs, qcow2_vm_state_offset(s) + pos, qiov);\n\n    bs->growable = growable;\n\n\n\n\n    /* bdrv_co_do_writev will have increased the total_sectors value to include\n\n     * the VM state - the VM state is however not an actual part of the block\n\n     * device, therefore, we need to restore the old value. */\n\n    bs->total_sectors = total_sectors;\n\n\n\n    return ret;\n\n}", "idx": 7263}
{"project": "FFmpeg", "commit_id": "1ca7dc60d2f2cac8fce1bdb53d3d5bae195161b0", "target": 1, "func": "yuv2422_1_c_template(SwsContext *c, const int16_t *buf0,\n\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n                     const int16_t *abuf0, uint8_t *dest, int dstW,\n\n                     int uvalpha, int y, enum PixelFormat target)\n\n{\n\n    const int16_t *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1];\n\n    int i;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 = buf0[i * 2]     >> 7;\n\n            int Y2 = buf0[i * 2 + 1] >> 7;\n\n            int U  = ubuf1[i]        >> 7;\n\n            int V  = vbuf1[i]        >> 7;\n\n\n\n            output_pixels(i * 4, Y1, U, Y2, V);\n\n        }\n\n    } else {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 =  buf0[i * 2]          >> 7;\n\n            int Y2 =  buf0[i * 2 + 1]      >> 7;\n\n            int U  = (ubuf0[i] + ubuf1[i]) >> 8;\n\n            int V  = (vbuf0[i] + vbuf1[i]) >> 8;\n\n\n\n            output_pixels(i * 4, Y1, U, Y2, V);\n\n        }\n\n    }\n\n}\n", "idx": 7295}
{"project": "qemu", "commit_id": "99f2cf4b2dad7b37c69759deb0d0b19d3ec1a24a", "target": 1, "func": "static void local_mapped_file_attr(int dirfd, const char *name,\n\n                                   struct stat *stbuf)\n\n{\n\n    FILE *fp;\n\n    char buf[ATTR_MAX];\n\n    int map_dirfd;\n\n\n\n    map_dirfd = openat(dirfd, VIRTFS_META_DIR,\n\n                       O_RDONLY | O_DIRECTORY | O_NOFOLLOW);\n\n    if (map_dirfd == -1) {\n\n        return;\n\n    }\n\n\n\n    fp = local_fopenat(map_dirfd, name, \"r\");\n\n    close_preserve_errno(map_dirfd);\n\n    if (!fp) {\n\n        return;\n\n    }\n\n    memset(buf, 0, ATTR_MAX);\n\n    while (fgets(buf, ATTR_MAX, fp)) {\n\n        if (!strncmp(buf, \"virtfs.uid\", 10)) {\n\n            stbuf->st_uid = atoi(buf+11);\n\n        } else if (!strncmp(buf, \"virtfs.gid\", 10)) {\n\n            stbuf->st_gid = atoi(buf+11);\n\n        } else if (!strncmp(buf, \"virtfs.mode\", 11)) {\n\n            stbuf->st_mode = atoi(buf+12);\n\n        } else if (!strncmp(buf, \"virtfs.rdev\", 11)) {\n\n            stbuf->st_rdev = atoi(buf+12);\n\n        }\n\n        memset(buf, 0, ATTR_MAX);\n\n    }\n\n    fclose(fp);\n\n}\n", "idx": 7308}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "static void legacy_kbd_event(DeviceState *dev, QemuConsole *src,\n\n                             InputEvent *evt)\n\n{\n\n    QEMUPutKbdEntry *entry = (QEMUPutKbdEntry *)dev;\n\n    int scancodes[3], i, count;\n\n\n\n    if (!entry || !entry->put_kbd) {\n\n        return;\n\n    }\n\n    count = qemu_input_key_value_to_scancode(evt->key->key,\n\n                                             evt->key->down,\n\n                                             scancodes);\n\n    for (i = 0; i < count; i++) {\n\n        entry->put_kbd(entry->opaque, scancodes[i]);\n\n    }\n\n}\n", "idx": 7316}
{"project": "qemu", "commit_id": "c169998802505c244b8bcad562633f29de7d74a4", "target": 0, "func": "PITState *pit_init(int base, qemu_irq irq)\n\n{\n\n    PITState *pit = &pit_state;\n\n    PITChannelState *s;\n\n\n\n    s = &pit->channels[0];\n\n    /* the timer 0 is connected to an IRQ */\n\n    s->irq_timer = qemu_new_timer(vm_clock, pit_irq_timer, s);\n\n    s->irq = irq;\n\n\n\n    vmstate_register(base, &vmstate_pit, pit);\n\n    qemu_register_reset(pit_reset, pit);\n\n    register_ioport_write(base, 4, 1, pit_ioport_write, pit);\n\n    register_ioport_read(base, 3, 1, pit_ioport_read, pit);\n\n\n\n    pit_reset(pit);\n\n\n\n    return pit;\n\n}\n", "idx": 7322}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_literal(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"nul\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 7349}
{"project": "FFmpeg", "commit_id": "838740e6420538ad45982da6b1d3aa3ae91307f5", "target": 1, "func": "static void decode_sublayer_hrd(HEVCContext *s, int nb_cpb,\n\n                                int subpic_params_present)\n\n{\n\n    GetBitContext *gb = &s->HEVClc.gb;\n\n    int i;\n\n\n\n    for (i = 0; i < nb_cpb; i++) {\n\n        get_ue_golomb_long(gb); // bit_rate_value_minus1\n\n        get_ue_golomb_long(gb); // cpb_size_value_minus1\n\n\n\n        if (subpic_params_present) {\n\n            get_ue_golomb_long(gb); // cpb_size_du_value_minus1\n\n            get_ue_golomb_long(gb); // bit_rate_du_value_minus1\n\n        }\n\n        skip_bits1(gb); // cbr_flag\n\n    }\n\n}\n", "idx": 7352}
{"project": "qemu", "commit_id": "441692ddd8321d5e0f09b163e86410e578d87236", "target": 1, "func": "static inline int onenand_load_main(OneNANDState *s, int sec, int secn,\n\n                void *dest)\n\n{\n\n    if (s->blk_cur) {\n\n        return blk_read(s->blk_cur, sec, dest, secn) < 0;\n\n    } else if (sec + secn > s->secs_cur) {\n\n        return 1;\n\n    }\n\n\n\n    memcpy(dest, s->current + (sec << 9), secn << 9);\n\n\n\n    return 0;\n\n}\n", "idx": 7353}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "static void flush_trace_file(void)\n\n{\n\n    /* If the trace file is not open yet, open it now */\n\n    if (!trace_fp) {\n\n        trace_fp = fopen(trace_file_name, \"w\");\n\n        if (!trace_fp) {\n\n            /* Avoid repeatedly trying to open file on failure */\n\n            trace_file_enabled = false;\n\n            return;\n\n        }\n\n        write_header(trace_fp);\n\n    }\n\n\n\n    if (trace_fp) {\n\n        size_t unused; /* for when fwrite(3) is declared warn_unused_result */\n\n        unused = fwrite(trace_buf, trace_idx * sizeof(trace_buf[0]), 1, trace_fp);\n\n    }\n\n}\n", "idx": 7355}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "void helper_fxtoq(CPUSPARCState *env, int64_t src)\n\n{\n\n    /* No possible exceptions converting long long to long double.  */\n\n    QT0 = int64_to_float128(src, &env->fp_status);\n\n}\n", "idx": 7359}
{"project": "qemu", "commit_id": "25f8e2f512d87f0a77fc5c0b367dd200a7834d21", "target": 0, "func": "static int pci_piix3_ide_initfn(PCIDevice *dev)\n\n{\n\n    PCIIDEState *d = DO_UPCAST(PCIIDEState, dev, dev);\n\n\n\n    pci_config_set_vendor_id(d->dev.config, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(d->dev.config, PCI_DEVICE_ID_INTEL_82371SB_1);\n\n    return pci_piix_ide_initfn(d);\n\n}\n", "idx": 7377}
{"project": "qemu", "commit_id": "be09ac4194bd0a61c0d9412c32431fbe2273cba1", "target": 0, "func": "static abi_long do_getpeername(int fd, abi_ulong target_addr,\n\n                               abi_ulong target_addrlen_addr)\n\n{\n\n    socklen_t addrlen;\n\n    void *addr;\n\n    abi_long ret;\n\n\n\n    if (get_user_u32(addrlen, target_addrlen_addr))\n\n        return -TARGET_EFAULT;\n\n\n\n    if (addrlen < 0 || addrlen > MAX_SOCK_ADDR)\n\n        return -TARGET_EINVAL;\n\n\n\n    addr = alloca(addrlen);\n\n\n\n    ret = get_errno(getpeername(fd, addr, &addrlen));\n\n    if (!is_error(ret)) {\n\n        host_to_target_sockaddr(target_addr, addr, addrlen);\n\n        if (put_user_u32(addrlen, target_addrlen_addr))\n\n            ret = -TARGET_EFAULT;\n\n    }\n\n    return ret;\n\n}\n", "idx": 7378}
{"project": "qemu", "commit_id": "c18ad9a54b75495ce61e8b28d353f8eec51768fc", "target": 0, "func": "void ppc_hash64_set_external_hpt(PowerPCCPU *cpu, void *hpt, int shift,\n\n                                 Error **errp)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    Error *local_err = NULL;\n\n\n\n    cpu_synchronize_state(CPU(cpu));\n\n\n\n    env->external_htab = hpt;\n\n    ppc_hash64_set_sdr1(cpu, (target_ulong)(uintptr_t)hpt | (shift - 18),\n\n                        &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Not strictly necessary, but makes it clearer that an external\n\n     * htab is in use when debugging */\n\n    env->htab_base = -1;\n\n\n\n    if (kvm_enabled()) {\n\n        if (kvmppc_put_books_sregs(cpu) < 0) {\n\n            error_setg(errp, \"Unable to update SDR1 in KVM\");\n\n        }\n\n    }\n\n}\n", "idx": 7383}
{"project": "qemu", "commit_id": "672558d2ea8dd782d1d2adc6e16af3bc34029a36", "target": 1, "func": "void numa_set_mem_node_id(ram_addr_t addr, uint64_t size, uint32_t node)\n\n{\n\n    struct numa_addr_range *range = g_malloc0(sizeof(*range));\n\n\n\n    /*\n\n     * Memory-less nodes can come here with 0 size in which case,\n\n     * there is nothing to do.\n\n     */\n\n    if (!size) {\n\n        return;\n\n    }\n\n\n\n    range->mem_start = addr;\n\n    range->mem_end = addr + size - 1;\n\n    QLIST_INSERT_HEAD(&numa_info[node].addr, range, entry);\n\n}\n", "idx": 7394}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_bound_d(int v, int b)\n\n{\n\n\tint r = v;\n\n\tasm (\"bound.d\\t%1, %0\\n\" : \"+r\" (r) : \"ri\" (b));\n\n\treturn r;\n\n}\n", "idx": 7400}
{"project": "FFmpeg", "commit_id": "baced9f5986a466c957456f5cf32a722d8b35512", "target": 0, "func": "static void mpeg4_encode_visual_object_header(MpegEncContext * s){\n\n    int profile_and_level_indication;\n\n    int vo_ver_id;\n\n    \n\n    if(s->max_b_frames || s->quarter_sample){\n\n        profile_and_level_indication= 0xF1; // adv simple level 1\n\n        vo_ver_id= 5;\n\n    }else{\n\n        profile_and_level_indication= 0x01; // simple level 1\n\n        vo_ver_id= 1;\n\n    }\n\n    //FIXME levels\n\n\n\n    put_bits(&s->pb, 16, 0);\n\n    put_bits(&s->pb, 16, VOS_STARTCODE);\n\n\n\n    put_bits(&s->pb, 8, profile_and_level_indication);\n\n\n\n    put_bits(&s->pb, 16, 0);\n\n    put_bits(&s->pb, 16, VISUAL_OBJ_STARTCODE);\n\n    \n\n    put_bits(&s->pb, 1, 1);\n\n        put_bits(&s->pb, 4, vo_ver_id);\n\n        put_bits(&s->pb, 3, 1); //priority\n\n \n\n    put_bits(&s->pb, 4, 1); //visual obj type== video obj\n\n    \n\n    put_bits(&s->pb, 1, 0); //video signal type == no clue //FIXME\n\n\n\n    ff_mpeg4_stuffing(&s->pb);\n\n}\n", "idx": 7406}
{"project": "FFmpeg", "commit_id": "3c27275c1309190f2d6ed69140b67d014215b6c9", "target": 0, "func": "static void add_entry1(TiffEncoderContext *s,\n\n                       enum TiffTags tag, enum TiffTypes type, int val)\n\n{\n\n    uint16_t w  = val;\n\n    uint32_t dw = val;\n\n    add_entry(s, tag, type, 1, type == TIFF_SHORT ? (void *)&w : (void *)&dw);\n\n}\n", "idx": 7434}
{"project": "qemu", "commit_id": "02b07434bed8360715198b4cbfdfebd17f7cac32", "target": 0, "func": "static const char *pxb_host_root_bus_path(PCIHostState *host_bridge,\n\n                                          PCIBus *rootbus)\n\n{\n\n    PXBBus *bus = PXB_BUS(rootbus);\n\n\n\n    snprintf(bus->bus_path, 8, \"0000:%02x\", pxb_bus_num(rootbus));\n\n    return bus->bus_path;\n\n}\n", "idx": 7446}
{"project": "qemu", "commit_id": "717adf960933da0650d995f050d457063d591914", "target": 0, "func": "int qemu_strtou64(const char *nptr, const char **endptr, int base,\n\n                  uint64_t *result)\n\n{\n\n    char *p;\n\n    int err = 0;\n\n    if (!nptr) {\n\n        if (endptr) {\n\n            *endptr = nptr;\n\n        }\n\n        err = -EINVAL;\n\n    } else {\n\n        errno = 0;\n\n        /* FIXME This assumes uint64_t is unsigned long long */\n\n        *result = strtoull(nptr, &p, base);\n\n        /* Windows returns 1 for negative out-of-range values.  */\n\n        if (errno == ERANGE) {\n\n            *result = -1;\n\n        }\n\n        err = check_strtox_error(nptr, p, endptr, errno);\n\n    }\n\n    return err;\n\n}\n", "idx": 7450}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "void v9fs_string_init(V9fsString *str)\n\n{\n\n    str->data = NULL;\n\n    str->size = 0;\n\n}\n", "idx": 7484}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void do_spawn_thread(ThreadPool *pool)\n\n{\n\n    QemuThread t;\n\n\n\n    /* Runs with lock taken.  */\n\n    if (!pool->new_threads) {\n\n        return;\n\n    }\n\n\n\n    pool->new_threads--;\n\n    pool->pending_threads++;\n\n\n\n    qemu_thread_create(&t, \"worker\", worker_thread, pool, QEMU_THREAD_DETACHED);\n\n}\n", "idx": 7487}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void virtio_net_tx_complete(NetClientState *nc, ssize_t len)\n\n{\n\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n\n    VirtIONetQueue *q = virtio_net_get_subqueue(nc);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n\n\n    virtqueue_push(q->tx_vq, &q->async_tx.elem, 0);\n\n    virtio_notify(vdev, q->tx_vq);\n\n\n\n    q->async_tx.elem.out_num = 0;\n\n\n\n    virtio_queue_set_notification(q->tx_vq, 1);\n\n    virtio_net_flush_tx(q);\n\n}\n", "idx": 7502}
{"project": "qemu", "commit_id": "0f8c289ad539feb5135c545bea947b310a893f4b", "target": 1, "func": "static int net_socket_mcast_init(NetClientState *peer,\n\n                                 const char *model,\n\n                                 const char *name,\n\n                                 const char *host_str,\n\n                                 const char *localaddr_str)\n\n{\n\n    NetSocketState *s;\n\n    int fd;\n\n    struct sockaddr_in saddr;\n\n    struct in_addr localaddr, *param_localaddr;\n\n\n\n    if (parse_host_port(&saddr, host_str) < 0)\n\n        return -1;\n\n\n\n    if (localaddr_str != NULL) {\n\n        if (inet_aton(localaddr_str, &localaddr) == 0)\n\n            return -1;\n\n        param_localaddr = &localaddr;\n\n    } else {\n\n        param_localaddr = NULL;\n\n    }\n\n\n\n    fd = net_socket_mcast_create(&saddr, param_localaddr);\n\n    if (fd < 0)\n\n        return -1;\n\n\n\n    s = net_socket_fd_init(peer, model, name, fd, 0);\n\n    if (!s)\n\n        return -1;\n\n\n\n    s->dgram_dst = saddr;\n\n\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: mcast=%s:%d\",\n\n             inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return 0;\n\n\n\n}\n", "idx": 7522}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void pl041_device_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = pl041_init;\n\n    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);\n\n    dc->no_user = 1;\n\n    dc->reset = pl041_device_reset;\n\n    dc->vmsd = &vmstate_pl041;\n\n    dc->props = pl041_device_properties;\n\n}\n", "idx": 7528}
{"project": "qemu", "commit_id": "a41642708a5d1cbe8ad966227bbee1ed5eb421ad", "target": 1, "func": "static SpiceChannelList *qmp_query_spice_channels(void)\n\n{\n\n    SpiceChannelList *cur_item = NULL, *head = NULL;\n\n    ChannelList *item;\n\n\n\n    QTAILQ_FOREACH(item, &channel_list, link) {\n\n        SpiceChannelList *chan;\n\n        char host[NI_MAXHOST], port[NI_MAXSERV];\n\n        struct sockaddr *paddr;\n\n        socklen_t plen;\n\n\n\n        if (!(item->info->flags & SPICE_CHANNEL_EVENT_FLAG_ADDR_EXT)) {\n\n            error_report(\"invalid channel event\");\n\n            return NULL;\n\n        }\n\n\n\n        chan = g_malloc0(sizeof(*chan));\n\n        chan->value = g_malloc0(sizeof(*chan->value));\n\n        chan->value->base = g_malloc0(sizeof(*chan->value->base));\n\n\n\n        paddr = (struct sockaddr *)&item->info->paddr_ext;\n\n        plen = item->info->plen_ext;\n\n        getnameinfo(paddr, plen,\n\n                    host, sizeof(host), port, sizeof(port),\n\n                    NI_NUMERICHOST | NI_NUMERICSERV);\n\n        chan->value->base->host = g_strdup(host);\n\n        chan->value->base->port = g_strdup(port);\n\n        chan->value->base->family = inet_netfamily(paddr->sa_family);\n\n\n\n        chan->value->connection_id = item->info->connection_id;\n\n        chan->value->channel_type = item->info->type;\n\n        chan->value->channel_id = item->info->id;\n\n        chan->value->tls = item->info->flags & SPICE_CHANNEL_EVENT_FLAG_TLS;\n\n\n\n       /* XXX: waiting for the qapi to support GSList */\n\n        if (!cur_item) {\n\n            head = cur_item = chan;\n\n        } else {\n\n            cur_item->next = chan;\n\n            cur_item = chan;\n\n        }\n\n    }\n\n\n\n    return head;\n\n}\n", "idx": 7531}
{"project": "qemu", "commit_id": "ece2d05ed4adb9a9aa3ca9da0496be769dfb3a25", "target": 1, "func": "static int cd_read_sector(IDEState *s, int lba, uint8_t *buf, int sector_size)\n\n{\n\n    int ret;\n\n\n\n    switch(sector_size) {\n\n    case 2048:\n\n        block_acct_start(blk_get_stats(s->blk), &s->acct,\n\n                         4 * BDRV_SECTOR_SIZE, BLOCK_ACCT_READ);\n\n        ret = blk_read(s->blk, (int64_t)lba << 2, buf, 4);\n\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n\n        break;\n\n    case 2352:\n\n        block_acct_start(blk_get_stats(s->blk), &s->acct,\n\n                         4 * BDRV_SECTOR_SIZE, BLOCK_ACCT_READ);\n\n        ret = blk_read(s->blk, (int64_t)lba << 2, buf + 16, 4);\n\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n\n        if (ret < 0)\n\n            return ret;\n\n        cd_data_to_raw(buf, lba);\n\n        break;\n\n    default:\n\n        ret = -EIO;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 7538}
{"project": "qemu", "commit_id": "81145834d39897c6f153ac26a4077f90f269c5fc", "target": 1, "func": "static int cow_read(BlockDriverState *bs, int64_t sector_num,\n\n                    uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVCowState *s = bs->opaque;\n\n    int ret, n;\n\n\n\n    while (nb_sectors > 0) {\n\n        if (cow_is_allocated(bs, sector_num, nb_sectors, &n)) {\n\n            ret = bdrv_pread(bs->file,\n\n                        s->cow_sectors_offset + sector_num * 512,\n\n                        buf, n * 512);\n\n            if (ret != n * 512)\n\n                return -1;\n\n        } else {\n\n            if (bs->backing_hd) {\n\n                /* read from the base image */\n\n                ret = bdrv_read(bs->backing_hd, sector_num, buf, n);\n\n                if (ret < 0)\n\n                    return -1;\n\n            } else {\n\n            memset(buf, 0, n * 512);\n\n        }\n\n        }\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n    return 0;\n\n}\n", "idx": 7540}
{"project": "qemu", "commit_id": "7ebaf7955603cc50988e0eafd5e6074320fefc70", "target": 0, "func": "static HotplugHandler *spapr_get_hotpug_handler(MachineState *machine,\n\n                                             DeviceState *dev)\n\n{\n\n    if (object_dynamic_cast(OBJECT(dev), TYPE_PC_DIMM) ||\n\n        object_dynamic_cast(OBJECT(dev), TYPE_SPAPR_CPU_CORE)) {\n\n        return HOTPLUG_HANDLER(machine);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 7580}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void yuvj444p_to_rgb24(AVPicture *dst, AVPicture *src,\n\n                              int width, int height)\n\n{\n\n    uint8_t *y1_ptr, *cb_ptr, *cr_ptr, *d, *d1;\n\n    int w, y, cb, cr, r_add, g_add, b_add;\n\n    uint8_t *cm = cropTbl + MAX_NEG_CROP;\n\n    unsigned int r, g, b;\n\n\n\n    d = dst->data[0];\n\n    y1_ptr = src->data[0];\n\n    cb_ptr = src->data[1];\n\n    cr_ptr = src->data[2];\n\n    for(;height > 0; height --) {\n\n        d1 = d;\n\n        for(w = width; w > 0; w--) {\n\n            YUV_TO_RGB1(cb_ptr[0], cr_ptr[0]);\n\n\n\n            YUV_TO_RGB2(r, g, b, y1_ptr[0]);\n\n            RGB_OUT(d1, r, g, b);\n\n            d1 += BPP;\n\n\n\n            y1_ptr++;\n\n            cb_ptr++;\n\n            cr_ptr++;\n\n        }\n\n        d += dst->linesize[0];\n\n        y1_ptr += src->linesize[0] - width;\n\n        cb_ptr += src->linesize[1] - width;\n\n        cr_ptr += src->linesize[2] - width;\n\n    }\n\n}\n", "idx": 7610}
{"project": "qemu", "commit_id": "cf0f7cf903073f9dd9979dd33d52618b384ac2cb", "target": 1, "func": "void kvm_init_cpu_signals(CPUState *cpu)\n\n{\n\n    int r;\n\n    sigset_t set;\n\n    struct sigaction sigact;\n\n\n\n    memset(&sigact, 0, sizeof(sigact));\n\n    sigact.sa_handler = dummy_signal;\n\n    sigaction(SIG_IPI, &sigact, NULL);\n\n\n\n    pthread_sigmask(SIG_BLOCK, NULL, &set);\n\n#if defined KVM_HAVE_MCE_INJECTION\n\n    sigdelset(&set, SIGBUS);\n\n    pthread_sigmask(SIG_SETMASK, &set, NULL);\n\n#endif\n\n    sigdelset(&set, SIG_IPI);\n\n    r = kvm_set_signal_mask(cpu, &set);\n\n    if (r) {\n\n        fprintf(stderr, \"kvm_set_signal_mask: %s\\n\", strerror(-r));\n\n        exit(1);\n\n    }\n\n}\n", "idx": 7665}
{"project": "qemu", "commit_id": "3e40ba0faf0822fa78336fe6cd9d677ea9b14f1b", "target": 1, "func": "static void vfio_disable_msix(VFIODevice *vdev)\n{\n    msix_unset_vector_notifiers(&vdev->pdev);\n    if (vdev->nr_vectors) {\n        vfio_disable_irqindex(vdev, VFIO_PCI_MSIX_IRQ_INDEX);\n    vfio_disable_msi_common(vdev);\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n            vdev->host.bus, vdev->host.slot, vdev->host.function);", "idx": 7678}
{"project": "FFmpeg", "commit_id": "c1847c932b1576e8224c38e112a5fd29fa8a6098", "target": 1, "func": "static int rtcp_parse_packet(RTPDemuxContext *s, const unsigned char *buf, int len)\n\n{\n\n    int payload_len;\n\n    while (len >= 2) {\n\n        switch (buf[1]) {\n\n        case RTCP_SR:\n\n            if (len < 16) {\n\n                av_log(NULL, AV_LOG_ERROR, \"Invalid length for RTCP SR packet\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            payload_len = (AV_RB16(buf + 2) + 1) * 4;\n\n\n\n            s->last_rtcp_ntp_time = AV_RB64(buf + 8);\n\n            s->last_rtcp_timestamp = AV_RB32(buf + 16);\n\n            if (s->first_rtcp_ntp_time == AV_NOPTS_VALUE) {\n\n                s->first_rtcp_ntp_time = s->last_rtcp_ntp_time;\n\n                if (!s->base_timestamp)\n\n                    s->base_timestamp = s->last_rtcp_timestamp;\n\n                s->rtcp_ts_offset = s->last_rtcp_timestamp - s->base_timestamp;\n\n            }\n\n\n\n            buf += payload_len;\n\n            len -= payload_len;\n\n            break;\n\n        case RTCP_BYE:\n\n            return -RTCP_BYE;\n\n        default:\n\n            return -1;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 7689}
{"project": "qemu", "commit_id": "36cf2a37132c7f01fa9adb5f95f5312b27742fd4", "target": 1, "func": "void virtqueue_map_sg(struct iovec *sg, hwaddr *addr,\n    size_t num_sg, int is_write)\n{\n    unsigned int i;\n    hwaddr len;\n    for (i = 0; i < num_sg; i++) {\n        len = sg[i].iov_len;\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n        if (sg[i].iov_base == NULL || len != sg[i].iov_len) {\n            error_report(\"virtio: trying to map MMIO memory\");", "idx": 7690}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void ehci_async_complete_packet(USBPort *port, USBPacket *packet)\n\n{\n\n    EHCIQueue *q;\n\n    EHCIState *s = port->opaque;\n\n    uint32_t portsc = s->portsc[port->index];\n\n\n\n    if (portsc & PORTSC_POWNER) {\n\n        USBPort *companion = s->companion_ports[port->index];\n\n        companion->ops->complete(companion, packet);\n\n        return;\n\n    }\n\n\n\n    q = container_of(packet, EHCIQueue, packet);\n\n    trace_usb_ehci_queue_action(q, \"wakeup\");\n\n    assert(q->async == EHCI_ASYNC_INFLIGHT);\n\n    q->async = EHCI_ASYNC_FINISHED;\n\n    q->usb_status = packet->len;\n\n}\n", "idx": 7706}
{"project": "FFmpeg", "commit_id": "b505f15b1530d72682b3314e84936f80fe6e43b2", "target": 1, "func": "static int thread_execute(AVCodecContext *avctx, action_func* func, void *arg, int *ret, int job_count, int job_size)\n\n{\n\n    SliceThreadContext *c = avctx->internal->thread_ctx;\n\n\n\n    if (!(avctx->active_thread_type&FF_THREAD_SLICE) || avctx->thread_count <= 1)\n\n        return avcodec_default_execute(avctx, func, arg, ret, job_count, job_size);\n\n\n\n    if (job_count <= 0)\n\n        return 0;\n\n\n\n    pthread_mutex_lock(&c->current_job_lock);\n\n\n\n    c->current_job = avctx->thread_count;\n\n    c->job_count = job_count;\n\n    c->job_size = job_size;\n\n    c->args = arg;\n\n    c->func = func;\n\n    c->rets = ret;\n\n    c->current_execute++;\n\n    pthread_cond_broadcast(&c->current_job_cond);\n\n\n\n    thread_park_workers(c, avctx->thread_count);\n\n\n\n    return 0;\n\n}\n", "idx": 7712}
{"project": "FFmpeg", "commit_id": "85e7386ae0d33ede4c575d4df4c1faae6c906338", "target": 0, "func": "static void gain_compensate(COOKContext *q, cook_gains *gains_ptr,\n\n                            float* previous_buffer)\n\n{\n\n    const float fc = q->pow2tab[gains_ptr->previous[0] + 63];\n\n    float *buffer = q->mono_mdct_output;\n\n    int i;\n\n\n\n    /* Overlap with the previous block. */\n\n    for(i=0 ; i<q->samples_per_channel ; i++) {\n\n        buffer[i] *= fc;\n\n        buffer[i] += previous_buffer[i];\n\n    }\n\n\n\n    /* Apply gain profile */\n\n    for (i = 0; i < 8; i++) {\n\n        if (gains_ptr->now[i] || gains_ptr->now[i + 1])\n\n            interpolate(q, &buffer[q->gain_size_factor * i],\n\n                        gains_ptr->now[i], gains_ptr->now[i + 1]);\n\n    }\n\n\n\n    /* Save away the current to be previous block. */\n\n    memcpy(previous_buffer, buffer+q->samples_per_channel,\n\n           sizeof(float)*q->samples_per_channel);\n\n}\n", "idx": 7715}
{"project": "FFmpeg", "commit_id": "8ebed703f153e979edb2156754c8bdac4d5d6266", "target": 1, "func": "static inline int l3_unscale(int value, int exponent)\n\n{\n\n    unsigned int m;\n\n    int e;\n\n\n\n    e  = table_4_3_exp  [4 * value + (exponent & 3)];\n\n    m  = table_4_3_value[4 * value + (exponent & 3)];\n\n    e -= exponent >> 2;\n\n#ifdef DEBUG\n\n    if(e < 1)\n\n        av_log(NULL, AV_LOG_WARNING, \"l3_unscale: e is %d\\n\", e);\n\n#endif\n\n    if (e > (SUINT)31)\n\n        return 0;\n\n    m = (m + (1 << (e - 1))) >> e;\n\n\n\n    return m;\n\n}\n", "idx": 7735}
{"project": "qemu", "commit_id": "c2d76497b6eafcaedc806e07804e7bed55a98a0b", "target": 1, "func": "void get_tmp_filename(char *filename, int size)\n\n{\n\n    char temp_dir[MAX_PATH];\n\n\n\n    GetTempPath(MAX_PATH, temp_dir);\n\n    GetTempFileName(temp_dir, \"qem\", 0, filename);\n\n}\n", "idx": 7770}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void qemu_clock_enable(QEMUClockType type, bool enabled)\n\n{\n\n    QEMUClock *clock = qemu_clock_ptr(type);\n\n    QEMUTimerList *tl;\n\n    bool old = clock->enabled;\n\n    clock->enabled = enabled;\n\n    if (enabled && !old) {\n\n        qemu_clock_notify(type);\n\n    } else if (!enabled && old) {\n\n        QLIST_FOREACH(tl, &clock->timerlists, list) {\n\n            qemu_event_wait(&tl->timers_done_ev);\n\n        }\n\n    }\n\n}\n", "idx": 7791}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t grlib_gptimer_read(void *opaque, target_phys_addr_t addr,\n\n                                   unsigned size)\n\n{\n\n    GPTimerUnit        *unit  = opaque;\n\n    target_phys_addr_t  timer_addr;\n\n    int                 id;\n\n    uint32_t            value = 0;\n\n\n\n    addr &= 0xff;\n\n\n\n    /* Unit registers */\n\n    switch (addr) {\n\n    case SCALER_OFFSET:\n\n        trace_grlib_gptimer_readl(-1, addr, unit->scaler);\n\n        return unit->scaler;\n\n\n\n    case SCALER_RELOAD_OFFSET:\n\n        trace_grlib_gptimer_readl(-1, addr, unit->reload);\n\n        return unit->reload;\n\n\n\n    case CONFIG_OFFSET:\n\n        trace_grlib_gptimer_readl(-1, addr, unit->config);\n\n        return unit->config;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    timer_addr = (addr % TIMER_BASE);\n\n    id         = (addr - TIMER_BASE) / TIMER_BASE;\n\n\n\n    if (id >= 0 && id < unit->nr_timers) {\n\n\n\n        /* GPTimer registers */\n\n        switch (timer_addr) {\n\n        case COUNTER_OFFSET:\n\n            value = ptimer_get_count(unit->timers[id].ptimer);\n\n            trace_grlib_gptimer_readl(id, addr, value);\n\n            return value;\n\n\n\n        case COUNTER_RELOAD_OFFSET:\n\n            value = unit->timers[id].reload;\n\n            trace_grlib_gptimer_readl(id, addr, value);\n\n            return value;\n\n\n\n        case CONFIG_OFFSET:\n\n            trace_grlib_gptimer_readl(id, addr, unit->timers[id].config);\n\n            return unit->timers[id].config;\n\n\n\n        default:\n\n            break;\n\n        }\n\n\n\n    }\n\n\n\n    trace_grlib_gptimer_readl(-1, addr, 0);\n\n    return 0;\n\n}\n", "idx": 7792}
{"project": "qemu", "commit_id": "6d8048341995b31a77dc2e0dcaaf4e3df0e3121a", "target": 0, "func": "static int get_cpsr(QEMUFile *f, void *opaque, size_t size,\n\n                    VMStateField *field)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t val = qemu_get_be32(f);\n\n\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        if (val & XPSR_EXCP) {\n\n            /* This is a CPSR format value from an older QEMU. (We can tell\n\n             * because values transferred in XPSR format always have zero\n\n             * for the EXCP field, and CPSR format will always have bit 4\n\n             * set in CPSR_M.) Rearrange it into XPSR format. The significant\n\n             * differences are that the T bit is not in the same place, the\n\n             * primask/faultmask info may be in the CPSR I and F bits, and\n\n             * we do not want the mode bits.\n\n             */\n\n            uint32_t newval = val;\n\n\n\n            newval &= (CPSR_NZCV | CPSR_Q | CPSR_IT | CPSR_GE);\n\n            if (val & CPSR_T) {\n\n                newval |= XPSR_T;\n\n            }\n\n            /* If the I or F bits are set then this is a migration from\n\n             * an old QEMU which still stored the M profile FAULTMASK\n\n             * and PRIMASK in env->daif. For a new QEMU, the data is\n\n             * transferred using the vmstate_m_faultmask_primask subsection.\n\n             */\n\n            if (val & CPSR_F) {\n\n                env->v7m.faultmask = 1;\n\n            }\n\n            if (val & CPSR_I) {\n\n                env->v7m.primask = 1;\n\n            }\n\n            val = newval;\n\n        }\n\n        /* Ignore the low bits, they are handled by vmstate_m. */\n\n        xpsr_write(env, val, ~XPSR_EXCP);\n\n        return 0;\n\n    }\n\n\n\n    env->aarch64 = ((val & PSTATE_nRW) == 0);\n\n\n\n    if (is_a64(env)) {\n\n        pstate_write(env, val);\n\n        return 0;\n\n    }\n\n\n\n    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);\n\n    return 0;\n\n}\n", "idx": 7797}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t m5206_mbar_readl(void *opaque, target_phys_addr_t offset)\n\n{\n\n    m5206_mbar_state *s = (m5206_mbar_state *)opaque;\n\n    int width;\n\n    offset &= 0x3ff;\n\n    if (offset >= 0x200) {\n\n        hw_error(\"Bad MBAR read offset 0x%x\", (int)offset);\n\n    }\n\n    width = m5206_mbar_width[offset >> 2];\n\n    if (width < 4) {\n\n        uint32_t val;\n\n        val = m5206_mbar_readw(opaque, offset) << 16;\n\n        val |= m5206_mbar_readw(opaque, offset + 2);\n\n        return val;\n\n    }\n\n    return m5206_mbar_read(s, offset, 4);\n\n}\n", "idx": 7819}
{"project": "qemu", "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06", "target": 0, "func": "uint64_t qcow2_alloc_compressed_cluster_offset(BlockDriverState *bs,\n\n                                               uint64_t offset,\n\n                                               int compressed_size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t *l2_table;\n\n    int64_t cluster_offset;\n\n    int nb_csectors;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return 0;\n\n    }\n\n\n\n    /* Compression can't overwrite anything. Fail if the cluster was already\n\n     * allocated. */\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    if (cluster_offset & L2E_OFFSET_MASK) {\n\n        qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n        return 0;\n\n    }\n\n\n\n    cluster_offset = qcow2_alloc_bytes(bs, compressed_size);\n\n    if (cluster_offset < 0) {\n\n        qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n        return 0;\n\n    }\n\n\n\n    nb_csectors = ((cluster_offset + compressed_size - 1) >> 9) -\n\n                  (cluster_offset >> 9);\n\n\n\n    cluster_offset |= QCOW_OFLAG_COMPRESSED |\n\n                      ((uint64_t)nb_csectors << s->csize_shift);\n\n\n\n    /* update L2 table */\n\n\n\n    /* compressed clusters never have the copied flag */\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L2_UPDATE_COMPRESSED);\n\n    qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n    l2_table[l2_index] = cpu_to_be64(cluster_offset);\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return 0;\n\n    }\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 7826}
{"project": "qemu", "commit_id": "318347234d7069b62d38391dd27e269a3107d668", "target": 0, "func": "void spapr_core_unplug_request(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                               Error **errp)\n\n{\n\n    int index;\n\n    sPAPRDRConnector *drc;\n\n    sPAPRDRConnectorClass *drck;\n\n    Error *local_err = NULL;\n\n    CPUCore *cc = CPU_CORE(dev);\n\n    int smt = kvmppc_smt_threads();\n\n\n\n    if (!spapr_find_cpu_slot(MACHINE(hotplug_dev), cc->core_id, &index)) {\n\n        error_setg(errp, \"Unable to find CPU core with core-id: %d\",\n\n                   cc->core_id);\n\n        return;\n\n    }\n\n    if (index == 0) {\n\n        error_setg(errp, \"Boot CPU core may not be unplugged\");\n\n        return;\n\n    }\n\n\n\n    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index * smt);\n\n    g_assert(drc);\n\n\n\n    drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    drck->detach(drc, dev, spapr_core_release, NULL, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    spapr_hotplug_req_remove_by_index(drc);\n\n}\n", "idx": 7837}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "void commit_active_start(BlockDriverState *bs, BlockDriverState *base,\n\n                         int64_t speed,\n\n                         BlockdevOnError on_error,\n\n                         BlockDriverCompletionFunc *cb,\n\n                         void *opaque, Error **errp)\n\n{\n\n    int64_t length, base_length;\n\n    int orig_base_flags;\n\n    int ret;\n\n    Error *local_err = NULL;\n\n\n\n    orig_base_flags = bdrv_get_flags(base);\n\n\n\n    if (bdrv_reopen(base, bs->open_flags, errp)) {\n\n        return;\n\n    }\n\n\n\n    length = bdrv_getlength(bs);\n\n    if (length < 0) {\n\n        error_setg_errno(errp, -length,\n\n                         \"Unable to determine length of %s\", bs->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    base_length = bdrv_getlength(base);\n\n    if (base_length < 0) {\n\n        error_setg_errno(errp, -base_length,\n\n                         \"Unable to determine length of %s\", base->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    if (length > base_length) {\n\n        ret = bdrv_truncate(base, length);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret,\n\n                            \"Top image %s is larger than base image %s, and \"\n\n                             \"resize of base image failed\",\n\n                             bs->filename, base->filename);\n\n            goto error_restore_flags;\n\n        }\n\n    }\n\n\n\n    bdrv_ref(base);\n\n    mirror_start_job(bs, base, speed, 0, 0,\n\n                     on_error, on_error, cb, opaque, &local_err,\n\n                     &commit_active_job_driver, false, base);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    return;\n\n\n\nerror_restore_flags:\n\n    /* ignore error and errp for bdrv_reopen, because we want to propagate\n\n     * the original error */\n\n    bdrv_reopen(base, orig_base_flags, NULL);\n\n    return;\n\n}\n", "idx": 7858}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_up_char(void)\n\n{\n\n    int idx;\n\n\n\n    if (term_hist_entry == 0)\n\n\treturn;\n\n    if (term_hist_entry == -1) {\n\n\t/* Find latest entry */\n\n\tfor (idx = 0; idx < TERM_MAX_CMDS; idx++) {\n\n\t    if (term_history[idx] == NULL)\n\n\t\tbreak;\n\n\t}\n\n\tterm_hist_entry = idx;\n\n    }\n\n    term_hist_entry--;\n\n    if (term_hist_entry >= 0) {\n\n\tpstrcpy(term_cmd_buf, sizeof(term_cmd_buf), \n\n                term_history[term_hist_entry]);\n\n\tterm_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n    }\n\n}\n", "idx": 7877}
{"project": "FFmpeg", "commit_id": "d5fd610dabb4c7a6f63d4479e66c93c37339b6c0", "target": 1, "func": "static int kalman_smoothen(WMAVoiceContext *s, int pitch,\n\n                           const float *in, float *out, int size)\n\n{\n\n    int n;\n\n    float optimal_gain = 0, dot;\n\n    const float *ptr = &in[-FFMAX(s->min_pitch_val, pitch - 3)],\n\n                *end = &in[-FFMIN(s->max_pitch_val, pitch + 3)],\n\n                *best_hist_ptr;\n\n\n\n    /* find best fitting point in history */\n\n    do {\n\n        dot = ff_scalarproduct_float_c(in, ptr, size);\n\n        if (dot > optimal_gain) {\n\n            optimal_gain  = dot;\n\n            best_hist_ptr = ptr;\n\n        }\n\n    } while (--ptr >= end);\n\n\n\n    if (optimal_gain <= 0)\n\n        return -1;\n\n    dot = ff_scalarproduct_float_c(best_hist_ptr, best_hist_ptr, size);\n\n    if (dot <= 0) // would be 1.0\n\n        return -1;\n\n\n\n    if (optimal_gain <= dot) {\n\n        dot = dot / (dot + 0.6 * optimal_gain); // 0.625-1.000\n\n    } else\n\n        dot = 0.625;\n\n\n\n    /* actual smoothing */\n\n    for (n = 0; n < size; n++)\n\n        out[n] = best_hist_ptr[n] + dot * (in[n] - best_hist_ptr[n]);\n\n\n\n    return 0;\n\n}\n", "idx": 7894}
{"project": "FFmpeg", "commit_id": "b505f15b1530d72682b3314e84936f80fe6e43b2", "target": 1, "func": "static av_always_inline void thread_park_workers(SliceThreadContext *c, int thread_count)\n\n{\n\n    while (c->current_job != thread_count + c->job_count)\n\n        pthread_cond_wait(&c->last_job_cond, &c->current_job_lock);\n\n    pthread_mutex_unlock(&c->current_job_lock);\n\n}\n", "idx": 7905}
{"project": "FFmpeg", "commit_id": "c0170d09738c74280af78c6f64914c52a9b6e075", "target": 0, "func": "int av_image_get_linesize(enum PixelFormat pix_fmt, int width, int plane)\n\n{\n\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt];\n\n    int max_step     [4];       /* max pixel step for each plane */\n\n    int max_step_comp[4];       /* the component for each plane which has the max pixel step */\n\n    int s, linesize;\n\n\n\n    if ((unsigned)pix_fmt >= PIX_FMT_NB || desc->flags & PIX_FMT_HWACCEL)\n\n        return AVERROR(EINVAL);\n\n\n\n    av_image_fill_max_pixsteps(max_step, max_step_comp, desc);\n\n    s = (max_step_comp[plane] == 1 || max_step_comp[plane] == 2) ? desc->log2_chroma_w : 0;\n\n    linesize = max_step[plane] * (((width + (1 << s) - 1)) >> s);\n\n    if (desc->flags & PIX_FMT_BITSTREAM)\n\n        linesize = (linesize + 7) >> 3;\n\n    return linesize;\n\n}\n", "idx": 7906}
{"project": "FFmpeg", "commit_id": "695af8eed642ff0104834495652d1ee784a4c14d", "target": 0, "func": "static int field_end(H264Context *h, int in_setup)\n\n{\n\n    MpegEncContext *const s     = &h->s;\n\n    AVCodecContext *const avctx = s->avctx;\n\n    int err = 0;\n\n    s->mb_y = 0;\n\n\n\n    if (!in_setup && !s->droppable)\n\n        ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX,\n\n                                  s->picture_structure == PICT_BOTTOM_FIELD);\n\n\n\n    if (CONFIG_H264_VDPAU_DECODER &&\n\n        s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n\n        ff_vdpau_h264_set_reference_frames(s);\n\n\n\n    if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {\n\n        if (!s->droppable) {\n\n            err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n\n            h->prev_poc_msb = h->poc_msb;\n\n            h->prev_poc_lsb = h->poc_lsb;\n\n        }\n\n        h->prev_frame_num_offset = h->frame_num_offset;\n\n        h->prev_frame_num        = h->frame_num;\n\n        h->outputed_poc          = h->next_outputed_poc;\n\n    }\n\n\n\n    if (avctx->hwaccel) {\n\n        if (avctx->hwaccel->end_frame(avctx) < 0)\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"hardware accelerator failed to decode picture\\n\");\n\n    }\n\n\n\n    if (CONFIG_H264_VDPAU_DECODER &&\n\n        s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n\n        ff_vdpau_h264_picture_complete(s);\n\n\n\n    /*\n\n     * FIXME: Error handling code does not seem to support interlaced\n\n     * when slices span multiple rows\n\n     * The ff_er_add_slice calls don't work right for bottom\n\n     * fields; they cause massive erroneous error concealing\n\n     * Error marking covers both fields (top and bottom).\n\n     * This causes a mismatched s->error_count\n\n     * and a bad error table. Further, the error count goes to\n\n     * INT_MAX when called for bottom field, because mb_y is\n\n     * past end by one (callers fault) and resync_mb_y != 0\n\n     * causes problems for the first MB line, too.\n\n     */\n\n    if (!FIELD_PICTURE && h->current_slice)\n\n        ff_er_frame_end(s);\n\n\n\n    ff_MPV_frame_end(s);\n\n\n\n    h->current_slice = 0;\n\n\n\n    return err;\n\n}\n", "idx": 7907}
{"project": "qemu", "commit_id": "e6ae5981ea4b0f6feb223009a5108582e7644f8f", "target": 0, "func": "static inline int nvic_exec_prio(NVICState *s)\n\n{\n\n    CPUARMState *env = &s->cpu->env;\n\n    int running;\n\n\n\n    if (env->daif & PSTATE_F) { /* FAULTMASK */\n\n        running = -1;\n\n    } else if (env->daif & PSTATE_I) { /* PRIMASK */\n\n        running = 0;\n\n    } else if (env->v7m.basepri > 0) {\n\n        running = env->v7m.basepri & nvic_gprio_mask(s);\n\n    } else {\n\n        running = NVIC_NOEXC_PRIO; /* lower than any possible priority */\n\n    }\n\n    /* consider priority of active handler */\n\n    return MIN(running, s->exception_prio);\n\n}\n", "idx": 7929}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint16(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    qemu_get_be16s(f, v);\n\n    return 0;\n\n}\n", "idx": 7949}
{"project": "qemu", "commit_id": "cd245a19329edfcd968b00d05ad92de7a0e2daa1", "target": 1, "func": "void *qemu_malloc(size_t size)\n\n{\n\n    if (!size && !allow_zero_malloc()) {\n\n        abort();\n\n    }\n\n    return oom_check(malloc(size ? size : 1));\n\n}\n", "idx": 7955}
{"project": "qemu", "commit_id": "8caa05d8891d0a09dc4c00908c24c6ddfd872bbe", "target": 0, "func": "static bool timer_mod_ns_locked(QEMUTimerList *timer_list,\n\n                                QEMUTimer *ts, int64_t expire_time)\n\n{\n\n    QEMUTimer **pt, *t;\n\n\n\n    /* add the timer in the sorted list */\n\n    pt = &timer_list->active_timers;\n\n    for (;;) {\n\n        t = *pt;\n\n        if (!timer_expired_ns(t, expire_time)) {\n\n            break;\n\n        }\n\n        pt = &t->next;\n\n    }\n\n    ts->expire_time = MAX(expire_time, 0);\n\n    ts->next = *pt;\n\n    *pt = ts;\n\n\n\n    return pt == &timer_list->active_timers;\n\n}\n", "idx": 7963}
{"project": "qemu", "commit_id": "a980f7f2c2f4d7e9a1eba4f804cd66dbd458b6d4", "target": 0, "func": "static void qvirtio_9p_start(void)\n\n{\n\n    char *args;\n\n\n\n    test_share = g_strdup(\"/tmp/qtest.XXXXXX\");\n\n    g_assert_nonnull(mkdtemp(test_share));\n\n\n\n    args = g_strdup_printf(\"-fsdev local,id=fsdev0,security_model=none,path=%s \"\n\n                           \"-device virtio-9p-pci,fsdev=fsdev0,mount_tag=%s\",\n\n                           test_share, mount_tag);\n\n\n\n    qtest_start(args);\n\n    g_free(args);\n\n}\n", "idx": 7969}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "float64 int32_to_float64( int32 a STATUS_PARAM )\n\n{\n\n    flag zSign;\n\n    uint32 absA;\n\n    int8 shiftCount;\n\n    bits64 zSig;\n\n\n\n    if ( a == 0 ) return 0;\n\n    zSign = ( a < 0 );\n\n    absA = zSign ? - a : a;\n\n    shiftCount = countLeadingZeros32( absA ) + 21;\n\n    zSig = absA;\n\n    return packFloat64( zSign, 0x432 - shiftCount, zSig<<shiftCount );\n\n\n\n}\n", "idx": 7995}
{"project": "qemu", "commit_id": "577d0a38070d1d6c4c7fab5c2054380770b1ec6b", "target": 0, "func": "void blkconf_serial(BlockConf *conf, char **serial)\n\n{\n\n    DriveInfo *dinfo;\n\n\n\n    if (!*serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = g_strdup(dinfo->serial);\n\n        }\n\n    }\n\n}\n", "idx": 7998}
{"project": "qemu", "commit_id": "4cae4d5acaea23f3def84c8dc67ef5106323e5cb", "target": 1, "func": "static void peripheral_device_del_completion(ReadLineState *rs,\n\n                                             const char *str, size_t len)\n\n{\n\n    Object *peripheral;\n\n    GSList *list = NULL, *item;\n\n\n\n    peripheral = object_resolve_path(\"/machine/peripheral/\", NULL);\n\n    if (peripheral == NULL) {\n\n        return;\n\n    }\n\n\n\n    object_child_foreach(peripheral, qdev_build_hotpluggable_device_list,\n\n                         &list);\n\n\n\n    for (item = list; item; item = g_slist_next(item)) {\n\n        DeviceState *dev = item->data;\n\n\n\n        if (dev->id && !strncmp(str, dev->id, len)) {\n\n            readline_add_completion(rs, dev->id);\n\n        }\n\n    }\n\n\n\n    g_slist_free(list);\n\n}\n", "idx": 8024}
{"project": "FFmpeg", "commit_id": "705f5e5e155f6f280a360af220fc5b30cfcee702", "target": 0, "func": "av_cold void ff_synth_filter_init(SynthFilterContext *c)\n\n{\n\n    c->synth_filter_float = synth_filter_float;\n\n\n\n    if (ARCH_ARM) ff_synth_filter_init_arm(c);\n\n    if (ARCH_X86) ff_synth_filter_init_x86(c);\n\n}\n", "idx": 8030}
{"project": "qemu", "commit_id": "cfaf6d36ae761da1033159d85d670706ffb24fb9", "target": 0, "func": "static void tcp_accept_incoming_migration(void *opaque)\n\n{\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int s = (unsigned long)opaque;\n\n    QEMUFile *f;\n\n    int c, ret;\n\n\n\n    do {\n\n        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);\n\n    } while (c == -1 && socket_error() == EINTR);\n\n\n\n    DPRINTF(\"accepted migration\\n\");\n\n\n\n    if (c == -1) {\n\n        fprintf(stderr, \"could not accept migration connection\\n\");\n\n        return;\n\n    }\n\n\n\n    f = qemu_fopen_socket(c);\n\n    if (f == NULL) {\n\n        fprintf(stderr, \"could not qemu_fopen socket\\n\");\n\n        goto out;\n\n    }\n\n\n\n    ret = qemu_loadvm_state(f);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        goto out_fopen;\n\n    }\n\n    qemu_announce_self();\n\n    DPRINTF(\"successfully loaded vm state\\n\");\n\n\n\n    /* we've successfully migrated, close the server socket */\n\n    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);\n\n    close(s);\n\n    if (autostart)\n\n        vm_start();\n\n\n\nout_fopen:\n\n    qemu_fclose(f);\n\nout:\n\n    close(c);\n\n}\n", "idx": 8044}
{"project": "FFmpeg", "commit_id": "90527811d7db0da5d770235261c4b718b0869a99", "target": 0, "func": "int main(int argc, char** argv)\n\n{\n\n    FILE *f= fopen(argv[1], \"rb+\");\n\n    int count= atoi(argv[2]);\n\n    int maxburst= atoi(argv[3]);\n\n    int length;\n\n\n\n    srand (time (0));\n\n\n\n    fseek(f, 0, SEEK_END);\n\n    length= ftell(f);\n\n    fseek(f, 0, SEEK_SET);\n\n\n\n    while(count--){\n\n        int burst= 1 + random() * (uint64_t) (abs(maxburst)-1) / RAND_MAX;\n\n        int pos= random() * (uint64_t) length / RAND_MAX;\n\n        fseek(f, pos, SEEK_SET);\n\n\n\n        if(maxburst<0) burst= -maxburst;\n\n\n\n        if(pos + burst > length)\n\n            continue;\n\n\n\n        while(burst--){\n\n            int val= random() * 256ULL / RAND_MAX;\n\n\n\n            if(maxburst<0) val=0;\n\n\n\n            fwrite(&val, 1, 1, f);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 8065}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_info_network(int argc, const char **argv)\n\n{\n\n    int i, j;\n\n    NetDriverState *nd;\n\n    \n\n    for(i = 0; i < nb_nics; i++) {\n\n        nd = &nd_table[i];\n\n        term_printf(\"%d: ifname=%s macaddr=\", i, nd->ifname);\n\n        for(j = 0; j < 6; j++) {\n\n            if (j > 0)\n\n                term_printf(\":\");\n\n            term_printf(\"%02x\", nd->macaddr[j]);\n\n        }\n\n        term_printf(\"\\n\");\n\n    }\n\n}\n", "idx": 8073}
{"project": "qemu", "commit_id": "86a6a9bf551ffa183880480b37c5836d3916687a", "target": 0, "func": "void xen_invalidate_map_cache(void)\n\n{\n\n    unsigned long i;\n\n    MapCacheRev *reventry;\n\n\n\n    /* Flush pending AIO before destroying the mapcache */\n\n    bdrv_drain_all();\n\n\n\n    QTAILQ_FOREACH(reventry, &mapcache->locked_entries, next) {\n\n        DPRINTF(\"There should be no locked mappings at this time, \"\n\n                \"but \"TARGET_FMT_plx\" -> %p is present\\n\",\n\n                reventry->paddr_index, reventry->vaddr_req);\n\n    }\n\n\n\n    mapcache_lock();\n\n\n\n    for (i = 0; i < mapcache->nr_buckets; i++) {\n\n        MapCacheEntry *entry = &mapcache->entry[i];\n\n\n\n        if (entry->vaddr_base == NULL) {\n\n            continue;\n\n        }\n\n        if (entry->lock > 0) {\n\n            continue;\n\n        }\n\n\n\n        if (munmap(entry->vaddr_base, entry->size) != 0) {\n\n            perror(\"unmap fails\");\n\n            exit(-1);\n\n        }\n\n\n\n        entry->paddr_index = 0;\n\n        entry->vaddr_base = NULL;\n\n        entry->size = 0;\n\n        g_free(entry->valid_mapping);\n\n        entry->valid_mapping = NULL;\n\n    }\n\n\n\n    mapcache->last_entry = NULL;\n\n\n\n    mapcache_unlock();\n\n}\n", "idx": 8081}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_clkdsp_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x04:\t/* DSP_IDLECT1 */\n\n        return s->clkm.dsp_idlect1;\n\n\n\n    case 0x08:\t/* DSP_IDLECT2 */\n\n        return s->clkm.dsp_idlect2;\n\n\n\n    case 0x14:\t/* DSP_RSTCT2 */\n\n        return s->clkm.dsp_rstct2;\n\n\n\n    case 0x18:\t/* DSP_SYSST */\n\n        return (s->clkm.clocking_scheme << 11) | s->clkm.cold_start |\n\n                (s->cpu->env.halted << 6);      /* Quite useless... */\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 8086}
{"project": "qemu", "commit_id": "aab2293687ee54a409f3fb53a1ab3595b595e0fb", "target": 1, "func": "static int fd_close(MigrationState *s)\n\n{\n\n    DPRINTF(\"fd_close\\n\");\n\n    if (s->fd != -1) {\n\n        close(s->fd);\n\n        s->fd = -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8088}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "struct USBEndpoint *usb_ep_get(USBDevice *dev, int pid, int ep)\n\n{\n\n    struct USBEndpoint *eps = pid == USB_TOKEN_IN ? dev->ep_in : dev->ep_out;\n\n    if (ep == 0) {\n\n        return &dev->ep_ctl;\n\n    }\n\n    assert(pid == USB_TOKEN_IN || pid == USB_TOKEN_OUT);\n\n    assert(ep > 0 && ep <= USB_MAX_ENDPOINTS);\n\n    return eps + ep - 1;\n\n}\n", "idx": 8149}
{"project": "FFmpeg", "commit_id": "80ca19f766aea8f4724aac1b3faa772d25163c8a", "target": 0, "func": "static int ipvideo_decode_block_opcode_0xB(IpvideoContext *s)\n\n{\n\n    int y;\n\n\n\n    /* 64-color encoding (each pixel in block is a different color) */\n\n    CHECK_STREAM_PTR(64);\n\n\n\n    for (y = 0; y < 8; y++) {\n\n        memcpy(s->pixel_ptr, s->stream_ptr, 8);\n\n        s->stream_ptr += 8;\n\n        s->pixel_ptr  += s->stride;\n\n    }\n\n\n\n    /* report success */\n\n    return 0;\n\n}\n", "idx": 8162}
{"project": "FFmpeg", "commit_id": "9cbb3fce5965f4e1423cace3d1dc340a7a8091f4", "target": 1, "func": "uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type,\n\n                                 int size)\n\n{\n\n    int elems = pkt->side_data_elems;\n\n\n\n    if ((unsigned)elems + 1 > INT_MAX / sizeof(*pkt->side_data))\n\n        return NULL;\n\n    if ((unsigned)size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)\n\n        return NULL;\n\n\n\n    pkt->side_data = av_realloc(pkt->side_data,\n\n                                (elems + 1) * sizeof(*pkt->side_data));\n\n    if (!pkt->side_data)\n\n        return NULL;\n\n\n\n    pkt->side_data[elems].data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!pkt->side_data[elems].data)\n\n        return NULL;\n\n    pkt->side_data[elems].size = size;\n\n    pkt->side_data[elems].type = type;\n\n    pkt->side_data_elems++;\n\n\n\n    return pkt->side_data[elems].data;\n\n}\n", "idx": 8168}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void pointer_event(VncState *vs, int button_mask, int x, int y)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON_MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = 0x01,\n\n        [INPUT_BUTTON_MIDDLE]     = 0x02,\n\n        [INPUT_BUTTON_RIGHT]      = 0x04,\n\n        [INPUT_BUTTON_WHEEL_UP]   = 0x08,\n\n        [INPUT_BUTTON_WHEEL_DOWN] = 0x10,\n\n    };\n\n    QemuConsole *con = vs->vd->dcl.con;\n\n    int width = surface_width(vs->vd->ds);\n\n    int height = surface_height(vs->vd->ds);\n\n\n\n    if (vs->last_bmask != button_mask) {\n\n        qemu_input_update_buttons(con, bmap, vs->last_bmask, button_mask);\n\n        vs->last_bmask = button_mask;\n\n    }\n\n\n\n    if (vs->absolute) {\n\n        qemu_input_queue_abs(con, INPUT_AXIS_X, x, width);\n\n        qemu_input_queue_abs(con, INPUT_AXIS_Y, y, height);\n\n    } else if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE)) {\n\n        qemu_input_queue_rel(con, INPUT_AXIS_X, x - 0x7FFF);\n\n        qemu_input_queue_rel(con, INPUT_AXIS_Y, y - 0x7FFF);\n\n    } else {\n\n        if (vs->last_x != -1) {\n\n            qemu_input_queue_rel(con, INPUT_AXIS_X, x - vs->last_x);\n\n            qemu_input_queue_rel(con, INPUT_AXIS_Y, y - vs->last_y);\n\n        }\n\n        vs->last_x = x;\n\n        vs->last_y = y;\n\n    }\n\n    qemu_input_event_sync();\n\n}\n", "idx": 8173}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_uint16(Visitor *v, uint16_t *obj, const char *name, Error **errp)\n\n{\n\n    int64_t value;\n\n    if (!error_is_set(errp)) {\n\n        if (v->type_uint16) {\n\n            v->type_uint16(v, obj, name, errp);\n\n        } else {\n\n            value = *obj;\n\n            v->type_int(v, &value, name, errp);\n\n            if (value < 0 || value > UINT16_MAX) {\n\n                error_set(errp, QERR_INVALID_PARAMETER_VALUE, name ? name : \"null\",\n\n                          \"uint16_t\");\n\n                return;\n\n            }\n\n            *obj = value;\n\n        }\n\n    }\n\n}\n", "idx": 8177}
{"project": "FFmpeg", "commit_id": "ed7fa39c2dd63607fd5c5ed3c607a11a8a33bbe3", "target": 0, "func": "static int mov_write_avcc_tag(ByteIOContext *pb, MOVTrack *track)\n\n{\n\n    offset_t pos = url_ftell(pb);\n\n\n\n    put_be32(pb, 0);\n\n    put_tag(pb, \"avcC\");\n\n    if (track->vosLen > 6) {\n\n        /* check for h264 start code */\n\n        if (AV_RB32(track->vosData) == 0x00000001) {\n\n            uint8_t *buf, *end;\n\n            uint32_t sps_size=0, pps_size=0;\n\n            uint8_t *sps=0, *pps=0;\n\n\n\n            avc_parse_nal_units(&track->vosData, &track->vosLen);\n\n            buf = track->vosData;\n\n            end = track->vosData + track->vosLen;\n\n\n\n            /* look for sps and pps */\n\n            while (buf < end) {\n\n                unsigned int size;\n\n                uint8_t nal_type;\n\n                size = AV_RB32(buf);\n\n                nal_type = buf[4] & 0x1f;\n\n                if (nal_type == 7) { /* SPS */\n\n                    sps = buf + 4;\n\n                    sps_size = size;\n\n                } else if (nal_type == 8) { /* PPS */\n\n                    pps = buf + 4;\n\n                    pps_size = size;\n\n                }\n\n                buf += size + 4;\n\n            }\n\n            assert(sps);\n\n            assert(pps);\n\n\n\n            put_byte(pb, 1); /* version */\n\n            put_byte(pb, sps[1]); /* profile */\n\n            put_byte(pb, sps[2]); /* profile compat */\n\n            put_byte(pb, sps[3]); /* level */\n\n            put_byte(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */\n\n            put_byte(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */\n\n\n\n            put_be16(pb, sps_size);\n\n            put_buffer(pb, sps, sps_size);\n\n            put_byte(pb, 1); /* number of pps */\n\n            put_be16(pb, pps_size);\n\n            put_buffer(pb, pps, pps_size);\n\n        } else {\n\n            put_buffer(pb, track->vosData, track->vosLen);\n\n        }\n\n    }\n\n    return updateSize(pb, pos);\n\n}\n", "idx": 8190}
{"project": "FFmpeg", "commit_id": "f3ad901a32c95239f302f173b866b82fb1f6cdf9", "target": 0, "func": "static inline int compress_coeffs(int *coef, int order, int c_bits)\n\n{\n\n    int i, res = 0;\n\n    const int low_idx   = c_bits ?  4 : 2;\n\n    const int shift_val = c_bits ?  8 : 4;\n\n    const int high_idx  = c_bits ? 11 : 5;\n\n    for (i = 0; i < order; i++)\n\n        if (coef[i] < low_idx || coef[i] > high_idx)\n\n            res++;\n\n    if (res == order)\n\n        for (i = 0; i < order; i++)\n\n            coef[i] -= (coef[i] > high_idx) ? shift_val : 0;\n\n    return res == order;\n\n}\n", "idx": 8196}
{"project": "FFmpeg", "commit_id": "7f58eb3c2b552f232905731b5944307e72c590a0", "target": 1, "func": "static av_cold int indeo3_decode_end(AVCodecContext *avctx)\n{\n    Indeo3DecodeContext *s = avctx->priv_data;\n    iv_free_func(s);\n    return 0;\n}", "idx": 8218}
{"project": "qemu", "commit_id": "bd83b3620517ef9f2079cfda465953e60263f623", "target": 1, "func": "void qemu_iovec_destroy(QEMUIOVector *qiov)\n\n{\n\n    assert(qiov->nalloc != -1);\n\n\n\n\n    g_free(qiov->iov);\n\n\n\n}", "idx": 8226}
{"project": "qemu", "commit_id": "b0f2027cde31c645524256763672e09eeb204a9a", "target": 1, "func": "bool virtio_blk_data_plane_create(VirtIODevice *vdev, VirtIOBlkConf *blk,\n                                  VirtIOBlockDataPlane **dataplane)\n{\n    VirtIOBlockDataPlane *s;\n    int fd;\n    *dataplane = NULL;\n    if (!blk->data_plane) {\n        return true;\n    if (blk->scsi) {\n        error_report(\"device is incompatible with x-data-plane, use scsi=off\");\n    if (blk->config_wce) {\n        error_report(\"device is incompatible with x-data-plane, \"\n                     \"use config-wce=off\");\n    fd = raw_get_aio_fd(blk->conf.bs);\n    if (fd < 0) {\n        error_report(\"drive is incompatible with x-data-plane, \"\n                     \"use format=raw,cache=none,aio=native\");\n    s = g_new0(VirtIOBlockDataPlane, 1);\n    s->vdev = vdev;\n    s->fd = fd;\n    s->blk = blk;\n    /* Prevent block operations that conflict with data plane thread */\n    bdrv_set_in_use(blk->conf.bs, 1);\n    *dataplane = s;\n    return true;", "idx": 8233}
{"project": "qemu", "commit_id": "7c560456707bfe53eb1728fcde759be7d9418b62", "target": 0, "func": "static void ecc_mem_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    printf(\"ECC: Unsupported write 0x\" TARGET_FMT_plx \" %02x\\n\",\n\n           addr, val & 0xff);\n\n}\n", "idx": 8250}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static int bdrv_write_em(BlockDriverState *bs, int64_t sector_num,\n\n                         const uint8_t *buf, int nb_sectors)\n\n{\n\n    int async_ret;\n\n    BlockDriverAIOCB *acb;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n\n\n    async_ret = NOT_DONE;\n\n    iov.iov_base = (void *)buf;\n\n    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    acb = bs->drv->bdrv_aio_writev(bs, sector_num, &qiov, nb_sectors,\n\n                                   bdrv_rw_em_cb, &async_ret);\n\n    if (acb == NULL) {\n\n        async_ret = -1;\n\n        goto fail;\n\n    }\n\n    while (async_ret == NOT_DONE) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\nfail:\n\n    return async_ret;\n\n}\n", "idx": 8255}
{"project": "qemu", "commit_id": "0cd09c3a6cc2230ba38c462fc410b4acce59eb6f", "target": 0, "func": "static uint32_t virtio_9p_get_features(VirtIODevice *vdev, uint32_t features)\n\n{\n\n    features |= 1 << VIRTIO_9P_MOUNT_TAG;\n\n    return features;\n\n}\n", "idx": 8262}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "AVOpenCLExternalEnv *av_opencl_alloc_external_env(void)\n\n{\n\n    AVOpenCLExternalEnv *ext = av_mallocz(sizeof(AVOpenCLExternalEnv));\n\n    if (!ext) {\n\n        av_log(&openclutils, AV_LOG_ERROR,\n\n         \"Could not malloc external opencl environment data space\\n\");\n\n    }\n\n    return ext;\n\n}\n", "idx": 8276}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t error_mem_read(void *opaque, target_phys_addr_t addr,\n\n                               unsigned size)\n\n{\n\n    abort();\n\n}\n", "idx": 8284}
{"project": "qemu", "commit_id": "9f1d4b1d6939d39fe570d886f6a651f4764bcbcb", "target": 0, "func": "static void openpic_set_irq(void *opaque, int n_IRQ, int level)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    IRQSource *src;\n\n\n\n    if (n_IRQ >= MAX_IRQ) {\n\n        fprintf(stderr, \"%s: IRQ %d out of range\\n\", __func__, n_IRQ);\n\n        abort();\n\n    }\n\n\n\n    src = &opp->src[n_IRQ];\n\n    DPRINTF(\"openpic: set irq %d = %d ivpr=0x%08x\\n\",\n\n            n_IRQ, level, src->ivpr);\n\n    if (src->level) {\n\n        /* level-sensitive irq */\n\n        src->pending = level;\n\n        if (!level) {\n\n            src->ivpr &= ~IVPR_ACTIVITY_MASK;\n\n        }\n\n    } else {\n\n        /* edge-sensitive irq */\n\n        if (level) {\n\n            src->pending = 1;\n\n        }\n\n    }\n\n    openpic_update_irq(opp, n_IRQ);\n\n}\n", "idx": 8297}
{"project": "FFmpeg", "commit_id": "d31dbec3742e488156621b9ca21069f8c05aabf0", "target": 0, "func": "static int context_init(H264Context *h){\n\n    CHECKED_ALLOCZ(h->top_borders[0], h->s.mb_width * (16+8+8) * sizeof(uint8_t))\n\n    CHECKED_ALLOCZ(h->top_borders[1], h->s.mb_width * (16+8+8) * sizeof(uint8_t))\n\n\n\n    return 0;\n\nfail:\n\n    return -1; // free_tables will clean up for us\n\n}\n", "idx": 8311}
{"project": "FFmpeg", "commit_id": "fd34dbea58e097609ff09cf7dcc59f74930195d3", "target": 1, "func": "static int mxf_read_material_package(void *arg, AVIOContext *pb, int tag, int size, UID uid)\n\n{\n\n    MXFPackage *package = arg;\n\n    switch(tag) {\n\n    case 0x4403:\n\n        package->tracks_count = avio_rb32(pb);\n\n        if (package->tracks_count >= UINT_MAX / sizeof(UID))\n\n            return -1;\n\n        package->tracks_refs = av_malloc(package->tracks_count * sizeof(UID));\n\n        if (!package->tracks_refs)\n\n            return -1;\n\n        avio_skip(pb, 4); /* useless size of objects, always 16 according to specs */\n\n        avio_read(pb, (uint8_t *)package->tracks_refs, package->tracks_count * sizeof(UID));\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8366}
{"project": "qemu", "commit_id": "9f14b0add1dcdbfa2ee61051d068211fb0a1fcc9", "target": 0, "func": "static void rng_egd_finalize(Object *obj)\n\n{\n\n    RngEgd *s = RNG_EGD(obj);\n\n\n\n    if (s->chr) {\n\n        qemu_chr_add_handlers(s->chr, NULL, NULL, NULL, NULL);\n\n        qemu_chr_fe_release(s->chr);\n\n    }\n\n\n\n    g_free(s->chr_name);\n\n\n\n    rng_egd_free_requests(s);\n\n}\n", "idx": 8374}
{"project": "FFmpeg", "commit_id": "472ea1284e925297b08921b7189f57f6789c898c", "target": 1, "func": "static int cinepak_decode_strip (CinepakContext *s,\n                                 cvid_strip_t *strip, uint8_t *data, int size)\n{\n    uint8_t *eod = (data + size);\n    int      chunk_id, chunk_size;\n    /* coordinate sanity checks */\n    if (strip->x1 >= s->width  || strip->x2 > s->width  ||\n        strip->y1 >= s->height || strip->y2 > s->height ||\n        strip->x1 >= strip->x2 || strip->y1 >= strip->y2)\n    while ((data + 4) <= eod) {\n        chunk_id   = BE_16 (&data[0]);\n        chunk_size = BE_16 (&data[2]) - 4;\n        data      += 4;\n        chunk_size = ((data + chunk_size) > eod) ? (eod - data) : chunk_size;\n        switch (chunk_id) {\n        case 0x2000:\n        case 0x2100:\n        case 0x2400:\n        case 0x2500:\n            cinepak_decode_codebook (strip->v4_codebook, chunk_id, \n                chunk_size, data);\n            break;\n        case 0x2200:\n        case 0x2300:\n        case 0x2600:\n        case 0x2700:\n            cinepak_decode_codebook (strip->v1_codebook, chunk_id, \n                chunk_size, data);\n            break;\n        case 0x3000:\n        case 0x3100:\n        case 0x3200:\n            return cinepak_decode_vectors (s, strip, chunk_id, \n                chunk_size, data);\n        }\n        data += chunk_size;\n    }\n}", "idx": 8419}
{"project": "FFmpeg", "commit_id": "c3e6e8f06c42499bd020fd0b37f9542150e6067b", "target": 0, "func": "void *av_realloc_array(void *ptr, size_t nmemb, size_t size)\n\n{\n\n    if (size <= 0 || nmemb >= INT_MAX / size)\n\n        return NULL;\n\n    return av_realloc(ptr, nmemb * size);\n\n}\n", "idx": 8424}
{"project": "qemu", "commit_id": "f278d4947fff814dcde2ef2acad36d172ff8be35", "target": 1, "func": "int pic_read_irq(DeviceState *d)\n\n{\n\n    PICCommonState *s = DO_UPCAST(PICCommonState, dev.qdev, d);\n\n    int irq, irq2, intno;\n\n\n\n    irq = pic_get_irq(s);\n\n    if (irq >= 0) {\n\n        if (irq == 2) {\n\n            irq2 = pic_get_irq(slave_pic);\n\n            if (irq2 >= 0) {\n\n                pic_intack(slave_pic, irq2);\n\n            } else {\n\n                /* spurious IRQ on slave controller */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                irq2 = 7;\n\n\n            intno = slave_pic->irq_base + irq2;\n\n        } else {\n\n            intno = s->irq_base + irq;\n\n\n        pic_intack(s, irq);\n\n    } else {\n\n        /* spurious IRQ on host controller */\n\n\n\n\n        irq = 7;\n\n        intno = s->irq_base + irq;\n\n\n\n\n#if defined(DEBUG_PIC) || defined(DEBUG_IRQ_LATENCY)\n\n    if (irq == 2) {\n\n        irq = irq2 + 8;\n\n\n#endif\n\n#ifdef DEBUG_IRQ_LATENCY\n\n    printf(\"IRQ%d latency=%0.3fus\\n\",\n\n           irq,\n\n           (double)(qemu_get_clock_ns(vm_clock) -\n\n                    irq_time[irq]) * 1000000.0 / get_ticks_per_sec());\n\n#endif\n\n    DPRINTF(\"pic_interrupt: irq=%d\\n\", irq);\n\n    return intno;\n", "idx": 8440}
{"project": "qemu", "commit_id": "b021d1c04452276f4926eed2d104ccbd1037a6e1", "target": 1, "func": "void memory_region_notify_one(IOMMUNotifier *notifier,\n\n                              IOMMUTLBEntry *entry)\n\n{\n\n    IOMMUNotifierFlag request_flags;\n\n\n\n    /*\n\n     * Skip the notification if the notification does not overlap\n\n     * with registered range.\n\n     */\n\n    if (notifier->start > entry->iova + entry->addr_mask + 1 ||\n\n        notifier->end < entry->iova) {\n\n        return;\n\n    }\n\n\n\n    if (entry->perm & IOMMU_RW) {\n\n        request_flags = IOMMU_NOTIFIER_MAP;\n\n    } else {\n\n        request_flags = IOMMU_NOTIFIER_UNMAP;\n\n    }\n\n\n\n    if (notifier->notifier_flags & request_flags) {\n\n        notifier->notify(notifier, entry);\n\n    }\n\n}\n", "idx": 8449}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void udp_chr_close(CharDriverState *chr)\n\n{\n\n    NetCharDriver *s = chr->opaque;\n\n    if (s->tag) {\n\n        g_source_remove(s->tag);\n\n        s->tag = 0;\n\n    }\n\n    if (s->chan) {\n\n        g_io_channel_unref(s->chan);\n\n        closesocket(s->fd);\n\n    }\n\n    g_free(s);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n}\n", "idx": 8451}
{"project": "FFmpeg", "commit_id": "c8f9f9b91a3d3254e62f4fbcd6065a504164b06b", "target": 1, "func": "static int vmdaudio_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 uint8_t *buf, int buf_size)\n\n{\n\n    VmdAudioContext *s = (VmdAudioContext *)avctx->priv_data;\n\n    unsigned int sound_flags;\n\n    unsigned char *output_samples = (unsigned char *)data;\n\n\n\n    /* point to the start of the encoded data */\n\n    unsigned char *p = buf + 16;\n\n    unsigned char *p_end = buf + buf_size;\n\n\n\n    if (buf_size < 16)\n\n        return buf_size;\n\n\n\n    if (buf[6] == 1) {\n\n        /* the chunk contains audio */\n\n        *data_size = vmdaudio_loadsound(s, output_samples, p, 0);\n\n    } else if (buf[6] == 2) {\n\n        /* the chunk contains audio and silence mixed together */\n\n        sound_flags = LE_32(p);\n\n        p += 4;\n\n\n\n        /* do something with extrabufs here? */\n\n\n\n        while (p < p_end) {\n\n            if (sound_flags & 0x01)\n\n                /* silence */\n\n                *data_size += vmdaudio_loadsound(s, output_samples, p, 1);\n\n            else {\n\n                /* audio */\n\n                *data_size += vmdaudio_loadsound(s, output_samples, p, 0);\n\n                p += s->block_align;\n\n            }\n\n            output_samples += (s->block_align * s->bits / 8);\n\n            sound_flags >>= 1;\n\n        }\n\n    } else if (buf[6] == 3) {\n\n        /* silent chunk */\n\n        *data_size = vmdaudio_loadsound(s, output_samples, p, 1);\n\n    }\n\n\n\n    return buf_size;\n\n}\n", "idx": 8460}
{"project": "qemu", "commit_id": "24355b79bdaf6ab12f7c610b032fc35ec045cd55", "target": 1, "func": "static void scsi_write_same_complete(void *opaque, int ret)\n\n{\n\n    WriteSameCBData *data = opaque;\n\n    SCSIDiskReq *r = data->r;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    assert(r->req.aiocb != NULL);\n\n    r->req.aiocb = NULL;\n\n    aio_context_acquire(blk_get_aio_context(s->qdev.conf.blk));\n\n    if (scsi_disk_req_check_error(r, ret, true)) {\n\n        goto done;\n\n    }\n\n\n\n    block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);\n\n\n\n    data->nb_sectors -= data->iov.iov_len / 512;\n\n    data->sector += data->iov.iov_len / 512;\n\n    data->iov.iov_len = MIN(data->nb_sectors * 512, data->iov.iov_len);\n\n    if (data->iov.iov_len) {\n\n        block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,\n\n                         data->iov.iov_len, BLOCK_ACCT_WRITE);\n\n        /* Reinitialize qiov, to handle unaligned WRITE SAME request\n\n         * where final qiov may need smaller size */\n\n        qemu_iovec_init_external(&data->qiov, &data->iov, 1);\n\n        r->req.aiocb = blk_aio_pwritev(s->qdev.conf.blk,\n\n                                       data->sector << BDRV_SECTOR_BITS,\n\n                                       &data->qiov, 0,\n\n                                       scsi_write_same_complete, data);\n\n\n        return;\n\n    }\n\n\n\n    scsi_req_complete(&r->req, GOOD);\n\n\n\ndone:\n\n    scsi_req_unref(&r->req);\n\n    qemu_vfree(data->iov.iov_base);\n\n    g_free(data);\n\n\n}", "idx": 8469}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "void xen_be_unbind_evtchn(struct XenDevice *xendev)\n\n{\n\n    if (xendev->local_port == -1) {\n\n        return;\n\n    }\n\n    qemu_set_fd_handler(xc_evtchn_fd(xendev->evtchndev), NULL, NULL, NULL);\n\n    xc_evtchn_unbind(xendev->evtchndev, xendev->local_port);\n\n    xen_be_printf(xendev, 2, \"unbind evtchn port %d\\n\", xendev->local_port);\n\n    xendev->local_port = -1;\n\n}\n", "idx": 8566}
{"project": "FFmpeg", "commit_id": "baf4c489e5f468a208596cd128a6f1c49e6ae35b", "target": 0, "func": "int avio_printf(AVIOContext *s, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    char buf[4096];\n\n    int ret;\n\n\n\n    va_start(ap, fmt);\n\n    ret = vsnprintf(buf, sizeof(buf), fmt, ap);\n\n    va_end(ap);\n\n    avio_write(s, buf, strlen(buf));\n\n    return ret;\n\n}\n", "idx": 8573}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "static int ppc_hash64_check_prot(int prot, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n    if (access_type == ACCESS_CODE) {\n\n        if (prot & PAGE_EXEC) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else if (rw) {\n\n        if (prot & PAGE_WRITE) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else {\n\n        if (prot & PAGE_READ) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8574}
{"project": "qemu", "commit_id": "d7b61ecc61f84d23f98f1ee270fb48b41834ca00", "target": 0, "func": "static int unin_agp_pci_host_init(PCIDevice *d)\n\n{\n\n    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_APPLE);\n\n    pci_config_set_device_id(d->config, PCI_DEVICE_ID_APPLE_UNI_N_AGP);\n\n    d->config[0x08] = 0x00; // revision\n\n    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);\n\n    d->config[0x0C] = 0x08; // cache_line_size\n\n    d->config[0x0D] = 0x10; // latency_timer\n\n    //    d->config[0x34] = 0x80; // capabilities_pointer\n\n    return 0;\n\n}\n", "idx": 8624}
{"project": "qemu", "commit_id": "8978b34af3250354e0b67340a7e920f909beda13", "target": 0, "func": "static void float_number(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        double decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"32.43\", 32.43 },\n\n        { \"0.222\", 0.222 },\n\n        { \"-32.12313\", -32.12313 },\n\n        { \"-32.20e-10\", -32.20e-10, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QFloat *qfloat;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n        qfloat = qobject_to_qfloat(obj);\n\n        g_assert(qfloat_get_double(qfloat) == test_cases[i].decoded);\n\n\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(obj);\n\n            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qfloat);\n\n    }\n\n}\n", "idx": 8625}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void ecc_mem_write(void *opaque, target_phys_addr_t addr, uint64_t val,\n\n                          unsigned size)\n\n{\n\n    ECCState *s = opaque;\n\n\n\n    switch (addr >> 2) {\n\n    case ECC_MER:\n\n        if (s->version == ECC_MCC)\n\n            s->regs[ECC_MER] = (val & ECC_MER_MASK_0);\n\n        else if (s->version == ECC_EMC)\n\n            s->regs[ECC_MER] = s->version | (val & ECC_MER_MASK_1);\n\n        else if (s->version == ECC_SMC)\n\n            s->regs[ECC_MER] = s->version | (val & ECC_MER_MASK_2);\n\n        trace_ecc_mem_writel_mer(val);\n\n        break;\n\n    case ECC_MDR:\n\n        s->regs[ECC_MDR] =  val & ECC_MDR_MASK;\n\n        trace_ecc_mem_writel_mdr(val);\n\n        break;\n\n    case ECC_MFSR:\n\n        s->regs[ECC_MFSR] =  val;\n\n        qemu_irq_lower(s->irq);\n\n        trace_ecc_mem_writel_mfsr(val);\n\n        break;\n\n    case ECC_VCR:\n\n        s->regs[ECC_VCR] =  val;\n\n        trace_ecc_mem_writel_vcr(val);\n\n        break;\n\n    case ECC_DR:\n\n        s->regs[ECC_DR] =  val;\n\n        trace_ecc_mem_writel_dr(val);\n\n        break;\n\n    case ECC_ECR0:\n\n        s->regs[ECC_ECR0] =  val;\n\n        trace_ecc_mem_writel_ecr0(val);\n\n        break;\n\n    case ECC_ECR1:\n\n        s->regs[ECC_ECR0] =  val;\n\n        trace_ecc_mem_writel_ecr1(val);\n\n        break;\n\n    }\n\n}\n", "idx": 8647}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_op_mull_T0_T1(void)\n\n{\n\n    TCGv tmp1 = tcg_temp_new(TCG_TYPE_I64);\n\n    TCGv tmp2 = tcg_temp_new(TCG_TYPE_I64);\n\n\n\n    tcg_gen_extu_i32_i64(tmp1, cpu_T[0]);\n\n    tcg_gen_extu_i32_i64(tmp2, cpu_T[1]);\n\n    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n    tcg_gen_trunc_i64_i32(cpu_T[0], tmp1);\n\n    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n    tcg_gen_trunc_i64_i32(cpu_T[1], tmp1);\n\n}\n", "idx": 8666}
{"project": "FFmpeg", "commit_id": "c64b2d480b4a35d4face9928b4265a0fda3f3dd9", "target": 1, "func": "static int get_stats(AVCodecContext *avctx, int eos)\n\n{\n\n#ifdef TH_ENCCTL_2PASS_OUT\n\n    TheoraContext *h = avctx->priv_data;\n\n    uint8_t *buf;\n\n    int bytes;\n\n\n\n    bytes = th_encode_ctl(h->t_state, TH_ENCCTL_2PASS_OUT, &buf, sizeof(buf));\n\n    if (bytes < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting first pass stats\\n\");\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    if (!eos) {\n\n        void *tmp = av_fast_realloc(h->stats, &h->stats_size,\n\n                                   h->stats_offset + bytes);\n\n        if (!tmp)\n\n\n        h->stats = tmp;\n\n        memcpy(h->stats + h->stats_offset, buf, bytes);\n\n        h->stats_offset += bytes;\n\n    } else {\n\n        int b64_size = AV_BASE64_SIZE(h->stats_offset);\n\n        // libtheora generates a summary header at the end\n\n        memcpy(h->stats, buf, bytes);\n\n        avctx->stats_out = av_malloc(b64_size);\n\n\n\n        av_base64_encode(avctx->stats_out, b64_size, h->stats, h->stats_offset);\n\n    }\n\n    return 0;\n\n#else\n\n    av_log(avctx, AV_LOG_ERROR, \"libtheora too old to support 2pass\\n\");\n\n    return AVERROR(ENOSUP);\n\n#endif\n\n}", "idx": 8694}
{"project": "FFmpeg", "commit_id": "3920d1387834e2bc334aff9f518f4beb24e470bd", "target": 1, "func": "static int allocate_buffers(ALACContext *alac)\n\n{\n\n    int ch;\n\n    int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n\n\n        alac->direct_output = alac->sample_size > 16 && av_sample_fmt_is_planar(alac->avctx->sample_fmt);\n\n        if (!alac->direct_output) {\n\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n\n                             buf_size, buf_alloc_fail);\n\n        }\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n    }\n\n    return 0;\n\nbuf_alloc_fail:\n\n    alac_decode_close(alac->avctx);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 8702}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_subfco (void)\n\n{\n\n    T2 = T0;\n\n    T0 = T1 - T0;\n\n    if (likely(T0 > T1)) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n    if (likely(!(((~T2) ^ T1 ^ (-1)) & ((~T2) ^ T0) & (1 << 31)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n}\n", "idx": 8719}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_del_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeDeleteQ *c = (NvmeDeleteQ *)cmd;\n\n    NvmeRequest *req, *next;\n\n    NvmeSQueue *sq;\n\n    NvmeCQueue *cq;\n\n    uint16_t qid = le16_to_cpu(c->qid);\n\n\n\n    if (!qid || nvme_check_sqid(n, qid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n\n\n    sq = n->sq[qid];\n\n    while (!QTAILQ_EMPTY(&sq->out_req_list)) {\n\n        req = QTAILQ_FIRST(&sq->out_req_list);\n\n        assert(req->aiocb);\n\n        blk_aio_cancel(req->aiocb);\n\n    }\n\n    if (!nvme_check_cqid(n, sq->cqid)) {\n\n        cq = n->cq[sq->cqid];\n\n        QTAILQ_REMOVE(&cq->sq_list, sq, entry);\n\n\n\n        nvme_post_cqes(cq);\n\n        QTAILQ_FOREACH_SAFE(req, &cq->req_list, entry, next) {\n\n            if (req->sq == sq) {\n\n                QTAILQ_REMOVE(&cq->req_list, req, entry);\n\n                QTAILQ_INSERT_TAIL(&sq->req_list, req, entry);\n\n            }\n\n        }\n\n    }\n\n\n\n    nvme_free_sq(sq, n);\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 8724}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void t_gen_btst(TCGv d, TCGv a, TCGv b)\n\n{\n\n        TCGv sbit;\n\n        TCGv bset;\n\n        TCGv t0;\n\n\tint l1;\n\n\n\n        /* des ref:\n\n           The N flag is set according to the selected bit in the dest reg.\n\n           The Z flag is set if the selected bit and all bits to the right are\n\n           zero.\n\n           The X flag is cleared.\n\n           Other flags are left untouched.\n\n           The destination reg is not affected.\n\n\n\n        unsigned int fz, sbit, bset, mask, masked_t0;\n\n\n\n        sbit = T1 & 31;\n\n        bset = !!(T0 & (1 << sbit));\n\n        mask = sbit == 31 ? -1 : (1 << (sbit + 1)) - 1;\n\n        masked_t0 = T0 & mask;\n\n        fz = !(masked_t0 | bset);\n\n\n\n        // Clear the X, N and Z flags.\n\n        T0 = env->pregs[PR_CCS] & ~(X_FLAG | N_FLAG | Z_FLAG);\n\n        // Set the N and Z flags accordingly.\n\n        T0 |= (bset << 3) | (fz << 2);\n\n        */\n\n\n\n\tl1 = gen_new_label();\n\n        sbit = tcg_temp_new(TCG_TYPE_TL);\n\n        bset = tcg_temp_new(TCG_TYPE_TL);\n\n        t0 = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n        /* Compute bset and sbit.  */\n\n        tcg_gen_andi_tl(sbit, b, 31);\n\n        tcg_gen_shl_tl(t0, tcg_const_tl(1), sbit);\n\n        tcg_gen_and_tl(bset, a, t0);\n\n        tcg_gen_shr_tl(bset, bset, sbit);\n\n\t/* Displace to N_FLAG.  */\n\n        tcg_gen_shli_tl(bset, bset, 3);\n\n\n\n        tcg_gen_shl_tl(sbit, tcg_const_tl(2), sbit);\n\n        tcg_gen_subi_tl(sbit, sbit, 1);\n\n        tcg_gen_and_tl(sbit, a, sbit);\n\n\n\n        tcg_gen_andi_tl(d, cpu_PR[PR_CCS], ~(X_FLAG | N_FLAG | Z_FLAG));\n\n\t/* or in the N_FLAG.  */\n\n        tcg_gen_or_tl(d, d, bset);\n\n\ttcg_gen_brcondi_tl(TCG_COND_NE, sbit, 0, l1);\n\n\t/* or in the Z_FLAG.  */\n\n\ttcg_gen_ori_tl(d, d, Z_FLAG);\n\n\tgen_set_label(l1);\n\n\n\n        tcg_temp_free(sbit);\n\n        tcg_temp_free(bset);\n\n}\n", "idx": 8750}
{"project": "FFmpeg", "commit_id": "631c56a8e46dea41585f3e7b3ef9c52b49faa385", "target": 0, "func": "int ff_network_init(void)\n\n{\n\n#if HAVE_WINSOCK2_H\n\n    WSADATA wsaData;\n\n#endif\n\n\n\n    if (!ff_network_inited_globally)\n\n        av_log(NULL, AV_LOG_WARNING, \"Using network protocols without global \"\n\n                                     \"network initialization. Please use \"\n\n                                     \"avformat_network_init(), this will \"\n\n                                     \"become mandatory later.\\n\");\n\n#if HAVE_WINSOCK2_H\n\n    if (WSAStartup(MAKEWORD(1,1), &wsaData))\n\n        return 0;\n\n#endif\n\n    return 1;\n\n}\n", "idx": 8801}
{"project": "FFmpeg", "commit_id": "90fc00a623de44e137fe1601b91356e8cd8bdd54", "target": 1, "func": "static int jacosub_probe(AVProbeData *p)\n\n{\n\n    const char *ptr     = p->buf;\n\n    const char *ptr_end = p->buf + p->buf_size;\n\n\n\n    if (AV_RB24(ptr) == 0xEFBBBF)\n\n        ptr += 3; /* skip UTF-8 BOM */\n\n\n\n    while (ptr < ptr_end) {\n\n        while (jss_whitespace(*ptr))\n\n            ptr++;\n\n        if (*ptr != '#' && *ptr != '\\n') {\n\n            if (timed_line(ptr))\n\n                return AVPROBE_SCORE_EXTENSION + 1;\n\n            return 0;\n\n        }\n\n        ptr += strcspn(ptr, \"\\n\") + 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8803}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "static void test_parse_path(void)\n\n{\n\n    g_test_trap_subprocess (\"/logging/parse_path/subprocess\", 0, 0);\n\n    g_test_trap_assert_passed();\n\n    g_test_trap_assert_stdout(\"\");\n\n    g_test_trap_assert_stderr(\"\");\n\n}\n", "idx": 8827}
{"project": "qemu", "commit_id": "d1eb8f2acba579830cf3798c3c15ce51be852c56", "target": 0, "func": "int floatx80_unordered(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 8837}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static void usbredir_do_attach(void *opaque)\n\n{\n\n    USBRedirDevice *dev = opaque;\n\n\n\n    /* In order to work properly with XHCI controllers we need these caps */\n\n    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(\n\n        usbredirparser_peer_has_cap(dev->parser,\n\n                                    usb_redir_cap_ep_info_max_packet_size) &&\n\n        usbredirparser_peer_has_cap(dev->parser,\n\n                                    usb_redir_cap_32bits_bulk_length) &&\n\n        usbredirparser_peer_has_cap(dev->parser,\n\n                                    usb_redir_cap_64bits_ids))) {\n\n        ERROR(\"usb-redir-host lacks capabilities needed for use with XHCI\\n\");\n\n        usbredir_reject_device(dev);\n\n        return;\n\n    }\n\n\n\n    if (usb_device_attach(&dev->dev) != 0) {\n\n        WARNING(\"rejecting device due to speed mismatch\\n\");\n\n        usbredir_reject_device(dev);\n\n    }\n\n}\n", "idx": 8838}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fctidz (uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN conversion */\n\n        farg.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN | POWERPC_EXCP_FP_VXCVI);\n\n    } else if (unlikely(float64_is_nan(farg.d) || float64_is_infinity(farg.d))) {\n\n        /* qNan / infinity conversion */\n\n        farg.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXCVI);\n\n    } else {\n\n        farg.ll = float64_to_int64_round_to_zero(farg.d, &env->fp_status);\n\n    }\n\n    return farg.ll;\n\n}\n", "idx": 8853}
{"project": "qemu", "commit_id": "dd4d607e40dcd2cb7646b510504880a70939d91b", "target": 0, "func": "static void vtd_iommu_notify_flag_changed(MemoryRegion *iommu,\n\n                                          IOMMUNotifierFlag old,\n\n                                          IOMMUNotifierFlag new)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu, VTDAddressSpace, iommu);\n\n\n\n    if (new & IOMMU_NOTIFIER_MAP) {\n\n        error_report(\"Device at bus %s addr %02x.%d requires iommu \"\n\n                     \"notifier which is currently not supported by \"\n\n                     \"intel-iommu emulation\",\n\n                     vtd_as->bus->qbus.name, PCI_SLOT(vtd_as->devfn),\n\n                     PCI_FUNC(vtd_as->devfn));\n\n        exit(1);\n\n    }\n\n}\n", "idx": 8862}
{"project": "qemu", "commit_id": "e2779de053b64f023de382fd87b3596613d47d1e", "target": 0, "func": "static int xen_pt_long_reg_write(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                                 uint32_t *val, uint32_t dev_value,\n\n                                 uint32_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint32_t writable_mask = 0;\n\n    uint32_t throughable_mask = get_throughable_mask(s, reg, valid_mask);\n\n\n\n    /* modify emulate register */\n\n    writable_mask = reg->emu_mask & ~reg->ro_mask & valid_mask;\n\n    cfg_entry->data = XEN_PT_MERGE_VALUE(*val, cfg_entry->data, writable_mask);\n\n\n\n    /* create value for writing to I/O device register */\n\n    *val = XEN_PT_MERGE_VALUE(*val, dev_value, throughable_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 8864}
{"project": "qemu", "commit_id": "fa6252b0565526ec2347e248172f91771e0d9f47", "target": 1, "func": "coroutine_fn iscsi_co_write_zeroes(BlockDriverState *bs, int64_t sector_num,\n\n                                   int nb_sectors, BdrvRequestFlags flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct IscsiTask iTask;\n\n    uint64_t lba;\n\n    uint32_t nb_blocks;\n\n\n\n    if (!is_request_lun_aligned(sector_num, nb_sectors, iscsilun)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!iscsilun->lbp.lbpws) {\n\n        /* WRITE SAME is not supported by the target */\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    lba = sector_qemu2lun(sector_num, iscsilun);\n\n    nb_blocks = sector_qemu2lun(nb_sectors, iscsilun);\n\n\n\n    if (iscsilun->zeroblock == NULL) {\n\n        iscsilun->zeroblock = g_malloc0(iscsilun->block_size);\n\n    }\n\n\n\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\n\nretry:\n\n    if (iscsi_writesame16_task(iscsilun->iscsi, iscsilun->lun, lba,\n\n                               iscsilun->zeroblock, iscsilun->block_size,\n\n                               nb_blocks, 0, !!(flags & BDRV_REQ_MAY_UNMAP),\n\n                               0, 0, iscsi_co_generic_cb, &iTask) == NULL) {\n\n        return -EIO;\n\n    }\n\n\n\n    while (!iTask.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    if (iTask.task != NULL) {\n\n        scsi_free_scsi_task(iTask.task);\n\n        iTask.task = NULL;\n\n    }\n\n\n\n    if (iTask.do_retry) {\n\n        goto retry;\n\n    }\n\n\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 8873}
{"project": "qemu", "commit_id": "44b6789299a8acca3f25331bc411055cafc7bb06", "target": 1, "func": "static BlkverifyAIOCB *blkverify_aio_get(BlockDriverState *bs, bool is_write,\n\n                                         int64_t sector_num, QEMUIOVector *qiov,\n\n                                         int nb_sectors,\n\n                                         BlockCompletionFunc *cb,\n\n                                         void *opaque)\n\n{\n\n    BlkverifyAIOCB *acb = qemu_aio_get(&blkverify_aiocb_info, bs, cb, opaque);\n\n\n\n    acb->is_write = is_write;\n\n    acb->sector_num = sector_num;\n\n    acb->nb_sectors = nb_sectors;\n\n    acb->ret = -EINPROGRESS;\n\n    acb->done = 0;\n\n    acb->qiov = qiov;\n\n    acb->buf = NULL;\n\n    acb->verify = NULL;\n\n    return acb;\n\n}\n", "idx": 8874}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_validate_list(TestInputVisitorData *data,\n\n                                const void *unused)\n\n{\n\n    UserDefOneList *head = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"[ { 'string': 'string0', 'integer': 42 }, { 'string': 'string1', 'integer': 43 }, { 'string': 'string2', 'integer': 44 } ]\");\n\n\n\n    visit_type_UserDefOneList(v, NULL, &head, &error_abort);\n\n    qapi_free_UserDefOneList(head);\n\n}\n", "idx": 8915}
{"project": "qemu", "commit_id": "871271615108fd58273423d98b7cefe08e6f75a0", "target": 0, "func": "void monitor_init(CharDriverState *chr, int show_banner)\n\n{\n\n    int i;\n\n\n\n    if (is_first_init) {\n\n        key_timer = qemu_new_timer(vm_clock, release_keys, NULL);\n\n        if (!key_timer)\n\n            return;\n\n        for (i = 0; i < MAX_MON; i++) {\n\n            monitor_hd[i] = NULL;\n\n        }\n\n        is_first_init = 0;\n\n    }\n\n    for (i = 0; i < MAX_MON; i++) {\n\n        if (monitor_hd[i] == NULL) {\n\n            monitor_hd[i] = chr;\n\n            break;\n\n        }\n\n    }\n\n\n\n    hide_banner = !show_banner;\n\n\n\n    qemu_chr_add_handlers(chr, term_can_read, term_read, term_event, cur_mon);\n\n\n\n    readline_start(\"\", 0, monitor_command_cb, NULL);\n\n}\n", "idx": 8978}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int iommu_dma_memory_rw(DMAContext *dma, dma_addr_t addr,\n\n                        void *buf, dma_addr_t len, DMADirection dir)\n\n{\n\n    target_phys_addr_t paddr, plen;\n\n    int err;\n\n\n\n#ifdef DEBUG_IOMMU\n\n    fprintf(stderr, \"dma_memory_rw context=%p addr=0x\" DMA_ADDR_FMT \" len=0x\"\n\n            DMA_ADDR_FMT \" dir=%d\\n\", dma, addr, len, dir);\n\n#endif\n\n\n\n    while (len) {\n\n        err = dma->translate(dma, addr, &paddr, &plen, dir);\n\n        if (err) {\n\n\t    /*\n\n             * In case of failure on reads from the guest, we clean the\n\n             * destination buffer so that a device that doesn't test\n\n             * for errors will not expose qemu internal memory.\n\n\t     */\n\n\t    memset(buf, 0, len);\n\n            return -1;\n\n        }\n\n\n\n        /* The translation might be valid for larger regions. */\n\n        if (plen > len) {\n\n            plen = len;\n\n        }\n\n\n\n        address_space_rw(dma->as, paddr, buf, plen, dir == DMA_DIRECTION_FROM_DEVICE);\n\n\n\n        len -= plen;\n\n        addr += plen;\n\n        buf += plen;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9001}
{"project": "FFmpeg", "commit_id": "990b13806d38f51201afb4e5048c61bf3e1c576e", "target": 1, "func": "static void blend_frame(AVFilterContext *ctx,\n\n                        AVFrame *top_buf,\n\n                        AVFrame *bottom_buf,\n\n                        AVFrame *dst_buf)\n\n{\n\n    BlendContext *b = ctx->priv;\n\n    AVFilterLink *inlink = ctx->inputs[0];\n\n    FilterParams *param;\n\n    int plane;\n\n\n\n    for (plane = 0; dst_buf->data[plane]; plane++) {\n\n        int hsub = plane == 1 || plane == 2 ? b->hsub : 0;\n\n        int vsub = plane == 1 || plane == 2 ? b->vsub : 0;\n\n        int outw = dst_buf->width  >> hsub;\n\n        int outh = dst_buf->height >> vsub;\n\n        uint8_t *dst    = dst_buf->data[plane];\n\n        uint8_t *top    = top_buf->data[plane];\n\n        uint8_t *bottom = bottom_buf->data[plane];\n\n\n\n        param = &b->params[plane];\n\n        param->values[VAR_N]  = inlink->frame_count;\n\n        param->values[VAR_T]  = dst_buf->pts == AV_NOPTS_VALUE ? NAN : dst_buf->pts * av_q2d(inlink->time_base);\n\n        param->values[VAR_W]  = outw;\n\n        param->values[VAR_H]  = outh;\n\n        param->values[VAR_SW] = outw / dst_buf->width;\n\n        param->values[VAR_SH] = outh / dst_buf->height;\n\n        param->blend(top, top_buf->linesize[plane],\n\n                     bottom, bottom_buf->linesize[plane],\n\n                     dst, dst_buf->linesize[plane], outw, outh, param);\n\n    }\n\n}\n", "idx": 9024}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(simple_list)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \"[43,42]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \"[43]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \"[]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \"[{}]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    {},\n\n                                        })),\n\n                        {},\n\n                            })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QLIST);\n\n\n\n        fail_unless(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str));\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QLIST);\n\n\n\n        fail_unless(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 9032}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "static void readline_update(ReadLineState *rs)\n\n{\n\n    int i, delta, len;\n\n\n\n    if (rs->cmd_buf_size != rs->last_cmd_buf_size ||\n\n        memcmp(rs->cmd_buf, rs->last_cmd_buf, rs->cmd_buf_size) != 0) {\n\n        for(i = 0; i < rs->last_cmd_buf_index; i++) {\n\n            monitor_printf(rs->mon, \"\\033[D\");\n\n        }\n\n        rs->cmd_buf[rs->cmd_buf_size] = '\\0';\n\n        if (rs->read_password) {\n\n            len = strlen(rs->cmd_buf);\n\n            for(i = 0; i < len; i++)\n\n                monitor_printf(rs->mon, \"*\");\n\n        } else {\n\n            monitor_printf(rs->mon, \"%s\", rs->cmd_buf);\n\n        }\n\n        monitor_printf(rs->mon, \"\\033[K\");\n\n        memcpy(rs->last_cmd_buf, rs->cmd_buf, rs->cmd_buf_size);\n\n        rs->last_cmd_buf_size = rs->cmd_buf_size;\n\n        rs->last_cmd_buf_index = rs->cmd_buf_size;\n\n    }\n\n    if (rs->cmd_buf_index != rs->last_cmd_buf_index) {\n\n        delta = rs->cmd_buf_index - rs->last_cmd_buf_index;\n\n        if (delta > 0) {\n\n            for(i = 0;i < delta; i++) {\n\n                monitor_printf(rs->mon, \"\\033[C\");\n\n            }\n\n        } else {\n\n            delta = -delta;\n\n            for(i = 0;i < delta; i++) {\n\n                monitor_printf(rs->mon, \"\\033[D\");\n\n            }\n\n        }\n\n        rs->last_cmd_buf_index = rs->cmd_buf_index;\n\n    }\n\n    monitor_flush(rs->mon);\n\n}\n", "idx": 9051}
{"project": "qemu", "commit_id": "758ead31c7e17bf17a9ef2e0ca1c3e86ab296b43", "target": 1, "func": "void virtio_queue_update_rings(VirtIODevice *vdev, int n)\n\n{\n\n    VRing *vring = &vdev->vq[n].vring;\n\n\n\n    if (!vring->desc) {\n\n        /* not yet setup -> nothing to do */\n\n        return;\n\n    }\n\n    vring->avail = vring->desc + vring->num * sizeof(VRingDesc);\n\n    vring->used = vring_align(vring->avail +\n\n                              offsetof(VRingAvail, ring[vring->num]),\n\n                              vring->align);\n\n    virtio_init_region_cache(vdev, n);\n\n}\n", "idx": 9079}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel4_mc21_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_4w_msa(src - (2 * stride) - 2, stride, dst, stride, 4, 0);\n\n}\n", "idx": 9083}
{"project": "qemu", "commit_id": "c8389550dedc65892fba9c3df29423efd802f544", "target": 1, "func": "static void vmgenid_realize(DeviceState *dev, Error **errp)\n\n{\n\n    VmGenIdState *vms = VMGENID(dev);\n\n\n\n    if (!vms->write_pointer_available) {\n\n        error_setg(errp, \"%s requires DMA write support in fw_cfg, \"\n\n                   \"which this machine type does not provide\", VMGENID_DEVICE);\n\n        return;\n\n    }\n\n\n\n    /* Given that this function is executing, there is at least one VMGENID\n\n     * device. Check if there are several.\n\n     */\n\n    if (!find_vmgenid_dev()) {\n\n        error_setg(errp, \"at most one %s device is permitted\", VMGENID_DEVICE);\n\n        return;\n\n    }\n\n\n\n    qemu_register_reset(vmgenid_handle_reset, vms);\n\n}\n", "idx": 9110}
{"project": "FFmpeg", "commit_id": "57623cba1301ee7874687dd7e04c611051638e9d", "target": 0, "func": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n\n                                  int *got_frame, uint8_t *data_start,\n\n                                  unsigned int data_size)\n\n{\n\n    WebPContext *s = avctx->priv_data;\n\n    AVPacket pkt;\n\n    int ret;\n\n\n\n    if (!s->initialized) {\n\n        ff_vp8_decode_init(avctx);\n\n        s->initialized = 1;\n\n        avctx->get_format = webp_get_format;\n\n    }\n\n    s->lossless = 0;\n\n\n\n    if (data_size > INT_MAX) {\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = data_start;\n\n    pkt.size = data_size;\n\n\n\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n\n    if (s->has_alpha) {\n\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n\n                                     s->alpha_data_size);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    return ret;\n\n}\n", "idx": 9130}
{"project": "qemu", "commit_id": "2db59a76c421cdd1039d10e32a9798952d3ff5ba", "target": 1, "func": "static void gen_window_check1(DisasContext *dc, unsigned r1)\n\n{\n\n    if (dc->tb->flags & XTENSA_TBFLAG_EXCM) {\n\n        return;\n\n    }\n\n    if (option_enabled(dc, XTENSA_OPTION_WINDOWED_REGISTER) &&\n\n            r1 / 4 > dc->used_window) {\n\n        int label = gen_new_label();\n\n        TCGv_i32 ws = tcg_temp_new_i32();\n\n\n\n        dc->used_window = r1 / 4;\n\n        tcg_gen_deposit_i32(ws, cpu_SR[WINDOW_START], cpu_SR[WINDOW_START],\n\n                dc->config->nareg / 4, dc->config->nareg / 4);\n\n        tcg_gen_shr_i32(ws, ws, cpu_SR[WINDOW_BASE]);\n\n        tcg_gen_andi_i32(ws, ws, (2 << (r1 / 4)) - 2);\n\n        tcg_gen_brcondi_i32(TCG_COND_EQ, ws, 0, label);\n\n        {\n\n            TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n            TCGv_i32 w = tcg_const_i32(r1 / 4);\n\n\n\n            gen_advance_ccount_cond(dc);\n\n            gen_helper_window_check(cpu_env, pc, w);\n\n\n\n            tcg_temp_free(w);\n\n            tcg_temp_free(pc);\n\n        }\n\n        gen_set_label(label);\n\n        tcg_temp_free(ws);\n\n    }\n\n}\n", "idx": 9142}
{"project": "FFmpeg", "commit_id": "1c495b0bf690995c45f79f4f19500921e14ec78a", "target": 1, "func": "static void sd_1d97_float(float *p, int i0, int i1)\n\n{\n\n    int i;\n\n\n\n    if (i1 <= i0 + 1) {\n\n        if (i0 == 1)\n\n            p[1] *= F_LFTG_X;\n\n        else\n\n            p[0] *= F_LFTG_K;\n\n        return;\n\n    }\n\n\n\n    extend97_float(p, i0, i1);\n\n    i0++; i1++;\n\n\n\n    for (i = i0/2 - 2; i < i1/2 + 1; i++)\n\n        p[2*i+1] -= 1.586134 * (p[2*i] + p[2*i+2]);\n\n    for (i = i0/2 - 1; i < i1/2 + 1; i++)\n\n        p[2*i] -= 0.052980 * (p[2*i-1] + p[2*i+1]);\n\n    for (i = i0/2 - 1; i < i1/2; i++)\n\n        p[2*i+1] += 0.882911 * (p[2*i] + p[2*i+2]);\n\n    for (i = i0/2; i < i1/2; i++)\n\n        p[2*i] += 0.443506 * (p[2*i-1] + p[2*i+1]);\n\n}\n", "idx": 9192}
{"project": "qemu", "commit_id": "9d8f818cdee83e726a5dd14b645738ec632d2577", "target": 0, "func": "int nbd_client_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    NBDRequest request = {\n\n        .type = NBD_CMD_TRIM,\n\n        .from = offset,\n\n        .len = bytes,\n\n    };\n\n\n\n    assert(!(client->info.flags & NBD_FLAG_READ_ONLY));\n\n    if (!(client->info.flags & NBD_FLAG_SEND_TRIM)) {\n\n        return 0;\n\n    }\n\n\n\n    return nbd_co_request(bs, &request, NULL);\n\n}\n", "idx": 9207}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static QEMUCursor *qxl_cursor(PCIQXLDevice *qxl, QXLCursor *cursor,\n\n                              uint32_t group_id)\n\n{\n\n    QEMUCursor *c;\n\n    size_t size;\n\n\n\n    c = cursor_alloc(cursor->header.width, cursor->header.height);\n\n    c->hot_x = cursor->header.hot_spot_x;\n\n    c->hot_y = cursor->header.hot_spot_y;\n\n    switch (cursor->header.type) {\n\n    case SPICE_CURSOR_TYPE_ALPHA:\n\n        size = sizeof(uint32_t) * cursor->header.width * cursor->header.height;\n\n        qxl_unpack_chunks(c->data, size, qxl, &cursor->chunk, group_id);\n\n        if (qxl->debug > 2) {\n\n            cursor_print_ascii_art(c, \"qxl/alpha\");\n\n        }\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: not implemented: type %d\\n\",\n\n                __FUNCTION__, cursor->header.type);\n\n        goto fail;\n\n    }\n\n    return c;\n\n\n\nfail:\n\n    cursor_put(c);\n\n    return NULL;\n\n}\n", "idx": 9211}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QFloat *qfloat_from_double(double value)\n\n{\n\n    QFloat *qf;\n\n\n\n    qf = g_malloc(sizeof(*qf));\n\n    qf->value = value;\n\n    QOBJECT_INIT(qf, &qfloat_type);\n\n\n\n    return qf;\n\n}\n", "idx": 9218}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void *qemu_blockalign(BlockDriverState *bs, size_t size)\n\n{\n\n    return qemu_memalign(bdrv_opt_mem_align(bs), size);\n\n}\n", "idx": 9220}
{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static void spapr_drc_release(sPAPRDRConnector *drc)\n\n{\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    drck->release(drc->dev);\n\n\n\n    drc->awaiting_release = false;\n\n    g_free(drc->fdt);\n\n    drc->fdt = NULL;\n\n    drc->fdt_start_offset = 0;\n\n    object_property_del(OBJECT(drc), \"device\", &error_abort);\n\n    drc->dev = NULL;\n\n}\n", "idx": 9226}
{"project": "FFmpeg", "commit_id": "99683a307776a7638ccce236a4ce5aa3e914e77d", "target": 1, "func": "static void jpeg_put_comments(MpegEncContext *s)\n\n{\n\n    PutBitContext *p = &s->pb;\n\n    int size;\n\n    uint8_t *ptr;\n\n\n\n    if (s->aspect_ratio_info /* && !lossless */)\n\n    {\n\n    /* JFIF header */\n\n    put_marker(p, APP0);\n\n    put_bits(p, 16, 16);\n\n    put_string(p, \"JFIF\"); /* this puts the trailing zero-byte too */\n\n    put_bits(p, 16, 0x0201); /* v 1.02 */\n\n    put_bits(p, 8, 0); /* units type: 0 - aspect ratio */\n\n    put_bits(p, 16, s->avctx->sample_aspect_ratio.num);\n\n    put_bits(p, 16, s->avctx->sample_aspect_ratio.den);\n\n    put_bits(p, 8, 0); /* thumbnail width */\n\n    put_bits(p, 8, 0); /* thumbnail height */\n\n    }\n\n\n\n    /* comment */\n\n    if(!(s->flags & CODEC_FLAG_BITEXACT)){\n\n        put_marker(p, COM);\n\n        flush_put_bits(p);\n\n        ptr = pbBufPtr(p);\n\n        put_bits(p, 16, 0); /* patched later */\n\n        put_string(p, LIBAVCODEC_IDENT);\n\n        size = strlen(LIBAVCODEC_IDENT)+3;\n\n        ptr[0] = size >> 8;\n\n        ptr[1] = size;\n\n    }\n\n}\n", "idx": 9227}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_narrow(int size, TCGv dest, TCGv src)\n\n{\n\n    switch (size) {\n\n    case 0: gen_helper_neon_narrow_u8(dest, src); break;\n\n    case 1: gen_helper_neon_narrow_u16(dest, src); break;\n\n    case 2: tcg_gen_trunc_i64_i32(dest, src); break;\n\n    default: abort();\n\n    }\n\n}\n", "idx": 9249}
{"project": "qemu", "commit_id": "ffbb1705a33df8e2fb12b24d96663d63b22eaf8b", "target": 0, "func": "void spapr_dt_events(void *fdt, uint32_t check_exception_irq)\n\n{\n\n    int event_sources, epow_events;\n\n    uint32_t irq_ranges[] = {cpu_to_be32(check_exception_irq), cpu_to_be32(1)};\n\n    uint32_t interrupts[] = {cpu_to_be32(check_exception_irq), 0};\n\n\n\n    _FDT(event_sources = fdt_add_subnode(fdt, 0, \"event-sources\"));\n\n\n\n    _FDT(fdt_setprop(fdt, event_sources, \"interrupt-controller\", NULL, 0));\n\n    _FDT(fdt_setprop_cell(fdt, event_sources, \"#interrupt-cells\", 2));\n\n    _FDT(fdt_setprop(fdt, event_sources, \"interrupt-ranges\",\n\n                     irq_ranges, sizeof(irq_ranges)));\n\n\n\n    _FDT(epow_events = fdt_add_subnode(fdt, event_sources, \"epow-events\"));\n\n    _FDT(fdt_setprop(fdt, epow_events, \"interrupts\",\n\n                     interrupts, sizeof(interrupts)));\n\n}\n", "idx": 9307}
{"project": "FFmpeg", "commit_id": "4381bddc9f93da34a44e683bdc4c05c6f061244e", "target": 0, "func": "static void ff_dlog_link(void *ctx, AVFilterLink *link, int end)\n\n{\n\n    if (link->type == AVMEDIA_TYPE_VIDEO) {\n\n        av_dlog(ctx,\n\n                \"link[%p s:%dx%d fmt:%-16s %-16s->%-16s]%s\",\n\n                link, link->w, link->h,\n\n                av_pix_fmt_descriptors[link->format].name,\n\n                link->src ? link->src->filter->name : \"\",\n\n                link->dst ? link->dst->filter->name : \"\",\n\n                end ? \"\\n\" : \"\");\n\n    } else {\n\n        char buf[128];\n\n        av_get_channel_layout_string(buf, sizeof(buf), -1, link->channel_layout);\n\n\n\n        av_dlog(ctx,\n\n                \"link[%p r:%\"PRId64\" cl:%s fmt:%-16s %-16s->%-16s]%s\",\n\n                link, link->sample_rate, buf,\n\n                av_get_sample_fmt_name(link->format),\n\n                link->src ? link->src->filter->name : \"\",\n\n                link->dst ? link->dst->filter->name : \"\",\n\n                end ? \"\\n\" : \"\");\n\n    }\n\n}\n", "idx": 9327}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qmp_migrate_set_capabilities(MigrationCapabilityStatusList *params,\n\n                                  Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n    MigrationCapabilityStatusList *cap;\n\n\n\n    if (s->state == MIG_STATE_ACTIVE || s->state == MIG_STATE_SETUP) {\n\n        error_set(errp, QERR_MIGRATION_ACTIVE);\n\n        return;\n\n    }\n\n\n\n    for (cap = params; cap; cap = cap->next) {\n\n        s->enabled_capabilities[cap->value->capability] = cap->value->state;\n\n    }\n\n}\n", "idx": 9334}
{"project": "qemu", "commit_id": "635db18f68ded6abec11cd4cf64ebc15c1c6b190", "target": 1, "func": "void qmp_qmp_capabilities(Error **errp)\n\n{\n\n    cur_mon->qmp.in_command_mode = true;\n\n}\n", "idx": 9346}
{"project": "FFmpeg", "commit_id": "af19f78f2fe2b969104d4419efd25fdee90a2814", "target": 0, "func": "void dsputil_init_mlib(void)\n\n{\n\n    put_pixels_tab[0][0] = put_pixels16_mlib;\n\n    put_pixels_tab[0][1] = put_pixels16_x2_mlib;\n\n    put_pixels_tab[0][2] = put_pixels16_y2_mlib;\n\n    put_pixels_tab[0][3] = put_pixels16_xy2_mlib;\n\n    put_pixels_tab[1][0] = put_pixels8_mlib;\n\n    put_pixels_tab[1][1] = put_pixels8_x2_mlib;\n\n    put_pixels_tab[1][2] = put_pixels8_y2_mlib;\n\n    put_pixels_tab[1][3] = put_pixels8_xy2_mlib;\n\n\n\n    avg_pixels_tab[0][0] = avg_pixels16_mlib;\n\n    avg_pixels_tab[0][1] = avg_pixels16_x2_mlib;\n\n    avg_pixels_tab[0][2] = avg_pixels16_y2_mlib;\n\n    avg_pixels_tab[0][3] = avg_pixels16_xy2_mlib;\n\n    avg_pixels_tab[1][0] = avg_pixels8_mlib;\n\n    avg_pixels_tab[1][1] = avg_pixels8_x2_mlib;\n\n    avg_pixels_tab[1][2] = avg_pixels8_y2_mlib;\n\n    avg_pixels_tab[1][3] = avg_pixels8_xy2_mlib;\n\n    \n\n    put_no_rnd_pixels_tab[0][0] = put_pixels16_mlib;\n\n    put_no_rnd_pixels_tab[1][0] = put_pixels8_mlib;\n\n    \n\n    add_pixels_clamped = add_pixels_clamped_mlib;\n\n}\n", "idx": 9359}
{"project": "qemu", "commit_id": "a78b1299f1bbb9608e3e3a36a7f16cf700a2789d", "target": 0, "func": "static inline int handle_cpu_signal(uintptr_t pc, unsigned long address,\n\n                                    int is_write, sigset_t *old_set)\n\n{\n\n    CPUState *cpu = current_cpu;\n\n    CPUClass *cc;\n\n    int ret;\n\n\n\n    /* We must handle PC addresses from two different sources:\n\n     * a call return address and a signal frame address.\n\n     *\n\n     * Within cpu_restore_state_from_tb we assume the former and adjust\n\n     * the address by -GETPC_ADJ so that the address is within the call\n\n     * insn so that addr does not accidentally match the beginning of the\n\n     * next guest insn.\n\n     *\n\n     * However, when the PC comes from the signal frame, it points to\n\n     * the actual faulting host insn and not a call insn.  Subtracting\n\n     * GETPC_ADJ in that case may accidentally match the previous guest insn.\n\n     *\n\n     * So for the later case, adjust forward to compensate for what\n\n     * will be done later by cpu_restore_state_from_tb.\n\n     */\n\n    if (helper_retaddr) {\n\n        pc = helper_retaddr;\n\n    } else {\n\n        pc += GETPC_ADJ;\n\n    }\n\n\n\n    /* For synchronous signals we expect to be coming from the vCPU\n\n     * thread (so current_cpu should be valid) and either from running\n\n     * code or during translation which can fault as we cross pages.\n\n     *\n\n     * If neither is true then something has gone wrong and we should\n\n     * abort rather than try and restart the vCPU execution.\n\n     */\n\n    if (!cpu || !cpu->running) {\n\n        printf(\"qemu:%s received signal outside vCPU context @ pc=0x%\"\n\n               PRIxPTR \"\\n\",  __func__, pc);\n\n        abort();\n\n    }\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    printf(\"qemu: SIGSEGV pc=0x%08lx address=%08lx w=%d oldset=0x%08lx\\n\",\n\n           pc, address, is_write, *(unsigned long *)old_set);\n\n#endif\n\n    /* XXX: locking issue */\n\n    if (is_write && h2g_valid(address)) {\n\n        switch (page_unprotect(h2g(address), pc)) {\n\n        case 0:\n\n            /* Fault not caused by a page marked unwritable to protect\n\n             * cached translations, must be the guest binary's problem.\n\n             */\n\n            break;\n\n        case 1:\n\n            /* Fault caused by protection of cached translation; TBs\n\n             * invalidated, so resume execution.  Retain helper_retaddr\n\n             * for a possible second fault.\n\n             */\n\n            return 1;\n\n        case 2:\n\n            /* Fault caused by protection of cached translation, and the\n\n             * currently executing TB was modified and must be exited\n\n             * immediately.  Clear helper_retaddr for next execution.\n\n             */\n\n            helper_retaddr = 0;\n\n            cpu_exit_tb_from_sighandler(cpu, old_set);\n\n            /* NORETURN */\n\n\n\n        default:\n\n            g_assert_not_reached();\n\n        }\n\n    }\n\n\n\n    /* Convert forcefully to guest address space, invalid addresses\n\n       are still valid segv ones */\n\n    address = h2g_nocheck(address);\n\n\n\n    cc = CPU_GET_CLASS(cpu);\n\n    /* see if it is an MMU fault */\n\n    g_assert(cc->handle_mmu_fault);\n\n    ret = cc->handle_mmu_fault(cpu, address, is_write, MMU_USER_IDX);\n\n\n\n    if (ret == 0) {\n\n        /* The MMU fault was handled without causing real CPU fault.\n\n         *  Retain helper_retaddr for a possible second fault.\n\n         */\n\n        return 1;\n\n    }\n\n\n\n    /* All other paths lead to cpu_exit; clear helper_retaddr\n\n     * for next execution.\n\n     */\n\n    helper_retaddr = 0;\n\n\n\n    if (ret < 0) {\n\n        return 0; /* not an MMU fault */\n\n    }\n\n\n\n    /* Now we have a real cpu fault.  */\n\n    cpu_restore_state(cpu, pc);\n\n\n\n    sigprocmask(SIG_SETMASK, old_set, NULL);\n\n    cpu_loop_exit(cpu);\n\n\n\n    /* never comes here */\n\n    return 1;\n\n}\n", "idx": 9375}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline bool media_is_cd(SCSIDiskState *s)\n\n{\n\n    uint64_t nb_sectors;\n\n    if (s->qdev.type != TYPE_ROM) {\n\n        return false;\n\n    }\n\n    if (!bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        return false;\n\n    }\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    return nb_sectors <= CD_MAX_SECTORS;\n\n}\n", "idx": 9390}
{"project": "FFmpeg", "commit_id": "42ee137a0a7d025f77964e38b438d00095e6dd11", "target": 1, "func": "static av_cold int m101_decode_init(AVCodecContext *avctx)\n\n{\n\n    if (avctx->extradata_size < 6*4)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (avctx->extradata[2*4] == 10)\n\n        avctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n\n    else\n\n        avctx->pix_fmt = AV_PIX_FMT_YUYV422;\n\n\n\n\n\n    return 0;\n\n}\n", "idx": 9408}
{"project": "qemu", "commit_id": "e2dd21e510ed66daeb4c5d58638450c1fb8c6fea", "target": 1, "func": "static void wait_for_serial(const char *side)\n\n{\n\n    char *serialpath = g_strdup_printf(\"%s/%s\", tmpfs, side);\n\n    FILE *serialfile = fopen(serialpath, \"r\");\n\n    const char *arch = qtest_get_arch();\n\n    int started = (strcmp(side, \"src_serial\") == 0 &&\n\n                   strcmp(arch, \"ppc64\") == 0) ? 0 : 1;\n\n\n\n    do {\n\n        int readvalue = fgetc(serialfile);\n\n\n\n        if (!started) {\n\n            /* SLOF prints its banner before starting test,\n\n             * to ignore it, mark the start of the test with '_',\n\n             * ignore all characters until this marker\n\n             */\n\n            switch (readvalue) {\n\n            case '_':\n\n                started = 1;\n\n                break;\n\n            case EOF:\n\n                fseek(serialfile, 0, SEEK_SET);\n\n                usleep(1000);\n\n                break;\n\n            }\n\n            continue;\n\n        }\n\n        switch (readvalue) {\n\n        case 'A':\n\n            /* Fine */\n\n            break;\n\n\n\n        case 'B':\n\n            /* It's alive! */\n\n            fclose(serialfile);\n\n            g_free(serialpath);\n\n            return;\n\n\n\n        case EOF:\n\n            started = (strcmp(side, \"src_serial\") == 0 &&\n\n                       strcmp(arch, \"ppc64\") == 0) ? 0 : 1;\n\n            fseek(serialfile, 0, SEEK_SET);\n\n            usleep(1000);\n\n            break;\n\n\n\n        default:\n\n            fprintf(stderr, \"Unexpected %d on %s serial\\n\", readvalue, side);\n\n            g_assert_not_reached();\n\n        }\n\n    } while (true);\n\n}\n", "idx": 9441}
{"project": "FFmpeg", "commit_id": "0ce3a0f9d9523a9bcad4c6d451ca5bbd7a4f420d", "target": 1, "func": "static void restore_median(uint8_t *src, int step, int stride,\n\n                           int width, int height, int slices, int rmode)\n\n{\n\n    int i, j, slice;\n\n    int A, B, C;\n\n    uint8_t *bsrc;\n\n    int slice_start, slice_height;\n\n    const int cmask = ~rmode;\n\n\n\n    for (slice = 0; slice < slices; slice++) {\n\n        slice_start  = ((slice * height) / slices) & cmask;\n\n        slice_height = ((((slice + 1) * height) / slices) & cmask) -\n\n                       slice_start;\n\n\n\n\n\n        bsrc = src + slice_start * stride;\n\n\n\n        // first line - left neighbour prediction\n\n        bsrc[0] += 0x80;\n\n        A = bsrc[0];\n\n        for (i = step; i < width * step; i += step) {\n\n            bsrc[i] += A;\n\n            A        = bsrc[i];\n\n        }\n\n        bsrc += stride;\n\n        if (slice_height == 1)\n\n\n        // second line - first element has top prediction, the rest uses median\n\n        C        = bsrc[-stride];\n\n        bsrc[0] += C;\n\n        A        = bsrc[0];\n\n        for (i = step; i < width * step; i += step) {\n\n            B        = bsrc[i - stride];\n\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n\n            C        = B;\n\n            A        = bsrc[i];\n\n        }\n\n        bsrc += stride;\n\n        // the rest of lines use continuous median prediction\n\n        for (j = 2; j < slice_height; j++) {\n\n            for (i = 0; i < width * step; i += step) {\n\n                B        = bsrc[i - stride];\n\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n\n                C        = B;\n\n                A        = bsrc[i];\n\n            }\n\n            bsrc += stride;\n\n        }\n\n    }\n\n}", "idx": 9466}
{"project": "FFmpeg", "commit_id": "25715064c2ef4978672a91f8c856f3e8809a7c45", "target": 0, "func": "static int decode_seq_header(AVSContext *h) {\n\n    MpegEncContext *s = &h->s;\n\n    int frame_rate_code;\n\n\n\n    h->profile =         get_bits(&s->gb,8);\n\n    h->level =           get_bits(&s->gb,8);\n\n    skip_bits1(&s->gb); //progressive sequence\n\n    s->width =           get_bits(&s->gb,14);\n\n    s->height =          get_bits(&s->gb,14);\n\n    skip_bits(&s->gb,2); //chroma format\n\n    skip_bits(&s->gb,3); //sample_precision\n\n    h->aspect_ratio =    get_bits(&s->gb,4);\n\n    frame_rate_code =    get_bits(&s->gb,4);\n\n    skip_bits(&s->gb,18);//bit_rate_lower\n\n    skip_bits1(&s->gb);  //marker_bit\n\n    skip_bits(&s->gb,12);//bit_rate_upper\n\n    s->low_delay =       get_bits1(&s->gb);\n\n    h->mb_width  = (s->width  + 15) >> 4;\n\n    h->mb_height = (s->height + 15) >> 4;\n\n    h->s.avctx->time_base.den = avpriv_frame_rate_tab[frame_rate_code].num;\n\n    h->s.avctx->time_base.num = avpriv_frame_rate_tab[frame_rate_code].den;\n\n    h->s.avctx->width  = s->width;\n\n    h->s.avctx->height = s->height;\n\n    if(!h->top_qp)\n\n        ff_cavs_init_top_lines(h);\n\n    return 0;\n\n}\n", "idx": 9481}
{"project": "FFmpeg", "commit_id": "d9d9fd9446eb722fd288f56d905f0dfde661af8f", "target": 1, "func": "int ff_mpeg_er_init(MpegEncContext *s)\n\n{\n\n    ERContext *er = &s->er;\n\n    int mb_array_size = s->mb_height * s->mb_stride;\n\n    int i;\n\n\n\n    er->avctx       = s->avctx;\n\n\n\n    er->mb_index2xy = s->mb_index2xy;\n\n    er->mb_num      = s->mb_num;\n\n    er->mb_width    = s->mb_width;\n\n    er->mb_height   = s->mb_height;\n\n    er->mb_stride   = s->mb_stride;\n\n    er->b8_stride   = s->b8_stride;\n\n\n\n    er->er_temp_buffer     = av_malloc(s->mb_height * s->mb_stride);\n\n    er->error_status_table = av_mallocz(mb_array_size);\n\n    if (!er->er_temp_buffer || !er->error_status_table)\n\n        goto fail;\n\n\n\n    er->mbskip_table  = s->mbskip_table;\n\n    er->mbintra_table = s->mbintra_table;\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(s->dc_val); i++)\n\n        er->dc_val[i] = s->dc_val[i];\n\n\n\n    er->decode_mb = mpeg_er_decode_mb;\n\n    er->opaque    = s;\n\n\n\n    return 0;\n\nfail:\n\n    av_freep(&er->er_temp_buffer);\n\n    av_freep(&er->error_status_table);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 9483}
{"project": "qemu", "commit_id": "35f9304d925a5423c51bd2c83a81fa3cc2b6e680", "target": 1, "func": "static target_ulong remove_hpte(CPUPPCState *env, target_ulong ptex,\n\n                                target_ulong avpn,\n\n                                target_ulong flags,\n\n                                target_ulong *vp, target_ulong *rp)\n\n{\n\n    uint8_t *hpte;\n\n    target_ulong v, r, rb;\n\n\n\n    if ((ptex * HASH_PTE_SIZE_64) & ~env->htab_mask) {\n\n        return REMOVE_PARM;\n\n    }\n\n\n\n    hpte = env->external_htab + (ptex * HASH_PTE_SIZE_64);\n\n    while (!lock_hpte(hpte, HPTE_V_HVLOCK)) {\n\n        /* We have no real concurrency in qemu soft-emulation, so we\n\n         * will never actually have a contested lock */\n\n        assert(0);\n\n    }\n\n\n\n    v = ldq_p(hpte);\n\n    r = ldq_p(hpte + (HASH_PTE_SIZE_64/2));\n\n\n\n    if ((v & HPTE_V_VALID) == 0 ||\n\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n\n        stq_p(hpte, v & ~HPTE_V_HVLOCK);\n\n        assert(!(ldq_p(hpte) & HPTE_V_HVLOCK));\n\n        return REMOVE_NOT_FOUND;\n\n    }\n\n    *vp = v & ~HPTE_V_HVLOCK;\n\n    *rp = r;\n\n    stq_p(hpte, 0);\n\n    rb = compute_tlbie_rb(v, r, ptex);\n\n    ppc_tlb_invalidate_one(env, rb);\n\n    assert(!(ldq_p(hpte) & HPTE_V_HVLOCK));\n\n    return REMOVE_SUCCESS;\n\n}\n", "idx": 9495}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "SerialState *serial_init(int base, qemu_irq irq, int baudbase,\n\n                         CharDriverState *chr)\n\n{\n\n    SerialState *s;\n\n\n\n    s = qemu_mallocz(sizeof(SerialState));\n\n    if (!s)\n\n        return NULL;\n\n    s->irq = irq;\n\n    s->baudbase = baudbase;\n\n\n\n    s->tx_timer = qemu_new_timer(vm_clock, serial_tx_done, s);\n\n    if (!s->tx_timer)\n\n        return NULL;\n\n\n\n    qemu_register_reset(serial_reset, s);\n\n    serial_reset(s);\n\n\n\n    register_savevm(\"serial\", base, 2, serial_save, serial_load, s);\n\n\n\n    register_ioport_write(base, 8, 1, serial_ioport_write, s);\n\n    register_ioport_read(base, 8, 1, serial_ioport_read, s);\n\n    s->chr = chr;\n\n    qemu_chr_add_handlers(chr, serial_can_receive1, serial_receive1,\n\n                          serial_event, s);\n\n    return s;\n\n}\n", "idx": 9512}
{"project": "qemu", "commit_id": "e4f4fb1eca795e36f363b4647724221e774523c1", "target": 1, "func": "static void kvmclock_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = kvmclock_realize;\n\n    dc->vmsd = &kvmclock_vmsd;\n\n    dc->props = kvmclock_properties;\n\n\n\n\n\n\n}", "idx": 9514}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(bgr24ToUV_half)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused)\n\n{\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        int b= src1[6*i + 0] + src1[6*i + 3];\n\n        int g= src1[6*i + 1] + src1[6*i + 4];\n\n        int r= src1[6*i + 2] + src1[6*i + 5];\n\n\n\n        dstU[i]= (RU*r + GU*g + BU*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n        dstV[i]= (RV*r + GV*g + BV*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);\n\n    }\n\n    assert(src1 == src2);\n\n}\n", "idx": 9522}
{"project": "qemu", "commit_id": "f3a06403b82c7f036564e4caf18b52ce6885fcfb", "target": 1, "func": "static int64_t guest_file_handle_add(FILE *fh, Error **errp)\n\n{\n\n    GuestFileHandle *gfh;\n\n    int64_t handle;\n\n\n\n    handle = ga_get_fd_handle(ga_state, errp);\n\n    if (handle < 0) {\n\n        return -1;\n\n    }\n\n\n\n    gfh = g_malloc0(sizeof(GuestFileHandle));\n\n    gfh->id = handle;\n\n    gfh->fh = fh;\n\n    QTAILQ_INSERT_TAIL(&guest_file_state.filehandles, gfh, next);\n\n\n\n    return handle;\n\n}\n", "idx": 9523}
{"project": "qemu", "commit_id": "55e00a19b6dc8f20e5688866451bb4a60e649459", "target": 0, "func": "static void armv7m_nvic_class_init(ObjectClass *klass, void *data)\n\n{\n\n    NVICClass *nc = NVIC_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    nc->parent_reset = dc->reset;\n\n    nc->parent_init = sdc->init;\n\n    sdc->init = armv7m_nvic_init;\n\n    dc->vmsd  = &vmstate_nvic;\n\n    dc->reset = armv7m_nvic_reset;\n\n    dc->props = armv7m_nvic_properties;\n\n}\n", "idx": 9579}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static int ehci_qh_do_overlay(EHCIQueue *q)\n\n{\n\n    int i;\n\n    int dtoggle;\n\n    int ping;\n\n    int eps;\n\n    int reload;\n\n\n\n    // remember values in fields to preserve in qh after overlay\n\n\n\n    dtoggle = q->qh.token & QTD_TOKEN_DTOGGLE;\n\n    ping    = q->qh.token & QTD_TOKEN_PING;\n\n\n\n    q->qh.current_qtd = q->qtdaddr;\n\n    q->qh.next_qtd    = q->qtd.next;\n\n    q->qh.altnext_qtd = q->qtd.altnext;\n\n    q->qh.token       = q->qtd.token;\n\n\n\n\n\n    eps = get_field(q->qh.epchar, QH_EPCHAR_EPS);\n\n    if (eps == EHCI_QH_EPS_HIGH) {\n\n        q->qh.token &= ~QTD_TOKEN_PING;\n\n        q->qh.token |= ping;\n\n    }\n\n\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n\n    set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT);\n\n\n\n    for (i = 0; i < 5; i++) {\n\n        q->qh.bufptr[i] = q->qtd.bufptr[i];\n\n    }\n\n\n\n    if (!(q->qh.epchar & QH_EPCHAR_DTC)) {\n\n        // preserve QH DT bit\n\n        q->qh.token &= ~QTD_TOKEN_DTOGGLE;\n\n        q->qh.token |= dtoggle;\n\n    }\n\n\n\n    q->qh.bufptr[1] &= ~BUFPTR_CPROGMASK_MASK;\n\n    q->qh.bufptr[2] &= ~BUFPTR_FRAMETAG_MASK;\n\n\n\n    put_dwords(NLPTR_GET(q->qhaddr), (uint32_t *) &q->qh, sizeof(EHCIqh) >> 2);\n\n\n\n    return 0;\n\n}\n", "idx": 9583}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t intel_hda_mmio_readw(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    return intel_hda_reg_read(d, reg, 0xffff);\n\n}\n", "idx": 9585}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "static void rtas_ibm_read_pci_config(sPAPREnvironment *spapr,\n\n                                     uint32_t token, uint32_t nargs,\n\n                                     target_ulong args,\n\n                                     uint32_t nret, target_ulong rets)\n\n{\n\n    uint64_t buid;\n\n    uint32_t size, addr;\n\n\n\n    if ((nargs != 4) || (nret != 2)) {\n\n        rtas_st(rets, 0, -1);\n\n        return;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    size = rtas_ld(args, 3);\n\n    addr = rtas_ld(args, 0);\n\n\n\n    finish_read_pci_config(spapr, buid, addr, size, rets);\n\n}\n", "idx": 9586}
{"project": "qemu", "commit_id": "5923f85fb82df7c8c60a89458a5ae856045e5ab1", "target": 1, "func": "static bool acpi_get_mcfg(AcpiMcfgInfo *mcfg)\n\n{\n\n    Object *pci_host;\n\n    QObject *o;\n\n\n\n    pci_host = acpi_get_i386_pci_host();\n\n    g_assert(pci_host);\n\n\n\n    o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_BASE, NULL);\n\n    if (!o) {\n\n        return false;\n\n    }\n\n    mcfg->mcfg_base = qnum_get_int(qobject_to_qnum(o));\n\n    qobject_decref(o);\n\n\n\n    o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_SIZE, NULL);\n\n    assert(o);\n\n    mcfg->mcfg_size = qnum_get_int(qobject_to_qnum(o));\n\n    qobject_decref(o);\n\n    return true;\n\n}\n", "idx": 9611}
{"project": "qemu", "commit_id": "b14ef7c9ab41ea824c3ccadb070ad95567cca84e", "target": 1, "func": "static void unassigned_mem_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem write \" TARGET_FMT_plx \" = 0x%x\\n\", addr, val);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 1, 0, 0, 4);\n\n#endif\n\n}\n", "idx": 9613}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_utimensat(FsContext *s, V9fsPath *fs_path,\n\n                           const struct timespec *buf)\n\n{\n\n    int retval;\n\n    retval = v9fs_request(s->private, T_UTIME, NULL, \"sqqqq\",\n\n                          fs_path,\n\n                          buf[0].tv_sec, buf[0].tv_nsec,\n\n                          buf[1].tv_sec, buf[1].tv_nsec);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n    }\n\n    return retval;\n\n}\n", "idx": 9642}
{"project": "FFmpeg", "commit_id": "2e7744a6a265604600f86a85c6961dbf5df9ecdd", "target": 1, "func": "static int subviewer_decode_frame(AVCodecContext *avctx,\n\n                                  void *data, int *got_sub_ptr, AVPacket *avpkt)\n\n{\n\n    char c;\n\n    AVSubtitle *sub = data;\n\n    const char *ptr = avpkt->data;\n\n    AVBPrint buf;\n\n\n\n    /* To be removed later */\n\n    if (sscanf(ptr, \"%*u:%*u:%*u.%*u,%*u:%*u:%*u.%*u%c\", &c) == 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"AVPacket is not clean (contains timing \"\n\n               \"information). You need to upgrade your libavformat or \"\n\n               \"sanitize your packet.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n    // note: no need to rescale pts & duration since they are in the same\n\n    // timebase as ASS (1/100)\n\n    if (ptr && avpkt->size > 0 && !subviewer_event_to_ass(&buf, ptr))\n\n        ff_ass_add_rect(sub, buf.str, avpkt->pts, avpkt->duration, 0);\n\n    *got_sub_ptr = sub->num_rects > 0;\n\n    av_bprint_finalize(&buf, NULL);\n\n    return avpkt->size;\n\n}\n", "idx": 9649}
{"project": "qemu", "commit_id": "141af038dd1e73ed32e473046adeb822537c1152", "target": 1, "func": "static int csrhci_write(struct CharDriverState *chr,\n\n                const uint8_t *buf, int len)\n\n{\n\n    struct csrhci_s *s = (struct csrhci_s *) chr->opaque;\n\n    int plen = s->in_len;\n\n\n\n    if (!s->enable)\n\n        return 0;\n\n\n\n    s->in_len += len;\n\n    memcpy(s->inpkt + plen, buf, len);\n\n\n\n    while (1) {\n\n        if (s->in_len >= 2 && plen < 2)\n\n            s->in_hdr = csrhci_header_len(s->inpkt) + 1;\n\n\n\n        if (s->in_len >= s->in_hdr && plen < s->in_hdr)\n\n            s->in_data = csrhci_data_len(s->inpkt) + s->in_hdr;\n\n\n\n        if (s->in_len >= s->in_data) {\n\n            csrhci_in_packet(s, s->inpkt);\n\n\n\n            memmove(s->inpkt, s->inpkt + s->in_len, s->in_len - s->in_data);\n\n            s->in_len -= s->in_data;\n\n            s->in_hdr = INT_MAX;\n\n            s->in_data = INT_MAX;\n\n            plen = 0;\n\n        } else\n\n            break;\n\n    }\n\n\n\n    return len;\n\n}\n", "idx": 9660}
{"project": "FFmpeg", "commit_id": "e5540b3fd30367ce3cc33b2f34a04b660dbc4b38", "target": 0, "func": "static int standard_decode_picture_header(VC9Context *v)\n\n{\n\n    int status = 0;\n\n\n\n    if (v->finterpflag) v->interpfrm = get_bits(&v->gb, 1);\n\n    skip_bits(&v->gb, 2); //framecnt unused\n\n    if (v->rangered) v->rangeredfrm = get_bits(&v->gb, 1);\n\n    v->pict_type = get_bits(&v->gb, 1);\n\n    if (v->avctx->max_b_frames && !v->pict_type)\n\n    {\n\n        if (get_bits(&v->gb, 1)) v->pict_type = I_TYPE;\n\n        else v->pict_type = P_TYPE;\n\n    }\n\n    else v->pict_type++; //P_TYPE\n\n\n\n    switch (v->pict_type)\n\n    {\n\n    case I_TYPE: status = decode_i_picture_header(v); break;\n\n    case BI_TYPE: status = decode_b_picture_header(v); break;\n\n    case P_TYPE: status = decode_p_picture_header(v); break;\n\n    case B_TYPE: status = decode_b_picture_header(v); break;\n\n    }\n\n\n\n    if (status == FRAME_SKIPED)\n\n    {\n\n      av_log(v, AV_LOG_INFO, \"Skipping frame...\\n\");\n\n      return status;\n\n    }\n\n\n\n    /* AC/DC Syntax */\n\n    v->transacfrm = get_bits(&v->gb, 1);\n\n    if (v->transacfrm) v->transacfrm += get_bits(&v->gb, 1);\n\n    if (v->pict_type == I_TYPE || v->pict_type == BI_TYPE)\n\n    {\n\n        v->transacfrm2 = get_bits(&v->gb, 1);\n\n        if (v->transacfrm2) v->transacfrm2 += get_bits(&v->gb, 1);\n\n    }\n\n    v->transacdctab = get_bits(&v->gb, 1);\n\n   \n\n    return 0;\n\n}\n", "idx": 9661}
{"project": "qemu", "commit_id": "4782a23b270ecbb9ce0ca6f3f1b60857a09cef0e", "target": 0, "func": "static void do_program_interrupt(CPUS390XState *env)\n\n{\n\n    uint64_t mask, addr;\n\n    LowCore *lowcore;\n\n    hwaddr len = TARGET_PAGE_SIZE;\n\n    int ilen = env->int_pgm_ilen;\n\n\n\n    switch (ilen) {\n\n    case ILEN_LATER:\n\n        ilen = get_ilen(cpu_ldub_code(env, env->psw.addr));\n\n        break;\n\n    case ILEN_LATER_INC:\n\n        ilen = get_ilen(cpu_ldub_code(env, env->psw.addr));\n\n        env->psw.addr += ilen;\n\n        break;\n\n    default:\n\n        assert(ilen == 2 || ilen == 4 || ilen == 6);\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"%s: code=0x%x ilen=%d\\n\",\n\n                  __func__, env->int_pgm_code, ilen);\n\n\n\n    lowcore = cpu_physical_memory_map(env->psa, &len, 1);\n\n\n\n    lowcore->pgm_ilen = cpu_to_be16(ilen);\n\n    lowcore->pgm_code = cpu_to_be16(env->int_pgm_code);\n\n    lowcore->program_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n    lowcore->program_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n    mask = be64_to_cpu(lowcore->program_new_psw.mask);\n\n    addr = be64_to_cpu(lowcore->program_new_psw.addr);\n\n\n\n    cpu_physical_memory_unmap(lowcore, len, 1, len);\n\n\n\n    DPRINTF(\"%s: %x %x %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n            env->int_pgm_code, ilen, env->psw.mask,\n\n            env->psw.addr);\n\n\n\n    load_psw(env, mask, addr);\n\n}\n", "idx": 9666}
{"project": "qemu", "commit_id": "29e179bc3f5e804ab58b975e65c91cb9cd287846", "target": 0, "func": "int get_physical_address(CPUState * env, target_ulong * physical,\n\n\t\t\t int *prot, target_ulong address,\n\n\t\t\t int rw, int access_type)\n\n{\n\n    /* P1, P2 and P4 areas do not use translation */\n\n    if ((address >= 0x80000000 && address < 0xc0000000) ||\n\n\taddress >= 0xe0000000) {\n\n\tif (!(env->sr & SR_MD)\n\n\t    && (address < 0xe0000000 || address > 0xe4000000)) {\n\n\t    /* Unauthorized access in user mode (only store queues are available) */\n\n\t    fprintf(stderr, \"Unauthorized access\\n\");\n\n\t    return (rw & PAGE_WRITE) ? MMU_DTLB_MISS_WRITE :\n\n\t\tMMU_DTLB_MISS_READ;\n\n\t}\n\n\t/* Mask upper 3 bits */\n\n\t*physical = address & 0x1FFFFFFF;\n\n\t*prot = PAGE_READ | PAGE_WRITE;\n\n\treturn MMU_OK;\n\n    }\n\n\n\n    /* If MMU is disabled, return the corresponding physical page */\n\n    if (!env->mmucr & MMUCR_AT) {\n\n\t*physical = address & 0x1FFFFFFF;\n\n\t*prot = PAGE_READ | PAGE_WRITE;\n\n\treturn MMU_OK;\n\n    }\n\n\n\n    /* We need to resort to the MMU */\n\n    return get_mmu_address(env, physical, prot, address, rw, access_type);\n\n}\n", "idx": 9669}
{"project": "FFmpeg", "commit_id": "cbba331aa02f29870581ff0b7ded7477b279ae2c", "target": 0, "func": "static int show_format(WriterContext *w, AVFormatContext *fmt_ctx)\n\n{\n\n    char val_str[128];\n\n    int64_t size = fmt_ctx->pb ? avio_size(fmt_ctx->pb) : -1;\n\n    int ret = 0;\n\n\n\n    writer_print_section_header(w, SECTION_ID_FORMAT);\n\n    print_str(\"filename\",         fmt_ctx->filename);\n\n    print_int(\"nb_streams\",       fmt_ctx->nb_streams);\n\n    print_int(\"nb_programs\",      fmt_ctx->nb_programs);\n\n    print_str(\"format_name\",      fmt_ctx->iformat->name);\n\n    if (!do_bitexact) {\n\n        if (fmt_ctx->iformat->long_name) print_str    (\"format_long_name\", fmt_ctx->iformat->long_name);\n\n        else                             print_str_opt(\"format_long_name\", \"unknown\");\n\n    }\n\n    print_time(\"start_time\",      fmt_ctx->start_time, &AV_TIME_BASE_Q);\n\n    print_time(\"duration\",        fmt_ctx->duration,   &AV_TIME_BASE_Q);\n\n    if (size >= 0) print_val    (\"size\", size, unit_byte_str);\n\n    else           print_str_opt(\"size\", \"N/A\");\n\n    if (fmt_ctx->bit_rate > 0) print_val    (\"bit_rate\", fmt_ctx->bit_rate, unit_bit_per_second_str);\n\n    else                       print_str_opt(\"bit_rate\", \"N/A\");\n\n    print_int(\"probe_score\", av_format_get_probe_score(fmt_ctx));\n\n    ret = show_tags(w, fmt_ctx->metadata, SECTION_ID_FORMAT_TAGS);\n\n\n\n    writer_print_section_footer(w);\n\n    fflush(stdout);\n\n    return ret;\n\n}\n", "idx": 9689}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "void replay_fetch_data_kind(void)\n\n{\n\n    if (replay_file) {\n\n        if (!replay_has_unread_data) {\n\n            replay_data_kind = replay_get_byte();\n\n            if (replay_data_kind == EVENT_INSTRUCTION) {\n\n                replay_state.instructions_count = replay_get_dword();\n\n            }\n\n            replay_check_error();\n\n            replay_has_unread_data = 1;\n\n            if (replay_data_kind >= EVENT_COUNT) {\n\n                error_report(\"Replay: unknown event kind %d\", replay_data_kind);\n\n                exit(1);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 9699}
{"project": "qemu", "commit_id": "19d2b5e6ff7202c2bf45c547efa85ae6c2d76bbd", "target": 0, "func": "static void DMA_run (void)\n\n{\n\n    struct dma_cont *d;\n\n    int icont, ichan;\n\n    int rearm = 0;\n\n    static int running = 0;\n\n\n\n    if (running) {\n\n        rearm = 1;\n\n        goto out;\n\n    } else {\n\n        running = 1;\n\n    }\n\n\n\n    d = dma_controllers;\n\n\n\n    for (icont = 0; icont < 2; icont++, d++) {\n\n        for (ichan = 0; ichan < 4; ichan++) {\n\n            int mask;\n\n\n\n            mask = 1 << ichan;\n\n\n\n            if ((0 == (d->mask & mask)) && (0 != (d->status & (mask << 4)))) {\n\n                channel_run (icont, ichan);\n\n                rearm = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    running = 0;\n\nout:\n\n    if (rearm)\n\n        qemu_bh_schedule_idle(dma_bh);\n\n}\n", "idx": 9700}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static inline void reset_bit(uint32_t *field, int bit)\n\n{\n\n    field[bit >> 5] &= ~(1 << (bit & 0x1F));\n\n}\n", "idx": 9712}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_aio_cancel_async(BlockAIOCB *acb)\n\n{\n\n    if (acb->aiocb_info->cancel_async) {\n\n        acb->aiocb_info->cancel_async(acb);\n\n    }\n\n}\n", "idx": 9743}
{"project": "qemu", "commit_id": "2c0ef9f411ae6081efa9eca5b3eab2dbeee45a6c", "target": 0, "func": "Visitor *qapi_dealloc_get_visitor(QapiDeallocVisitor *v)\n\n{\n\n    return &v->visitor;\n\n}\n", "idx": 9745}
{"project": "FFmpeg", "commit_id": "cc13bc8c4f0f4afa30d0b94c3f3a369ccd2aaf0b", "target": 0, "func": "static int decode_extradata_ps(const uint8_t *data, int size, H264ParamSets *ps,\n\n                               int is_avc, void *logctx)\n\n{\n\n    H2645Packet pkt = { 0 };\n\n    int i, ret = 0;\n\n\n\n    ret = ff_h2645_packet_split(&pkt, data, size, logctx, is_avc, 2, AV_CODEC_ID_H264);\n\n    if (ret < 0) {\n\n        ret = 0;\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < pkt.nb_nals; i++) {\n\n        H2645NAL *nal = &pkt.nals[i];\n\n        switch (nal->type) {\n\n        case H264_NAL_SPS:\n\n            ret = ff_h264_decode_seq_parameter_set(&nal->gb, logctx, ps, 0);\n\n            if (ret < 0)\n\n                goto fail;\n\n            break;\n\n        case H264_NAL_PPS:\n\n            ret = ff_h264_decode_picture_parameter_set(&nal->gb, logctx, ps,\n\n                                                       nal->size_bits);\n\n            if (ret < 0)\n\n                goto fail;\n\n            break;\n\n        default:\n\n            av_log(logctx, AV_LOG_VERBOSE, \"Ignoring NAL type %d in extradata\\n\",\n\n                   nal->type);\n\n            break;\n\n        }\n\n    }\n\n\n\nfail:\n\n    ff_h2645_packet_uninit(&pkt);\n\n    return ret;\n\n}\n", "idx": 9759}
{"project": "FFmpeg", "commit_id": "22522d9c2c69624fe4d81d61ee65a56610f22f1d", "target": 1, "func": "int ff_qsv_decode_init(AVCodecContext *avctx, QSVContext *q, mfxSession session)\n\n{\n\n    mfxVideoParam param = { { 0 } };\n\n    int ret;\n\n\n\n    q->async_fifo = av_fifo_alloc((1 + q->async_depth) *\n\n                                  (sizeof(mfxSyncPoint) + sizeof(QSVFrame*)));\n\n    if (!q->async_fifo)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ret = qsv_init_session(avctx, q, session);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing an MFX session\\n\");\n\n        return ret;\n\n    }\n\n\n\n\n\n    ret = ff_qsv_codec_id_to_mfx(avctx->codec_id);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    param.mfx.CodecId      = ret;\n\n    param.mfx.CodecProfile = avctx->profile;\n\n    param.mfx.CodecLevel   = avctx->level;\n\n\n\n    param.mfx.FrameInfo.BitDepthLuma   = 8;\n\n    param.mfx.FrameInfo.BitDepthChroma = 8;\n\n    param.mfx.FrameInfo.Shift          = 0;\n\n    param.mfx.FrameInfo.FourCC         = MFX_FOURCC_NV12;\n\n    param.mfx.FrameInfo.Width          = avctx->coded_width;\n\n    param.mfx.FrameInfo.Height         = avctx->coded_height;\n\n    param.mfx.FrameInfo.ChromaFormat   = MFX_CHROMAFORMAT_YUV420;\n\n\n\n    param.IOPattern   = q->iopattern;\n\n    param.AsyncDepth  = q->async_depth;\n\n    param.ExtParam    = q->ext_buffers;\n\n    param.NumExtParam = q->nb_ext_buffers;\n\n\n\n    ret = MFXVideoDECODE_Init(q->session, &param);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing the MFX video decoder\\n\");\n\n        return ff_qsv_error(ret);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9774}
{"project": "qemu", "commit_id": "fc9c0a9c4b2c07cf2b8683f2617af584f14c93e7", "target": 1, "func": "void block_job_sleep_ns(BlockJob *job, QEMUClockType type, int64_t ns)\n\n{\n\n    assert(job->busy);\n\n\n\n    /* Check cancellation *before* setting busy = false, too!  */\n\n    if (block_job_is_cancelled(job)) {\n\n        return;\n\n    }\n\n\n\n    job->busy = false;\n\n    if (!block_job_should_pause(job)) {\n\n        co_aio_sleep_ns(blk_get_aio_context(job->blk), type, ns);\n\n    }\n\n    /* The job can be paused while sleeping, so check this again */\n\n    if (block_job_should_pause(job)) {\n\n        qemu_coroutine_yield();\n\n    }\n\n    job->busy = true;\n\n}\n", "idx": 9780}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_mouse_reset(DeviceState *dev)\n\n{\n\n    ADBDevice *d = ADB_DEVICE(dev);\n\n    MouseState *s = ADB_MOUSE(dev);\n\n\n\n    d->handler = 2;\n\n    d->devaddr = ADB_DEVID_MOUSE;\n\n    s->last_buttons_state = s->buttons_state = 0;\n\n    s->dx = s->dy = s->dz = 0;\n\n}\n", "idx": 9793}
{"project": "qemu", "commit_id": "f8a83245d9ec685bc6aa6173d6765fe03e20688f", "target": 1, "func": "static void raw_close(BlockDriverState *bs)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    if (s->fd >= 0) {\n\n        close(s->fd);\n\n        s->fd = -1;\n\n        if (s->aligned_buf != NULL)\n\n            qemu_free(s->aligned_buf);\n\n    }\n\n}\n", "idx": 9795}
{"project": "FFmpeg", "commit_id": "06bf6d3bc04979bd39ecdc7311d0daf8aee7e10f", "target": 1, "func": "static void start_frame_overlay(AVFilterLink *inlink, AVFilterBufferRef *inpicref)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    OverlayContext *over = ctx->priv;\n\n\n\n    inpicref->pts = av_rescale_q(inpicref->pts, ctx->inputs[OVERLAY]->time_base,\n\n                                 ctx->outputs[0]->time_base);\n\n\n\n    if (!over->overpicref) over->overpicref      = inpicref;\n\n    else                   over->overpicref_next = inpicref;\n\n}\n", "idx": 9835}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(simple_dict)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \"{\\\"foo\\\": 42, \\\"bar\\\": \\\"hello world\\\"}\",\n\n            .decoded = QLIT_QDICT(((LiteralQDictEntry[]){\n\n                        { \"foo\", QLIT_QINT(42) },\n\n                        { \"bar\", QLIT_QSTR(\"hello world\") },\n\n                        { }\n\n                    })),\n\n        }, {\n\n            .encoded = \"{}\",\n\n            .decoded = QLIT_QDICT(((LiteralQDictEntry[]){\n\n                        { }\n\n                    })),\n\n        }, {\n\n            .encoded = \"{\\\"foo\\\": 43}\",\n\n            .decoded = QLIT_QDICT(((LiteralQDictEntry[]){\n\n                        { \"foo\", QLIT_QINT(43) },\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QDICT);\n\n\n\n        fail_unless(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str));\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QDICT);\n\n\n\n        fail_unless(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 9860}
{"project": "qemu", "commit_id": "a0efbf16604770b9d805bcf210ec29942321134f", "target": 0, "func": "static void i440fx_pcihost_get_pci_hole64_end(Object *obj, Visitor *v,\n\n                                              const char *name, void *opaque,\n\n                                              Error **errp)\n\n{\n\n    PCIHostState *h = PCI_HOST_BRIDGE(obj);\n\n    Range w64;\n\n\n\n    pci_bus_get_w64_range(h->bus, &w64);\n\n\n\n    visit_type_uint64(v, name, &w64.end, errp);\n\n}\n", "idx": 9861}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "void ioinst_handle_stsch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    uint64_t addr;\n\n    int cc;\n\n    SCHIB schib;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return;\n\n    }\n\n\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid)) {\n\n        /*\n\n         * As operand exceptions have a lower priority than access exceptions,\n\n         * we check whether the memory area is writeable (injecting the\n\n         * access execption if it is not) first.\n\n         */\n\n        if (!s390_cpu_virt_mem_check_write(cpu, addr, ar, sizeof(schib))) {\n\n            program_interrupt(env, PGM_OPERAND, 2);\n\n        }\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"stsch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch) {\n\n        if (css_subch_visible(sch)) {\n\n            css_do_stsch(sch, &schib);\n\n            cc = 0;\n\n        } else {\n\n            /* Indicate no more subchannels in this css/ss */\n\n            cc = 3;\n\n        }\n\n    } else {\n\n        if (css_schid_final(m, cssid, ssid, schid)) {\n\n            cc = 3; /* No more subchannels in this css/ss */\n\n        } else {\n\n            /* Store an empty schib. */\n\n            memset(&schib, 0, sizeof(schib));\n\n            cc = 0;\n\n        }\n\n    }\n\n    if (cc != 3) {\n\n        if (s390_cpu_virt_mem_write(cpu, addr, ar, &schib,\n\n                                    sizeof(schib)) != 0) {\n\n            return;\n\n        }\n\n    } else {\n\n        /* Access exceptions have a higher priority than cc3 */\n\n        if (s390_cpu_virt_mem_check_write(cpu, addr, ar, sizeof(schib)) != 0) {\n\n            return;\n\n        }\n\n    }\n\n    setcc(cpu, cc);\n\n}\n", "idx": 9866}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static void cow_close(BlockDriverState *bs)\n\n{\n\n}\n", "idx": 9872}
{"project": "qemu", "commit_id": "8daea510951dd309a44cea8de415c685c43851cf", "target": 1, "func": "void qdev_prop_set_drive(DeviceState *dev, const char *name,\n\n                         BlockBackend *value, Error **errp)\n\n{\n\n    object_property_set_str(OBJECT(dev), value ? blk_name(value) : \"\",\n\n                            name, errp);\n\n}\n", "idx": 9893}
{"project": "qemu", "commit_id": "5c843af22604edecda10d4bb89d4eede9e1bd3d0", "target": 1, "func": "int net_slirp_redir(const char *redir_str)\n\n{\n\n    struct slirp_config_str *config;\n\n\n\n    if (QTAILQ_EMPTY(&slirp_stacks)) {\n\n        config = g_malloc(sizeof(*config));\n\n        pstrcpy(config->str, sizeof(config->str), redir_str);\n\n        config->flags = SLIRP_CFG_HOSTFWD | SLIRP_CFG_LEGACY;\n\n        config->next = slirp_configs;\n\n        slirp_configs = config;\n\n        return 0;\n\n    }\n\n\n\n    return slirp_hostfwd(QTAILQ_FIRST(&slirp_stacks), redir_str, 1);\n\n}\n", "idx": 9894}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void decode_refpass(Jpeg2000T1Context *t1, int width, int height,\n\n                           int bpno, int vert_causal_ctx_csty_symbol)\n\n{\n\n    int phalf, nhalf;\n\n    int y0, x, y;\n\n\n\n    phalf = 1 << (bpno - 1);\n\n    nhalf = -phalf;\n\n\n\n    for (y0 = 0; y0 < height; y0 += 4)\n\n        for (x = 0; x < width; x++)\n\n            for (y = y0; y < height && y < y0 + 4; y++)\n\n                if ((t1->flags[y + 1][x + 1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS)) == JPEG2000_T1_SIG) {\n\n                    int flags_mask = (vert_causal_ctx_csty_symbol && y == y0 + 3) ?\n\n                        ~(JPEG2000_T1_SIG_S | JPEG2000_T1_SIG_SW | JPEG2000_T1_SIG_SE | JPEG2000_T1_SGN_S) : -1;\n\n                    int ctxno = ff_jpeg2000_getrefctxno(t1->flags[y + 1][x + 1] & flags_mask);\n\n                    int r     = ff_mqc_decode(&t1->mqc,\n\n                                              t1->mqc.cx_states + ctxno)\n\n                                ? phalf : nhalf;\n\n                    t1->data[y][x]          += t1->data[y][x] < 0 ? -r : r;\n\n                    t1->flags[y + 1][x + 1] |= JPEG2000_T1_REF;\n\n                }\n\n}\n", "idx": 9901}
{"project": "qemu", "commit_id": "b0b1d69079fcb9453f45aade9e9f6b71422147b0", "target": 1, "func": "static void kvm_invoke_set_guest_debug(void *data)\n\n{\n\n    struct kvm_set_guest_debug_data *dbg_data = data;\n\n    CPUState *env = dbg_data->env;\n\n\n\n    if (env->kvm_vcpu_dirty) {\n\n        kvm_arch_put_registers(env);\n\n        env->kvm_vcpu_dirty = 0;\n\n    }\n\n    dbg_data->err = kvm_vcpu_ioctl(env, KVM_SET_GUEST_DEBUG, &dbg_data->dbg);\n\n}\n", "idx": 9904}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static uint32_t find_subframe_rice_params(FlacEncodeContext *s,\n\n                                          FlacSubframe *sub, int pred_order)\n\n{\n\n    int pmin = get_max_p_order(s->options.min_partition_order,\n\n                               s->frame.blocksize, pred_order);\n\n    int pmax = get_max_p_order(s->options.max_partition_order,\n\n                               s->frame.blocksize, pred_order);\n\n\n\n    uint32_t bits = 8 + pred_order * sub->obits + 2 + 4;\n\n    if (sub->type == FLAC_SUBFRAME_LPC)\n\n        bits += 4 + 5 + pred_order * s->options.lpc_coeff_precision;\n\n    bits += calc_rice_params(&sub->rc, pmin, pmax, sub->residual,\n\n                             s->frame.blocksize, pred_order);\n\n    return bits;\n\n}\n", "idx": 9911}
{"project": "FFmpeg", "commit_id": "b6db385922b79939b0dc124d53ddb4824afac040", "target": 0, "func": "static int mmap_start(AVFormatContext *ctx)\n\n{\n\n    struct video_data *s = ctx->priv_data;\n\n    enum v4l2_buf_type type;\n\n    int i, res;\n\n\n\n    for (i = 0; i < s->buffers; i++) {\n\n        struct v4l2_buffer buf;\n\n\n\n        memset(&buf, 0, sizeof(struct v4l2_buffer));\n\n        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n        buf.memory = V4L2_MEMORY_MMAP;\n\n        buf.index  = i;\n\n\n\n        res = ioctl(s->fd, VIDIOC_QBUF, &buf);\n\n        if (res < 0) {\n\n            av_log(ctx, AV_LOG_ERROR, \"ioctl(VIDIOC_QBUF): %s\\n\",\n\n                   strerror(errno));\n\n\n\n            return AVERROR(errno);\n\n        }\n\n    }\n\n\n\n    type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n    res = ioctl(s->fd, VIDIOC_STREAMON, &type);\n\n    if (res < 0) {\n\n        av_log(ctx, AV_LOG_ERROR, \"ioctl(VIDIOC_STREAMON): %s\\n\",\n\n               strerror(errno));\n\n\n\n        return AVERROR(errno);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9919}
{"project": "qemu", "commit_id": "f8c35c1d59c9fecf79f6d5a02cd09f472a6f411d", "target": 0, "func": "static void bdrv_rw_em_cb(void *opaque, int ret)\n\n{\n\n    *(int *)opaque = ret;\n\n}\n", "idx": 9964}
{"project": "qemu", "commit_id": "9d6f106552fa5ad9e3128b5052863835526ba271", "target": 0, "func": "void ppc_set_compat(PowerPCCPU *cpu, uint32_t compat_pvr, Error **errp)\n\n{\n\n    int ret = 0;\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *host_pcc;\n\n\n\n    cpu->compat_pvr = compat_pvr;\n\n\n\n    switch (compat_pvr) {\n\n    case CPU_POWERPC_LOGICAL_2_05:\n\n        env->spr[SPR_PCR] = PCR_TM_DIS | PCR_VSX_DIS | PCR_COMPAT_2_07 |\n\n                            PCR_COMPAT_2_06 | PCR_COMPAT_2_05;\n\n        break;\n\n    case CPU_POWERPC_LOGICAL_2_06:\n\n    case CPU_POWERPC_LOGICAL_2_06_PLUS:\n\n        env->spr[SPR_PCR] = PCR_TM_DIS | PCR_COMPAT_2_07 | PCR_COMPAT_2_06;\n\n        break;\n\n    case CPU_POWERPC_LOGICAL_2_07:\n\n        env->spr[SPR_PCR] = PCR_COMPAT_2_07;\n\n        break;\n\n    default:\n\n        env->spr[SPR_PCR] = 0;\n\n        break;\n\n    }\n\n\n\n    host_pcc = kvm_ppc_get_host_cpu_class();\n\n    if (host_pcc) {\n\n        env->spr[SPR_PCR] &= host_pcc->pcr_mask;\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        ret = kvmppc_set_compat(cpu, cpu->compat_pvr);\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret,\n\n                             \"Unable to set CPU compatibility mode in KVM\");\n\n        }\n\n    }\n\n}\n", "idx": 9969}
{"project": "qemu", "commit_id": "acf6e5f0962c4be670d4a93ede77423512521876", "target": 0, "func": "static coroutine_fn int sd_co_pdiscard(BlockDriverState *bs, int64_t offset,\n\n                                      int count)\n\n{\n\n    SheepdogAIOCB acb;\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    QEMUIOVector discard_iov;\n\n    struct iovec iov;\n\n    uint32_t zero = 0;\n\n\n\n    if (!s->discard_supported) {\n\n        return 0;\n\n    }\n\n\n\n    memset(&discard_iov, 0, sizeof(discard_iov));\n\n    memset(&iov, 0, sizeof(iov));\n\n    iov.iov_base = &zero;\n\n    iov.iov_len = sizeof(zero);\n\n    discard_iov.iov = &iov;\n\n    discard_iov.niov = 1;\n\n    if (!QEMU_IS_ALIGNED(offset | count, BDRV_SECTOR_SIZE)) {\n\n        return -ENOTSUP;\n\n    }\n\n    sd_aio_setup(&acb, s, &discard_iov, offset >> BDRV_SECTOR_BITS,\n\n                 count >> BDRV_SECTOR_BITS, AIOCB_DISCARD_OBJ);\n\n\n\nretry:\n\n    if (check_overlapping_aiocb(s, &acb)) {\n\n        qemu_co_queue_wait(&s->overlapping_queue);\n\n        goto retry;\n\n    }\n\n\n\n    sd_co_rw_vector(&acb);\n\n\n\n    QLIST_REMOVE(&acb, aiocb_siblings);\n\n    qemu_co_queue_restart_all(&s->overlapping_queue);\n\n    return acb.ret;\n\n}\n", "idx": 10004}
{"project": "qemu", "commit_id": "880a7578381d1c7ed4d41c7599ae3cc06567a824", "target": 0, "func": "static void gdb_vm_stopped(void *opaque, int reason)\n\n{\n\n    GDBState *s = opaque;\n\n    char buf[256];\n\n    const char *type;\n\n    int ret;\n\n\n\n    if (s->state == RS_SYSCALL)\n\n        return;\n\n\n\n    /* disable single step if it was enable */\n\n    cpu_single_step(s->env, 0);\n\n\n\n    if (reason == EXCP_DEBUG) {\n\n        if (s->env->watchpoint_hit) {\n\n            switch (s->env->watchpoint_hit->flags & BP_MEM_ACCESS) {\n\n            case BP_MEM_READ:\n\n                type = \"r\";\n\n                break;\n\n            case BP_MEM_ACCESS:\n\n                type = \"a\";\n\n                break;\n\n            default:\n\n                type = \"\";\n\n                break;\n\n            }\n\n            snprintf(buf, sizeof(buf), \"T%02x%swatch:\" TARGET_FMT_lx \";\",\n\n                     SIGTRAP, type, s->env->watchpoint_hit->vaddr);\n\n            put_packet(s, buf);\n\n            s->env->watchpoint_hit = NULL;\n\n            return;\n\n        }\n\n\ttb_flush(s->env);\n\n        ret = SIGTRAP;\n\n    } else if (reason == EXCP_INTERRUPT) {\n\n        ret = SIGINT;\n\n    } else {\n\n        ret = 0;\n\n    }\n\n    snprintf(buf, sizeof(buf), \"S%02x\", ret);\n\n    put_packet(s, buf);\n\n}\n", "idx": 10013}
{"project": "qemu", "commit_id": "d6085e3ace20bc9b0fa625d8d79b22668710e217", "target": 0, "func": "void qemu_peer_set_offload(NetClientState *nc, int csum, int tso4, int tso6,\n\n                          int ecn, int ufo)\n\n{\n\n    if (!nc->peer || !nc->peer->info->set_offload) {\n\n        return;\n\n    }\n\n\n\n    nc->peer->info->set_offload(nc->peer, csum, tso4, tso6, ecn, ufo);\n\n}\n", "idx": 10015}
{"project": "qemu", "commit_id": "071663dfc3b93e3f3e573d726cfb685fd25472fa", "target": 0, "func": "uint32_t helper_bcdsetsgn(ppc_avr_t *r, ppc_avr_t *b, uint32_t ps)\n\n{\n\n    int i;\n\n    int invalid = 0;\n\n    int sgnb = bcd_get_sgn(b);\n\n\n\n    *r = *b;\n\n    bcd_put_digit(r, bcd_preferred_sgn(sgnb, ps), 0);\n\n\n\n    for (i = 1; i < 32; i++) {\n\n        bcd_get_digit(b, i, &invalid);\n\n        if (unlikely(invalid)) {\n\n            return CRF_SO;\n\n        }\n\n    }\n\n\n\n    return bcd_cmp_zero(r);\n\n}\n", "idx": 10018}
{"project": "qemu", "commit_id": "393a98924eb00df76231384b86652e1d5f964d67", "target": 0, "func": "uint32_t msix_bar_size(PCIDevice *dev)\n\n{\n\n    return (dev->cap_present & QEMU_PCI_CAP_MSIX) ?\n\n        dev->msix_bar_size : 0;\n\n}\n", "idx": 10020}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->dinfo->bdrv;\n\n    s->conf = conf;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    register_savevm(\"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 10056}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "int ffurl_register_protocol(URLProtocol *protocol)\n\n{\n\n    URLProtocol **p;\n\n    p = &first_protocol;\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n    *p             = protocol;\n\n    protocol->next = NULL;\n\n    return 0;\n\n}\n", "idx": 10060}
{"project": "FFmpeg", "commit_id": "856834a77f4145adc5951e8b08984981fed4463d", "target": 0, "func": "static av_cold int common_init(AVCodecContext *avctx){\n\n    FFV1Context *s = avctx->priv_data;\n\n\n\n    s->avctx= avctx;\n\n    s->flags= avctx->flags;\n\n\n\n    avcodec_get_frame_defaults(&s->picture);\n\n\n\n    ff_dsputil_init(&s->dsp, avctx);\n\n\n\n    s->width = avctx->width;\n\n    s->height= avctx->height;\n\n\n\n    assert(s->width && s->height);\n\n    //defaults\n\n    s->num_h_slices=1;\n\n    s->num_v_slices=1;\n\n\n\n\n\n    return 0;\n\n}\n", "idx": 10075}
{"project": "qemu", "commit_id": "e5b8b0d4ba29fe1268ba049519a1b0cf8552a21a", "target": 0, "func": "static bool e1000_has_rxbufs(E1000State *s, size_t total_size)\n\n{\n\n    int bufs;\n\n    /* Fast-path short packets */\n\n    if (total_size <= s->rxbuf_size) {\n\n        return s->mac_reg[RDH] != s->mac_reg[RDT] || !s->check_rxov;\n\n    }\n\n    if (s->mac_reg[RDH] < s->mac_reg[RDT]) {\n\n        bufs = s->mac_reg[RDT] - s->mac_reg[RDH];\n\n    } else if (s->mac_reg[RDH] > s->mac_reg[RDT] || !s->check_rxov) {\n\n        bufs = s->mac_reg[RDLEN] /  sizeof(struct e1000_rx_desc) +\n\n            s->mac_reg[RDT] - s->mac_reg[RDH];\n\n    } else {\n\n        return false;\n\n    }\n\n    return total_size <= bufs * s->rxbuf_size;\n\n}\n", "idx": 10077}
{"project": "qemu", "commit_id": "d2164ad35c411d97abd2aa5c6f160283d215e214", "target": 1, "func": "static int get_uint8_equal(QEMUFile *f, void *pv, size_t size,\n\n                           VMStateField *field)\n\n{\n\n    uint8_t *v = pv;\n\n    uint8_t v2;\n\n    qemu_get_8s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n\n    error_report(\"%x != %x\", *v, v2);\n\n\n\n\n    return -EINVAL;\n", "idx": 10110}
{"project": "qemu", "commit_id": "249e7e0fff080df0eff54730f3b6459d92d61e5a", "target": 0, "func": "static void cpu_ioreq_move(ioreq_t *req)\n\n{\n\n    int i;\n\n\n\n    if (!req->data_is_ptr) {\n\n        if (req->dir == IOREQ_READ) {\n\n            for (i = 0; i < req->count; i++) {\n\n                read_phys_req_item(req->addr, req, i, &req->data);\n\n            }\n\n        } else if (req->dir == IOREQ_WRITE) {\n\n            for (i = 0; i < req->count; i++) {\n\n                write_phys_req_item(req->addr, req, i, &req->data);\n\n            }\n\n        }\n\n    } else {\n\n        uint64_t tmp;\n\n\n\n        if (req->dir == IOREQ_READ) {\n\n            for (i = 0; i < req->count; i++) {\n\n                read_phys_req_item(req->addr, req, i, &tmp);\n\n                write_phys_req_item(req->data, req, i, &tmp);\n\n            }\n\n        } else if (req->dir == IOREQ_WRITE) {\n\n            for (i = 0; i < req->count; i++) {\n\n                read_phys_req_item(req->data, req, i, &tmp);\n\n                write_phys_req_item(req->addr, req, i, &tmp);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 10124}
{"project": "qemu", "commit_id": "e1c37d0e94048502f9874e6356ce7136d4b05bdb", "target": 0, "func": "bool qemu_savevm_state_blocked(Monitor *mon)\n\n{\n\n    SaveStateEntry *se;\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        if (se->no_migrate) {\n\n            monitor_printf(mon, \"state blocked by non-migratable device '%s'\\n\",\n\n                           se->idstr);\n\n            return true;\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 10133}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_abso(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    int l3 = gen_new_label();\n\n    /* Start with XER OV disabled, the most likely case */\n\n    tcg_gen_movi_tl(cpu_ov, 0);\n\n    tcg_gen_brcondi_tl(TCG_COND_GE, cpu_gpr[rA(ctx->opcode)], 0, l2);\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_gpr[rA(ctx->opcode)], 0x80000000, l1);\n\n    tcg_gen_movi_tl(cpu_ov, 1);\n\n    tcg_gen_movi_tl(cpu_so, 1);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_neg_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_br(l3);\n\n    gen_set_label(l2);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    gen_set_label(l3);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rD(ctx->opcode)]);\n\n}\n", "idx": 10137}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "DeviceState *sysbus_create_varargs(const char *name,\n\n                                   target_phys_addr_t addr, ...)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    va_list va;\n\n    qemu_irq irq;\n\n    int n;\n\n\n\n    dev = qdev_create(NULL, name);\n\n    s = sysbus_from_qdev(dev);\n\n    qdev_init(dev);\n\n    if (addr != (target_phys_addr_t)-1) {\n\n        sysbus_mmio_map(s, 0, addr);\n\n    }\n\n    va_start(va, addr);\n\n    n = 0;\n\n    while (1) {\n\n        irq = va_arg(va, qemu_irq);\n\n        if (!irq) {\n\n            break;\n\n        }\n\n        sysbus_connect_irq(s, n, irq);\n\n        n++;\n\n    }\n\n    return dev;\n\n}\n", "idx": 10146}
{"project": "qemu", "commit_id": "2b584959ed300ddff4acba0d7554becad5f274fd", "target": 0, "func": "void bdrv_set_translation_hint(BlockDriverState *bs, int translation)\n\n{\n\n    bs->translation = translation;\n\n}\n", "idx": 10187}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int coroutine_fn raw_co_preadv(BlockDriverState *bs, uint64_t offset,\n\n                                      uint64_t bytes, QEMUIOVector *qiov,\n\n                                      int flags)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (offset > UINT64_MAX - s->offset) {\n\n        return -EINVAL;\n\n    }\n\n    offset += s->offset;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);\n\n}\n", "idx": 10193}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static bool balloon_stats_supported(const VirtIOBalloon *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    return vdev->guest_features & (1 << VIRTIO_BALLOON_F_STATS_VQ);\n\n}\n", "idx": 10212}
{"project": "qemu", "commit_id": "82258945ef2cc4a4ec7cdcef02e751bd30cb199f", "target": 1, "func": "static void pm_update_sci(PIIX4PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n    int64_t expire_time;\n\n\n\n    pmsts = get_pmsts(s);\n\n    sci_level = (((pmsts & s->pmen) &\n\n                  (RTC_EN | PWRBTN_EN | GBL_EN | TMROF_EN)) != 0);\n\n    qemu_set_irq(s->irq, sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    if ((s->pmen & TMROF_EN) && !(pmsts & TMROF_EN)) {\n\n        expire_time = muldiv64(s->tmr_overflow_time, ticks_per_sec, PM_FREQ);\n\n        qemu_mod_timer(s->tmr_timer, expire_time);\n\n        s->tmr_overflow_time += 0x800000;\n\n    } else {\n\n        qemu_del_timer(s->tmr_timer);\n\n    }\n\n}\n", "idx": 10215}
{"project": "qemu", "commit_id": "237d78f8fc62e62f62246883ecf62e44ed35fb80", "target": 0, "func": "static int discard_single_l2(BlockDriverState *bs, uint64_t offset,\n\n                             uint64_t nb_clusters, enum qcow2_discard_type type,\n\n                             bool full_discard)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n    assert(nb_clusters <= INT_MAX);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_l2_entry;\n\n\n\n        old_l2_entry = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /*\n\n         * If full_discard is false, make sure that a discarded area reads back\n\n         * as zeroes for v3 images (we cannot do it for v2 without actually\n\n         * writing a zero-filled buffer). We can skip the operation if the\n\n         * cluster is already marked as zero, or if it's unallocated and we\n\n         * don't have a backing file.\n\n         *\n\n         * TODO We might want to use bdrv_get_block_status(bs) here, but we're\n\n         * holding s->lock, so that doesn't work today.\n\n         *\n\n         * If full_discard is true, the sector should not read back as zeroes,\n\n         * but rather fall through to the backing file.\n\n         */\n\n        switch (qcow2_get_cluster_type(old_l2_entry)) {\n\n        case QCOW2_CLUSTER_UNALLOCATED:\n\n            if (full_discard || !bs->backing) {\n\n                continue;\n\n            }\n\n            break;\n\n\n\n        case QCOW2_CLUSTER_ZERO_PLAIN:\n\n            if (!full_discard) {\n\n                continue;\n\n            }\n\n            break;\n\n\n\n        case QCOW2_CLUSTER_ZERO_ALLOC:\n\n        case QCOW2_CLUSTER_NORMAL:\n\n        case QCOW2_CLUSTER_COMPRESSED:\n\n            break;\n\n\n\n        default:\n\n            abort();\n\n        }\n\n\n\n        /* First remove L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (!full_discard && s->qcow_version >= 3) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        } else {\n\n            l2_table[l2_index + i] = cpu_to_be64(0);\n\n        }\n\n\n\n        /* Then decrease the refcount */\n\n        qcow2_free_any_clusters(bs, old_l2_entry, 1, type);\n\n    }\n\n\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void **) &l2_table);\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 10222}
{"project": "FFmpeg", "commit_id": "b53f89710b03c4c832bb03e4e132b1ace17fb4e4", "target": 0, "func": "static int alac_decode_frame(AVCodecContext *avctx, void *data,\n\n                             int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    ALACContext *alac = avctx->priv_data;\n\n    enum RawDataBlockType element;\n\n    int channels;\n\n    int ch, ret, got_end;\n\n\n\n    init_get_bits(&alac->gb, avpkt->data, avpkt->size * 8);\n\n\n\n    got_end = 0;\n\n    alac->nb_samples = 0;\n\n    ch = 0;\n\n    while (get_bits_left(&alac->gb) >= 3) {\n\n        element = get_bits(&alac->gb, 3);\n\n        if (element == TYPE_END) {\n\n            got_end = 1;\n\n            break;\n\n        }\n\n        if (element > TYPE_CPE && element != TYPE_LFE) {\n\n            av_log(avctx, AV_LOG_ERROR, \"syntax element unsupported: %d\\n\", element);\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n\n\n        channels = (element == TYPE_CPE) ? 2 : 1;\n\n        if (ch + channels > alac->channels) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid element channel count\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        ret = decode_element(avctx, data,\n\n                             alac_channel_layout_offsets[alac->channels - 1][ch],\n\n                             channels);\n\n        if (ret < 0 && get_bits_left(&alac->gb))\n\n            return ret;\n\n\n\n        ch += channels;\n\n    }\n\n    if (!got_end) {\n\n        av_log(avctx, AV_LOG_ERROR, \"no end tag found. incomplete packet.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (avpkt->size * 8 - get_bits_count(&alac->gb) > 8) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error : %d bits left\\n\",\n\n               avpkt->size * 8 - get_bits_count(&alac->gb));\n\n    }\n\n\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = alac->frame;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 10232}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static void g364fb_init(DeviceState *dev, G364State *s)\n\n{\n\n    s->vram = g_malloc0(s->vram_size);\n\n\n\n    s->con = graphic_console_init(g364fb_update_display,\n\n                                  g364fb_invalidate_display,\n\n                                  g364fb_screen_dump, NULL, s);\n\n\n\n    memory_region_init_io(&s->mem_ctrl, &g364fb_ctrl_ops, s, \"ctrl\", 0x180000);\n\n    memory_region_init_ram_ptr(&s->mem_vram, \"vram\",\n\n                               s->vram_size, s->vram);\n\n    vmstate_register_ram(&s->mem_vram, dev);\n\n    memory_region_set_coalescing(&s->mem_vram);\n\n}\n", "idx": 10239}
{"project": "qemu", "commit_id": "a8d411abac9347aadeac87687b8a3c9895ea0fd7", "target": 0, "func": "void helper_xssqrtqp(CPUPPCState *env, uint32_t opcode)\n\n{\n\n    ppc_vsr_t xb;\n\n    ppc_vsr_t xt;\n\n    float_status tstat;\n\n\n\n    getVSR(rB(opcode) + 32, &xb, env);\n\n    memset(&xt, 0, sizeof(xt));\n\n    helper_reset_fpstatus(env);\n\n\n\n    if (unlikely(Rc(opcode) != 0)) {\n\n        /* TODO: Support xsadddpo after round-to-odd is implemented */\n\n        abort();\n\n    }\n\n\n\n    tstat = env->fp_status;\n\n    set_float_exception_flags(0, &tstat);\n\n    xt.f128 = float128_sqrt(xb.f128, &tstat);\n\n    env->fp_status.float_exception_flags |= tstat.float_exception_flags;\n\n\n\n    if (unlikely(tstat.float_exception_flags & float_flag_invalid)) {\n\n        if (float128_is_signaling_nan(xb.f128, &tstat)) {\n\n            float_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN, 1);\n\n            xt.f128 = float128_snan_to_qnan(xb.f128);\n\n        } else if  (float128_is_quiet_nan(xb.f128, &tstat)) {\n\n            xt.f128 = xb.f128;\n\n        } else if (float128_is_neg(xb.f128) && !float128_is_zero(xb.f128)) {\n\n            float_invalid_op_excp(env, POWERPC_EXCP_FP_VXSQRT, 1);\n\n            set_snan_bit_is_one(0, &env->fp_status);\n\n            xt.f128 = float128_default_nan(&env->fp_status);\n\n        }\n\n    }\n\n\n\n    helper_compute_fprf_float128(env, xt.f128);\n\n    putVSR(rD(opcode) + 32, &xt, env);\n\n    float_check_status(env);\n\n}\n", "idx": 10264}
{"project": "qemu", "commit_id": "ad96090a01d848df67d70c5259ed8aa321fa8716", "target": 0, "func": "static int is_dup_page(uint8_t *page, uint8_t ch)\n\n{\n\n    uint32_t val = ch << 24 | ch << 16 | ch << 8 | ch;\n\n    uint32_t *array = (uint32_t *)page;\n\n    int i;\n\n\n\n    for (i = 0; i < (TARGET_PAGE_SIZE / 4); i++) {\n\n        if (array[i] != val)\n\n            return 0;\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 10274}
{"project": "qemu", "commit_id": "fae2afb10e3fdceab612c62a2b1e8b944ff578d9", "target": 0, "func": "void qxl_log_command(PCIQXLDevice *qxl, const char *ring, QXLCommandExt *ext)\n\n{\n\n    bool compat = ext->flags & QXL_COMMAND_FLAG_COMPAT;\n\n    void *data;\n\n\n\n    if (!qxl->cmdlog) {\n\n        return;\n\n    }\n\n    fprintf(stderr, \"%\" PRId64 \" qxl-%d/%s:\", qemu_get_clock_ns(vm_clock),\n\n            qxl->id, ring);\n\n    fprintf(stderr, \" cmd @ 0x%\" PRIx64 \" %s%s\", ext->cmd.data,\n\n            qxl_name(qxl_type, ext->cmd.type),\n\n            compat ? \"(compat)\" : \"\");\n\n\n\n    data = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n\n    switch (ext->cmd.type) {\n\n    case QXL_CMD_DRAW:\n\n        if (!compat) {\n\n            qxl_log_cmd_draw(qxl, data, ext->group_id);\n\n        } else {\n\n            qxl_log_cmd_draw_compat(qxl, data, ext->group_id);\n\n        }\n\n        break;\n\n    case QXL_CMD_SURFACE:\n\n        qxl_log_cmd_surface(qxl, data);\n\n        break;\n\n    case QXL_CMD_CURSOR:\n\n        qxl_log_cmd_cursor(qxl, data, ext->group_id);\n\n        break;\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n}\n", "idx": 10283}
{"project": "qemu", "commit_id": "7dfbfc7927c1f7ab9f6910768ed6d966645b5866", "target": 0, "func": "int vnc_display_disable_login(DisplayState *ds)\n\n{\n\n    VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n\n\n\n    if (!vs) {\n\n        return -1;\n\n    }\n\n\n\n    if (vs->password) {\n\n        g_free(vs->password);\n\n    }\n\n\n\n    vs->password = NULL;\n\n    vs->auth = VNC_AUTH_VNC;\n\n\n\n    return 0;\n\n}\n", "idx": 10288}
{"project": "qemu", "commit_id": "b02ef3d92b19ad304a84433d3817f0903296ebc7", "target": 0, "func": "static void read_storage_element0_info(SCLPDevice *sclp, SCCB *sccb)\n\n{\n\n    int i, assigned;\n\n    int subincrement_id = SCLP_STARTING_SUBINCREMENT_ID;\n\n    ReadStorageElementInfo *storage_info = (ReadStorageElementInfo *) sccb;\n\n    sclpMemoryHotplugDev *mhd = get_sclp_memory_hotplug_dev();\n\n\n\n    assert(mhd);\n\n\n\n    if ((ram_size >> mhd->increment_size) >= 0x10000) {\n\n        sccb->h.response_code = cpu_to_be16(SCLP_RC_SCCB_BOUNDARY_VIOLATION);\n\n        return;\n\n    }\n\n\n\n    /* Return information regarding core memory */\n\n    storage_info->max_id = cpu_to_be16(mhd->standby_mem_size ? 1 : 0);\n\n    assigned = ram_size >> mhd->increment_size;\n\n    storage_info->assigned = cpu_to_be16(assigned);\n\n\n\n    for (i = 0; i < assigned; i++) {\n\n        storage_info->entries[i] = cpu_to_be32(subincrement_id);\n\n        subincrement_id += SCLP_INCREMENT_UNIT;\n\n    }\n\n    sccb->h.response_code = cpu_to_be16(SCLP_RC_NORMAL_READ_COMPLETION);\n\n}\n", "idx": 10293}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "void net_rx_pkt_attach_data(struct NetRxPkt *pkt, const void *data,\n\n                               size_t len, bool strip_vlan)\n\n{\n\n    uint16_t tci = 0;\n\n    uint16_t ploff;\n\n    assert(pkt);\n\n    pkt->vlan_stripped = false;\n\n\n\n    if (strip_vlan) {\n\n        pkt->vlan_stripped = eth_strip_vlan(data, pkt->ehdr_buf, &ploff, &tci);\n\n    }\n\n\n\n    if (pkt->vlan_stripped) {\n\n        pkt->vec[0].iov_base = pkt->ehdr_buf;\n\n        pkt->vec[0].iov_len = ploff - sizeof(struct vlan_header);\n\n        pkt->vec[1].iov_base = (uint8_t *) data + ploff;\n\n        pkt->vec[1].iov_len = len - ploff;\n\n        pkt->vec_len = 2;\n\n        pkt->tot_len = len - ploff + sizeof(struct eth_header);\n\n    } else {\n\n        pkt->vec[0].iov_base = (void *)data;\n\n        pkt->vec[0].iov_len = len;\n\n        pkt->vec_len = 1;\n\n        pkt->tot_len = len;\n\n    }\n\n\n\n    pkt->tci = tci;\n\n}\n", "idx": 10317}
{"project": "qemu", "commit_id": "95c318f5e1f88d7e5bcc6deac17330fd4806a2d3", "target": 1, "func": "static int subpage_register (subpage_t *mmio, uint32_t start, uint32_t end,\n\n                             ram_addr_t memory, ram_addr_t region_offset)\n\n{\n\n    int idx, eidx;\n\n\n\n    if (start >= TARGET_PAGE_SIZE || end >= TARGET_PAGE_SIZE)\n\n        return -1;\n\n    idx = SUBPAGE_IDX(start);\n\n    eidx = SUBPAGE_IDX(end);\n\n#if defined(DEBUG_SUBPAGE)\n\n    printf(\"%s: %p start %08x end %08x idx %08x eidx %08x mem %ld\\n\", __func__,\n\n           mmio, start, end, idx, eidx, memory);\n\n#endif\n\n\n\n    memory = (memory >> IO_MEM_SHIFT) & (IO_MEM_NB_ENTRIES - 1);\n\n    for (; idx <= eidx; idx++) {\n\n        mmio->sub_io_index[idx] = memory;\n\n        mmio->region_offset[idx] = region_offset;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 10349}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_output_type_null(Visitor *v, const char *name, Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qmp_output_add_obj(qov, name, qnull());\n\n}\n", "idx": 10376}
{"project": "qemu", "commit_id": "463c534db516701ac732ac606c33c7101cf22e56", "target": 0, "func": "static void xhci_child_detach(USBPort *uport, USBDevice *child)\n\n{\n\n    USBBus *bus = usb_bus_from_device(child);\n\n    XHCIState *xhci = container_of(bus, XHCIState, bus);\n\n\n\n    xhci_detach_slot(xhci, uport);\n\n}\n", "idx": 10383}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(addme)\n\n{\n\n    T1 = T0;\n\n    T0 += xer_ca + (-1);\n\n    if (T1 != 0)\n\n        xer_ca = 1;\n\n    RETURN();\n\n}\n", "idx": 10389}
{"project": "qemu", "commit_id": "8ce1ee4618f4a557959f5a5731f6726b30416df5", "target": 1, "func": "GuestMemoryBlockInfo *qmp_guest_get_memory_block_info(Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    char *dirpath;\n\n    int dirfd;\n\n    char *buf;\n\n    GuestMemoryBlockInfo *info;\n\n\n\n    dirpath = g_strdup_printf(\"/sys/devices/system/memory/\");\n\n    dirfd = open(dirpath, O_RDONLY | O_DIRECTORY);\n\n    if (dirfd == -1) {\n\n        error_setg_errno(errp, errno, \"open(\\\"%s\\\")\", dirpath);\n\n        g_free(dirpath);\n\n        return NULL;\n\n    }\n\n    g_free(dirpath);\n\n\n\n    buf = g_malloc0(20);\n\n    ga_read_sysfs_file(dirfd, \"block_size_bytes\", buf, 20, &local_err);\n\n\n    if (local_err) {\n\n        g_free(buf);\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n\n\n    info = g_new0(GuestMemoryBlockInfo, 1);\n\n    info->size = strtol(buf, NULL, 16); /* the unit is bytes */\n\n\n\n    g_free(buf);\n\n\n\n    return info;\n\n}", "idx": 10409}
{"project": "FFmpeg", "commit_id": "d05588e21e4744ae6a47192dc2da2844d6934a5d", "target": 0, "func": "AVInputFormat *av_probe_input_format3(AVProbeData *pd, int is_opened,\n\n                                      int *score_ret)\n\n{\n\n    AVProbeData lpd = *pd;\n\n    AVInputFormat *fmt1 = NULL, *fmt;\n\n    int score, nodat = 0, score_max = 0;\n\n    const static uint8_t zerobuffer[AVPROBE_PADDING_SIZE];\n\n\n\n    if (!lpd.buf)\n\n        lpd.buf = zerobuffer;\n\n\n\n    if (lpd.buf_size > 10 && ff_id3v2_match(lpd.buf, ID3v2_DEFAULT_MAGIC)) {\n\n        int id3len = ff_id3v2_tag_len(lpd.buf);\n\n        if (lpd.buf_size > id3len + 16) {\n\n            lpd.buf      += id3len;\n\n            lpd.buf_size -= id3len;\n\n        } else\n\n            nodat = 1;\n\n    }\n\n\n\n    fmt = NULL;\n\n    while ((fmt1 = av_iformat_next(fmt1))) {\n\n        if (!is_opened == !(fmt1->flags & AVFMT_NOFILE))\n\n            continue;\n\n        score = 0;\n\n        if (fmt1->read_probe) {\n\n            score = fmt1->read_probe(&lpd);\n\n            if (fmt1->extensions && av_match_ext(lpd.filename, fmt1->extensions))\n\n                score = FFMAX(score, nodat ? AVPROBE_SCORE_EXTENSION / 2 - 1 : 1);\n\n        } else if (fmt1->extensions) {\n\n            if (av_match_ext(lpd.filename, fmt1->extensions))\n\n                score = AVPROBE_SCORE_EXTENSION;\n\n        }\n\n        if (score > score_max) {\n\n            score_max = score;\n\n            fmt       = fmt1;\n\n        } else if (score == score_max)\n\n            fmt = NULL;\n\n    }\n\n    if (nodat)\n\n        score_max = FFMIN(AVPROBE_SCORE_EXTENSION / 2 - 1, score_max);\n\n    *score_ret = score_max;\n\n\n\n    return fmt;\n\n}\n", "idx": 10412}
{"project": "qemu", "commit_id": "f76f665547f4a954a2c83552a88816fc2a316be0", "target": 1, "func": "static int virtio_balloon_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    vdev = virtio_balloon_init(&pci_dev->qdev);\n\n\n\n\n    virtio_init_pci(proxy, vdev);\n\n    return 0;\n", "idx": 10422}
{"project": "qemu", "commit_id": "1104d83c726d2b20f9cec7b99ab3570a2fdbd46d", "target": 1, "func": "int nbd_client_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    NBDRequest request = {\n\n        .type = NBD_CMD_TRIM,\n\n        .from = offset,\n\n        .len = bytes,\n\n    };\n\n\n\n\n    if (!(client->info.flags & NBD_FLAG_SEND_TRIM)) {\n\n        return 0;\n\n    }\n\n\n\n    return nbd_co_request(bs, &request, NULL);\n\n}", "idx": 10462}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static int index_search_timestamp(AVIndexEntry *entries, \n\n                                  int nb_entries, int wanted_timestamp)\n\n{\n\n    int a, b, m;\n\n    int64_t timestamp;\n\n\n\n    if (nb_entries <= 0)\n\n        return -1;\n\n    \n\n    a = 0;\n\n    b = nb_entries - 1;\n\n    while (a <= b) {\n\n        m = (a + b) >> 1;\n\n        timestamp = entries[m].timestamp;\n\n        if (timestamp == wanted_timestamp)\n\n            goto found;\n\n        else if (timestamp > wanted_timestamp) {\n\n            b = m - 1;\n\n        } else {\n\n            a = m + 1;\n\n        }\n\n    }\n\n    m = a;\n\n    if (m > 0)\n\n        m--;\n\n found:\n\n    return m;\n\n}\n", "idx": 10471}
{"project": "qemu", "commit_id": "fa0cfdf24a75f3e6aa6c8b6efcbebd09e7f054aa", "target": 0, "func": "static void vnc_disconnect_finish(VncState *vs)\n\n{\n\n    if (vs->input.buffer) qemu_free(vs->input.buffer);\n\n    if (vs->output.buffer) qemu_free(vs->output.buffer);\n\n#ifdef CONFIG_VNC_TLS\n\n    vnc_tls_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_TLS */\n\n#ifdef CONFIG_VNC_SASL\n\n    vnc_sasl_client_cleanup(vs);\n\n#endif /* CONFIG_VNC_SASL */\n\n    audio_del(vs);\n\n\n\n    VncState *p, *parent = NULL;\n\n    for (p = vs->vd->clients; p != NULL; p = p->next) {\n\n        if (p == vs) {\n\n            if (parent)\n\n                parent->next = p->next;\n\n            else\n\n                vs->vd->clients = p->next;\n\n            break;\n\n        }\n\n        parent = p;\n\n    }\n\n    if (!vs->vd->clients)\n\n        dcl->idle = 1;\n\n\n\n    vnc_remove_timer(vs->vd);\n\n    qemu_free(vs);\n\n}\n", "idx": 10494}
{"project": "qemu", "commit_id": "e6908bfe8e07f2b452e78e677da1b45b1c0f6829", "target": 1, "func": "static void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n    vs->client_pf.rmax = red_max;\n    vs->client_pf.rbits = hweight_long(red_max);\n    vs->client_pf.rshift = red_shift;\n    vs->client_pf.rmask = red_max << red_shift;\n    vs->client_pf.gmax = green_max;\n    vs->client_pf.gbits = hweight_long(green_max);\n    vs->client_pf.gshift = green_shift;\n    vs->client_pf.gmask = green_max << green_shift;\n    vs->client_pf.bmax = blue_max;\n    vs->client_pf.bbits = hweight_long(blue_max);\n    vs->client_pf.bshift = blue_shift;\n    vs->client_pf.bmask = blue_max << blue_shift;\n    vs->client_pf.bits_per_pixel = bits_per_pixel;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n    set_pixel_conversion(vs);\n    graphic_hw_invalidate(NULL);\n    graphic_hw_update(NULL);", "idx": 10501}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static uint8_t qpci_pc_config_readb(QPCIBus *bus, int devfn, uint8_t offset)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    return inb(0xcfc);\n\n}\n", "idx": 10522}
{"project": "qemu", "commit_id": "28143b409f698210d85165ca518235ac7e7c5ac5", "target": 0, "func": "int kvm_has_xcrs(void)\n\n{\n\n    return kvm_state->xcrs;\n\n}\n", "idx": 10575}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_bl(TCGv dst, TCGv_i32 src)\n\n{\n\n    gen_mov_reg_V(cpu_tmp0, src);\n\n    gen_mov_reg_N(dst, src);\n\n    tcg_gen_xor_tl(dst, dst, cpu_tmp0);\n\n}\n", "idx": 10579}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void tilegx_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    TileGXCPU *cpu = TILEGX_CPU(obj);\n\n    CPUTLGState *env = &cpu->env;\n\n    static bool tcg_initialized;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled() && !tcg_initialized) {\n\n        tcg_initialized = true;\n\n        tilegx_tcg_init();\n\n    }\n\n}\n", "idx": 10590}
{"project": "qemu", "commit_id": "df46189412567906312684eb72ba87c6a86a4cdb", "target": 1, "func": "getouraddr(void)\n\n{\n\n\tchar buff[256];\n\n\tstruct hostent *he = NULL;\n\n\n\n\tif (gethostname(buff,256) == 0)\n\n            he = gethostbyname(buff);\n\n        if (he)\n\n            our_addr = *(struct in_addr *)he->h_addr;\n\n        if (our_addr.s_addr == 0)\n\n            our_addr.s_addr = loopback_addr.s_addr;\n\n}\n", "idx": 10592}
{"project": "FFmpeg", "commit_id": "af2ea724951b4b12b4522b462047eebbf9566b84", "target": 0, "func": "void av_aes_crypt(AVAES *a, uint8_t *dst_, const uint8_t *src_,\n\n                  int count, uint8_t *iv_, int decrypt)\n\n{\n\n    av_aes_block       *dst = (av_aes_block *) dst_;\n\n    const av_aes_block *src = (const av_aes_block *) src_;\n\n    av_aes_block        *iv = (av_aes_block *) iv_;\n\n\n\n    while (count--) {\n\n        addkey(&a->state[1], src, &a->round_key[a->rounds]);\n\n        if (decrypt) {\n\n            crypt(a, 0, inv_sbox, dec_multbl);\n\n            if (iv) {\n\n                addkey(&a->state[0], &a->state[0], iv);\n\n                memcpy(iv, src, 16);\n\n            }\n\n            addkey(dst, &a->state[0], &a->round_key[0]);\n\n        } else {\n\n            if (iv)\n\n                addkey(&a->state[1], &a->state[1], iv);\n\n            crypt(a, 2, sbox, enc_multbl);\n\n            addkey(dst, &a->state[0], &a->round_key[0]);\n\n            if (iv)\n\n                memcpy(iv, dst, 16);\n\n        }\n\n        src++;\n\n        dst++;\n\n    }\n\n}\n", "idx": 10596}
{"project": "qemu", "commit_id": "249127d0dfeb2cf5e24d9353b6d54c91c1666ddc", "target": 1, "func": "static void spapr_cpu_core_realize_child(Object *child, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());\n\n    CPUState *cs = CPU(child);\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    Object *obj;\n\n\n\n    obj = object_new(spapr->icp_type);\n\n    object_property_add_child(OBJECT(cpu), \"icp\", obj, NULL);\n\n    object_property_add_const_link(obj, \"xics\", OBJECT(spapr), &error_abort);\n\n    object_property_set_bool(obj, true, \"realized\", &local_err);\n\n    if (local_err) {\n\n        goto error;\n\n    }\n\n\n\n    object_property_set_bool(child, true, \"realized\", &local_err);\n\n    if (local_err) {\n\n        goto error;\n\n    }\n\n\n\n    spapr_cpu_init(spapr, cpu, &local_err);\n\n    if (local_err) {\n\n        goto error;\n\n    }\n\n\n\n    xics_cpu_setup(XICS_FABRIC(spapr), cpu, ICP(obj));\n\n    return;\n\n\n\nerror:\n\n    object_unparent(obj);\n\n    error_propagate(errp, local_err);\n\n}\n", "idx": 10599}
{"project": "qemu", "commit_id": "90527d2a8bb08ca5b4774eacfdd6b8fe9671c077", "target": 1, "func": "static int get_real_id(const char *devpath, const char *idname, uint16_t *val)\n\n{\n\n    FILE *f;\n\n    char name[128];\n\n    long id;\n\n\n\n    snprintf(name, sizeof(name), \"%s%s\", devpath, idname);\n\n    f = fopen(name, \"r\");\n\n    if (f == NULL) {\n\n        error_report(\"%s: %s: %m\", __func__, name);\n\n        return -1;\n\n    }\n\n    if (fscanf(f, \"%li\\n\", &id) == 1) {\n\n        *val = id;\n\n    } else {\n\n\n        return -1;\n\n    }\n\n\n\n\n    return 0;\n\n}", "idx": 10611}
{"project": "FFmpeg", "commit_id": "a09bb3ba5e018b81a659c199a84cd1d80c07d869", "target": 0, "func": "void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic){\n\n    int i;\n\n    InternalBuffer *buf, *last;\n\n    AVCodecInternal *avci = s->internal;\n\n\n\n    assert(s->codec_type == AVMEDIA_TYPE_VIDEO);\n\n\n\n    assert(pic->type==FF_BUFFER_TYPE_INTERNAL);\n\n    assert(avci->buffer_count);\n\n\n\n    if (avci->buffer) {\n\n        buf = NULL; /* avoids warning */\n\n        for (i = 0; i < avci->buffer_count; i++) { //just 3-5 checks so is not worth to optimize\n\n            buf = &avci->buffer[i];\n\n            if (buf->data[0] == pic->data[0])\n\n                break;\n\n        }\n\n        assert(i < avci->buffer_count);\n\n        avci->buffer_count--;\n\n        last = &avci->buffer[avci->buffer_count];\n\n\n\n        FFSWAP(InternalBuffer, *buf, *last);\n\n    }\n\n\n\n    for (i = 0; i < AV_NUM_DATA_POINTERS; i++) {\n\n        pic->data[i]=NULL;\n\n//        pic->base[i]=NULL;\n\n    }\n\n//printf(\"R%X\\n\", pic->opaque);\n\n\n\n    if(s->debug&FF_DEBUG_BUFFERS)\n\n        av_log(s, AV_LOG_DEBUG, \"default_release_buffer called on pic %p, %d \"\n\n               \"buffers used\\n\", pic, avci->buffer_count);\n\n}\n", "idx": 10659}
{"project": "qemu", "commit_id": "dfda68377e20943f474505e75238cb96bc6874bf", "target": 1, "func": "static int get_S2prot(CPUARMState *env, int s2ap, int xn)\n\n{\n\n    int prot = 0;\n\n\n\n    if (s2ap & 1) {\n\n        prot |= PAGE_READ;\n\n    }\n\n    if (s2ap & 2) {\n\n        prot |= PAGE_WRITE;\n\n    }\n\n    if (!xn) {\n\n        prot |= PAGE_EXEC;\n\n    }\n\n    return prot;\n\n}\n", "idx": 10679}
{"project": "qemu", "commit_id": "c4523aae0664aecaa366d45e3d0f3d810ca33062", "target": 1, "func": "void qvirtio_pci_foreach(QPCIBus *bus, uint16_t device_type,\n\n                void (*func)(QVirtioDevice *d, void *data), void *data)\n\n{\n\n    QVirtioPCIForeachData d = { .func = func,\n\n                                .device_type = device_type,\n\n                                .user_data = data };\n\n\n\n    qpci_device_foreach(bus, PCI_VENDOR_ID_REDHAT_QUMRANET, -1,\n\n                                qvirtio_pci_foreach_callback, &d);\n\n}\n", "idx": 10683}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_slbmfee(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    gen_helper_load_slb_esid(cpu_gpr[rS(ctx->opcode)], cpu_env,\n\n                             cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 10685}
{"project": "qemu", "commit_id": "4096974e1885913dfe2931863be47bd35b266521", "target": 1, "func": "static int qcow2_make_empty(BlockDriverState *bs)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t offset, end_offset;\n\n    int step = QEMU_ALIGN_DOWN(INT_MAX, s->cluster_size);\n\n    int l1_clusters, ret = 0;\n\n\n\n    l1_clusters = DIV_ROUND_UP(s->l1_size, s->cluster_size / sizeof(uint64_t));\n\n\n\n    if (s->qcow_version >= 3 && !s->snapshots &&\n\n        3 + l1_clusters <= s->refcount_block_size &&\n\n        s->crypt_method_header != QCOW_CRYPT_LUKS) {\n\n        /* The following function only works for qcow2 v3 images (it requires\n\n         * the dirty flag) and only as long as there are no snapshots (because\n\n         * it completely empties the image). Furthermore, the L1 table and three\n\n         * additional clusters (image header, refcount table, one refcount\n\n         * block) have to fit inside one refcount block. It cannot be used\n\n         * for LUKS (yet) as it throws away the LUKS header cluster(s) */\n\n        return make_completely_empty(bs);\n\n    }\n\n\n\n    /* This fallback code simply discards every active cluster; this is slow,\n\n     * but works in all cases */\n\n    end_offset = bs->total_sectors * BDRV_SECTOR_SIZE;\n\n    for (offset = 0; offset < end_offset; offset += step) {\n\n        /* As this function is generally used after committing an external\n\n         * snapshot, QCOW2_DISCARD_SNAPSHOT seems appropriate. Also, the\n\n         * default action for this kind of discard is to pass the discard,\n\n         * which will ideally result in an actually smaller image file, as\n\n         * is probably desired. */\n\n        ret = qcow2_cluster_discard(bs, offset, MIN(step, end_offset - offset),\n\n                                    QCOW2_DISCARD_SNAPSHOT, true);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 10692}
{"project": "qemu", "commit_id": "2a7e6857cd3178d705a49c4adde2f3af26ed3ae1", "target": 0, "func": "static VncBasicInfoList *qmp_query_server_entry(QIOChannelSocket *ioc,\n\n                                                bool websocket,\n\n                                                VncBasicInfoList *prev)\n\n{\n\n    VncBasicInfoList *list;\n\n    VncBasicInfo *info;\n\n    Error *err = NULL;\n\n    SocketAddress *addr;\n\n\n\n    addr = qio_channel_socket_get_local_address(ioc, &err);\n\n    if (!addr) {\n\n        error_free(err);\n\n        return prev;\n\n    }\n\n\n\n    info = g_new0(VncBasicInfo, 1);\n\n    vnc_init_basic_info(addr, info, &err);\n\n    qapi_free_SocketAddress(addr);\n\n    if (err) {\n\n        qapi_free_VncBasicInfo(info);\n\n        error_free(err);\n\n        return prev;\n\n    }\n\n    info->websocket = websocket;\n\n\n\n    list = g_new0(VncBasicInfoList, 1);\n\n    list->value = info;\n\n    list->next = prev;\n\n    return list;\n\n}\n", "idx": 10722}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "uint32_t HELPER(get_cp_reg)(CPUARMState *env, void *rip)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n\n\n    return ri->readfn(env, ri);\n\n}\n", "idx": 10728}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static NetSocketState *net_socket_fd_init_dgram(VLANState *vlan, int fd, \n\n                                          int is_connected)\n\n{\n\n    struct sockaddr_in saddr;\n\n    int newfd;\n\n    socklen_t saddr_len;\n\n    NetSocketState *s;\n\n\n\n    /* fd passed: multicast: \"learn\" dgram_dst address from bound address and save it\n\n     * Because this may be \"shared\" socket from a \"master\" process, datagrams would be recv() \n\n     * by ONLY ONE process: we must \"clone\" this dgram socket --jjo\n\n     */\n\n\n\n    if (is_connected) {\n\n\tif (getsockname(fd, (struct sockaddr *) &saddr, &saddr_len) == 0) {\n\n\t    /* must be bound */\n\n\t    if (saddr.sin_addr.s_addr==0) {\n\n\t\tfprintf(stderr, \"qemu: error: init_dgram: fd=%d unbound, cannot setup multicast dst addr\\n\",\n\n\t\t\tfd);\n\n\t\treturn NULL;\n\n\t    }\n\n\t    /* clone dgram socket */\n\n\t    newfd = net_socket_mcast_create(&saddr);\n\n\t    if (newfd < 0) {\n\n\t\t/* error already reported by net_socket_mcast_create() */\n\n\t\tclose(fd);\n\n\t\treturn NULL;\n\n\t    }\n\n\t    /* clone newfd to fd, close newfd */\n\n\t    dup2(newfd, fd);\n\n\t    close(newfd);\n\n\t\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: error: init_dgram: fd=%d failed getsockname(): %s\\n\",\n\n\t\t    fd, strerror(errno));\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    s = qemu_mallocz(sizeof(NetSocketState));\n\n    if (!s)\n\n        return NULL;\n\n    s->fd = fd;\n\n\n\n    s->vc = qemu_new_vlan_client(vlan, net_socket_receive_dgram, s);\n\n    qemu_set_fd_handler(s->fd, net_socket_send_dgram, NULL, s);\n\n\n\n    /* mcast: save bound address as dst */\n\n    if (is_connected) s->dgram_dst=saddr;\n\n\n\n    snprintf(s->vc->info_str, sizeof(s->vc->info_str),\n\n\t    \"socket: fd=%d (%s mcast=%s:%d)\", \n\n\t    fd, is_connected? \"cloned\" : \"\",\n\n\t    inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return s;\n\n}\n", "idx": 10729}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "void ff_put_h264_qpel16_mc23_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_16w_msa(src - (2 * stride) - 2,\n\n                              stride, dst, stride, 16, 1);\n\n}\n", "idx": 10739}
{"project": "FFmpeg", "commit_id": "d31dbec3742e488156621b9ca21069f8c05aabf0", "target": 0, "func": "static int init_duplicate_context(MpegEncContext *s, MpegEncContext *base){\n\n    int i;\n\n\n\n    // edge emu needs blocksize + filter length - 1 (=17x17 for halfpel / 21x21 for h264)\n\n    CHECKED_ALLOCZ(s->allocated_edge_emu_buffer, (s->width+64)*2*21*2); //(width + edge + align)*interlaced*MBsize*tolerance\n\n    s->edge_emu_buffer= s->allocated_edge_emu_buffer + (s->width+64)*2*21;\n\n\n\n     //FIXME should be linesize instead of s->width*2 but that is not known before get_buffer()\n\n    CHECKED_ALLOCZ(s->me.scratchpad,  (s->width+64)*4*16*2*sizeof(uint8_t))\n\n    s->me.temp=         s->me.scratchpad;\n\n    s->rd_scratchpad=   s->me.scratchpad;\n\n    s->b_scratchpad=    s->me.scratchpad;\n\n    s->obmc_scratchpad= s->me.scratchpad + 16;\n\n    if (s->encoding) {\n\n        CHECKED_ALLOCZ(s->me.map      , ME_MAP_SIZE*sizeof(uint32_t))\n\n        CHECKED_ALLOCZ(s->me.score_map, ME_MAP_SIZE*sizeof(uint32_t))\n\n        if(s->avctx->noise_reduction){\n\n            CHECKED_ALLOCZ(s->dct_error_sum, 2 * 64 * sizeof(int))\n\n        }\n\n    }\n\n    CHECKED_ALLOCZ(s->blocks, 64*12*2 * sizeof(DCTELEM))\n\n    s->block= s->blocks[0];\n\n\n\n    for(i=0;i<12;i++){\n\n        s->pblocks[i] = &s->block[i];\n\n    }\n\n    return 0;\n\nfail:\n\n    return -1; //free() through MPV_common_end()\n\n}\n", "idx": 10751}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_4w_msa(src - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 4);\n\n}\n", "idx": 10762}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint64_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n    uint64_t v2;\n\n    qemu_get_be64s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n", "idx": 10803}
{"project": "qemu", "commit_id": "82a93a1d307064f35c363f79b04b0a0149ac53d9", "target": 1, "func": "void spapr_drc_detach(sPAPRDRConnector *drc, DeviceState *d, Error **errp)\n\n{\n\n    trace_spapr_drc_detach(spapr_drc_index(drc));\n\n\n\n    if (drc->isolation_state != SPAPR_DR_ISOLATION_STATE_ISOLATED) {\n\n        trace_spapr_drc_awaiting_isolated(spapr_drc_index(drc));\n\n        drc->awaiting_release = true;\n\n        return;\n\n    }\n\n\n\n    if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n\n        drc->allocation_state != SPAPR_DR_ALLOCATION_STATE_UNUSABLE) {\n\n        trace_spapr_drc_awaiting_unusable(spapr_drc_index(drc));\n\n        drc->awaiting_release = true;\n\n        return;\n\n    }\n\n\n\n    if (drc->awaiting_allocation) {\n\n        drc->awaiting_release = true;\n\n        trace_spapr_drc_awaiting_allocation(spapr_drc_index(drc));\n\n        return;\n\n    }\n\n\n\n    spapr_drc_release(drc);\n\n}\n", "idx": 10813}
{"project": "qemu", "commit_id": "7f4a930e64b9e69cd340395a7e4f0494aef4fcdd", "target": 1, "func": "static int vhost_user_set_log_base(struct vhost_dev *dev, uint64_t base,\n\n                                   struct vhost_log *log)\n\n{\n\n    int fds[VHOST_MEMORY_MAX_NREGIONS];\n\n    size_t fd_num = 0;\n\n    bool shmfd = virtio_has_feature(dev->protocol_features,\n\n                                    VHOST_USER_PROTOCOL_F_LOG_SHMFD);\n\n    VhostUserMsg msg = {\n\n        .request = VHOST_USER_SET_LOG_BASE,\n\n        .flags = VHOST_USER_VERSION,\n\n        .u64 = base,\n\n        .size = sizeof(m.u64),\n\n    };\n\n\n\n    if (shmfd && log->fd != -1) {\n\n        fds[fd_num++] = log->fd;\n\n    }\n\n\n\n    vhost_user_write(dev, &msg, fds, fd_num);\n\n\n\n    if (shmfd) {\n\n        msg.size = 0;\n\n        if (vhost_user_read(dev, &msg) < 0) {\n\n            return 0;\n\n        }\n\n\n\n        if (msg.request != VHOST_USER_SET_LOG_BASE) {\n\n            error_report(\"Received unexpected msg type. \"\n\n                         \"Expected %d received %d\",\n\n                         VHOST_USER_SET_LOG_BASE, msg.request);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10815}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void *vmstate_base_addr(void *opaque, VMStateField *field, bool alloc)\n\n{\n\n    void *base_addr = opaque + field->offset;\n\n\n\n    if (field->flags & VMS_POINTER) {\n\n        if (alloc && (field->flags & VMS_ALLOC)) {\n\n            gsize size = 0;\n\n            if (field->flags & VMS_VBUFFER) {\n\n                size = vmstate_size(opaque, field);\n\n            } else {\n\n                int n_elems = vmstate_n_elems(opaque, field);\n\n                if (n_elems) {\n\n                    size = n_elems * field->size;\n\n                }\n\n            }\n\n            if (size) {\n\n                *((void **)base_addr + field->start) = g_malloc(size);\n\n            }\n\n        }\n\n        base_addr = *(void **)base_addr + field->start;\n\n    }\n\n\n\n    return base_addr;\n\n}\n", "idx": 10820}
{"project": "FFmpeg", "commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "target": 1, "func": "static void add_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\n\n                                 ptrdiff_t line_size)\n\n{\n\n    int i;\n\n\n\n    /* read the pixels */\n\n    for (i = 0; i < 8; i++) {\n\n        pixels[0] = av_clip_uint8(pixels[0] + block[0]);\n\n        pixels[1] = av_clip_uint8(pixels[1] + block[1]);\n\n        pixels[2] = av_clip_uint8(pixels[2] + block[2]);\n\n        pixels[3] = av_clip_uint8(pixels[3] + block[3]);\n\n        pixels[4] = av_clip_uint8(pixels[4] + block[4]);\n\n        pixels[5] = av_clip_uint8(pixels[5] + block[5]);\n\n        pixels[6] = av_clip_uint8(pixels[6] + block[6]);\n\n        pixels[7] = av_clip_uint8(pixels[7] + block[7]);\n\n        pixels   += line_size;\n\n        block    += 8;\n\n    }\n\n}\n", "idx": 10828}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "const char *avio_enum_protocols(void **opaque, int output)\n\n{\n\n    URLProtocol *p;\n\n    *opaque = ffurl_protocol_next(*opaque);\n\n    if (!(p = *opaque))\n\n        return NULL;\n\n    if ((output && p->url_write) || (!output && p->url_read))\n\n        return p->name;\n\n    return avio_enum_protocols(opaque, output);\n\n}\n", "idx": 10835}
{"project": "FFmpeg", "commit_id": "cadab5a2a74d715fc16325bd89f8b8091def1083", "target": 1, "func": "static int read_highpass(AVCodecContext *avctx, uint8_t *ptr, int plane, AVFrame *frame)\n{\n    PixletContext *ctx = avctx->priv_data;\n    ptrdiff_t stride = frame->linesize[plane] / 2;\n    int i, ret;\n    for (i = 0; i < ctx->levels * 3; i++) {\n        int32_t a = bytestream2_get_be32(&ctx->gb);\n        int32_t b = bytestream2_get_be32(&ctx->gb);\n        int32_t c = bytestream2_get_be32(&ctx->gb);\n        int32_t d = bytestream2_get_be32(&ctx->gb);\n        int16_t *dest = (int16_t *)frame->data[plane] + ctx->band[plane][i + 1].x +\n                                               stride * ctx->band[plane][i + 1].y;\n        unsigned size = ctx->band[plane][i + 1].size;\n        uint32_t magic;\n        magic = bytestream2_get_be32(&ctx->gb);\n        if (magic != 0xDEADBEEF) {\n            av_log(avctx, AV_LOG_ERROR, \"wrong magic number: 0x%08\"PRIX32\n                   \" for plane %d, band %d\\n\", magic, plane, i);\n        }\n        ret = read_high_coeffs(avctx, ptr + bytestream2_tell(&ctx->gb), dest, size,\n                               c, (b >= FFABS(a)) ? b : a, d,\n                               ctx->band[plane][i + 1].width, stride);\n        if (ret < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"error in highpass coefficients for plane %d, band %d\\n\", plane, i);\n            return ret;\n        }\n        bytestream2_skip(&ctx->gb, ret);\n    }\n    return 0;\n}", "idx": 10840}
{"project": "qemu", "commit_id": "4fa62005d0a85df9bb14ea9f53109d7c5f66eeb9", "target": 1, "func": "static int coroutine_fn v9fs_complete_renameat(V9fsPDU *pdu, int32_t olddirfid,\n\n                                               V9fsString *old_name,\n\n                                               int32_t newdirfid,\n\n                                               V9fsString *new_name)\n\n{\n\n    int err = 0;\n\n    V9fsState *s = pdu->s;\n\n    V9fsFidState *newdirfidp = NULL, *olddirfidp = NULL;\n\n\n\n    olddirfidp = get_fid(pdu, olddirfid);\n\n    if (olddirfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out;\n\n    }\n\n    if (newdirfid != -1) {\n\n        newdirfidp = get_fid(pdu, newdirfid);\n\n        if (newdirfidp == NULL) {\n\n            err = -ENOENT;\n\n            goto out;\n\n        }\n\n    } else {\n\n        newdirfidp = get_fid(pdu, olddirfid);\n\n    }\n\n\n\n    err = v9fs_co_renameat(pdu, &olddirfidp->path, old_name,\n\n                           &newdirfidp->path, new_name);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    if (s->ctx.export_flags & V9FS_PATHNAME_FSCONTEXT) {\n\n        /* Only for path based fid  we need to do the below fixup */\n\n        v9fs_fix_fid_paths(pdu, &olddirfidp->path, old_name,\n\n                           &newdirfidp->path, new_name);\n\n    }\n\nout:\n\n    if (olddirfidp) {\n\n        put_fid(pdu, olddirfidp);\n\n    }\n\n    if (newdirfidp) {\n\n        put_fid(pdu, newdirfidp);\n\n    }\n\n    return err;\n\n}\n", "idx": 10860}
{"project": "FFmpeg", "commit_id": "eba1ff31304e407db3cefd7532108408f364367b", "target": 1, "func": "static int decode_bytes(const uint8_t *input, uint8_t *out, int bytes)\n\n{\n\n    int i, off;\n\n    uint32_t c;\n\n    const uint32_t *buf;\n\n    uint32_t *output = (uint32_t *)out;\n\n\n\n    off = (intptr_t)input & 3;\n\n    buf = (const uint32_t *)(input - off);\n\n    c   = av_be2ne32((0x537F6103 >> (off * 8)) | (0x537F6103 << (32 - (off * 8))));\n\n    bytes += 3 + off;\n\n    for (i = 0; i < bytes / 4; i++)\n\n        output[i] = c ^ buf[i];\n\n\n\n    if (off)\n\n        avpriv_request_sample(NULL, \"Offset of %d\", off);\n\n\n\n    return off;\n\n}\n", "idx": 10862}
{"project": "qemu", "commit_id": "46c5874e9cd752ed8ded31af03472edd8fc3efc1", "target": 0, "func": "static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,\n\n                                    sPAPREnvironment *spapr,\n\n                                    uint32_t token, uint32_t nargs,\n\n                                    target_ulong args, uint32_t nret,\n\n                                    target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n    int ret;\n\n\n\n    if ((nargs != 4) || (nret != 1)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    addr = rtas_ld(args, 0);\n\n    option = rtas_ld(args, 3);\n\n\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_set_option) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_set_option(sphb, addr, option);\n\n    rtas_st(rets, 0, ret);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 10889}
{"project": "qemu", "commit_id": "9d40cd8a68cfc7606f4548cc9e812bab15c6dc28", "target": 0, "func": "static bool nvic_user_access_ok(NVICState *s, hwaddr offset)\n\n{\n\n    /* Return true if unprivileged access to this register is permitted. */\n\n    switch (offset) {\n\n    case 0xf00: /* STIR: accessible only if CCR.USERSETMPEND permits */\n\n        return s->cpu->env.v7m.ccr & R_V7M_CCR_USERSETMPEND_MASK;\n\n    default:\n\n        /* All other user accesses cause a BusFault unconditionally */\n\n        return false;\n\n    }\n\n}\n", "idx": 10897}
{"project": "qemu", "commit_id": "2a62914bd8209d97e918f30f0de74bec2bf622c4", "target": 0, "func": "static int64_t cpu_get_icount_locked(void)\n\n{\n\n    int64_t icount;\n\n    CPUState *cpu = current_cpu;\n\n\n\n    icount = timers_state.qemu_icount;\n\n    if (cpu) {\n\n        if (!cpu_can_do_io(cpu)) {\n\n            fprintf(stderr, \"Bad clock read\\n\");\n\n        }\n\n        icount -= (cpu->icount_decr.u16.low + cpu->icount_extra);\n\n    }\n\n    return timers_state.qemu_icount_bias + cpu_icount_to_ns(icount);\n\n}\n", "idx": 10932}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static void sigp_start(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    SigpInfo *si = arg.host_ptr;\n\n\n\n    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {\n\n        si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n        return;\n\n    }\n\n\n\n    s390_cpu_set_state(CPU_STATE_OPERATING, cpu);\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n", "idx": 10938}
{"project": "qemu", "commit_id": "2563c9c6b8670400c48e562034b321a7cf3d9a85", "target": 1, "func": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n\n{\n\n    ssize_t ret = 0;\n\n    char small[1024];\n\n    char *buffer;\n\n\n\n    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n\n    while (size > 0) {\n\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n\n\n\n        if (count <= 0) {\n\n            goto cleanup;\n\n        }\n\n        assert(count <= size);\n\n        size -= count;\n\n        ret += count;\n\n    }\n\n\n\n cleanup:\n\n    if (buffer != small) {\n\n        g_free(buffer);\n\n    }\n\n    return ret;\n\n}\n", "idx": 10964}
{"project": "qemu", "commit_id": "262a69f4282e44426c7a132138581d400053e0a1", "target": 1, "func": "void *qemu_get_virtqueue_element(VirtIODevice *vdev, QEMUFile *f, size_t sz)\n\n{\n\n    VirtQueueElement *elem;\n\n    VirtQueueElementOld data;\n\n    int i;\n\n\n\n    qemu_get_buffer(f, (uint8_t *)&data, sizeof(VirtQueueElementOld));\n\n\n\n    /* TODO: teach all callers that this can fail, and return failure instead\n\n     * of asserting here.\n\n     * When we do, we might be able to re-enable NDEBUG below.\n\n     */\n\n#ifdef NDEBUG\n\n#error building with NDEBUG is not supported\n\n#endif\n\n    assert(ARRAY_SIZE(data.in_addr) >= data.in_num);\n\n    assert(ARRAY_SIZE(data.out_addr) >= data.out_num);\n\n\n\n    elem = virtqueue_alloc_element(sz, data.out_num, data.in_num);\n\n    elem->index = data.index;\n\n\n\n    for (i = 0; i < elem->in_num; i++) {\n\n        elem->in_addr[i] = data.in_addr[i];\n\n    }\n\n\n\n    for (i = 0; i < elem->out_num; i++) {\n\n        elem->out_addr[i] = data.out_addr[i];\n\n    }\n\n\n\n    for (i = 0; i < elem->in_num; i++) {\n\n        /* Base is overwritten by virtqueue_map.  */\n\n        elem->in_sg[i].iov_base = 0;\n\n        elem->in_sg[i].iov_len = data.in_sg[i].iov_len;\n\n    }\n\n\n\n    for (i = 0; i < elem->out_num; i++) {\n\n        /* Base is overwritten by virtqueue_map.  */\n\n        elem->out_sg[i].iov_base = 0;\n\n        elem->out_sg[i].iov_len = data.out_sg[i].iov_len;\n\n    }\n\n\n\n    virtqueue_map(vdev, elem);\n\n    return elem;\n\n}\n", "idx": 10965}
{"project": "qemu", "commit_id": "c4237dfa635900e4d1cdc6038d5efe3507f45f0c", "target": 1, "func": "static void mirror_read_complete(void *opaque, int ret)\n\n{\n\n    MirrorOp *op = opaque;\n\n    MirrorBlockJob *s = op->s;\n\n    if (ret < 0) {\n\n        BlockDriverState *source = s->common.bs;\n\n        BlockErrorAction action;\n\n\n\n        bdrv_set_dirty(source, op->sector_num, op->nb_sectors);\n\n        action = mirror_error_action(s, true, -ret);\n\n        if (action == BLOCK_ERROR_ACTION_REPORT && s->ret >= 0) {\n\n            s->ret = ret;\n\n        }\n\n\n\n        mirror_iteration_done(op, ret);\n\n        return;\n\n    }\n\n    bdrv_aio_writev(s->target, op->sector_num, &op->qiov, op->nb_sectors,\n\n                    mirror_write_complete, op);\n\n}\n", "idx": 10970}
{"project": "qemu", "commit_id": "e268ca52328eb0460ae0d10b7f4313a63d5b000c", "target": 0, "func": "static BlockDriverAIOCB *qcow_aio_writev(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowAIOCB *acb;\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    acb = qemu_aio_get(bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    acb->hd_aiocb = NULL;\n\n    acb->sector_num = sector_num;\n\n    acb->qiov = qiov;\n\n    if (qiov->niov > 1) {\n\n        acb->buf = acb->orig_buf = qemu_memalign(512, qiov->size);\n\n        qemu_iovec_to_buffer(qiov, acb->buf);\n\n    } else {\n\n        acb->buf = (uint8_t *)qiov->iov->iov_base;\n\n    }\n\n    acb->nb_sectors = nb_sectors;\n\n    acb->n = 0;\n\n\n\n    qcow_aio_write_cb(acb, 0);\n\n    return &acb->common;\n\n}\n", "idx": 10986}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static uint32_t vmsvga_bios_read(void *opaque, uint32_t address)\n\n{\n\n    printf(\"%s: what are we supposed to return?\\n\", __FUNCTION__);\n\n    return 0xcafe;\n\n}\n", "idx": 11006}
{"project": "FFmpeg", "commit_id": "dc6b99d6b20e832a7d353474c2d093f8b2fb17d2", "target": 0, "func": "static int mov_write_ms_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0);\n\n    avio_wl32(pb, track->tag); // store it byteswapped\n\n    track->enc->codec_tag = av_bswap16(track->tag >> 16);\n\n    ff_put_wav_header(pb, track->enc, 0);\n\n    return update_size(pb, pos);\n\n}\n", "idx": 11019}
{"project": "FFmpeg", "commit_id": "d1f558b3628d3ab99fd93a98b5758ef1be45a5da", "target": 0, "func": "static int copy_to_pbr(DCAXllDecoder *s, uint8_t *data, int size, int delay)\n\n{\n\n    if (size > DCA_XLL_PBR_BUFFER_MAX)\n\n        return AVERROR(ENOSPC);\n\n\n\n    if (!s->pbr_buffer && !(s->pbr_buffer = av_malloc(DCA_XLL_PBR_BUFFER_MAX + DCA_BUFFER_PADDING_SIZE)))\n\n        return AVERROR(ENOMEM);\n\n\n\n    memcpy(s->pbr_buffer, data, size);\n\n    s->pbr_length = size;\n\n    s->pbr_delay = delay;\n\n    return 0;\n\n}\n", "idx": 11023}
{"project": "FFmpeg", "commit_id": "89523beea45e265d985aace8be79b45e94f21e6b", "target": 0, "func": "static void sigill_handler (int sig)\n\n{\n\n    if (!canjump) {\n\n        signal (sig, SIG_DFL);\n\n        raise (sig);\n\n    }\n\n\n\n    canjump = 0;\n\n    siglongjmp (jmpbuf, 1);\n\n}\n", "idx": 11027}
{"project": "qemu", "commit_id": "c572f23a3e7180dbeab5e86583e43ea2afed6271", "target": 1, "func": "static void v9fs_lcreate(void *opaque)\n\n{\n\n    int32_t dfid, flags, mode;\n\n    gid_t gid;\n\n    ssize_t err = 0;\n\n    ssize_t offset = 7;\n\n    V9fsString name;\n\n    V9fsFidState *fidp;\n\n    struct stat stbuf;\n\n    V9fsQID qid;\n\n    int32_t iounit;\n\n    V9fsPDU *pdu = opaque;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dsddd\", &dfid, &name, &flags,\n\n                  &mode, &gid);\n\n\n\n\n    fidp = get_fid(pdu, dfid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    flags = get_dotl_openflags(pdu->s, flags);\n\n    err = v9fs_co_open2(pdu, fidp, &name, gid,\n\n                        flags | O_CREAT, mode, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    fidp->fid_type = P9_FID_FILE;\n\n    fidp->open_flags = flags;\n\n    if (flags & O_EXCL) {\n\n        /*\n\n         * We let the host file system do O_EXCL check\n\n         * We should not reclaim such fd\n\n         */\n\n        fidp->flags |= FID_NON_RECLAIMABLE;\n\n    }\n\n    iounit =  get_iounit(pdu, &fidp->path);\n\n    stat_to_qid(&stbuf, &qid);\n\n    offset += pdu_marshal(pdu, offset, \"Qd\", &qid, iounit);\n\n    err = offset;\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    trace_v9fs_lcreate_return(pdu->tag, pdu->id,\n\n                              qid.type, qid.version, qid.path, iounit);\n\n    complete_pdu(pdu->s, pdu, err);\n\n    v9fs_string_free(&name);\n\n}", "idx": 11055}
{"project": "qemu", "commit_id": "9d7a4c6690ef9962a3b20034f65008f1ea15c1d6", "target": 1, "func": "g_malloc(size_t n_bytes)\n\n{\n\n    void *mem;\n\n    __coverity_negative_sink__(n_bytes);\n\n    mem = malloc(n_bytes == 0 ? 1 : n_bytes);\n\n    if (!mem) __coverity_panic__();\n\n    return mem;\n\n}\n", "idx": 11095}
{"project": "qemu", "commit_id": "2ed1ebcf65edf6757d8904000889ce52cc0a9d1b", "target": 0, "func": "void qemu_get_timedate(struct tm *tm, int offset)\n\n{\n\n    time_t ti;\n\n\n\n    time(&ti);\n\n    ti += offset;\n\n    if (rtc_date_offset == -1) {\n\n        if (rtc_utc)\n\n            gmtime_r(&ti, tm);\n\n        else\n\n            localtime_r(&ti, tm);\n\n    } else {\n\n        ti -= rtc_date_offset;\n\n        gmtime_r(&ti, tm);\n\n    }\n\n}\n", "idx": 11124}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_lpg_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    struct omap_lpg_s *s = (struct omap_lpg_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_read8(opaque, addr);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* LCR */\n\n        return s->control;\n\n\n\n    case 0x04:\t/* PMR */\n\n        return s->power;\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 11132}
{"project": "FFmpeg", "commit_id": "c33030bd7b81f7ef7d7ff9da9bfa1a3b4bfbafa1", "target": 0, "func": "static int gif_encode_frame(AVCodecContext *avctx, unsigned char *outbuf, int buf_size, void *data)\n\n{\n\n    GIFContext *s = avctx->priv_data;\n\n    AVFrame *pict = data;\n\n    AVFrame *const p = (AVFrame *)&s->picture;\n\n    uint8_t *outbuf_ptr = outbuf;\n\n\n\n    *p = *pict;\n\n    p->pict_type = FF_I_TYPE;\n\n    p->key_frame = 1;\n\n    gif_image_write_header(&outbuf_ptr, avctx->width, avctx->height, -1, (uint32_t *)pict->data[1]);\n\n    gif_image_write_image(&outbuf_ptr, 0, 0, avctx->width, avctx->height, pict->data[0], pict->linesize[0], PIX_FMT_PAL8);\n\n    return outbuf_ptr - outbuf;\n\n}\n", "idx": 11151}
{"project": "qemu", "commit_id": "63729c36924348e494d69adbbdec6fdda339b76b", "target": 0, "func": "static int local_mksock(FsContext *ctx2, const char *path)\n\n{\n\n    struct sockaddr_un addr;\n\n    int s;\n\n\n\n    addr.sun_family = AF_UNIX;\n\n    snprintf(addr.sun_path, 108, \"%s\", rpath(ctx2, path));\n\n\n\n    s = socket(PF_UNIX, SOCK_STREAM, 0);\n\n    if (s == -1) {\n\n        return -1;\n\n    }\n\n\n\n    if (bind(s, (struct sockaddr *)&addr, sizeof(addr))) {\n\n        close(s);\n\n        return -1;\n\n    }\n\n\n\n    close(s);\n\n    return 0;\n\n}\n", "idx": 11155}
{"project": "FFmpeg", "commit_id": "b76d853697a8b558e597ed4a6fc5a088b6c602c7", "target": 0, "func": "av_cold int avcodec_close(AVCodecContext *avctx)\n\n{\n\n    int ret = ff_lock_avcodec(avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (avcodec_is_open(avctx)) {\n\n        FramePool *pool = avctx->internal->pool;\n\n        int i;\n\n        if (HAVE_THREADS && avctx->internal->frame_thread_encoder && avctx->thread_count > 1) {\n\n            ff_unlock_avcodec();\n\n            ff_frame_thread_encoder_free(avctx);\n\n            ff_lock_avcodec(avctx);\n\n        }\n\n        if (HAVE_THREADS && avctx->thread_opaque)\n\n            ff_thread_free(avctx);\n\n        if (avctx->codec && avctx->codec->close)\n\n            avctx->codec->close(avctx);\n\n        avctx->coded_frame = NULL;\n\n        avctx->internal->byte_buffer_size = 0;\n\n        av_freep(&avctx->internal->byte_buffer);\n\n        if (!avctx->refcounted_frames)\n\n            av_frame_unref(&avctx->internal->to_free);\n\n        for (i = 0; i < FF_ARRAY_ELEMS(pool->pools); i++)\n\n            av_buffer_pool_uninit(&pool->pools[i]);\n\n        av_freep(&avctx->internal->pool);\n\n        av_freep(&avctx->internal);\n\n    }\n\n\n\n    if (avctx->priv_data && avctx->codec && avctx->codec->priv_class)\n\n        av_opt_free(avctx->priv_data);\n\n    av_opt_free(avctx);\n\n    av_freep(&avctx->priv_data);\n\n    if (av_codec_is_encoder(avctx->codec))\n\n        av_freep(&avctx->extradata);\n\n    avctx->codec = NULL;\n\n    avctx->active_thread_type = 0;\n\n\n\n    ff_unlock_avcodec();\n\n    return 0;\n\n}\n", "idx": 11158}
{"project": "qemu", "commit_id": "e0e2d644096c79a71099b176d08f465f6803a8b1", "target": 1, "func": "static void virtio_device_free_virtqueues(VirtIODevice *vdev)\n\n{\n\n    int i;\n\n    if (!vdev->vq) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {\n\n        VRingMemoryRegionCaches *caches;\n\n        if (vdev->vq[i].vring.num == 0) {\n\n            break;\n\n        }\n\n        caches = atomic_read(&vdev->vq[i].vring.caches);\n\n        atomic_set(&vdev->vq[i].vring.caches, NULL);\n\n        virtio_free_region_cache(caches);\n\n    }\n\n    g_free(vdev->vq);\n\n}\n", "idx": 11160}
{"project": "FFmpeg", "commit_id": "4a722a5cab15d5aefbf4dd83baa8be5a046580ca", "target": 1, "func": "static int common_end(HYuvContext *s)\n\n{\n\n    int i;\n\n\n\n    for(i = 0; i < 3; i++) {\n\n        av_freep(&s->temp[i]);\n\n    }\n\n    return 0;\n\n}\n", "idx": 11248}
{"project": "qemu", "commit_id": "97a2ae34537882df34810d538ab1f51085499d2c", "target": 1, "func": "static int coroutine_fn raw_co_write_zeroes(\n\n    BlockDriverState *bs, int64_t sector_num,\n\n    int nb_sectors, BdrvRequestFlags flags)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (!(flags & BDRV_REQ_MAY_UNMAP)) {\n\n        return -ENOTSUP;\n\n    }\n\n    if (!s->discard_zeroes) {\n\n        return -ENOTSUP;\n\n    }\n\n    return paio_submit_co(bs, s->fd, sector_num, NULL, nb_sectors,\n\n                          QEMU_AIO_DISCARD);\n\n}\n", "idx": 11254}
{"project": "FFmpeg", "commit_id": "c619ff6daf93a8f3c03decf2d3345d2474c3db91", "target": 0, "func": "static always_inline int dv_rl2vlc(int run, int l, uint32_t* vlc)\n\n{\n\n    *vlc = dv_vlc_map[run][((uint16_t)l)&0x1ff].vlc;\n\n    return dv_vlc_map[run][((uint16_t)l)&0x1ff].size;\n\n}\n", "idx": 11261}
{"project": "qemu", "commit_id": "f7736b91c40a617e93505e32dcbd2cb56aad8a23", "target": 0, "func": "static int dma_buf_prepare(BMDMAState *bm, int is_write)\n\n{\n\n    IDEState *s = bmdma_active_if(bm);\n\n    struct {\n\n        uint32_t addr;\n\n        uint32_t size;\n\n    } prd;\n\n    int l, len;\n\n\n\n    qemu_sglist_init(&s->sg, s->nsector / (TARGET_PAGE_SIZE/512) + 1);\n\n    s->io_buffer_size = 0;\n\n    for(;;) {\n\n        if (bm->cur_prd_len == 0) {\n\n            /* end of table (with a fail safe of one page) */\n\n            if (bm->cur_prd_last ||\n\n                (bm->cur_addr - bm->addr) >= 4096)\n\n                return s->io_buffer_size != 0;\n\n            cpu_physical_memory_read(bm->cur_addr, (uint8_t *)&prd, 8);\n\n            bm->cur_addr += 8;\n\n            prd.addr = le32_to_cpu(prd.addr);\n\n            prd.size = le32_to_cpu(prd.size);\n\n            len = prd.size & 0xfffe;\n\n            if (len == 0)\n\n                len = 0x10000;\n\n            bm->cur_prd_len = len;\n\n            bm->cur_prd_addr = prd.addr;\n\n            bm->cur_prd_last = (prd.size & 0x80000000);\n\n        }\n\n        l = bm->cur_prd_len;\n\n        if (l > 0) {\n\n            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);\n\n            bm->cur_prd_addr += l;\n\n            bm->cur_prd_len -= l;\n\n            s->io_buffer_size += l;\n\n        }\n\n    }\n\n    return 1;\n\n}\n", "idx": 11263}
{"project": "qemu", "commit_id": "1294ca797c6bee39d4dbc3e92010873ce4047e0e", "target": 0, "func": "static int usb_host_claim_interfaces(USBHostDevice *s, int configuration)\n\n{\n\n    USBDevice *udev = USB_DEVICE(s);\n\n    struct libusb_config_descriptor *conf;\n\n    int rc, i;\n\n\n\n    for (i = 0; i < USB_MAX_INTERFACES; i++) {\n\n        udev->altsetting[i] = 0;\n\n    }\n\n    udev->ninterfaces   = 0;\n\n    udev->configuration = 0;\n\n\n\n    if (configuration == 0) {\n\n        /* address state - ignore */\n\n        return USB_RET_SUCCESS;\n\n    }\n\n\n\n    usb_host_detach_kernel(s);\n\n\n\n    rc = libusb_get_active_config_descriptor(s->dev, &conf);\n\n    if (rc != 0) {\n\n        return USB_RET_STALL;\n\n    }\n\n\n\n    for (i = 0; i < conf->bNumInterfaces; i++) {\n\n        trace_usb_host_claim_interface(s->bus_num, s->addr, configuration, i);\n\n        rc = libusb_claim_interface(s->dh, i);\n\n        usb_host_libusb_error(\"libusb_claim_interface\", rc);\n\n        if (rc != 0) {\n\n            return USB_RET_STALL;\n\n        }\n\n        s->ifs[i].claimed = true;\n\n    }\n\n\n\n    udev->ninterfaces   = conf->bNumInterfaces;\n\n    udev->configuration = configuration;\n\n\n\n    libusb_free_config_descriptor(conf);\n\n    return USB_RET_SUCCESS;\n\n}\n", "idx": 11264}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_completion(void)\n\n{\n\n    int len, i, j, max_width, nb_cols;\n\n    char *cmdline;\n\n\n\n    nb_completions = 0;\n\n    \n\n    cmdline = qemu_malloc(term_cmd_buf_index + 1);\n\n    if (!cmdline)\n\n        return;\n\n    memcpy(cmdline, term_cmd_buf, term_cmd_buf_index);\n\n    cmdline[term_cmd_buf_index] = '\\0';\n\n    find_completion(cmdline);\n\n    qemu_free(cmdline);\n\n\n\n    /* no completion found */\n\n    if (nb_completions <= 0)\n\n        return;\n\n    if (nb_completions == 1) {\n\n        len = strlen(completions[0]);\n\n        for(i = completion_index; i < len; i++) {\n\n            term_insert_char(completions[0][i]);\n\n        }\n\n        /* extra space for next argument. XXX: make it more generic */\n\n        if (len > 0 && completions[0][len - 1] != '/')\n\n            term_insert_char(' ');\n\n    } else {\n\n        term_printf(\"\\n\");\n\n        max_width = 0;\n\n        for(i = 0; i < nb_completions; i++) {\n\n            len = strlen(completions[i]);\n\n            if (len > max_width)\n\n                max_width = len;\n\n        }\n\n        max_width += 2;\n\n        if (max_width < 10)\n\n            max_width = 10;\n\n        else if (max_width > 80)\n\n            max_width = 80;\n\n        nb_cols = 80 / max_width;\n\n        j = 0;\n\n        for(i = 0; i < nb_completions; i++) {\n\n            term_printf(\"%-*s\", max_width, completions[i]);\n\n            if (++j == nb_cols || i == (nb_completions - 1)) {\n\n                term_printf(\"\\n\");\n\n                j = 0;\n\n            }\n\n        }\n\n        term_show_prompt2();\n\n    }\n\n}\n", "idx": 11270}
{"project": "qemu", "commit_id": "36bcac16fdd6ecb75314db06171f54dcd400ab8c", "target": 1, "func": "static int parse_vdiname(BDRVSheepdogState *s, const char *filename,\n\n                         char *vdi, uint32_t *snapid, char *tag)\n\n{\n\n    char *p, *q, *uri;\n\n    const char *host_spec, *vdi_spec;\n\n    int nr_sep, ret;\n\n\n\n    strstart(filename, \"sheepdog:\", &filename);\n\n    p = q = g_strdup(filename);\n\n\n\n    /* count the number of separators */\n\n    nr_sep = 0;\n\n    while (*p) {\n\n        if (*p == ':') {\n\n            nr_sep++;\n\n        }\n\n        p++;\n\n    }\n\n    p = q;\n\n\n\n    /* use the first two tokens as host_spec. */\n\n    if (nr_sep >= 2) {\n\n        host_spec = p;\n\n        p = strchr(p, ':');\n\n        p++;\n\n        p = strchr(p, ':');\n\n        *p++ = '\\0';\n\n    } else {\n\n        host_spec = \"\";\n\n    }\n\n\n\n    vdi_spec = p;\n\n\n\n    p = strchr(vdi_spec, ':');\n\n    if (p) {\n\n        *p++ = '#';\n\n    }\n\n\n\n    uri = g_strdup_printf(\"sheepdog://%s/%s\", host_spec, vdi_spec);\n\n\n\n    ret = sd_parse_uri(s, uri, vdi, snapid, tag);\n\n\n\n    g_free(q);\n\n    g_free(uri);\n\n\n\n    return ret;\n\n}\n", "idx": 11288}
{"project": "FFmpeg", "commit_id": "295a7c0238e84b0ffa8f21ed938d45f51f54a4cd", "target": 1, "func": "static int decode_i2_frame(FourXContext *f, const uint8_t *buf, int length){\n\n    int x, y, x2, y2;\n\n    const int width= f->avctx->width;\n\n    const int height= f->avctx->height;\n\n    uint16_t *dst= (uint16_t*)f->current_picture.data[0];\n\n    const int stride= f->current_picture.linesize[0]>>1;\n\n\n\n    for(y=0; y<height; y+=16){\n\n        for(x=0; x<width; x+=16){\n\n            unsigned int color[4], bits;\n\n            memset(color, 0, sizeof(color));\n\n//warning following is purely guessed ...\n\n            color[0]= bytestream_get_le16(&buf);\n\n            color[1]= bytestream_get_le16(&buf);\n\n\n\n            if(color[0]&0x8000) av_log(NULL, AV_LOG_ERROR, \"unk bit 1\\n\");\n\n            if(color[1]&0x8000) av_log(NULL, AV_LOG_ERROR, \"unk bit 2\\n\");\n\n\n\n            color[2]= mix(color[0], color[1]);\n\n            color[3]= mix(color[1], color[0]);\n\n\n\n            bits= bytestream_get_le32(&buf);\n\n            for(y2=0; y2<16; y2++){\n\n                for(x2=0; x2<16; x2++){\n\n                    int index= 2*(x2>>2) + 8*(y2>>2);\n\n                    dst[y2*stride+x2]= color[(bits>>index)&3];\n\n                }\n\n            }\n\n            dst+=16;\n\n        }\n\n        dst += 16 * stride - x;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11293}
{"project": "FFmpeg", "commit_id": "ad5807f8aa883bee5431186dc1f24c5435d722d3", "target": 1, "func": "static int apc_read_header(AVFormatContext *s)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n\n\n    avio_rl32(pb); /* CRYO */\n\n    avio_rl32(pb); /* _APC */\n\n    avio_rl32(pb); /* 1.20 */\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n\n    st->codecpar->codec_id = AV_CODEC_ID_ADPCM_IMA_APC;\n\n\n\n    avio_rl32(pb); /* number of samples */\n\n    st->codecpar->sample_rate = avio_rl32(pb);\n\n\n\n    /* initial predictor values for adpcm decoder */\n\n    if (ff_get_extradata(s, st->codecpar, pb, 2 * 4) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (avio_rl32(pb)) {\n\n        st->codecpar->channels       = 2;\n\n        st->codecpar->channel_layout = AV_CH_LAYOUT_STEREO;\n\n    } else {\n\n        st->codecpar->channels       = 1;\n\n        st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;\n\n    }\n\n\n\n    st->codecpar->bits_per_coded_sample = 4;\n\n    st->codecpar->bit_rate = st->codecpar->bits_per_coded_sample * st->codecpar->channels\n\n                          * st->codecpar->sample_rate;\n\n    st->codecpar->block_align = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 11295}
{"project": "qemu", "commit_id": "be1fea9bc286f64c6c995bb0d7145a0b738aeddb", "target": 0, "func": "static inline uint16_t vring_avail_idx(VirtQueue *vq)\n\n{\n\n    hwaddr pa;\n\n    pa = vq->vring.avail + offsetof(VRingAvail, idx);\n\n    return virtio_lduw_phys(vq->vdev, pa);\n\n}\n", "idx": 11309}
{"project": "qemu", "commit_id": "1ac157da77c863b62b1d2f467626a440d57cf17d", "target": 0, "func": "void cpu_x86_update_cr0(CPUX86State *env)\n\n{\n\n    int pg_state, pe_state;\n\n\n\n#if defined(DEBUG_MMU)\n\n    printf(\"CR0 update: CR0=0x%08x\\n\", env->cr[0]);\n\n#endif\n\n    pg_state = env->cr[0] & CR0_PG_MASK;\n\n    if (pg_state != last_pg_state) {\n\n        tlb_flush(env);\n\n        last_pg_state = pg_state;\n\n    }\n\n    /* update PE flag in hidden flags */\n\n    pe_state = (env->cr[0] & CR0_PE_MASK);\n\n    env->hflags = (env->hflags & ~HF_PE_MASK) | (pe_state << HF_PE_SHIFT);\n\n    /* ensure that ADDSEG is always set in real mode */\n\n    env->hflags |= ((pe_state ^ 1) << HF_ADDSEG_SHIFT);\n\n}\n", "idx": 11313}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "func": "static void branch(DBDMA_channel *ch)\n\n{\n\n    dbdma_cmd *current = &ch->current;\n\n\n\n    ch->regs[DBDMA_CMDPTR_LO] = current->cmd_dep;\n\n    ch->regs[DBDMA_STATUS] |= cpu_to_be32(BT);\n\n    dbdma_cmdptr_load(ch);\n\n}\n", "idx": 11314}
{"project": "FFmpeg", "commit_id": "486f0b0cfc800cd38ec06635630539431d296774", "target": 1, "func": "void *ff_png_zalloc(void *opaque, unsigned int items, unsigned int size)\n\n{\n\n    if(items >= UINT_MAX / size)\n\n        return NULL;\n\n    return av_malloc(items * size);\n\n}\n", "idx": 11326}
{"project": "qemu", "commit_id": "7d99f4c1b5d12de7644a5bd8c3d46bff05c9ca7c", "target": 1, "func": "static int scsi_get_configuration(SCSIDiskState *s, uint8_t *outbuf)\n\n{\n\n    int current;\n\n\n\n    if (s->qdev.type != TYPE_ROM) {\n\n        return -1;\n\n    }\n\n    current = media_is_dvd(s) ? MMC_PROFILE_DVD_ROM : MMC_PROFILE_CD_ROM;\n\n    memset(outbuf, 0, 40);\n\n    stl_be_p(&outbuf[0], 36); /* Bytes after the data length field */\n\n    stw_be_p(&outbuf[6], current);\n\n    /* outbuf[8] - outbuf[19]: Feature 0 - Profile list */\n\n    outbuf[10] = 0x03; /* persistent, current */\n\n    outbuf[11] = 8; /* two profiles */\n\n    stw_be_p(&outbuf[12], MMC_PROFILE_DVD_ROM);\n\n    outbuf[14] = (current == MMC_PROFILE_DVD_ROM);\n\n    stw_be_p(&outbuf[16], MMC_PROFILE_CD_ROM);\n\n    outbuf[18] = (current == MMC_PROFILE_CD_ROM);\n\n    /* outbuf[20] - outbuf[31]: Feature 1 - Core feature */\n\n    stw_be_p(&outbuf[20], 1);\n\n    outbuf[22] = 0x08 | 0x03; /* version 2, persistent, current */\n\n    outbuf[23] = 8;\n\n    stl_be_p(&outbuf[24], 1); /* SCSI */\n\n    outbuf[28] = 1; /* DBE = 1, mandatory */\n\n    /* outbuf[32] - outbuf[39]: Feature 3 - Removable media feature */\n\n    stw_be_p(&outbuf[32], 3);\n\n    outbuf[34] = 0x08 | 0x03; /* version 2, persistent, current */\n\n    outbuf[35] = 4;\n\n    outbuf[36] = 0x39; /* tray, load=1, eject=1, unlocked at powerup, lock=1 */\n\n    /* TODO: Random readable, CD read, DVD read, drive serial number,\n\n       power management */\n\n    return 40;\n\n}\n", "idx": 11343}
{"project": "qemu", "commit_id": "1ec3b71cde6997db866a76ff3311cb97c0b6741a", "target": 1, "func": "static void rx_stop_cont_test(const QVirtioBus *bus, QVirtioDevice *dev,\n\n                              QGuestAllocator *alloc, QVirtQueue *vq,\n\n                              int socket)\n\n{\n\n    uint64_t req_addr;\n\n    uint32_t free_head;\n\n    char test[] = \"TEST\";\n\n    char buffer[64];\n\n    int len = htonl(sizeof(test));\n\n    struct iovec iov[] = {\n\n        {\n\n            .iov_base = &len,\n\n            .iov_len = sizeof(len),\n\n        }, {\n\n            .iov_base = test,\n\n            .iov_len = sizeof(test),\n\n        },\n\n    };\n\n    int ret;\n\n\n\n    req_addr = guest_alloc(alloc, 64);\n\n\n\n    free_head = qvirtqueue_add(vq, req_addr, 64, true, false);\n\n    qvirtqueue_kick(bus, dev, vq, free_head);\n\n\n\n    qmp(\"{ 'execute' : 'stop'}\");\n\n\n\n    ret = iov_send(socket, iov, 2, 0, sizeof(len) + sizeof(test));\n\n    g_assert_cmpint(ret, ==, sizeof(test) + sizeof(len));\n\n\n\n    /* We could check the status, but this command is more importantly to\n\n     * ensure the packet data gets queued in QEMU, before we do 'cont'.\n\n     */\n\n    qmp(\"{ 'execute' : 'query-status'}\");\n\n    qmp(\"{ 'execute' : 'cont'}\");\n\n\n\n    qvirtio_wait_queue_isr(bus, dev, vq, QVIRTIO_NET_TIMEOUT_US);\n\n    memread(req_addr + VNET_HDR_SIZE, buffer, sizeof(test));\n\n    g_assert_cmpstr(buffer, ==, \"TEST\");\n\n\n\n    guest_free(alloc, req_addr);\n\n}\n", "idx": 11349}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void nbd_read(void *opaque)\n\n{\n\n    NBDClient *client = opaque;\n\n\n\n    if (client->recv_coroutine) {\n\n        qemu_coroutine_enter(client->recv_coroutine, NULL);\n\n    } else {\n\n        qemu_coroutine_enter(qemu_coroutine_create(nbd_trip), client);\n\n    }\n\n}\n", "idx": 11357}
{"project": "qemu", "commit_id": "27463101f15bee17d2f46642c48a7373bc6c595e", "target": 1, "func": "int qemu_eventfd(int *fds)\n\n{\n\n#if defined(SYS_eventfd)\n\n    int ret;\n\n\n\n    ret = syscall(SYS_eventfd, 0);\n\n    if (ret >= 0) {\n\n        fds[0] = fds[1] = ret;\n\n        return 0;\n\n    } else if (!(ret == -1 && errno == ENOSYS))\n\n        return ret;\n\n#endif\n\n\n\n    return pipe(fds);\n\n}\n", "idx": 11373}
{"project": "qemu", "commit_id": "ce7f7cc2715145eadf1ac45a5dae63f535fc8bbf", "target": 1, "func": "int64_t ga_get_fd_handle(GAState *s, Error **errp)\n\n{\n\n    int64_t handle;\n\n\n\n    g_assert(s->pstate_filepath);\n\n    /* we blacklist commands and avoid operations that potentially require\n\n     * writing to disk when we're in a frozen state. this includes opening\n\n     * new files, so we should never get here in that situation\n\n     */\n\n    g_assert(!ga_is_frozen(s));\n\n\n\n    handle = s->pstate.fd_counter++;\n\n    if (s->pstate.fd_counter < 0) {\n\n        s->pstate.fd_counter = 0;\n\n    }\n\n    if (!write_persistent_state(&s->pstate, s->pstate_filepath)) {\n\n        error_setg(errp, \"failed to commit persistent state to disk\");\n\n    }\n\n\n\n    return handle;\n\n}\n", "idx": 11384}
{"project": "qemu", "commit_id": "7f6613cedc59fa849105668ae971dc31004bca1c", "target": 0, "func": "static void gen_load_fpr32h(TCGv_i32 t, int reg)\n\n{\n\n    TCGv_i64 t64 = tcg_temp_new_i64();\n\n    tcg_gen_shri_i64(t64, fpu_f64[reg], 32);\n\n    tcg_gen_trunc_i64_i32(t, t64);\n\n    tcg_temp_free_i64(t64);\n\n}\n", "idx": 11402}
{"project": "qemu", "commit_id": "3718d8ab65f68de2acccbe6a315907805f54e3cc", "target": 0, "func": "void block_job_completed(BlockJob *job, int ret)\n\n{\n\n    BlockDriverState *bs = job->bs;\n\n\n\n    assert(bs->job == job);\n\n    job->cb(job->opaque, ret);\n\n    bs->job = NULL;\n\n    g_free(job);\n\n    bdrv_set_in_use(bs, 0);\n\n}\n", "idx": 11414}
{"project": "FFmpeg", "commit_id": "cd823ff950cf81d54965eceedb64569fee79ab36", "target": 0, "func": "static int alloc_frame_buffer(MpegEncContext *s, Picture *pic)\n\n{\n\n    int r;\n\n\n\n    if (s->avctx->hwaccel) {\n\n        assert(!pic->hwaccel_data_private);\n\n        if (s->avctx->hwaccel->priv_data_size) {\n\n            pic->hwaccel_data_private = av_malloc(s->avctx->hwaccel->priv_data_size);\n\n            if (!pic->hwaccel_data_private) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"alloc_frame_buffer() failed (hwaccel private data allocation)\\n\");\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    r = s->avctx->get_buffer(s->avctx, (AVFrame*)pic);\n\n\n\n    if (r<0 || !pic->age || !pic->type || !pic->data[0]) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (%d %d %d %p)\\n\", r, pic->age, pic->type, pic->data[0]);\n\n        av_freep(&pic->hwaccel_data_private);\n\n        return -1;\n\n    }\n\n\n\n    if (s->linesize && (s->linesize != pic->linesize[0] || s->uvlinesize != pic->linesize[1])) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (stride changed)\\n\");\n\n        free_frame_buffer(s, pic);\n\n        return -1;\n\n    }\n\n\n\n    if (pic->linesize[1] != pic->linesize[2]) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (uv stride mismatch)\\n\");\n\n        free_frame_buffer(s, pic);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11446}
{"project": "FFmpeg", "commit_id": "33dc1913ab7aaefc991b3e665d1d0b5d0b088672", "target": 1, "func": "static void reset_packet_state(AVFormatContext *s)\n\n{\n\n    ASFContext *asf        = s->priv_data;\n\n    int i;\n\n\n\n    asf->state             = PARSE_PACKET_HEADER;\n\n    asf->offset            = 0;\n\n    asf->return_subpayload = 0;\n\n    asf->sub_left          = 0;\n\n    asf->sub_header_offset = 0;\n\n    asf->packet_offset     = asf->first_packet_offset;\n\n    asf->pad_len           = 0;\n\n    asf->rep_data_len      = 0;\n\n    asf->dts_delta         = 0;\n\n    asf->mult_sub_len      = 0;\n\n    asf->nb_mult_left      = 0;\n\n    asf->nb_sub            = 0;\n\n    asf->prop_flags        = 0;\n\n    asf->sub_dts           = 0;\n\n    asf->dts               = 0;\n\n    for (i = 0; i < asf->nb_streams; i++) {\n\n        ASFPacket *pkt = &asf->asf_st[i]->pkt;\n\n        pkt->size_left = 0;\n\n        pkt->data_size = 0;\n\n        pkt->duration  = 0;\n\n        pkt->flags     = 0;\n\n        pkt->dts       = 0;\n\n        pkt->duration  = 0;\n\n        av_free_packet(&pkt->avpkt);\n\n        av_init_packet(&pkt->avpkt);\n\n    }\n\n}\n", "idx": 11451}
{"project": "qemu", "commit_id": "b4176cb314995ad225d6c2b531568801feb04f3f", "target": 1, "func": "static int nbd_parse_offset_hole_payload(NBDStructuredReplyChunk *chunk,\n\n                                         uint8_t *payload, uint64_t orig_offset,\n\n                                         QEMUIOVector *qiov, Error **errp)\n\n{\n\n    uint64_t offset;\n\n    uint32_t hole_size;\n\n\n\n    if (chunk->length != sizeof(offset) + sizeof(hole_size)) {\n\n        error_setg(errp, \"Protocol error: invalid payload for \"\n\n                         \"NBD_REPLY_TYPE_OFFSET_HOLE\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    offset = payload_advance64(&payload);\n\n    hole_size = payload_advance32(&payload);\n\n\n\n    if (offset < orig_offset || hole_size > qiov->size ||\n\n        offset > orig_offset + qiov->size - hole_size) {\n\n        error_setg(errp, \"Protocol error: server sent chunk exceeding requested\"\n\n                         \" region\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_iovec_memset(qiov, offset - orig_offset, 0, hole_size);\n\n\n\n    return 0;\n\n}\n", "idx": 11457}
{"project": "FFmpeg", "commit_id": "0314dead4e7c058568e792842405190c06d71da5", "target": 1, "func": "AVEvalExpr * ff_parse(const char *s, const char * const *const_name,\n\n               double (**func1)(void *, double), const char **func1_name,\n\n               double (**func2)(void *, double, double), const char **func2_name,\n\n               const char **error){\n\n    Parser p;\n\n    AVEvalExpr * e;\n\n    char w[strlen(s) + 1], * wp = w;\n\n\n\n    while (*s)\n\n        if (!isspace(*s++)) *wp++ = s[-1];\n\n    *wp++ = 0;\n\n\n\n    p.stack_index=100;\n\n    p.s= w;\n\n    p.const_name = const_name;\n\n    p.func1      = func1;\n\n    p.func1_name = func1_name;\n\n    p.func2      = func2;\n\n    p.func2_name = func2_name;\n\n    p.error= error;\n\n\n\n    e = parse_expr(&p);\n\n    if (!verify_expr(e)) {\n\n        ff_eval_free(e);\n\n        return NULL;\n\n    }\n\n    return e;\n\n}\n", "idx": 11492}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_post_send_control(RDMAContext *rdma, uint8_t *buf,\n\n                                       RDMAControlHeader *head)\n\n{\n\n    int ret = 0;\n\n    RDMAWorkRequestData *wr = &rdma->wr_data[RDMA_WRID_CONTROL];\n\n    struct ibv_send_wr *bad_wr;\n\n    struct ibv_sge sge = {\n\n                           .addr = (uint64_t)(wr->control),\n\n                           .length = head->len + sizeof(RDMAControlHeader),\n\n                           .lkey = wr->control_mr->lkey,\n\n                         };\n\n    struct ibv_send_wr send_wr = {\n\n                                   .wr_id = RDMA_WRID_SEND_CONTROL,\n\n                                   .opcode = IBV_WR_SEND,\n\n                                   .send_flags = IBV_SEND_SIGNALED,\n\n                                   .sg_list = &sge,\n\n                                   .num_sge = 1,\n\n                                };\n\n\n\n    DDDPRINTF(\"CONTROL: sending %s..\\n\", control_desc[head->type]);\n\n\n\n    /*\n\n     * We don't actually need to do a memcpy() in here if we used\n\n     * the \"sge\" properly, but since we're only sending control messages\n\n     * (not RAM in a performance-critical path), then its OK for now.\n\n     *\n\n     * The copy makes the RDMAControlHeader simpler to manipulate\n\n     * for the time being.\n\n     */\n\n    assert(head->len <= RDMA_CONTROL_MAX_BUFFER - sizeof(*head));\n\n    memcpy(wr->control, head, sizeof(RDMAControlHeader));\n\n    control_to_network((void *) wr->control);\n\n\n\n    if (buf) {\n\n        memcpy(wr->control + sizeof(RDMAControlHeader), buf, head->len);\n\n    }\n\n\n\n\n\n    ret = ibv_post_send(rdma->qp, &send_wr, &bad_wr);\n\n\n\n    if (ret > 0) {\n\n        fprintf(stderr, \"Failed to use post IB SEND for control!\\n\");\n\n        return -ret;\n\n    }\n\n\n\n    ret = qemu_rdma_block_for_wrid(rdma, RDMA_WRID_SEND_CONTROL, NULL);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"rdma migration: send polling control error!\\n\");\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 11497}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static void pci_ich9_ahci_realize(PCIDevice *dev, Error **errp)\n\n{\n\n    struct AHCIPCIState *d;\n\n    int sata_cap_offset;\n\n    uint8_t *sata_cap;\n\n    d = ICH_AHCI(dev);\n\n\n\n    ahci_realize(&d->ahci, DEVICE(dev), pci_get_address_space(dev), 6);\n\n\n\n    pci_config_set_prog_interface(dev->config, AHCI_PROGMODE_MAJOR_REV_1);\n\n\n\n    dev->config[PCI_CACHE_LINE_SIZE] = 0x08;  /* Cache line size */\n\n    dev->config[PCI_LATENCY_TIMER]   = 0x00;  /* Latency timer */\n\n    pci_config_set_interrupt_pin(dev->config, 1);\n\n\n\n    /* XXX Software should program this register */\n\n    dev->config[0x90]   = 1 << 6; /* Address Map Register - AHCI mode */\n\n\n\n    d->ahci.irq = pci_allocate_irq(dev);\n\n\n\n    pci_register_bar(dev, ICH9_IDP_BAR, PCI_BASE_ADDRESS_SPACE_IO,\n\n                     &d->ahci.idp);\n\n    pci_register_bar(dev, ICH9_MEM_BAR, PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                     &d->ahci.mem);\n\n\n\n    sata_cap_offset = pci_add_capability2(dev, PCI_CAP_ID_SATA,\n\n                                          ICH9_SATA_CAP_OFFSET, SATA_CAP_SIZE,\n\n                                          errp);\n\n    if (sata_cap_offset < 0) {\n\n        return;\n\n    }\n\n\n\n    sata_cap = dev->config + sata_cap_offset;\n\n    pci_set_word(sata_cap + SATA_CAP_REV, 0x10);\n\n    pci_set_long(sata_cap + SATA_CAP_BAR,\n\n                 (ICH9_IDP_BAR + 0x4) | (ICH9_IDP_INDEX_LOG2 << 4));\n\n    d->ahci.idp_offset = ICH9_IDP_INDEX;\n\n\n\n    /* Although the AHCI 1.3 specification states that the first capability\n\n     * should be PMCAP, the Intel ICH9 data sheet specifies that the ICH9\n\n     * AHCI device puts the MSI capability first, pointing to 0x80. */\n\n    msi_init(dev, ICH9_MSI_CAP_OFFSET, 1, true, false);\n\n}\n", "idx": 11498}
{"project": "qemu", "commit_id": "dcc70cdf0932172fc5cf27617a3b033ca58d0176", "target": 1, "func": "static void parse_cmdline(const char *cmdline,\n\n                          int *pnb_args, char **args)\n\n{\n\n    const char *p;\n\n    int nb_args, ret;\n\n    char buf[1024];\n\n\n\n    p = cmdline;\n\n    nb_args = 0;\n\n    for (;;) {\n\n        while (qemu_isspace(*p)) {\n\n            p++;\n\n        }\n\n        if (*p == '\\0') {\n\n            break;\n\n        }\n\n        if (nb_args >= MAX_ARGS) {\n\n            break;\n\n        }\n\n        ret = get_str(buf, sizeof(buf), &p);\n\n        args[nb_args] = g_strdup(buf);\n\n        nb_args++;\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n    }\n\n    *pnb_args = nb_args;\n\n}\n", "idx": 11504}
{"project": "FFmpeg", "commit_id": "e87190f5d20d380608f792ceb14d0def1d80e24b", "target": 0, "func": "static void read_packets(WriterContext *w, AVFormatContext *fmt_ctx)\n\n{\n\n    int i, ret = 0;\n\n    int64_t cur_ts = fmt_ctx->start_time;\n\n\n\n    if (read_intervals_nb == 0) {\n\n        ReadInterval interval = (ReadInterval) { .has_start = 0, .has_end = 0 };\n\n        ret = read_interval_packets(w, fmt_ctx, &interval, &cur_ts);\n\n    } else {\n\n        for (i = 0; i < read_intervals_nb; i++) {\n\n            ret = read_interval_packets(w, fmt_ctx, &read_intervals[i], &cur_ts);\n\n            if (ret < 0)\n\n                break;\n\n        }\n\n    }\n\n}\n", "idx": 11528}
{"project": "qemu", "commit_id": "94ef4f337fb614f18b765a8e0e878a4c23cdedcd", "target": 1, "func": "static void vga_update_memory_access(VGACommonState *s)\n\n{\n\n    hwaddr base, offset, size;\n\n\n\n    if (s->legacy_address_space == NULL) {\n\n        return;\n\n    }\n\n\n\n    if (s->has_chain4_alias) {\n\n        memory_region_del_subregion(s->legacy_address_space, &s->chain4_alias);\n\n        object_unparent(OBJECT(&s->chain4_alias));\n\n        s->has_chain4_alias = false;\n\n        s->plane_updated = 0xf;\n\n    }\n\n    if ((s->sr[VGA_SEQ_PLANE_WRITE] & VGA_SR02_ALL_PLANES) ==\n\n        VGA_SR02_ALL_PLANES && s->sr[VGA_SEQ_MEMORY_MODE] & VGA_SR04_CHN_4M) {\n\n        offset = 0;\n\n        switch ((s->gr[VGA_GFX_MISC] >> 2) & 3) {\n\n        case 0:\n\n            base = 0xa0000;\n\n            size = 0x20000;\n\n            break;\n\n        case 1:\n\n            base = 0xa0000;\n\n            size = 0x10000;\n\n            offset = s->bank_offset;\n\n            break;\n\n        case 2:\n\n            base = 0xb0000;\n\n            size = 0x8000;\n\n            break;\n\n        case 3:\n\n        default:\n\n            base = 0xb8000;\n\n            size = 0x8000;\n\n            break;\n\n        }\n\n        assert(offset + size <= s->vram_size);\n\n        memory_region_init_alias(&s->chain4_alias, memory_region_owner(&s->vram),\n\n                                 \"vga.chain4\", &s->vram, offset, size);\n\n        memory_region_add_subregion_overlap(s->legacy_address_space, base,\n\n                                            &s->chain4_alias, 2);\n\n        s->has_chain4_alias = true;\n\n    }\n\n}\n", "idx": 11549}
{"project": "FFmpeg", "commit_id": "e021eeb9f06f4f4d83690d07b47cdcc4172a61e1", "target": 0, "func": "int av_opt_set_from_string(void *ctx, const char *opts,\n\n                           const char *const *shorthand,\n\n                           const char *key_val_sep, const char *pairs_sep)\n\n{\n\n    int ret, count = 0;\n\n    const char *dummy_shorthand = NULL;\n\n    char key_buf[68], *value;\n\n    const char *key;\n\n\n\n    if (!opts)\n\n        return 0;\n\n    if (!shorthand)\n\n        shorthand = &dummy_shorthand;\n\n\n\n    while (*opts) {\n\n        if ((ret = get_key(&opts, key_val_sep, key_buf, sizeof(key_buf))) < 0) {\n\n            if (*shorthand) {\n\n                key = *(shorthand++);\n\n            } else {\n\n                av_log(ctx, AV_LOG_ERROR, \"No option name near '%s'\\n\", opts);\n\n                return AVERROR(EINVAL);\n\n            }\n\n        } else {\n\n            key = key_buf;\n\n            while (*shorthand) /* discard all remaining shorthand */\n\n                shorthand++;\n\n        }\n\n\n\n        if (!(value = av_get_token(&opts, pairs_sep)))\n\n            return AVERROR(ENOMEM);\n\n        if (*opts && strchr(pairs_sep, *opts))\n\n            opts++;\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"Setting '%s' to value '%s'\\n\", key, value);\n\n        if ((ret = av_opt_set(ctx, key, value, 0)) < 0) {\n\n            if (ret == AVERROR_OPTION_NOT_FOUND)\n\n                av_log(ctx, AV_LOG_ERROR, \"Option '%s' not found\\n\", key);\n\n            av_free(value);\n\n            return ret;\n\n        }\n\n\n\n        av_free(value);\n\n        count++;\n\n    }\n\n    return count;\n\n}\n", "idx": 11570}
{"project": "qemu", "commit_id": "2436b61a6b386d712a1813b036921443bd1c5c39", "target": 0, "func": "void helper_sysexit(void)\n\n{\n\n    int cpl;\n\n\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    if (env->sysenter_cs == 0 || cpl != 0) {\n\n        raise_exception_err(EXCP0D_GPF, 0);\n\n    }\n\n    cpu_x86_set_cpl(env, 3);\n\n    cpu_x86_load_seg_cache(env, R_CS, ((env->sysenter_cs + 16) & 0xfffc) | 3,\n\n                           0, 0xffffffff,\n\n                           DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                           DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                           DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_SS, ((env->sysenter_cs + 24) & 0xfffc) | 3,\n\n                           0, 0xffffffff,\n\n                           DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |\n\n                           DESC_S_MASK | (3 << DESC_DPL_SHIFT) |\n\n                           DESC_W_MASK | DESC_A_MASK);\n\n    ESP = ECX;\n\n    EIP = EDX;\n\n#ifdef USE_KQEMU\n\n    if (kqemu_is_ok(env)) {\n\n        env->exception_index = -1;\n\n        cpu_loop_exit();\n\n    }\n\n#endif\n\n}\n", "idx": 11595}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_efsnabs(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);\n\n}\n", "idx": 11597}
{"project": "qemu", "commit_id": "f95d7cc7fecbc0e320e83c864ce2d99fee3d9236", "target": 0, "func": "static int pte64_check(struct mmu_ctx_hash64 *ctx, target_ulong pte0,\n\n                       target_ulong pte1, int h, int rwx)\n\n{\n\n    target_ulong mmask;\n\n    int access, ret, pp;\n\n\n\n    ret = -1;\n\n    /* Check validity and table match */\n\n    if ((pte0 & HPTE64_V_VALID) && (h == !!(pte0 & HPTE64_V_SECONDARY))) {\n\n        bool nx;\n\n\n\n        /* Check vsid & api */\n\n        mmask = PTE64_CHECK_MASK;\n\n        pp = (pte1 & HPTE64_R_PP) | ((pte1 & HPTE64_R_PP0) >> 61);\n\n        /* No execute if either noexec or guarded bits set */\n\n        nx = (pte1 & HPTE64_R_N) || (pte1 & HPTE64_R_G);\n\n        if (HPTE64_V_COMPARE(pte0, ctx->ptem)) {\n\n            if (ctx->raddr != (hwaddr)-1ULL) {\n\n                /* all matches should have equal RPN, WIMG & PP */\n\n                if ((ctx->raddr & mmask) != (pte1 & mmask)) {\n\n                    qemu_log(\"Bad RPN/WIMG/PP\\n\");\n\n                    return -3;\n\n                }\n\n            }\n\n            /* Compute access rights */\n\n            access = ppc_hash64_pp_check(ctx->key, pp, nx);\n\n            /* Keep the matching PTE informations */\n\n            ctx->raddr = pte1;\n\n            ctx->prot = access;\n\n            ret = ppc_hash64_check_prot(ctx->prot, rwx);\n\n            if (ret == 0) {\n\n                /* Access granted */\n\n                LOG_MMU(\"PTE access granted !\\n\");\n\n            } else {\n\n                /* Access right violation */\n\n                LOG_MMU(\"PTE access rejected\\n\");\n\n            }\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 11611}
{"project": "qemu", "commit_id": "552908fef5b67ad9d96b76d7cb8371ebc26c9bc8", "target": 0, "func": "static uint64_t bmdma_addr_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned width)\n\n{\n\n    BMDMAState *bm = opaque;\n\n    uint32_t mask = (1ULL << (width * 8)) - 1;\n\n    uint64_t data;\n\n\n\n    data = (bm->addr >> (addr * 8)) & mask;\n\n#ifdef DEBUG_IDE\n\n    printf(\"%s: 0x%08x\\n\", __func__, (unsigned)*data);\n\n#endif\n\n    return data;\n\n}\n", "idx": 11612}
{"project": "qemu", "commit_id": "8b7968f7c4ac8c07cad6a1a0891d38cf239a2839", "target": 0, "func": "static void qerror_abort(const QError *qerr, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n\n\n    fprintf(stderr, \"qerror: bad call in function '%s':\\n\", qerr->func);\n\n    fprintf(stderr, \"qerror: -> \");\n\n\n\n    va_start(ap, fmt);\n\n    vfprintf(stderr, fmt, ap);\n\n    va_end(ap);\n\n\n\n    fprintf(stderr, \"\\nqerror: call at %s:%d\\n\", qerr->file, qerr->linenr);\n\n    abort();\n\n}\n", "idx": 11613}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_nabs(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_GT, cpu_gpr[rA(ctx->opcode)], 0, l1);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_neg_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    gen_set_label(l2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rD(ctx->opcode)]);\n\n}\n", "idx": 11616}
{"project": "qemu", "commit_id": "d66b969b0d9c8eefdcbff4b48535b0fe1501d139", "target": 0, "func": "static void vtd_iotlb_page_invalidate(IntelIOMMUState *s, uint16_t domain_id,\n\n                                      hwaddr addr, uint8_t am)\n\n{\n\n    VTDIOTLBPageInvInfo info;\n\n\n\n    assert(am <= VTD_MAMV);\n\n    info.domain_id = domain_id;\n\n    info.gfn = addr >> VTD_PAGE_SHIFT_4K;\n\n    info.mask = ~((1 << am) - 1);\n\n    g_hash_table_foreach_remove(s->iotlb, vtd_hash_remove_by_page, &info);\n\n}\n", "idx": 11628}
{"project": "qemu", "commit_id": "568c73a4783cd981e9aa6de4f15dcda7829643ad", "target": 0, "func": "void qmp_x_input_send_event(bool has_console, int64_t console,\n\n                            InputEventList *events, Error **errp)\n\n{\n\n    InputEventList *e;\n\n    QemuConsole *con;\n\n\n\n    con = NULL;\n\n    if (has_console) {\n\n        con = qemu_console_lookup_by_index(console);\n\n        if (!con) {\n\n            error_setg(errp, \"console %\" PRId64 \" not found\", console);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (!runstate_is_running() && !runstate_check(RUN_STATE_SUSPENDED)) {\n\n        error_setg(errp, \"VM not running\");\n\n        return;\n\n    }\n\n\n\n    for (e = events; e != NULL; e = e->next) {\n\n        InputEvent *event = e->value;\n\n\n\n        if (!qemu_input_find_handler(1 << event->kind, con)) {\n\n            error_setg(errp, \"Input handler not found for \"\n\n                             \"event type %s\",\n\n                            InputEventKind_lookup[event->kind]);\n\n            return;\n\n        }\n\n    }\n\n\n\n    for (e = events; e != NULL; e = e->next) {\n\n        InputEvent *event = e->value;\n\n\n\n        qemu_input_event_send(con, event);\n\n    }\n\n\n\n    qemu_input_event_sync();\n\n}\n", "idx": 11683}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int scsi_event_status_media(SCSIDiskState *s, uint8_t *outbuf)\n\n{\n\n    uint8_t event_code, media_status;\n\n\n\n    media_status = 0;\n\n    if (s->tray_open) {\n\n        media_status = MS_TRAY_OPEN;\n\n    } else if (bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        media_status = MS_MEDIA_PRESENT;\n\n    }\n\n\n\n    /* Event notification descriptor */\n\n    event_code = MEC_NO_CHANGE;\n\n    if (media_status != MS_TRAY_OPEN) {\n\n        if (s->media_event) {\n\n            event_code = MEC_NEW_MEDIA;\n\n            s->media_event = false;\n\n        } else if (s->eject_request) {\n\n            event_code = MEC_EJECT_REQUESTED;\n\n            s->eject_request = false;\n\n        }\n\n    }\n\n\n\n    outbuf[0] = event_code;\n\n    outbuf[1] = media_status;\n\n\n\n    /* These fields are reserved, just clear them. */\n\n    outbuf[2] = 0;\n\n    outbuf[3] = 0;\n\n    return 4;\n\n}\n", "idx": 11687}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int targa_encode_init(AVCodecContext *avctx)\n\n{\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    return 0;\n\n}\n", "idx": 11688}
{"project": "qemu", "commit_id": "2c0ef9f411ae6081efa9eca5b3eab2dbeee45a6c", "target": 0, "func": "void qapi_dealloc_visitor_cleanup(QapiDeallocVisitor *v)\n\n{\n\n    g_free(v);\n\n}\n", "idx": 11691}
{"project": "qemu", "commit_id": "ecce1929bcb0d8f4efde39df5ceb1aac42df75d4", "target": 0, "func": "static void gd_ungrab_pointer(GtkDisplayState *s)\n\n{\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n    GdkDisplay *display = gtk_widget_get_display(s->drawing_area);\n\n    GdkDeviceManager *mgr = gdk_display_get_device_manager(display);\n\n    GList *devices = gdk_device_manager_list_devices(mgr,\n\n                                                     GDK_DEVICE_TYPE_MASTER);\n\n    GList *tmp = devices;\n\n    while (tmp) {\n\n        GdkDevice *dev = tmp->data;\n\n        if (gdk_device_get_source(dev) == GDK_SOURCE_MOUSE) {\n\n            gdk_device_ungrab(dev,\n\n                              GDK_CURRENT_TIME);\n\n        }\n\n        tmp = tmp->next;\n\n    }\n\n    g_list_free(devices);\n\n#else\n\n    gdk_pointer_ungrab(GDK_CURRENT_TIME);\n\n#endif\n\n}\n", "idx": 11693}
{"project": "qemu", "commit_id": "adae837d40dea7100040136647e3de44898994df", "target": 1, "func": "void machine_register_compat_props(MachineState *machine)\n\n{\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n    int i;\n\n    GlobalProperty *p;\n\n\n\n    if (!mc->compat_props) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < mc->compat_props->len; i++) {\n\n        p = g_array_index(mc->compat_props, GlobalProperty *, i);\n\n\n\n        qdev_prop_register_global(p);\n\n    }\n\n}", "idx": 11696}
{"project": "FFmpeg", "commit_id": "3e56db892600c2fbe34782c6140f1ee832a2c344", "target": 1, "func": "static int y216_decode_frame(AVCodecContext *avctx, void *data,\n\n                             int *got_frame, AVPacket *avpkt)\n\n{\n\n    AVFrame *pic = data;\n\n    const uint16_t *src = (uint16_t *)avpkt->data;\n\n    uint16_t *y, *u, *v, aligned_width = FFALIGN(avctx->width, 4);\n\n    int i, j, ret;\n\n\n\n    if (avpkt->size < 4 * avctx->height * aligned_width) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Insufficient input data.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    pic->key_frame = 1;\n\n    pic->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    y = (uint16_t *)pic->data[0];\n\n    u = (uint16_t *)pic->data[1];\n\n    v = (uint16_t *)pic->data[2];\n\n\n\n    for (i = 0; i < avctx->height; i++) {\n\n        for (j = 0; j < avctx->width >> 1; j++) {\n\n            u[    j    ] = src[4 * j    ] << 2 | src[4 * j    ] >> 14;\n\n            y[2 * j    ] = src[4 * j + 1] << 2 | src[4 * j + 1] >> 14;\n\n            v[    j    ] = src[4 * j + 2] << 2 | src[4 * j + 2] >> 14;\n\n            y[2 * j + 1] = src[4 * j + 3] << 2 | src[4 * j + 3] >> 14;\n\n        }\n\n\n\n        y += pic->linesize[0] >> 1;\n\n        u += pic->linesize[1] >> 1;\n\n        v += pic->linesize[2] >> 1;\n\n        src += aligned_width << 1;\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 11723}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_addo (void)\n\n{\n\n    T2 = T0;\n\n    T0 += T1;\n\n    if (likely(!((T2 ^ T1 ^ (-1)) & (T2 ^ T0) & (1 << 31)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n}\n", "idx": 11731}
{"project": "qemu", "commit_id": "9bc9732faeff09828fe38c0ebe2401ee131a6fca", "target": 1, "func": "static void nbd_coroutine_start(NbdClientSession *s,\n\n   struct nbd_request *request)\n\n{\n\n    /* Poor man semaphore.  The free_sema is locked when no other request\n\n     * can be accepted, and unlocked after receiving one reply.  */\n\n    if (s->in_flight >= MAX_NBD_REQUESTS - 1) {\n\n        qemu_co_mutex_lock(&s->free_sema);\n\n        assert(s->in_flight < MAX_NBD_REQUESTS);\n\n    }\n\n    s->in_flight++;\n\n\n\n    /* s->recv_coroutine[i] is set as soon as we get the send_lock.  */\n\n}\n", "idx": 11732}
{"project": "FFmpeg", "commit_id": "1c0e205fab4bd5bbfa0399af2cd5e281b414b3d5", "target": 1, "func": "void audio_decode_example(const char *outfilename, const char *filename)\n\n{\n\n    AVCodec *codec;\n\n    AVCodecContext *c= NULL;\n\n    int out_size, size, len;\n\n    FILE *f, *outfile;\n\n    uint8_t *outbuf;\n\n    uint8_t inbuf[INBUF_SIZE + FF_INPUT_BUFFER_PADDING_SIZE], *inbuf_ptr;\n\n\n\n    printf(\"Audio decoding\\n\");\n\n    \n\n    /* set end of buffer to 0 (this ensures that no overreading happens for damaged mpeg streams) */\n\n    memset(inbuf + INBUF_SIZE, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n    /* find the mpeg audio decoder */\n\n    codec = avcodec_find_decoder(CODEC_ID_MP2);\n\n    if (!codec) {\n\n        fprintf(stderr, \"codec not found\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    c= avcodec_alloc_context();\n\n\n\n    /* open it */\n\n    if (avcodec_open(c, codec) < 0) {\n\n        fprintf(stderr, \"could not open codec\\n\");\n\n        exit(1);\n\n    }\n\n    \n\n    outbuf = malloc(AVCODEC_MAX_AUDIO_FRAME_SIZE);\n\n\n\n    f = fopen(filename, \"r\");\n\n    if (!f) {\n\n        fprintf(stderr, \"could not open %s\\n\", filename);\n\n        exit(1);\n\n    }\n\n    outfile = fopen(outfilename, \"w\");\n\n    if (!outfile) {\n\n        free(c);\n\n        exit(1);\n\n    }\n\n        \n\n    /* decode until eof */\n\n    inbuf_ptr = inbuf;\n\n    for(;;) {\n\n        size = fread(inbuf, 1, INBUF_SIZE, f);\n\n        if (size == 0)\n\n            break;\n\n\n\n        inbuf_ptr = inbuf;\n\n        while (size > 0) {\n\n            len = avcodec_decode_audio(c, (short *)outbuf, &out_size, \n\n                                       inbuf_ptr, size);\n\n            if (len < 0) {\n\n                fprintf(stderr, \"Error while decoding\\n\");\n\n                exit(1);\n\n            }\n\n            if (out_size > 0) {\n\n                /* if a frame has been decoded, output it */\n\n                fwrite(outbuf, 1, out_size, outfile);\n\n            }\n\n            size -= len;\n\n            inbuf_ptr += len;\n\n        }\n\n    }\n\n\n\n    fclose(outfile);\n\n    fclose(f);\n\n    free(outbuf);\n\n\n\n    avcodec_close(c);\n\n    free(c);\n\n}\n", "idx": 11745}
{"project": "FFmpeg", "commit_id": "a930cd0d195ea1c33b6b97b3f3f60703f899e739", "target": 0, "func": "static int nprobe(AVFormatContext *s, uint8_t *enc_header, const uint8_t *n_val)\n\n{\n\n    OMAContext *oc = s->priv_data;\n\n    uint32_t pos, taglen, datalen;\n\n    struct AVDES av_des;\n\n\n\n    if (!enc_header || !n_val)\n\n        return -1;\n\n\n\n    pos = OMA_ENC_HEADER_SIZE + oc->k_size;\n\n    if (!memcmp(&enc_header[pos], \"EKB \", 4))\n\n        pos += 32;\n\n\n\n    if (AV_RB32(&enc_header[pos]) != oc->rid)\n\n        av_log(s, AV_LOG_DEBUG, \"Mismatching RID\\n\");\n\n\n\n    taglen = AV_RB32(&enc_header[pos+32]);\n\n    datalen = AV_RB32(&enc_header[pos+36]) >> 4;\n\n\n\n    pos += 44 + taglen;\n\n\n\n    av_des_init(&av_des, n_val, 192, 1);\n\n    while (datalen-- > 0) {\n\n        av_des_crypt(&av_des, oc->r_val, &enc_header[pos], 2, NULL, 1);\n\n        kset(s, oc->r_val, NULL, 16);\n\n        if (!rprobe(s, enc_header, oc->r_val))\n\n            return 0;\n\n        pos += 16;\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 11825}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void ide_sector_start_dma(IDEState *s, enum ide_dma_cmd dma_cmd)\n\n{\n\n    s->status = READY_STAT | SEEK_STAT | DRQ_STAT | BUSY_STAT;\n\n    s->io_buffer_index = 0;\n\n    s->io_buffer_size = 0;\n\n    s->dma_cmd = dma_cmd;\n\n\n\n    switch (dma_cmd) {\n\n    case IDE_DMA_READ:\n\n        block_acct_start(bdrv_get_stats(s->bs), &s->acct,\n\n                         s->nsector * BDRV_SECTOR_SIZE, BLOCK_ACCT_READ);\n\n        break;\n\n    case IDE_DMA_WRITE:\n\n        block_acct_start(bdrv_get_stats(s->bs), &s->acct,\n\n                         s->nsector * BDRV_SECTOR_SIZE, BLOCK_ACCT_WRITE);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    ide_start_dma(s, ide_dma_cb);\n\n}\n", "idx": 11841}
{"project": "qemu", "commit_id": "8b3d6cb1fa6ae12e80ed8c266a637468b52835c7", "target": 0, "func": "void s390_feat_bitmap_to_ascii(const S390FeatBitmap bitmap, void *opaque,\n\n                               void (*fn)(const char *name, void *opaque))\n\n{\n\n    S390Feat feat;\n\n\n\n    feat = find_first_bit(bitmap, S390_FEAT_MAX);\n\n    while (feat < S390_FEAT_MAX) {\n\n        fn(s390_feat_def(feat)->name, opaque);\n\n        feat = find_next_bit(bitmap, S390_FEAT_MAX, feat + 1);\n\n    };\n\n}\n", "idx": 11847}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "static uint64_t hpet_get_ticks(void)\n\n{\n\n    uint64_t ticks;\n\n    ticks = ns_to_ticks(qemu_get_clock(vm_clock) + hpet_statep->hpet_offset);\n\n    return ticks;\n\n}\n", "idx": 11863}
{"project": "FFmpeg", "commit_id": "e48ded8551172b58a78f30303a81dfce125344e0", "target": 0, "func": "static av_cold int asink_init(AVFilterContext *ctx, void *opaque)\n\n{\n\n    BufferSinkContext *buf = ctx->priv;\n\n    AVABufferSinkParams *params = opaque;\n\n\n\n    if (params && params->sample_fmts) {\n\n        buf->sample_fmts = ff_copy_int_list(params->sample_fmts);\n\n        if (!buf->sample_fmts)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    if (params && params->sample_rates) {\n\n        buf->sample_rates = ff_copy_int_list(params->sample_rates);\n\n        if (!buf->sample_rates)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    if (params && (params->channel_layouts || params->channel_counts)) {\n\n        if (params->all_channel_counts) {\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Conflicting all_channel_counts and list in parameters\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n        buf->channel_layouts = concat_channels_lists(params->channel_layouts,\n\n                                                     params->channel_counts);\n\n        if (!buf->channel_layouts)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    if (params)\n\n        buf->all_channel_counts = params->all_channel_counts;\n\n    return common_init(ctx);\n\n}\n", "idx": 11895}
{"project": "qemu", "commit_id": "c07a9008ac6985cd5a15909c2b9977d982defc12", "target": 0, "func": "static BlockDriverAIOCB *bdrv_aio_rw_vector(BlockDriverState *bs,\n\n                                            int64_t sector_num,\n\n                                            QEMUIOVector *iov,\n\n                                            int nb_sectors,\n\n                                            BlockDriverCompletionFunc *cb,\n\n                                            void *opaque,\n\n                                            int is_write)\n\n\n\n{\n\n    VectorTranslationState *s = qemu_mallocz(sizeof(*s));\n\n    BlockDriverAIOCB *aiocb = qemu_aio_get(bs, cb, opaque);\n\n\n\n    s->this_aiocb = aiocb;\n\n    s->iov = iov;\n\n    s->bounce = qemu_memalign(512, nb_sectors * 512);\n\n    s->is_write = is_write;\n\n    if (is_write) {\n\n        qemu_iovec_to_buffer(s->iov, s->bounce);\n\n        s->aiocb = bdrv_aio_write(bs, sector_num, s->bounce, nb_sectors,\n\n                                  bdrv_aio_rw_vector_cb, s);\n\n    } else {\n\n        s->aiocb = bdrv_aio_read(bs, sector_num, s->bounce, nb_sectors,\n\n                                 bdrv_aio_rw_vector_cb, s);\n\n    }\n\n    return aiocb;\n\n}\n", "idx": 11912}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static void pc_machine_set_max_ram_below_4g(Object *obj, Visitor *v,\n\n                                            const char *name, void *opaque,\n\n                                            Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n    Error *error = NULL;\n\n    uint64_t value;\n\n\n\n    visit_type_size(v, name, &value, &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        return;\n\n    }\n\n    if (value > (1ULL << 32)) {\n\n        error_setg(&error,\n\n                   \"Machine option 'max-ram-below-4g=%\"PRIu64\n\n                   \"' expects size less than or equal to 4G\", value);\n\n        error_propagate(errp, error);\n\n        return;\n\n    }\n\n\n\n    if (value < (1ULL << 20)) {\n\n        error_report(\"Warning: small max_ram_below_4g(%\"PRIu64\n\n                     \") less than 1M.  BIOS may not work..\",\n\n                     value);\n\n    }\n\n\n\n    pcms->max_ram_below_4g = value;\n\n}\n", "idx": 11914}
{"project": "FFmpeg", "commit_id": "9a2e79116d6235c53d8e9663a8d30d1950d7431a", "target": 1, "func": "static int rv30_decode_intra_types(RV34DecContext *r, GetBitContext *gb, int8_t *dst)\n\n{\n\n    int i, j, k;\n\n\n\n    for(i = 0; i < 4; i++, dst += r->intra_types_stride - 4){\n\n        for(j = 0; j < 4; j+= 2){\n\n            int code = svq3_get_ue_golomb(gb) << 1;\n\n            if(code >= 81*2){\n\n                av_log(r->s.avctx, AV_LOG_ERROR, \"Incorrect intra prediction code\\n\");\n\n                return -1;\n\n            }\n\n            for(k = 0; k < 2; k++){\n\n                int A = dst[-r->intra_types_stride] + 1;\n\n                int B = dst[-1] + 1;\n\n                *dst++ = rv30_itype_from_context[A * 90 + B * 9 + rv30_itype_code[code + k]];\n\n                if(dst[-1] == 9){\n\n                    av_log(r->s.avctx, AV_LOG_ERROR, \"Incorrect intra prediction mode\\n\");\n\n                    return -1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 11927}
{"project": "qemu", "commit_id": "595ab64169be9063d64c3b1aa1c249fbe2662221", "target": 1, "func": "static int stdio_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)\n\n{\n\n    QEMUFileStdio *s = opaque;\n\n    FILE *fp = s->stdio_file;\n\n    int bytes;\n\n\n\n    do {\n\n        clearerr(fp);\n\n        bytes = fread(buf, 1, size, fp);\n\n    } while ((bytes == 0) && ferror(fp) && (errno == EINTR));\n\n    return bytes;\n\n}\n", "idx": 11930}
{"project": "qemu", "commit_id": "03f4995781a64e106e6f73864a1e9c4163dac53b", "target": 0, "func": "static MemoryRegionSection *phys_page_find(PhysPageEntry lp, hwaddr index,\n\n                                           Node *nodes, MemoryRegionSection *sections)\n\n{\n\n    PhysPageEntry *p;\n\n    int i;\n\n\n\n    for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) {\n\n        if (lp.ptr == PHYS_MAP_NODE_NIL) {\n\n            return &sections[PHYS_SECTION_UNASSIGNED];\n\n        }\n\n        p = nodes[lp.ptr];\n\n        lp = p[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n    return &sections[lp.ptr];\n\n}\n", "idx": 11945}
{"project": "qemu", "commit_id": "4c8ae0f60e63478aea0a1741cca95474b68fb949", "target": 0, "func": "static int ram_save_block(QEMUFile *f, bool last_stage)\n\n{\n\n    RAMBlock *block = last_seen_block;\n\n    ram_addr_t offset = last_offset;\n\n    int bytes_sent = -1;\n\n    MemoryRegion *mr;\n\n    ram_addr_t current_addr;\n\n\n\n    if (!block)\n\n        block = QTAILQ_FIRST(&ram_list.blocks);\n\n\n\n    do {\n\n        mr = block->mr;\n\n        if (migration_bitmap_test_and_reset_dirty(mr, offset)) {\n\n            uint8_t *p;\n\n            int cont = (block == last_sent_block) ?\n\n                RAM_SAVE_FLAG_CONTINUE : 0;\n\n\n\n            p = memory_region_get_ram_ptr(mr) + offset;\n\n\n\n            if (is_dup_page(p)) {\n\n                acct_info.dup_pages++;\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);\n\n                qemu_put_byte(f, *p);\n\n                bytes_sent = 1;\n\n            } else if (migrate_use_xbzrle()) {\n\n                current_addr = block->offset + offset;\n\n                bytes_sent = save_xbzrle_page(f, p, current_addr, block,\n\n                                              offset, cont, last_stage);\n\n                if (!last_stage) {\n\n                    p = get_cached_data(XBZRLE.cache, current_addr);\n\n                }\n\n            }\n\n\n\n            /* either we didn't send yet (we may have had XBZRLE overflow) */\n\n            if (bytes_sent == -1) {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);\n\n                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);\n\n                bytes_sent = TARGET_PAGE_SIZE;\n\n                acct_info.norm_pages++;\n\n            }\n\n\n\n            /* if page is unmodified, continue to the next */\n\n            if (bytes_sent != 0) {\n\n                last_sent_block = block;\n\n                break;\n\n            }\n\n        }\n\n\n\n        offset += TARGET_PAGE_SIZE;\n\n        if (offset >= block->length) {\n\n            offset = 0;\n\n            block = QTAILQ_NEXT(block, next);\n\n            if (!block)\n\n                block = QTAILQ_FIRST(&ram_list.blocks);\n\n        }\n\n    } while (block != last_seen_block || offset != last_offset);\n\n\n\n    last_seen_block = block;\n\n    last_offset = offset;\n\n\n\n    return bytes_sent;\n\n}\n", "idx": 11947}
{"project": "qemu", "commit_id": "7d175d29c9430fcba7a98f2c71925137b7870da4", "target": 0, "func": "static int os_host_main_loop_wait(int64_t timeout)\n\n{\n\n    int ret;\n\n    static int spin_counter;\n\n\n\n    glib_pollfds_fill(&timeout);\n\n\n\n    /* If the I/O thread is very busy or we are incorrectly busy waiting in\n\n     * the I/O thread, this can lead to starvation of the BQL such that the\n\n     * VCPU threads never run.  To make sure we can detect the later case,\n\n     * print a message to the screen.  If we run into this condition, create\n\n     * a fake timeout in order to give the VCPU threads a chance to run.\n\n     */\n\n    if (!timeout && (spin_counter > MAX_MAIN_LOOP_SPIN)) {\n\n        static bool notified;\n\n\n\n        if (!notified && !qtest_driver()) {\n\n            fprintf(stderr,\n\n                    \"main-loop: WARNING: I/O thread spun for %d iterations\\n\",\n\n                    MAX_MAIN_LOOP_SPIN);\n\n            notified = true;\n\n        }\n\n\n\n        timeout = SCALE_MS;\n\n    }\n\n\n\n    if (timeout) {\n\n        spin_counter = 0;\n\n        qemu_mutex_unlock_iothread();\n\n    } else {\n\n        spin_counter++;\n\n    }\n\n\n\n    ret = qemu_poll_ns((GPollFD *)gpollfds->data, gpollfds->len, timeout);\n\n\n\n    if (timeout) {\n\n        qemu_mutex_lock_iothread();\n\n    }\n\n\n\n    glib_pollfds_poll();\n\n    return ret;\n\n}\n", "idx": 11955}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static void qemu_kill_report(void)\n\n{\n\n    if (!qtest_driver() && shutdown_signal != -1) {\n\n        fprintf(stderr, \"qemu: terminating on signal %d\", shutdown_signal);\n\n        if (shutdown_pid == 0) {\n\n            /* This happens for eg ^C at the terminal, so it's worth\n\n             * avoiding printing an odd message in that case.\n\n             */\n\n            fputc('\\n', stderr);\n\n        } else {\n\n            fprintf(stderr, \" from pid \" FMT_pid \"\\n\", shutdown_pid);\n\n        }\n\n        shutdown_signal = -1;\n\n    }\n\n}\n", "idx": 11963}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_bol(void)\n\n{\n\n    term_cmd_buf_index = 0;\n\n}\n", "idx": 11965}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static int gen_set_psr_im(DisasContext *s, uint32_t mask, int spsr, uint32_t val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_movi_i32(tmp, val);\n\n    return gen_set_psr(s, mask, spsr, tmp);\n\n}\n", "idx": 12004}
{"project": "qemu", "commit_id": "621ff94d5074d88253a5818c6b9c4db718fbfc65", "target": 0, "func": "static void vhost_ccw_scsi_realize(VirtioCcwDevice *ccw_dev, Error **errp)\n\n{\n\n    VHostSCSICcw *dev = VHOST_SCSI_CCW(ccw_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n    Error *err = NULL;\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&ccw_dev->bus));\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n    }\n\n}\n", "idx": 12030}
{"project": "qemu", "commit_id": "185b43386ad999c80bdc58e41b87f05e5b3e8463", "target": 0, "func": "ssize_t nbd_send_request(int csock, struct nbd_request *request)\n\n{\n\n    uint8_t buf[4 + 4 + 8 + 8 + 4];\n\n\n\n    cpu_to_be32w((uint32_t*)buf, NBD_REQUEST_MAGIC);\n\n    cpu_to_be32w((uint32_t*)(buf + 4), request->type);\n\n    cpu_to_be64w((uint64_t*)(buf + 8), request->handle);\n\n    cpu_to_be64w((uint64_t*)(buf + 16), request->from);\n\n    cpu_to_be32w((uint32_t*)(buf + 24), request->len);\n\n\n\n    TRACE(\"Sending request to client: \"\n\n          \"{ .from = %\" PRIu64\", .len = %u, .handle = %\" PRIu64\", .type=%i}\",\n\n          request->from, request->len, request->handle, request->type);\n\n\n\n    if (write_sync(csock, buf, sizeof(buf)) != sizeof(buf)) {\n\n        LOG(\"writing to socket failed\");\n\n        errno = EINVAL;\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12041}
{"project": "qemu", "commit_id": "64a31d5c3d73396a88563d7a504654edc85aa854", "target": 0, "func": "static void dmg_close(BlockDriverState *bs)\n\n{\n\n    BDRVDMGState *s = bs->opaque;\n\n    close(s->fd);\n\n    if(s->n_chunks>0) {\n\n\tfree(s->types);\n\n\tfree(s->offsets);\n\n\tfree(s->lengths);\n\n\tfree(s->sectors);\n\n\tfree(s->sectorcounts);\n\n    }\n\n    free(s->compressed_chunk);\n\n    free(s->uncompressed_chunk);\n\n    inflateEnd(&s->zstream);\n\n}\n", "idx": 12049}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lance_mem_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    SysBusPCNetState *d = opaque;\n\n\n\n    trace_lance_mem_writew(addr, val & 0xffff);\n\n    pcnet_ioport_writew(&d->state, addr, val & 0xffff);\n\n}\n", "idx": 12053}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "matroska_probe (AVProbeData *p)\n\n{\n\n    uint64_t total = 0;\n\n    int len_mask = 0x80, size = 1, n = 1;\n\n    uint8_t probe_data[] = { 'm', 'a', 't', 'r', 'o', 's', 'k', 'a' };\n\n\n\n    if (p->buf_size < 5)\n\n        return 0;\n\n\n\n    /* ebml header? */\n\n    if ((p->buf[0] << 24 | p->buf[1] << 16 |\n\n         p->buf[2] << 8 | p->buf[3]) != EBML_ID_HEADER)\n\n        return 0;\n\n\n\n    /* length of header */\n\n    total = p->buf[4];\n\n    while (size <= 8 && !(total & len_mask)) {\n\n        size++;\n\n        len_mask >>= 1;\n\n    }\n\n    if (size > 8)\n\n      return 0;\n\n    total &= (len_mask - 1);\n\n    while (n < size)\n\n        total = (total << 8) | p->buf[4 + n++];\n\n\n\n    /* does the probe data contain the whole header? */\n\n    if (p->buf_size < 4 + size + total)\n\n      return 0;\n\n\n\n    /* the header must contain the document type 'matroska'. For now,\n\n     * we don't parse the whole header but simply check for the\n\n     * availability of that array of characters inside the header.\n\n     * Not fully fool-proof, but good enough. */\n\n    for (n = 4 + size; n <= 4 + size + total - sizeof(probe_data); n++)\n\n        if (!memcmp (&p->buf[n], probe_data, sizeof(probe_data)))\n\n            return AVPROBE_SCORE_MAX;\n\n\n\n    return 0;\n\n}\n", "idx": 12056}
{"project": "FFmpeg", "commit_id": "8bedbb82cee4463a43e60eb22674c8bf927280ef", "target": 1, "func": "static void dequantization_float(int x, int y, Jpeg2000Cblk *cblk,\n\n                                 Jpeg2000Component *comp,\n\n                                 Jpeg2000T1Context *t1, Jpeg2000Band *band)\n\n{\n\n    int i, j, idx;\n\n    float *datap = &comp->data[(comp->coord[0][1] - comp->coord[0][0]) * y + x];\n\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j)\n\n        for (i = 0; i < (cblk->coord[0][1] - cblk->coord[0][0]); ++i) {\n\n            idx        = (comp->coord[0][1] - comp->coord[0][0]) * j + i;\n\n            datap[idx] = (float)(t1->data[j][i]) * band->f_stepsize;\n\n        }\n\n}\n", "idx": 12082}
{"project": "qemu", "commit_id": "0745eb1e4336bf665a911754d18ddd63794b352d", "target": 1, "func": "device_init(usb_host_register_devices)\n\n\n\nUSBDevice *usb_host_device_open(const char *devname)\n\n{\n\n    struct USBAutoFilter filter = { 0, 0, 0, 0 };\n\n    USBDevice *dev;\n\n    USBHostDevice *s;\n\n    char *p;\n\n\n\n    dev = usb_create(NULL /* FIXME */, \"USB Host Device\");\n\n    s = DO_UPCAST(USBHostDevice, dev, dev);\n\n\n\n    if (strstr(devname, \"auto:\")) {\n\n        if (parse_filter(devname+5, &filter) < 0)\n\n            goto fail;\n\n    } else {\n\n        if ((p = strchr(devname, '.'))) {\n\n            filter.bus_num = strtoul(devname, NULL, 0);\n\n            filter.addr    = strtoul(devname, NULL, 0);\n\n        } else if ((p = strchr(devname, ':'))) {\n\n            filter.vendor_id  = strtoul(devname, NULL, 16);\n\n            filter.product_id = strtoul(devname, NULL, 16);\n\n        } else {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    qdev_prop_set_uint32(&dev->qdev, \"bus\",       filter.bus_num);\n\n    qdev_prop_set_uint32(&dev->qdev, \"addr\",      filter.addr);\n\n    qdev_prop_set_uint32(&dev->qdev, \"vendorid\",  filter.vendor_id);\n\n    qdev_prop_set_uint32(&dev->qdev, \"productid\", filter.product_id);\n\n    qdev_init(&dev->qdev);\n\n    return dev;\n\n\n\nfail:\n\n    qdev_free(&dev->qdev);\n\n    return NULL;\n\n}\n", "idx": 12093}
{"project": "qemu", "commit_id": "27a749fb733dc64b7a215998be7f228a09bb27a7", "target": 1, "func": "void qemu_error_internal(const char *file, int linenr, const char *func,\n\n                         const char *fmt, ...)\n\n{\n\n    va_list va;\n\n    QError *qerror;\n\n\n\n    assert(qemu_error_sink != NULL);\n\n\n\n    va_start(va, fmt);\n\n    qerror = qerror_from_info(file, linenr, func, fmt, &va);\n\n    va_end(va);\n\n\n\n    switch (qemu_error_sink->dest) {\n\n    case ERR_SINK_FILE:\n\n        qerror_print(qerror);\n\n        QDECREF(qerror);\n\n        break;\n\n    case ERR_SINK_MONITOR:\n\n        assert(qemu_error_sink->mon->error == NULL);\n\n        qemu_error_sink->mon->error = qerror;\n\n        break;\n\n    }\n\n}\n", "idx": 12094}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_vert_8x8_msa(uint8_t *src, uint8_t *dst,\n\n                                       int32_t dst_stride)\n\n{\n\n    uint32_t row;\n\n    uint32_t src_data1, src_data2;\n\n\n\n    src_data1 = LW(src);\n\n    src_data2 = LW(src + 4);\n\n\n\n    for (row = 8; row--;) {\n\n        SW(src_data1, dst);\n\n        SW(src_data2, (dst + 4));\n\n        dst += dst_stride;\n\n    }\n\n}\n", "idx": 12101}
{"project": "qemu", "commit_id": "daa23699031693b434ec263b212f77ba505e353e", "target": 0, "func": "static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t index,\n\n                                uint64_t *buid, hwaddr *pio, hwaddr *mmio,\n\n                                unsigned n_dma, uint32_t *liobns, Error **errp)\n\n{\n\n    const uint64_t base_buid = 0x800000020000000ULL;\n\n    const hwaddr phb_spacing = 0x1000000000ULL; /* 64 GiB */\n\n    const hwaddr mmio_offset = 0xa0000000; /* 2 GiB + 512 MiB */\n\n    const hwaddr pio_offset = 0x80000000; /* 2 GiB */\n\n    const uint32_t max_index = 255;\n\n    const hwaddr phb0_alignment = 0x10000000000ULL; /* 1 TiB */\n\n\n\n    uint64_t ram_top = MACHINE(spapr)->ram_size;\n\n    hwaddr phb0_base, phb_base;\n\n    int i;\n\n\n\n    /* Do we have hotpluggable memory? */\n\n    if (MACHINE(spapr)->maxram_size > ram_top) {\n\n        /* Can't just use maxram_size, because there may be an\n\n         * alignment gap between normal and hotpluggable memory\n\n         * regions */\n\n        ram_top = spapr->hotplug_memory.base +\n\n            memory_region_size(&spapr->hotplug_memory.mr);\n\n    }\n\n\n\n    phb0_base = QEMU_ALIGN_UP(ram_top, phb0_alignment);\n\n\n\n    if (index > max_index) {\n\n        error_setg(errp, \"\\\"index\\\" for PAPR PHB is too large (max %u)\",\n\n                   max_index);\n\n        return;\n\n    }\n\n\n\n    *buid = base_buid + index;\n\n    for (i = 0; i < n_dma; ++i) {\n\n        liobns[i] = SPAPR_PCI_LIOBN(index, i);\n\n    }\n\n\n\n    phb_base = phb0_base + index * phb_spacing;\n\n    *pio = phb_base + pio_offset;\n\n    *mmio = phb_base + mmio_offset;\n\n}\n", "idx": 12105}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_save_vmstate(BlockDriverState *bs, const uint8_t *buf,\n\n                      int64_t pos, int size)\n\n{\n\n    QEMUIOVector qiov;\n\n    struct iovec iov = {\n\n        .iov_base   = (void *) buf,\n\n        .iov_len    = size,\n\n    };\n\n\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n    return bdrv_writev_vmstate(bs, &qiov, pos);\n\n}\n", "idx": 12109}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "void helper_fcmpo (uint64_t arg1, uint64_t arg2, uint32_t crfD)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n    uint32_t ret = 0;\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_nan(farg1.d) ||\n\n                 float64_is_nan(farg2.d))) {\n\n        ret = 0x01UL;\n\n    } else if (float64_lt(farg1.d, farg2.d, &env->fp_status)) {\n\n        ret = 0x08UL;\n\n    } else if (!float64_le(farg1.d, farg2.d, &env->fp_status)) {\n\n        ret = 0x04UL;\n\n    } else {\n\n        ret = 0x02UL;\n\n    }\n\n\n\n    env->fpscr &= ~(0x0F << FPSCR_FPRF);\n\n    env->fpscr |= ret << FPSCR_FPRF;\n\n    env->crf[crfD] = ret;\n\n    if (unlikely (ret == 0x01UL)) {\n\n        if (float64_is_signaling_nan(farg1.d) ||\n\n            float64_is_signaling_nan(farg2.d)) {\n\n            /* sNaN comparison */\n\n            fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN |\n\n                                  POWERPC_EXCP_FP_VXVC);\n\n        } else {\n\n            /* qNaN comparison */\n\n            fload_invalid_op_excp(POWERPC_EXCP_FP_VXVC);\n\n        }\n\n    }\n\n}\n", "idx": 12121}
{"project": "qemu", "commit_id": "882e9b89af7c1086d97cee11b2437337e756fa00", "target": 0, "func": "void qmp_x_blockdev_set_iothread(const char *node_name, StrOrNull *iothread,\n\n                                 Error **errp)\n\n{\n\n    AioContext *old_context;\n\n    AioContext *new_context;\n\n    BlockDriverState *bs;\n\n\n\n    bs = bdrv_find_node(node_name);\n\n    if (!bs) {\n\n        error_setg(errp, \"Cannot find node %s\", node_name);\n\n        return;\n\n    }\n\n\n\n    /* If we want to allow more extreme test scenarios this guard could be\n\n     * removed.  For now it protects against accidents. */\n\n    if (bdrv_has_blk(bs)) {\n\n        error_setg(errp, \"Node %s is in use\", node_name);\n\n        return;\n\n    }\n\n\n\n    if (iothread->type == QTYPE_QSTRING) {\n\n        IOThread *obj = iothread_by_id(iothread->u.s);\n\n        if (!obj) {\n\n            error_setg(errp, \"Cannot find iothread %s\", iothread->u.s);\n\n            return;\n\n        }\n\n\n\n        new_context = iothread_get_aio_context(obj);\n\n    } else {\n\n        new_context = qemu_get_aio_context();\n\n    }\n\n\n\n    old_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(old_context);\n\n\n\n    bdrv_set_aio_context(bs, new_context);\n\n\n\n    aio_context_release(old_context);\n\n}\n", "idx": 12132}
{"project": "qemu", "commit_id": "240f64b6dc3346d044d7beb7cc3a53668ce47384", "target": 0, "func": "static void test_dealloc_partial(void)\n\n{\n\n    static const char text[] = \"don't leak me\";\n\n\n\n    UserDefTwo *ud2 = NULL;\n\n    Error *err = NULL;\n\n\n\n    /* create partial object */\n\n    {\n\n        QDict *ud2_dict;\n\n        QmpInputVisitor *qiv;\n\n\n\n        ud2_dict = qdict_new();\n\n        qdict_put_obj(ud2_dict, \"string0\", QOBJECT(qstring_from_str(text)));\n\n\n\n        qiv = qmp_input_visitor_new(QOBJECT(ud2_dict), false);\n\n        visit_type_UserDefTwo(qmp_input_get_visitor(qiv), NULL, &ud2, &err);\n\n        qmp_input_visitor_cleanup(qiv);\n\n        QDECREF(ud2_dict);\n\n    }\n\n\n\n    /* verify partial success */\n\n    assert(ud2 != NULL);\n\n    assert(ud2->string0 != NULL);\n\n    assert(strcmp(ud2->string0, text) == 0);\n\n    assert(ud2->dict1 == NULL);\n\n\n\n    /* confirm & release construction error */\n\n    error_free_or_abort(&err);\n\n\n\n    /* tear down partial object */\n\n    qapi_free_UserDefTwo(ud2);\n\n}\n", "idx": 12137}
{"project": "qemu", "commit_id": "3468b59e18b179bc63c7ce934de912dfa9596122", "target": 0, "func": "size_t tcg_code_size(void)\n\n{\n\n    unsigned int i;\n\n    size_t total;\n\n\n\n    qemu_mutex_lock(&region.lock);\n\n    total = region.agg_size_full;\n\n    for (i = 0; i < n_tcg_ctxs; i++) {\n\n        const TCGContext *s = tcg_ctxs[i];\n\n        size_t size;\n\n\n\n        size = atomic_read(&s->code_gen_ptr) - s->code_gen_buffer;\n\n        g_assert(size <= s->code_gen_buffer_size);\n\n        total += size;\n\n    }\n\n    qemu_mutex_unlock(&region.lock);\n\n    return total;\n\n}\n", "idx": 12139}
{"project": "qemu", "commit_id": "703e0e89c669a70bbd6bf33c5e75f910d8d8cca3", "target": 1, "func": "static abi_ulong setup_arg_pages(abi_ulong p, struct linux_binprm *bprm,\n\n                                 struct image_info *info)\n\n{\n\n    abi_ulong stack_base, size, error;\n\n    int i;\n\n\n\n    /* Create enough stack to hold everything.  If we don't use\n\n     * it for args, we'll use it for something else...\n\n     */\n\n    size = x86_stack_size;\n\n    if (size < MAX_ARG_PAGES*TARGET_PAGE_SIZE)\n\n        size = MAX_ARG_PAGES*TARGET_PAGE_SIZE;\n\n    error = target_mmap(0,\n\n                        size + qemu_host_page_size,\n\n                        PROT_READ | PROT_WRITE,\n\n                        MAP_PRIVATE | MAP_ANONYMOUS,\n\n                        -1, 0);\n\n    if (error == -1) {\n\n        perror(\"stk mmap\");\n\n        exit(-1);\n\n    }\n\n    /* we reserve one extra page at the top of the stack as guard */\n\n    target_mprotect(error + size, qemu_host_page_size, PROT_NONE);\n\n\n\n    stack_base = error + size - MAX_ARG_PAGES*TARGET_PAGE_SIZE;\n\n    p += stack_base;\n\n\n\n    for (i = 0 ; i < MAX_ARG_PAGES ; i++) {\n\n\tif (bprm->page[i]) {\n\n\t    info->rss++;\n\n            /* FIXME - check return value of memcpy_to_target() for failure */\n\n\t    memcpy_to_target(stack_base, bprm->page[i], TARGET_PAGE_SIZE);\n\n\t    free(bprm->page[i]);\n\n\t}\n\n        stack_base += TARGET_PAGE_SIZE;\n\n    }\n\n    return p;\n\n}\n", "idx": 12166}
{"project": "qemu", "commit_id": "56c119e52ca229869912b22a5bec283487b0cf9b", "target": 1, "func": "void xen_map_cache_init(void)\n\n{\n\n    unsigned long size;\n\n    struct rlimit rlimit_as;\n\n\n\n    mapcache = g_malloc0(sizeof (MapCache));\n\n\n\n    QTAILQ_INIT(&mapcache->locked_entries);\n\n    mapcache->last_address_index = -1;\n\n\n\n    getrlimit(RLIMIT_AS, &rlimit_as);\n\n    if (rlimit_as.rlim_max < MCACHE_MAX_SIZE) {\n\n        rlimit_as.rlim_cur = rlimit_as.rlim_max;\n\n    } else {\n\n        rlimit_as.rlim_cur = MCACHE_MAX_SIZE;\n\n    }\n\n\n\n    setrlimit(RLIMIT_AS, &rlimit_as);\n\n    mapcache->max_mcache_size = rlimit_as.rlim_cur;\n\n\n\n    mapcache->nr_buckets =\n\n        (((mapcache->max_mcache_size >> XC_PAGE_SHIFT) +\n\n          (1UL << (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT)) - 1) >>\n\n         (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT));\n\n\n\n    size = mapcache->nr_buckets * sizeof (MapCacheEntry);\n\n    size = (size + XC_PAGE_SIZE - 1) & ~(XC_PAGE_SIZE - 1);\n\n    DPRINTF(\"%s, nr_buckets = %lx size %lu\\n\", __func__,\n\n            mapcache->nr_buckets, size);\n\n    mapcache->entry = g_malloc0(size);\n\n}\n", "idx": 12194}
{"project": "qemu", "commit_id": "38f3ef574b48afc507c6f636ae4393fd36bda072", "target": 1, "func": "static BlockDriver *bdrv_probe_all(const uint8_t *buf, int buf_size,\n\n                                   const char *filename)\n\n{\n\n    int score_max = 0, score;\n\n    BlockDriver *drv = NULL, *d;\n\n\n\n    QLIST_FOREACH(d, &bdrv_drivers, list) {\n\n        if (d->bdrv_probe) {\n\n            score = d->bdrv_probe(buf, buf_size, filename);\n\n            if (score > score_max) {\n\n                score_max = score;\n\n                drv = d;\n\n            }\n\n        }\n\n    }\n\n\n\n    return drv;\n\n}\n", "idx": 12203}
{"project": "qemu", "commit_id": "2ecea9b8de5cd74df314541b87f712ae77f862ec", "target": 1, "func": "static void do_change(const char *device, const char *target)\n\n{\n\n    if (strcmp(device, \"vnc\") == 0) {\n\n\tdo_change_vnc(target);\n\n    } else {\n\n\tdo_change_block(device, target);\n\n    }\n\n}\n", "idx": 12211}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_unrealize(DeviceState *dev, Error **errp)\n\n{\n\n    rc4030State *s = RC4030(dev);\n\n    int i;\n\n\n\n    timer_free(s->periodic_timer);\n\n\n\n    address_space_destroy(&s->dma_as);\n\n    object_unparent(OBJECT(&s->dma_tt));\n\n    object_unparent(OBJECT(&s->dma_tt_alias));\n\n    object_unparent(OBJECT(&s->dma_mr));\n\n    for (i = 0; i < MAX_TL_ENTRIES; ++i) {\n\n        memory_region_del_subregion(&s->dma_mr, &s->dma_mrs[i]);\n\n        object_unparent(OBJECT(&s->dma_mrs[i]));\n\n    }\n\n}\n", "idx": 12225}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_fop_dew_0e(DisasContext *ctx, uint32_t insn,\n\n                                   const DisasInsn *di)\n\n{\n\n    unsigned rt = extract32(insn, 0, 5);\n\n    unsigned ra = assemble_ra64(insn);\n\n    return do_fop_dew(ctx, rt, ra, di->f_dew);\n\n}\n", "idx": 12259}
{"project": "qemu", "commit_id": "5a3165263ae6782a7fe712a0a0c29c17468b9b68", "target": 0, "func": "static void check_watchpoint(int offset, int len_mask, int flags)\n\n{\n\n    CPUArchState *env = cpu_single_env;\n\n    target_ulong pc, cs_base;\n\n    TranslationBlock *tb;\n\n    target_ulong vaddr;\n\n    CPUWatchpoint *wp;\n\n    int cpu_flags;\n\n\n\n    if (env->watchpoint_hit) {\n\n        /* We re-entered the check after replacing the TB. Now raise\n\n         * the debug interrupt so that is will trigger after the\n\n         * current instruction. */\n\n        cpu_interrupt(env, CPU_INTERRUPT_DEBUG);\n\n        return;\n\n    }\n\n    vaddr = (env->mem_io_vaddr & TARGET_PAGE_MASK) + offset;\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if ((vaddr == (wp->vaddr & len_mask) ||\n\n             (vaddr & wp->len_mask) == wp->vaddr) && (wp->flags & flags)) {\n\n            wp->flags |= BP_WATCHPOINT_HIT;\n\n            if (!env->watchpoint_hit) {\n\n                env->watchpoint_hit = wp;\n\n                tb = tb_find_pc(env->mem_io_pc);\n\n                if (!tb) {\n\n                    cpu_abort(env, \"check_watchpoint: could not find TB for \"\n\n                              \"pc=%p\", (void *)env->mem_io_pc);\n\n                }\n\n                cpu_restore_state(tb, env, env->mem_io_pc);\n\n                tb_phys_invalidate(tb, -1);\n\n                if (wp->flags & BP_STOP_BEFORE_ACCESS) {\n\n                    env->exception_index = EXCP_DEBUG;\n\n                    cpu_loop_exit(env);\n\n                } else {\n\n                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);\n\n                    tb_gen_code(env, pc, cs_base, cpu_flags, 1);\n\n                    cpu_resume_from_signal(env, NULL);\n\n                }\n\n            }\n\n        } else {\n\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n\n        }\n\n    }\n\n}\n", "idx": 12298}
{"project": "qemu", "commit_id": "6502a14734e71b2f6dd079b0a1e546e6aa2d2f8d", "target": 0, "func": "BalloonInfo *qmp_query_balloon(Error **errp)\n\n{\n\n    BalloonInfo *info;\n\n\n\n    if (kvm_enabled() && !kvm_has_sync_mmu()) {\n\n        error_set(errp, QERR_KVM_MISSING_CAP, \"synchronous MMU\", \"balloon\");\n\n        return NULL;\n\n    }\n\n\n\n    info = g_malloc0(sizeof(*info));\n\n\n\n    if (qemu_balloon_status(info) == 0) {\n\n        error_set(errp, QERR_DEVICE_NOT_ACTIVE, \"balloon\");\n\n        qapi_free_BalloonInfo(info);\n\n        return NULL;\n\n    }\n\n\n\n    return info;\n\n}\n", "idx": 12308}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_full_correct(void)\n\n{\n\n    const char *str = \"123\";\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n}\n", "idx": 12325}
{"project": "qemu", "commit_id": "83e6813a93e38976391b8c382c3375e3e188df3e", "target": 0, "func": "static void arm_cpu_register_types(void)\n\n{\n\n    int i;\n\n\n\n    type_register_static(&arm_cpu_type_info);\n\n    for (i = 0; i < ARRAY_SIZE(arm_cpus); i++) {\n\n        cpu_register(&arm_cpus[i]);\n\n    }\n\n}\n", "idx": 12373}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gpio_write(void *opaque, target_phys_addr_t addr, uint64_t value,\n\n                       unsigned size)\n\n{\n\n    struct gpio_state_t *s = opaque;\n\n    D(printf(\"%s %x=%x\\n\", __func__, addr, (unsigned)value));\n\n\n\n    addr >>= 2;\n\n    switch (addr)\n\n    {\n\n        case RW_PA_DOUT:\n\n            /* Decode nand pins.  */\n\n            s->nand->ale = !!(value & (1 << 6));\n\n            s->nand->cle = !!(value & (1 << 5));\n\n            s->nand->ce  = !!(value & (1 << 4));\n\n\n\n            s->regs[addr] = value;\n\n            break;\n\n\n\n        case RW_PD_DOUT:\n\n            /* Temp sensor clk.  */\n\n            if ((s->regs[addr] ^ value) & 2)\n\n                tempsensor_clkedge(&s->tempsensor, !!(value & 2),\n\n                                   !!(value & 16));\n\n            s->regs[addr] = value;\n\n            break;\n\n\n\n        default:\n\n            s->regs[addr] = value;\n\n            break;\n\n    }\n\n}\n", "idx": 12375}
{"project": "qemu", "commit_id": "b8e9fc0625c49404d63b4391f6dc5cf27be8b45b", "target": 0, "func": "static int get_physical_address_code(CPUState *env,\n\n                                     target_phys_addr_t *physical, int *prot,\n\n                                     target_ulong address, int mmu_idx)\n\n{\n\n    unsigned int i;\n\n    uint64_t context;\n\n\n\n    int is_user = (mmu_idx == MMU_USER_IDX ||\n\n                   mmu_idx == MMU_USER_SECONDARY_IDX);\n\n\n\n    if ((env->lsu & IMMU_E) == 0 || (env->pstate & PS_RED) != 0) {\n\n        /* IMMU disabled */\n\n        *physical = ultrasparc_truncate_physical(address);\n\n        *prot = PAGE_EXEC;\n\n        return 0;\n\n    }\n\n\n\n    if (env->tl == 0) {\n\n        /* PRIMARY context */\n\n        context = env->dmmu.mmu_primary_context & 0x1fff;\n\n    } else {\n\n        /* NUCLEUS context */\n\n        context = 0;\n\n    }\n\n\n\n    for (i = 0; i < 64; i++) {\n\n        // ctx match, vaddr match, valid?\n\n        if (ultrasparc_tag_match(&env->itlb[i],\n\n                                 address, context, physical)) {\n\n            // access ok?\n\n            if ((env->itlb[i].tte & 0x4) && is_user) {\n\n                if (env->immu.sfsr) /* Fault status register */\n\n                    env->immu.sfsr = 2; /* overflow (not read before\n\n                                             another fault) */\n\n                env->immu.sfsr |= (is_user << 3) | 1;\n\n                env->exception_index = TT_TFAULT;\n\n#ifdef DEBUG_MMU\n\n                printf(\"TFAULT at 0x%\" PRIx64 \"\\n\", address);\n\n#endif\n\n                return 1;\n\n            }\n\n            *prot = PAGE_EXEC;\n\n            TTE_SET_USED(env->itlb[i].tte);\n\n            return 0;\n\n        }\n\n    }\n\n#ifdef DEBUG_MMU\n\n    printf(\"TMISS at 0x%\" PRIx64 \"\\n\", address);\n\n#endif\n\n    /* Context is stored in DMMU (dmmuregs[1]) also for IMMU */\n\n    env->immu.tag_access = (address & ~0x1fffULL) | context;\n\n    env->exception_index = TT_TMISS;\n\n    return 1;\n\n}\n", "idx": 12386}
{"project": "FFmpeg", "commit_id": "5e600185453e1a0ded70a59701f60a0022a88e42", "target": 0, "func": "int avfilter_parse_graph(AVFilterGraph *graph, const char *filters,\n\n                         AVFilterInOut *openLinks, AVClass *log_ctx)\n\n{\n\n    int index = 0;\n\n    char chr = 0;\n\n    int pad = 0;\n\n\n\n    AVFilterInOut *currInputs = NULL;\n\n\n\n    do {\n\n        AVFilterContext *filter;\n\n        filters += consume_whitespace(filters);\n\n\n\n        pad = parse_inputs(&filters, &currInputs, &openLinks, log_ctx);\n\n\n\n        if(pad < 0)\n\n            goto fail;\n\n\n\n        if(!(filter = parse_filter(&filters, graph, index, log_ctx)))\n\n            goto fail;\n\n\n\n        if(filter->input_count == 1 && !currInputs && !index) {\n\n            // First input can be ommitted if it is \"[in]\"\n\n            const char *tmp = \"[in]\";\n\n            pad = parse_inputs(&tmp, &currInputs, &openLinks, log_ctx);\n\n            if(pad < 0)\n\n                goto fail;\n\n        }\n\n\n\n        if(link_filter_inouts(filter, &currInputs, &openLinks, log_ctx) < 0)\n\n            goto fail;\n\n\n\n        pad = parse_outputs(&filters, &currInputs, &openLinks, log_ctx);\n\n\n\n        if(pad < 0)\n\n            goto fail;\n\n\n\n        filters += consume_whitespace(filters);\n\n        chr = *filters++;\n\n\n\n        if(chr == ';' && currInputs) {\n\n            av_log(log_ctx, AV_LOG_ERROR,\n\n                   \"Could not find a output to link when parsing \\\"%s\\\"\\n\",\n\n                   filters - 1);\n\n            goto fail;\n\n        }\n\n        index++;\n\n    } while(chr == ',' || chr == ';');\n\n\n\n    if(openLinks && !strcmp(openLinks->name, \"out\") && currInputs) {\n\n        // Last output can be ommitted if it is \"[out]\"\n\n        const char *tmp = \"[out]\";\n\n        if(parse_outputs(&tmp, &currInputs, &openLinks, log_ctx) < 0)\n\n            goto fail;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail:\n\n    avfilter_destroy_graph(graph);\n\n    free_inout(openLinks);\n\n    free_inout(currInputs);\n\n    return -1;\n\n}\n", "idx": 12399}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int qtrle_encode_init(AVCodecContext *avctx)\n\n{\n\n    QtrleEncContext *s = avctx->priv_data;\n\n\n\n    if (av_image_check_size(avctx->width, avctx->height, 0, avctx) < 0) {\n\n        return -1;\n\n    }\n\n    s->avctx=avctx;\n\n\n\n    switch (avctx->pix_fmt) {\n\n    case AV_PIX_FMT_RGB555BE:\n\n        s->pixel_size = 2;\n\n        break;\n\n    case AV_PIX_FMT_RGB24:\n\n        s->pixel_size = 3;\n\n        break;\n\n    case AV_PIX_FMT_ARGB:\n\n        s->pixel_size = 4;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported colorspace.\\n\");\n\n        break;\n\n    }\n\n    avctx->bits_per_coded_sample = s->pixel_size*8;\n\n\n\n    s->rlecode_table = av_mallocz(s->avctx->width);\n\n    s->skip_table    = av_mallocz(s->avctx->width);\n\n    s->length_table  = av_mallocz((s->avctx->width + 1)*sizeof(int));\n\n    if (!s->skip_table || !s->length_table || !s->rlecode_table) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error allocating memory.\\n\");\n\n        return -1;\n\n    }\n\n    if (avpicture_alloc(&s->previous_frame, avctx->pix_fmt, avctx->width, avctx->height) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error allocating picture\\n\");\n\n        return -1;\n\n    }\n\n\n\n    s->max_buf_size = s->avctx->width*s->avctx->height*s->pixel_size*2 /* image base material */\n\n                      + 15                                           /* header + footer */\n\n                      + s->avctx->height*2                           /* skip code+rle end */\n\n                      + s->avctx->width/MAX_RLE_BULK + 1             /* rle codes */;\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame) {\n\n        qtrle_encode_end(avctx);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12418}
{"project": "FFmpeg", "commit_id": "88db5551cf1ced4ea3e5e8bd5b684d2dc74b1ed2", "target": 0, "func": "static inline void check_for_slice(AVSContext *h) {\n\n    GetBitContext *gb = &h->s.gb;\n\n    int align;\n\n\n\n    if(h->mbx)\n\n        return;\n\n    align = (-get_bits_count(gb)) & 7;\n\n    if((show_bits_long(gb,24+align) & 0xFFFFFF) == 0x000001) {\n\n        skip_bits_long(gb,24+align);\n\n        h->stc = get_bits(gb,8);\n\n        decode_slice_header(h,gb);\n\n    }\n\n}\n", "idx": 12419}
{"project": "qemu", "commit_id": "3f66aa9c07d6392757f9d7b83849c7f791981725", "target": 1, "func": "ISADevice *isa_create_simple(const char *name)\n\n{\n\n    ISADevice *dev;\n\n\n\n    dev = isa_create(name);\n\n    if (qdev_init(&dev->qdev) != 0) {\n\n        return NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 12426}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "envlist_create(void)\n\n{\n\n\tenvlist_t *envlist;\n\n\n\n\tif ((envlist = malloc(sizeof (*envlist))) == NULL)\n\n\t\treturn (NULL);\n\n\n\n\tLIST_INIT(&envlist->el_entries);\n\n\tenvlist->el_count = 0;\n\n\n\n\treturn (envlist);\n\n}\n", "idx": 12440}
{"project": "qemu", "commit_id": "0d82d0e8b98cf0ea03a45f8542d835ebd3a84cd3", "target": 0, "func": "void qemu_fopen_ops_buffered(MigrationState *migration_state)\n\n{\n\n    QEMUFileBuffered *s;\n\n\n\n    s = g_malloc0(sizeof(*s));\n\n\n\n    s->migration_state = migration_state;\n\n    s->xfer_limit = migration_state->bandwidth_limit / 10;\n\n    s->migration_state->complete = false;\n\n\n\n    s->file = qemu_fopen_ops(s, &buffered_file_ops);\n\n\n\n    migration_state->file = s->file;\n\n\n\n    qemu_thread_create(&s->thread, buffered_file_thread, s,\n\n                       QEMU_THREAD_DETACHED);\n\n}\n", "idx": 12446}
{"project": "qemu", "commit_id": "943cec86d0864464ab29b42940c49d1ccbe8d268", "target": 0, "func": "static int nbd_negotiate_handle_export_name(NBDClient *client, uint32_t length)\n\n{\n\n    int rc = -EINVAL;\n\n    char name[256];\n\n\n\n    /* Client sends:\n\n        [20 ..  xx]   export name (length bytes)\n\n     */\n\n    TRACE(\"Checking length\");\n\n    if (length > 255) {\n\n        LOG(\"Bad length received\");\n\n        goto fail;\n\n    }\n\n    if (nbd_negotiate_read(client->ioc, name, length) != length) {\n\n        LOG(\"read failed\");\n\n        goto fail;\n\n    }\n\n    name[length] = '\\0';\n\n\n\n    TRACE(\"Client requested export '%s'\", name);\n\n\n\n    client->exp = nbd_export_find(name);\n\n    if (!client->exp) {\n\n        LOG(\"export not found\");\n\n        goto fail;\n\n    }\n\n\n\n    QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);\n\n    nbd_export_get(client->exp);\n\n    rc = 0;\n\nfail:\n\n    return rc;\n\n}\n", "idx": 12485}
{"project": "FFmpeg", "commit_id": "41fe750f4b130f08f41ce0e5126046315c891cae", "target": 1, "func": "void av_bitstream_filter_close(AVBitStreamFilterContext *bsfc){\n\n\n\n    if(bsfc->filter->close)\n\n        bsfc->filter->close(bsfc);\n\n    av_freep(&bsfc->priv_data);\n\n    av_parser_close(bsfc->parser);\n\n    av_free(bsfc);\n\n}", "idx": 12518}
{"project": "FFmpeg", "commit_id": "ae413a48e64274b9740c3b27398fea92108a0f0e", "target": 1, "func": "static void mov_text_cleanup_ftab(MovTextContext *m)\n\n{\n\n    int i;\n\n    for(i = 0; i < m->count_f; i++) {\n\n        av_freep(&m->ftab[i]->font);\n\n        av_freep(&m->ftab[i]);\n\n    }\n\n    av_freep(&m->ftab);\n\n}\n", "idx": 12520}
{"project": "qemu", "commit_id": "78dbbbe4dff95369c63bf77ee0df23371e1d6602", "target": 1, "func": "static inline bool extended_addresses_enabled(CPUARMState *env)\n\n{\n\n    return arm_feature(env, ARM_FEATURE_LPAE)\n\n        && (env->cp15.c2_control & (1 << 31));\n\n}\n", "idx": 12522}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "uint64_t migrate_max_downtime(void)\n\n{\n\n    return max_downtime;\n\n}\n", "idx": 12567}
{"project": "qemu", "commit_id": "80f5ce758ac277e76c016dd7c0b246e40d4fca2d", "target": 0, "func": "static void fill_note(struct memelfnote *note, const char *name, int type,\n\n                      unsigned int sz, void *data)\n\n{\n\n    unsigned int namesz;\n\n\n\n    namesz = strlen(name) + 1;\n\n    note->name = name;\n\n    note->namesz = namesz;\n\n    note->namesz_rounded = roundup(namesz, sizeof (int32_t));\n\n    note->type = type;\n\n    note->datasz = roundup(sz, sizeof (int32_t));;\n\n    note->data = data;\n\n\n\n    /*\n\n     * We calculate rounded up note size here as specified by\n\n     * ELF document.\n\n     */\n\n    note->notesz = sizeof (struct elf_note) +\n\n        note->namesz_rounded + note->datasz;\n\n}\n", "idx": 12628}
{"project": "qemu", "commit_id": "de08c606f9ddafe647b6843e2b10a6d6030b0fc0", "target": 0, "func": "int bdrv_snapshot_goto(BlockDriverState *bs,\n\n                       const char *snapshot_id)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int ret, open_ret;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (drv->bdrv_snapshot_goto)\n\n        return drv->bdrv_snapshot_goto(bs, snapshot_id);\n\n\n\n    if (bs->file) {\n\n        drv->bdrv_close(bs);\n\n        ret = bdrv_snapshot_goto(bs->file, snapshot_id);\n\n        open_ret = drv->bdrv_open(bs, NULL, bs->open_flags);\n\n        if (open_ret < 0) {\n\n            bdrv_delete(bs->file);\n\n            bs->drv = NULL;\n\n            return open_ret;\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    return -ENOTSUP;\n\n}\n", "idx": 12648}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_update_cpuid(CPUState *env)\n\n{\n\n    int critical_features_mask, features, ext_features, ext_features_mask;\n\n    uint32_t eax, ebx, ecx, edx;\n\n\n\n    /* the following features are kept identical on the host and\n\n       target cpus because they are important for user code. Strictly\n\n       speaking, only SSE really matters because the OS must support\n\n       it if the user code uses it. */\n\n    critical_features_mask =\n\n        CPUID_CMOV | CPUID_CX8 |\n\n        CPUID_FXSR | CPUID_MMX | CPUID_SSE |\n\n        CPUID_SSE2 | CPUID_SEP;\n\n    ext_features_mask = CPUID_EXT_SSE3 | CPUID_EXT_MONITOR;\n\n    if (!is_cpuid_supported()) {\n\n        features = 0;\n\n        ext_features = 0;\n\n    } else {\n\n        cpuid(1, eax, ebx, ecx, edx);\n\n        features = edx;\n\n        ext_features = ecx;\n\n    }\n\n#ifdef __x86_64__\n\n    /* NOTE: on x86_64 CPUs, SYSENTER is not supported in\n\n       compatibility mode, so in order to have the best performances\n\n       it is better not to use it */\n\n    features &= ~CPUID_SEP;\n\n#endif\n\n    env->cpuid_features = (env->cpuid_features & ~critical_features_mask) |\n\n        (features & critical_features_mask);\n\n    env->cpuid_ext_features = (env->cpuid_ext_features & ~ext_features_mask) |\n\n        (ext_features & ext_features_mask);\n\n    /* XXX: we could update more of the target CPUID state so that the\n\n       non accelerated code sees exactly the same CPU features as the\n\n       accelerated code */\n\n}\n", "idx": 12666}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static GenericList *qapi_dealloc_next_list(Visitor *v, GenericList **listp,\n\n                                           size_t size)\n\n{\n\n    GenericList *list = *listp;\n\n    QapiDeallocVisitor *qov = to_qov(v);\n\n    StackEntry *e = QTAILQ_FIRST(&qov->stack);\n\n\n\n    if (e && e->is_list_head) {\n\n        e->is_list_head = false;\n\n        return list;\n\n    }\n\n\n\n    if (list) {\n\n        list = list->next;\n\n        g_free(*listp);\n\n        return list;\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 12671}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qbool_destroy_obj(QObject *obj)\n\n{\n\n    assert(obj != NULL);\n\n    g_free(qobject_to_qbool(obj));\n\n}\n", "idx": 12674}
{"project": "FFmpeg", "commit_id": "7b6883898ff9000b9a9e71fc1fb6e842ec850a79", "target": 0, "func": "static void frame_thread_free(AVCodecContext *avctx, int thread_count)\n\n{\n\n    FrameThreadContext *fctx = avctx->thread_opaque;\n\n    AVCodec *codec = avctx->codec;\n\n    int i;\n\n\n\n    park_frame_worker_threads(fctx, thread_count);\n\n\n\n    if (fctx->prev_thread)\n\n        update_context_from_thread(fctx->threads->avctx, fctx->prev_thread->avctx, 0);\n\n\n\n    fctx->die = 1;\n\n\n\n    for (i = 0; i < thread_count; i++) {\n\n        PerThreadContext *p = &fctx->threads[i];\n\n\n\n        pthread_mutex_lock(&p->mutex);\n\n        pthread_cond_signal(&p->input_cond);\n\n        pthread_mutex_unlock(&p->mutex);\n\n\n\n        pthread_join(p->thread, NULL);\n\n\n\n        if (codec->close)\n\n            codec->close(p->avctx);\n\n\n\n        avctx->codec = NULL;\n\n\n\n        release_delayed_buffers(p);\n\n    }\n\n\n\n    for (i = 0; i < thread_count; i++) {\n\n        PerThreadContext *p = &fctx->threads[i];\n\n\n\n        avcodec_default_free_buffers(p->avctx);\n\n\n\n        pthread_mutex_destroy(&p->mutex);\n\n        pthread_mutex_destroy(&p->progress_mutex);\n\n        pthread_cond_destroy(&p->input_cond);\n\n        pthread_cond_destroy(&p->progress_cond);\n\n        pthread_cond_destroy(&p->output_cond);\n\n        av_freep(&p->avpkt.data);\n\n\n\n        if (i)\n\n            av_freep(&p->avctx->priv_data);\n\n\n\n        av_freep(&p->avctx);\n\n    }\n\n\n\n    av_freep(&fctx->threads);\n\n    pthread_mutex_destroy(&fctx->buffer_mutex);\n\n    av_freep(&avctx->thread_opaque);\n\n}\n", "idx": 12680}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static QemuOpt *qemu_opt_find(QemuOpts *opts, const char *name)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    TAILQ_FOREACH(opt, &opts->head, next) {\n\n        if (strcmp(opt->name, name) != 0)\n\n            continue;\n\n        return opt;\n\n    }\n\n    return NULL;\n\n}\n", "idx": 12685}
{"project": "qemu", "commit_id": "a4d2d1a063897b859b7f25e414b229370b679bc8", "target": 0, "func": "uint64_t helper_cmptun (uint64_t a, uint64_t b)\n\n{\n\n    float64 fa, fb;\n\n\n\n    fa = t_to_float64(a);\n\n    fb = t_to_float64(b);\n\n\n\n    if (float64_is_quiet_nan(fa) || float64_is_quiet_nan(fb))\n\n        return 0x4000000000000000ULL;\n\n    else\n\n        return 0;\n\n}\n", "idx": 12702}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "Aml *aml_arg(int pos)\n\n{\n\n    Aml *var;\n\n    uint8_t op = 0x68 /* ARG0 op */ + pos;\n\n\n\n    assert(pos <= 6);\n\n    var = aml_opcode(op);\n\n    return var;\n\n}\n", "idx": 12727}
{"project": "qemu", "commit_id": "c7cacb3e7a2e9fdf929c993b98268e4179147cbb", "target": 0, "func": "static int qemu_rbd_set_conf(rados_t cluster, const char *conf,\n\n                             bool only_read_conf_file,\n\n                             Error **errp)\n\n{\n\n    char *p, *buf;\n\n    char *name;\n\n    char *value;\n\n    Error *local_err = NULL;\n\n    int ret = 0;\n\n\n\n    buf = g_strdup(conf);\n\n    p = buf;\n\n\n\n    while (p) {\n\n        name = qemu_rbd_next_tok(RBD_MAX_CONF_NAME_SIZE, p,\n\n                                 '=', \"conf option name\", &p, &local_err);\n\n        if (local_err) {\n\n            break;\n\n        }\n\n        qemu_rbd_unescape(name);\n\n\n\n        if (!p) {\n\n            error_setg(errp, \"conf option %s has no value\", name);\n\n            ret = -EINVAL;\n\n            break;\n\n        }\n\n\n\n        value = qemu_rbd_next_tok(RBD_MAX_CONF_VAL_SIZE, p,\n\n                                  ':', \"conf option value\", &p, &local_err);\n\n        if (local_err) {\n\n            break;\n\n        }\n\n        qemu_rbd_unescape(value);\n\n\n\n        if (strcmp(name, \"conf\") == 0) {\n\n            /* read the conf file alone, so it doesn't override more\n\n               specific settings for a particular device */\n\n            if (only_read_conf_file) {\n\n                ret = rados_conf_read_file(cluster, value);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"error reading conf file %s\",\n\n                                     value);\n\n                    break;\n\n                }\n\n            }\n\n        } else if (strcmp(name, \"id\") == 0) {\n\n            /* ignore, this is parsed by qemu_rbd_parse_clientname() */\n\n        } else if (!only_read_conf_file) {\n\n            ret = rados_conf_set(cluster, name, value);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"invalid conf option %s\", name);\n\n                ret = -EINVAL;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n    }\n\n    g_free(buf);\n\n    return ret;\n\n}\n", "idx": 12765}
{"project": "qemu", "commit_id": "e508a92b621c7160122e99d3754e568f2b8e255e", "target": 0, "func": "static int arm946_prbs_read(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                            uint64_t *value)\n\n{\n\n    if (ri->crm >= 8) {\n\n        return EXCP_UDEF;\n\n    }\n\n    *value = env->cp15.c6_region[ri->crm];\n\n    return 0;\n\n}\n", "idx": 12778}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void lsi_do_dma(LSIState *s, int out)\n\n{\n\n    uint32_t count, id;\n\n    target_phys_addr_t addr;\n\n    SCSIDevice *dev;\n\n\n\n    assert(s->current);\n\n    if (!s->current->dma_len) {\n\n        /* Wait until data is available.  */\n\n        DPRINTF(\"DMA no data available\\n\");\n\n        return;\n\n    }\n\n\n\n    id = (s->current->tag >> 8) & 0xf;\n\n    dev = s->bus.devs[id];\n\n    if (!dev) {\n\n        lsi_bad_selection(s, id);\n\n        return;\n\n    }\n\n\n\n    count = s->dbc;\n\n    if (count > s->current->dma_len)\n\n        count = s->current->dma_len;\n\n\n\n    addr = s->dnad;\n\n    /* both 40 and Table Indirect 64-bit DMAs store upper bits in dnad64 */\n\n    if (lsi_dma_40bit(s) || lsi_dma_ti64bit(s))\n\n        addr |= ((uint64_t)s->dnad64 << 32);\n\n    else if (s->dbms)\n\n        addr |= ((uint64_t)s->dbms << 32);\n\n    else if (s->sbms)\n\n        addr |= ((uint64_t)s->sbms << 32);\n\n\n\n    DPRINTF(\"DMA addr=0x\" TARGET_FMT_plx \" len=%d\\n\", addr, count);\n\n    s->csbc += count;\n\n    s->dnad += count;\n\n    s->dbc -= count;\n\n\n\n    if (s->current->dma_buf == NULL) {\n\n        s->current->dma_buf = dev->info->get_buf(dev, s->current->tag);\n\n    }\n\n\n\n    /* ??? Set SFBR to first data byte.  */\n\n    if (out) {\n\n        cpu_physical_memory_read(addr, s->current->dma_buf, count);\n\n    } else {\n\n        cpu_physical_memory_write(addr, s->current->dma_buf, count);\n\n    }\n\n    s->current->dma_len -= count;\n\n    if (s->current->dma_len == 0) {\n\n        s->current->dma_buf = NULL;\n\n        if (out) {\n\n            /* Write the data.  */\n\n            dev->info->write_data(dev, s->current->tag);\n\n        } else {\n\n            /* Request any remaining data.  */\n\n            dev->info->read_data(dev, s->current->tag);\n\n        }\n\n    } else {\n\n        s->current->dma_buf += count;\n\n        lsi_resume_script(s);\n\n    }\n\n}\n", "idx": 12796}
{"project": "qemu", "commit_id": "eb7b5c35117bfb90dcfa881a0e3b23368c73fba6", "target": 1, "func": "static void iothread_instance_finalize(Object *obj)\n\n{\n\n    IOThread *iothread = IOTHREAD(obj);\n\n\n\n    iothread_stop(obj, NULL);\n\n    qemu_cond_destroy(&iothread->init_done_cond);\n\n    qemu_mutex_destroy(&iothread->init_done_lock);\n\n\n\n\n    aio_context_unref(iothread->ctx);\n", "idx": 12801}
{"project": "qemu", "commit_id": "e3cffe6fad29e07d401eabb913a6d88501d5c143", "target": 1, "func": "static void gen_isync(DisasContext *ctx)\n\n{\n\n    /*\n\n     * We need to check for a pending TLB flush. This can only happen in\n\n     * kernel mode however so check MSR_PR\n\n     */\n\n    if (!ctx->pr) {\n\n        gen_check_tlb_flush(ctx);\n\n    }\n\n    gen_stop_exception(ctx);\n\n}\n", "idx": 12817}
{"project": "qemu", "commit_id": "e2a176dfda32f5cf80703c2921a19fe75850c38c", "target": 0, "func": "static uint32_t taihu_cpld_readb (void *opaque, hwaddr addr)\n\n{\n\n    taihu_cpld_t *cpld;\n\n    uint32_t ret;\n\n\n\n    cpld = opaque;\n\n    switch (addr) {\n\n    case 0x0:\n\n        ret = cpld->reg0;\n\n        break;\n\n    case 0x1:\n\n        ret = cpld->reg1;\n\n        break;\n\n    default:\n\n        ret = 0;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 12829}
{"project": "qemu", "commit_id": "6a2b3d89fa49ec060db646d196864a8fd15c10cf", "target": 0, "func": "static void spin_reset(void *opaque)\n\n{\n\n    SpinState *s = opaque;\n\n    int i;\n\n\n\n    for (i = 0; i < MAX_CPUS; i++) {\n\n        SpinInfo *info = &s->spin[i];\n\n\n\n        info->pir = i;\n\n        info->r3 = i;\n\n        info->addr = 1;\n\n    }\n\n}\n", "idx": 12854}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parser_context_pop_token(JSONParserContext *ctxt)\n\n{\n\n    qobject_decref(ctxt->current);\n\n    assert(!g_queue_is_empty(ctxt->buf));\n\n    ctxt->current = g_queue_pop_head(ctxt->buf);\n\n    return ctxt->current;\n\n}\n", "idx": 12869}
{"project": "qemu", "commit_id": "d26d9e14c15837eba2b7447e8d15230bab8e0940", "target": 0, "func": "static void pc_fw_cfg_guest_info(PcGuestInfo *guest_info)\n\n{\n\n    PcRomPciInfo *info;\n\n    if (!guest_info->has_pci_info) {\n\n        return;\n\n    }\n\n\n\n    info = g_malloc(sizeof *info);\n\n    info->w32_min = cpu_to_le64(guest_info->pci_info.w32.begin);\n\n    info->w32_max = cpu_to_le64(guest_info->pci_info.w32.end);\n\n    info->w64_min = cpu_to_le64(guest_info->pci_info.w64.begin);\n\n    info->w64_max = cpu_to_le64(guest_info->pci_info.w64.end);\n\n    /* Pass PCI hole info to guest via a side channel.\n\n     * Required so guest PCI enumeration does the right thing. */\n\n    fw_cfg_add_file(guest_info->fw_cfg, \"etc/pci-info\", info, sizeof *info);\n\n}\n", "idx": 12871}
{"project": "FFmpeg", "commit_id": "041086191fc08ab162ad6117b07a5f39639d5d9d", "target": 0, "func": "static double get_video_clock(VideoState *is)\n\n{\n\n    double delta;\n\n    if (is->paused) { //FIXME timing gets messed after pause\n\n        delta = 0;\n\n    } else {\n\n        delta = (av_gettime() - is->video_current_pts_time) / 1000000.0;\n\n    }\n\n    return is->video_current_pts + delta;\n\n}\n", "idx": 12921}
{"project": "FFmpeg", "commit_id": "d8870f120ea5f46940bac63a90424ca6a6000ad9", "target": 0, "func": "static void set_downmix_coeffs(AC3DecodeContext *s)\n\n{\n\n    int i;\n\n    float cmix = gain_levels[s->center_mix_level];\n\n    float smix = gain_levels[s->surround_mix_level];\n\n\n\n    for(i=0; i<s->fbw_channels; i++) {\n\n        s->downmix_coeffs[i][0] = gain_levels[ac3_default_coeffs[s->channel_mode][i][0]];\n\n        s->downmix_coeffs[i][1] = gain_levels[ac3_default_coeffs[s->channel_mode][i][1]];\n\n    }\n\n    if(s->channel_mode > 1 && s->channel_mode & 1) {\n\n        s->downmix_coeffs[1][0] = s->downmix_coeffs[1][1] = cmix;\n\n    }\n\n    if(s->channel_mode == AC3_CHMODE_2F1R || s->channel_mode == AC3_CHMODE_3F1R) {\n\n        int nf = s->channel_mode - 2;\n\n        s->downmix_coeffs[nf][0] = s->downmix_coeffs[nf][1] = smix * LEVEL_MINUS_3DB;\n\n    }\n\n    if(s->channel_mode == AC3_CHMODE_2F2R || s->channel_mode == AC3_CHMODE_3F2R) {\n\n        int nf = s->channel_mode - 4;\n\n        s->downmix_coeffs[nf][0] = s->downmix_coeffs[nf+1][1] = smix;\n\n    }\n\n\n\n    s->downmix_coeff_sum[0] = s->downmix_coeff_sum[1] = 0.0f;\n\n    for(i=0; i<s->fbw_channels; i++) {\n\n        s->downmix_coeff_sum[0] += s->downmix_coeffs[i][0];\n\n        s->downmix_coeff_sum[1] += s->downmix_coeffs[i][1];\n\n    }\n\n}\n", "idx": 12936}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "int spapr_rtas_register(const char *name, spapr_rtas_fn fn)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < (rtas_next - rtas_table); i++) {\n\n        if (strcmp(name, rtas_table[i].name) == 0) {\n\n            fprintf(stderr, \"RTAS call \\\"%s\\\" registered twice\\n\", name);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    assert(rtas_next < (rtas_table + TOKEN_MAX));\n\n\n\n    rtas_next->name = name;\n\n    rtas_next->fn = fn;\n\n\n\n    return (rtas_next++ - rtas_table) + TOKEN_BASE;\n\n}\n", "idx": 12963}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_whitespace(void)\n\n{\n\n    const char *str = \"  \\t  \";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtol(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 12966}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t nvram_readw (void *opaque, target_phys_addr_t addr)\n\n{\n\n    M48t59State *NVRAM = opaque;\n\n    uint32_t retval;\n\n\n\n    retval = m48t59_read(NVRAM, addr) << 8;\n\n    retval |= m48t59_read(NVRAM, addr + 1);\n\n    return retval;\n\n}\n", "idx": 12999}
{"project": "qemu", "commit_id": "75e347d66ab81944b5b657d17cc90ef92af3f016", "target": 1, "func": "static int enable_write_target(BDRVVVFATState *s, Error **errp)\n\n{\n\n    BlockDriver *bdrv_qcow;\n\n    QEMUOptionParameter *options;\n\n    int ret;\n\n    int size = sector2cluster(s, s->sector_count);\n\n    s->used_clusters = calloc(size, 1);\n\n\n\n    array_init(&(s->commits), sizeof(commit_t));\n\n\n\n    s->qcow_filename = g_malloc(1024);\n\n    ret = get_tmp_filename(s->qcow_filename, 1024);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"can't create temporary file\");\n\n        goto err;\n\n    }\n\n\n\n    bdrv_qcow = bdrv_find_format(\"qcow\");\n\n    options = parse_option_parameters(\"\", bdrv_qcow->create_options, NULL);\n\n    set_option_parameter_int(options, BLOCK_OPT_SIZE, s->sector_count * 512);\n\n    set_option_parameter(options, BLOCK_OPT_BACKING_FILE, \"fat:\");\n\n\n\n    ret = bdrv_create(bdrv_qcow, s->qcow_filename, options, errp);\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    s->qcow = NULL;\n\n    ret = bdrv_open(&s->qcow, s->qcow_filename, NULL, NULL,\n\n                    BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH,\n\n                    bdrv_qcow, errp);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n#ifndef _WIN32\n\n    unlink(s->qcow_filename);\n\n#endif\n\n\n\n    bdrv_set_backing_hd(s->bs, bdrv_new(\"\", &error_abort));\n\n    s->bs->backing_hd->drv = &vvfat_write_target;\n\n    s->bs->backing_hd->opaque = g_malloc(sizeof(void*));\n\n    *(void**)s->bs->backing_hd->opaque = s;\n\n\n\n    return 0;\n\n\n\nerr:\n\n    g_free(s->qcow_filename);\n\n    s->qcow_filename = NULL;\n\n    return ret;\n\n}", "idx": 13036}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static av_cold int cinepak_encode_end(AVCodecContext *avctx)\n\n{\n\n    CinepakEncContext *s = avctx->priv_data;\n\n    int x;\n\n\n\n    av_free(s->codebook_input);\n\n    av_free(s->codebook_closest);\n\n    av_free(s->strip_buf);\n\n    av_free(s->frame_buf);\n\n    av_free(s->mb);\n\n#ifdef CINEPAKENC_DEBUG\n\n    av_free(s->best_mb);\n\n#endif\n\n\n\n    for(x = 0; x < 3; x++)\n\n        av_free(s->pict_bufs[x]);\n\n\n\n    av_log(avctx, AV_LOG_INFO, \"strip coding stats: %i V1 mode, %i V4 mode, %i MC mode (%i V1 encs, %i V4 encs, %i skips)\\n\",\n\n        s->num_v1_mode, s->num_v4_mode, s->num_mc_mode, s->num_v1_encs, s->num_v4_encs, s->num_skips);\n\n\n\n    return 0;\n\n}\n", "idx": 13039}
{"project": "qemu", "commit_id": "412e0e81b17488e228b4f8451df6a4af26064bb4", "target": 0, "func": "static unsigned virtqueue_read_next_desc(VirtIODevice *vdev, VRingDesc *desc,\n\n                                         hwaddr desc_pa, unsigned int max)\n\n{\n\n    unsigned int next;\n\n\n\n    /* If this descriptor says it doesn't chain, we're done. */\n\n    if (!(desc->flags & VRING_DESC_F_NEXT)) {\n\n        return max;\n\n    }\n\n\n\n    /* Check they're not leading us off end of descriptors. */\n\n    next = desc->next;\n\n    /* Make sure compiler knows to grab that: we don't want it changing! */\n\n    smp_wmb();\n\n\n\n    if (next >= max) {\n\n        error_report(\"Desc next is %u\", next);\n\n        exit(1);\n\n    }\n\n\n\n    vring_desc_read(vdev, desc, desc_pa, next);\n\n    return next;\n\n}\n", "idx": 13046}
{"project": "qemu", "commit_id": "f8b0aa25599782eef91edc00ebf620bd14db720c", "target": 0, "func": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka,\n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUState *env)\n\n{\n\n\tstruct rt_sigframe *frame;\n\n\tabi_ulong frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n\tstruct target_sigaltstack stack;\n\n\tint i, err = 0;\n\n\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n\n            return /* 1 */;\n\n\n\n\t__put_user_error(&frame->info, (abi_ulong *)&frame->pinfo, err);\n\n\t__put_user_error(&frame->uc, (abi_ulong *)&frame->puc, err);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n\t/* Clear all the bits of the ucontext we don't use.  */\n\n\tmemset(&frame->uc, 0, offsetof(struct target_ucontext, tuc_mcontext));\n\n\n\n        memset(&stack, 0, sizeof(stack));\n\n        __put_user(target_sigaltstack_used.ss_sp, &stack.ss_sp);\n\n        __put_user(target_sigaltstack_used.ss_size, &stack.ss_size);\n\n        __put_user(sas_ss_flags(get_sp_from_cpustate(env)), &stack.ss_flags);\n\n        memcpy(&frame->uc.tuc_stack, &stack, sizeof(stack));\n\n\n\n\terr |= setup_sigcontext(&frame->uc.tuc_mcontext, /*&frame->fpstate,*/\n\n\t\t\t\tenv, set->sig[0]);\n\n        for(i = 0; i < TARGET_NSIG_WORDS; i++) {\n\n            if (__put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]))\n\n                goto end;\n\n        }\n\n\n\n\tif (err == 0)\n\n\t\terr = setup_return(env, ka, &frame->retcode, frame, usig);\n\n\n\n\tif (err == 0) {\n\n\t\t/*\n\n\t\t * For realtime signals we must also set the second and third\n\n\t\t * arguments for the signal handler.\n\n\t\t *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06\n\n\t\t */\n\n            env->regs[1] = (abi_ulong)frame->pinfo;\n\n            env->regs[2] = (abi_ulong)frame->puc;\n\n\t}\n\n\n\nend:\n\n\tunlock_user_struct(frame, frame_addr, 1);\n\n\n\n        //\treturn err;\n\n}\n", "idx": 13060}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static void RENAME(lumRangeFromJpeg)(int16_t *dst, int width)\n\n{\n\n    int i;\n\n    for (i = 0; i < width; i++)\n\n        dst[i] = (dst[i]*14071 + 33561947)>>14;\n\n}\n", "idx": 13083}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_POWER_abso (void)\n\n{\n\n    if (T0 == INT32_MIN) {\n\n        T0 = INT32_MAX;\n\n        xer_ov = 1;\n\n        xer_so = 1;\n\n    } else {\n\n        T0 = -T0;\n\n        xer_ov = 0;\n\n    }\n\n}\n", "idx": 13091}
{"project": "FFmpeg", "commit_id": "96d0494123a05fb78a0fd3f03b0b5aaefc170b1c", "target": 0, "func": "static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n\n                                    const uint8_t *src, int width,\n\n                                    int esc_count)\n\n{\n\n    int i = 0;\n\n    int count;\n\n    uint8_t zero_run = 0;\n\n    const uint8_t *start = src;\n\n    uint8_t mask1 = -(esc_count < 2);\n\n    uint8_t mask2 = -(esc_count < 3);\n\n    uint8_t *end = dst + (width - 2);\n\n\n\noutput_zeros:\n\n    if (l->zeros_rem) {\n\n        count = FFMIN(l->zeros_rem, width - i);\n\n        memset(dst, 0, count);\n\n        l->zeros_rem -= count;\n\n        dst += count;\n\n    }\n\n\n\n    while (dst < end) {\n\n        i = 0;\n\n        while (!zero_run && dst + i < end) {\n\n            i++;\n\n            zero_run =\n\n                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n\n        }\n\n        if (zero_run) {\n\n            zero_run = 0;\n\n            i += esc_count;\n\n            memcpy(dst, src, i);\n\n            dst += i;\n\n            l->zeros_rem = lag_calc_zero_run(src[i]);\n\n\n\n            src += i + 1;\n\n            goto output_zeros;\n\n        } else {\n\n            memcpy(dst, src, i);\n\n            src += i;\n\n        }\n\n    }\n\n    return  src - start;\n\n}\n", "idx": 13110}
{"project": "qemu", "commit_id": "d3532a0db02296e687711b8cdc7791924efccea0", "target": 1, "func": "static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,\n\n\t\t\t\t\t    const uint8_t * src)\n\n{\n\n    uint8_t *dst;\n\n\n\n    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);\n\n\n\n    if (BLTUNSAFE(s))\n\n        return 0;\n\n\n\n    (*s->cirrus_rop) (s, dst, src,\n\n                      s->cirrus_blt_dstpitch, 0,\n\n                      s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n                             s->cirrus_blt_height);\n\n    return 1;\n\n}\n", "idx": 13135}
{"project": "qemu", "commit_id": "225d4be7099f0cfdf5c85b4e4be1fa1e5169543c", "target": 0, "func": "void sparc_iommu_memory_rw(void *opaque, target_phys_addr_t addr,\n\n                           uint8_t *buf, int len, int is_write)\n\n{\n\n    int l;\n\n    uint32_t flags;\n\n    target_phys_addr_t page, phys_addr;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        flags = iommu_page_get_flags(opaque, page);\n\n        if (!(flags & IOPTE_VALID))\n\n            return;\n\n        phys_addr = iommu_translate_pa(opaque, addr, flags);\n\n        if (is_write) {\n\n            if (!(flags & IOPTE_WRITE))\n\n                return;\n\n            cpu_physical_memory_write(phys_addr, buf, len);\n\n        } else {\n\n            cpu_physical_memory_read(phys_addr, buf, len);\n\n        }\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n}\n", "idx": 13176}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void *qemu_try_blockalign0(BlockDriverState *bs, size_t size)\n\n{\n\n    void *mem = qemu_try_blockalign(bs, size);\n\n\n\n    if (mem) {\n\n        memset(mem, 0, size);\n\n    }\n\n\n\n    return mem;\n\n}\n", "idx": 13180}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_underflow(void)\n\n{\n\n    const char *str = \"-99999999999999999999999999999999999999999999\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err  = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, -ERANGE);\n\n    g_assert_cmpint(res, ==, -1ul);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 13182}
{"project": "FFmpeg", "commit_id": "f3296b945464b41aa067949b24dfcfeb0db9d875", "target": 1, "func": "static int get_avc_nalsize(H264Context *h, const uint8_t *buf,\n\n                           int buf_size, int *buf_index)\n\n{\n\n    int i, nalsize = 0;\n\n\n\n    if (*buf_index >= buf_size - h->nal_length_size)\n\n        return -1;\n\n\n\n    for (i = 0; i < h->nal_length_size; i++)\n\n        nalsize = (nalsize << 8) | buf[(*buf_index)++];\n\n    if (nalsize <= 0 || nalsize > buf_size - *buf_index) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"AVC: nal size %d\\n\", nalsize);\n\n        return -1;\n\n    }\n\n    return nalsize;\n\n}\n", "idx": 13213}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "void palette8tobgr32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t#ifdef WORDS_BIGENDIAN\n\n\t\t\tdst[3]= palette[ src[i]*4+0 ];\n\n\t\t\tdst[2]= palette[ src[i]*4+1 ];\n\n\t\t\tdst[1]= palette[ src[i]*4+2 ];\n\n\t\t#else\n\n\t\t\t//FIXME slow?\n\n\t\t\tdst[0]= palette[ src[i]*4+0 ];\n\n\t\t\tdst[1]= palette[ src[i]*4+1 ];\n\n\t\t\tdst[2]= palette[ src[i]*4+2 ];\n\n\t\t\t//dst[3]= 0; /* do we need this cleansing? */\n\n\t\t#endif\n\n\n\n\t\tdst+= 4;\n\n\t}\n\n}\n", "idx": 13225}
{"project": "qemu", "commit_id": "675463d9b6b2c2b65a713a6d906aeebe9e6750ae", "target": 1, "func": "void isa_bus_irqs(ISABus *bus, qemu_irq *irqs)\n\n{\n\n    if (!bus) {\n\n        hw_error(\"Can't set isa irqs with no isa bus present.\");\n\n    }\n\n    bus->irqs = irqs;\n\n}\n", "idx": 13248}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_put_buffer(QEMUFile *f, const uint8_t *buf, int size)\n\n{\n\n    int l;\n\n\n\n    if (f->last_error) {\n\n        return;\n\n    }\n\n\n\n    while (size > 0) {\n\n        l = IO_BUF_SIZE - f->buf_index;\n\n        if (l > size) {\n\n            l = size;\n\n        }\n\n        memcpy(f->buf + f->buf_index, buf, l);\n\n        f->bytes_xfer += l;\n\n        if (f->ops->writev_buffer) {\n\n            add_to_iovec(f, f->buf + f->buf_index, l);\n\n        }\n\n        f->buf_index += l;\n\n        if (f->buf_index == IO_BUF_SIZE) {\n\n            qemu_fflush(f);\n\n        }\n\n        if (qemu_file_get_error(f)) {\n\n            break;\n\n        }\n\n        buf += l;\n\n        size -= l;\n\n    }\n\n}\n", "idx": 13270}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int check_intra_pred4x4_mode_emuedge(int mode, int mb_x, int mb_y, int *copy_buf)\n\n{\n\n    switch (mode) {\n\n    case VERT_PRED:\n\n        if (!mb_x && mb_y) {\n\n            *copy_buf = 1;\n\n            return mode;\n\n        }\n\n        /* fall-through */\n\n    case DIAG_DOWN_LEFT_PRED:\n\n    case VERT_LEFT_PRED:\n\n        return !mb_y ? DC_127_PRED : mode;\n\n    case HOR_PRED:\n\n        if (!mb_y) {\n\n            *copy_buf = 1;\n\n            return mode;\n\n        }\n\n        /* fall-through */\n\n    case HOR_UP_PRED:\n\n        return !mb_x ? DC_129_PRED : mode;\n\n    case TM_VP8_PRED:\n\n        return check_tm_pred4x4_mode(mode, mb_x, mb_y);\n\n    case DC_PRED: /* 4x4 DC doesn't use the same \"H.264-style\" exceptions\n\n                   * as 16x16/8x8 DC */\n\n    case DIAG_DOWN_RIGHT_PRED:\n\n    case VERT_RIGHT_PRED:\n\n    case HOR_DOWN_PRED:\n\n        if (!mb_y || !mb_x)\n\n            *copy_buf = 1;\n\n        return mode;\n\n    }\n\n    return mode;\n\n}\n", "idx": 13278}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void pl190_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = pl190_init;\n\n    dc->no_user = 1;\n\n    dc->reset = pl190_reset;\n\n    dc->vmsd = &vmstate_pl190;\n\n}\n", "idx": 13293}
{"project": "FFmpeg", "commit_id": "6fdbaa2b7fb56623ab2163f861952bc1408c39b3", "target": 1, "func": "void clamp_mv(VP8Context *s, VP56mv *dst, const VP56mv *src)\n\n{\n\n    dst->x = av_clip(src->x, s->mv_min.x, s->mv_max.x);\n\n    dst->y = av_clip(src->y, s->mv_min.y, s->mv_max.y);\n\n}\n", "idx": 13307}
{"project": "qemu", "commit_id": "ab7a0f0b6dbe8836d490c736803abef6e3695e1f", "target": 1, "func": "static void pxa2xx_gpio_write(void *opaque, hwaddr offset,\n\n                              uint64_t value, unsigned size)\n\n{\n\n    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;\n\n    int bank;\n\n    if (offset >= 0x200)\n\n        return;\n\n\n\n    bank = pxa2xx_gpio_regs[offset].bank;\n\n    switch (pxa2xx_gpio_regs[offset].reg) {\n\n    case GPDR:\t\t/* GPIO Pin-Direction registers */\n\n        s->dir[bank] = value;\n\n        pxa2xx_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GPSR:\t\t/* GPIO Pin-Output Set registers */\n\n        s->olevel[bank] |= value;\n\n        pxa2xx_gpio_handler_update(s);\n\n        s->gpsr[bank] = value;\n\n        break;\n\n\n\n    case GPCR:\t\t/* GPIO Pin-Output Clear registers */\n\n        s->olevel[bank] &= ~value;\n\n        pxa2xx_gpio_handler_update(s);\n\n        break;\n\n\n\n    case GRER:\t\t/* GPIO Rising-Edge Detect Enable registers */\n\n        s->rising[bank] = value;\n\n        break;\n\n\n\n    case GFER:\t\t/* GPIO Falling-Edge Detect Enable registers */\n\n        s->falling[bank] = value;\n\n        break;\n\n\n\n    case GAFR_L:\t/* GPIO Alternate Function registers */\n\n        s->gafr[bank * 2] = value;\n\n        break;\n\n\n\n    case GAFR_U:\t/* GPIO Alternate Function registers */\n\n        s->gafr[bank * 2 + 1] = value;\n\n        break;\n\n\n\n    case GEDR:\t\t/* GPIO Edge Detect Status registers */\n\n        s->status[bank] &= ~value;\n\n        pxa2xx_gpio_irq_update(s);\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"%s: Bad offset \" REG_FMT \"\\n\", __FUNCTION__, offset);\n\n    }\n\n}\n", "idx": 13324}
{"project": "FFmpeg", "commit_id": "e9af732a1a4c28f81959f19d434c9be609cff22a", "target": 1, "func": "AVFilterBufferRef *avfilter_default_get_audio_buffer(AVFilterLink *link, int perms,\n\n                                                     int nb_samples)\n\n{\n\n    AVFilterBufferRef *samplesref = NULL;\n\n    int linesize[8];\n\n    uint8_t *data[8];\n\n    int nb_channels = av_get_channel_layout_nb_channels(link->channel_layout);\n\n\n\n    /* Calculate total buffer size, round to multiple of 16 to be SIMD friendly */\n\n    if (av_samples_alloc(data, linesize,\n\n                         nb_channels, nb_samples, link->format,\n\n                         16) < 0)\n\n        return NULL;\n\n\n\n    samplesref =\n\n        avfilter_get_audio_buffer_ref_from_arrays(data, linesize, perms,\n\n                                                  nb_samples, link->format,\n\n                                                  link->channel_layout, link->planar);\n\n    if (!samplesref) {\n\n        av_free(data[0]);\n\n        return NULL;\n\n    }\n\n\n\n    return samplesref;\n\n}\n", "idx": 13334}
{"project": "qemu", "commit_id": "21f88d021d0d2b4ecee8f6cd6ca63a943a3ce71d", "target": 1, "func": "opts_check_struct(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GHashTableIter iter;\n\n    GQueue *any;\n\n\n\n    if (ov->depth > 0) {\n\n        return;\n\n    }\n\n\n\n    /* we should have processed all (distinct) QemuOpt instances */\n\n    g_hash_table_iter_init(&iter, ov->unprocessed_opts);\n\n    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {\n\n        const QemuOpt *first;\n\n\n\n        first = g_queue_peek_head(any);\n\n        error_setg(errp, QERR_INVALID_PARAMETER, first->name);\n\n    }\n\n}\n", "idx": 13337}
{"project": "qemu", "commit_id": "d5b27167e17e0d9393d6364703cc68e7f018023c", "target": 1, "func": "static int parse_chr(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    CharDriverState **ptr = qdev_get_prop_ptr(dev, prop);\n\n\n\n    *ptr = qemu_chr_find(str);\n\n    if (*ptr == NULL) {\n\n        return -ENOENT;\n\n    }\n\n    if ((*ptr)->assigned) {\n\n        return -EEXIST;\n\n    }\n\n    (*ptr)->assigned = 1;\n\n    return 0;\n\n}\n", "idx": 13346}
{"project": "FFmpeg", "commit_id": "657875b145c788d29b8e3bf38f79264e657932ae", "target": 0, "func": "static int aic_decode_coeffs(GetBitContext *gb, int16_t *dst,\n\n                             int band, int slice_width)\n\n{\n\n    int has_skips, coeff_type, coeff_bits, skip_type, skip_bits;\n\n    const int num_coeffs = aic_num_band_coeffs[band];\n\n    const uint8_t *scan = aic_scan[band];\n\n    int mb, idx, val;\n\n\n\n    has_skips  = get_bits1(gb);\n\n    coeff_type = get_bits1(gb);\n\n    coeff_bits = get_bits(gb, 3);\n\n\n\n    if (has_skips) {\n\n        skip_type = get_bits1(gb);\n\n        skip_bits = get_bits(gb, 3);\n\n\n\n        for (mb = 0; mb < slice_width; mb++) {\n\n            idx = -1;\n\n            do {\n\n                GET_CODE(val, skip_type, skip_bits);\n\n                idx += val + 1;\n\n                if (idx >= num_coeffs)\n\n                    break;\n\n                GET_CODE(val, coeff_type, coeff_bits);\n\n                val++;\n\n                if (val >= 0x10000)\n\n                    return AVERROR_INVALIDDATA;\n\n                dst[scan[idx]] = val;\n\n            } while (idx < num_coeffs - 1);\n\n            dst += num_coeffs;\n\n        }\n\n    } else {\n\n        for (mb = 0; mb < slice_width; mb++) {\n\n            for (idx = 0; idx < num_coeffs; idx++) {\n\n                GET_CODE(val, coeff_type, coeff_bits);\n\n                if (val >= 0x10000)\n\n                    return AVERROR_INVALIDDATA;\n\n                dst[scan[idx]] = val;\n\n            }\n\n            dst += num_coeffs;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 13361}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int sdp_probe(AVProbeData *p1)\n\n{\n\n    const char *p = p1->buf, *p_end = p1->buf + p1->buf_size;\n\n\n\n    /* we look for a line beginning \"c=IN IP4\" */\n\n    while (p < p_end && *p != '\\0') {\n\n        if (p + sizeof(\"c=IN IP4\") - 1 < p_end && av_strstart(p, \"c=IN IP4\", NULL))\n\n            return AVPROBE_SCORE_MAX / 2;\n\n\n\n        while(p < p_end - 1 && *p != '\\n') p++;\n\n        if (++p >= p_end)\n\n            break;\n\n        if (*p == '\\r')\n\n            p++;\n\n    }\n\n    return 0;\n\n}\n", "idx": 13372}
{"project": "qemu", "commit_id": "bf26ae32a92a8446bd9db569f9cdb53cc272aaad", "target": 0, "func": "static void unrealize(DeviceState *d, Error **errp)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    Object *root_container;\n\n    char name[256];\n\n    Error *err = NULL;\n\n\n\n    trace_spapr_drc_unrealize(spapr_drc_index(drc));\n\n    root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);\n\n    snprintf(name, sizeof(name), \"%x\", spapr_drc_index(drc));\n\n    object_property_del(root_container, name, &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n        object_unref(OBJECT(drc));\n\n    }\n\n}\n", "idx": 13375}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static void nbd_co_receive_reply(NBDClientSession *s,\n\n                                 NBDRequest *request,\n\n                                 NBDReply *reply,\n\n                                 QEMUIOVector *qiov)\n\n{\n\n    int ret;\n\n\n\n    /* Wait until we're woken up by nbd_read_reply_entry.  */\n\n    qemu_coroutine_yield();\n\n    *reply = s->reply;\n\n    if (reply->handle != request->handle ||\n\n        !s->ioc) {\n\n        reply->error = EIO;\n\n    } else {\n\n        if (qiov && reply->error == 0) {\n\n            ret = nbd_wr_syncv(s->ioc, qiov->iov, qiov->niov, request->len,\n\n                               true, NULL);\n\n            if (ret != request->len) {\n\n                reply->error = EIO;\n\n            }\n\n        }\n\n\n\n        /* Tell the read handler to read another header.  */\n\n        s->reply.handle = 0;\n\n    }\n\n}\n", "idx": 13377}
{"project": "qemu", "commit_id": "554f802da3f8b09b16b9a84ad5847b2eb0e9ad2b", "target": 1, "func": "void pcie_cap_slot_hotplug_cb(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                              Error **errp)\n\n{\n\n    uint8_t *exp_cap;\n\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n\n\n    pcie_cap_slot_hotplug_common(PCI_DEVICE(hotplug_dev), dev, &exp_cap, errp);\n\n\n\n    /* Don't send event when device is enabled during qemu machine creation:\n\n     * it is present on boot, no hotplug event is necessary. We do send an\n\n     * event when the device is disabled later. */\n\n    if (!dev->hotplugged) {\n\n        pci_word_test_and_set_mask(exp_cap + PCI_EXP_SLTSTA,\n\n                                   PCI_EXP_SLTSTA_PDS);\n\n        return;\n\n    }\n\n\n\n    /* TODO: multifunction hot-plug.\n\n     * Right now, only a device of function = 0 is allowed to be\n\n     * hot plugged/unplugged.\n\n     */\n\n    assert(PCI_FUNC(pci_dev->devfn) == 0);\n\n\n\n    pci_word_test_and_set_mask(exp_cap + PCI_EXP_SLTSTA,\n\n                               PCI_EXP_SLTSTA_PDS);\n\n    pcie_cap_slot_event(PCI_DEVICE(hotplug_dev), PCI_EXP_HP_EV_PDC);\n\n}\n", "idx": 13396}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void do_info_snapshots(Monitor *mon)\n\n{\n\n    DriveInfo *dinfo;\n\n    BlockDriverState *bs, *bs1;\n\n    QEMUSnapshotInfo *sn_tab, *sn;\n\n    int nb_sns, i;\n\n    char buf[256];\n\n\n\n    bs = get_bs_snapshots();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No available block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n    monitor_printf(mon, \"Snapshot devices:\");\n\n    TAILQ_FOREACH(dinfo, &drives, next) {\n\n        bs1 = dinfo->bdrv;\n\n        if (bdrv_has_snapshot(bs1)) {\n\n            if (bs == bs1)\n\n                monitor_printf(mon, \" %s\", bdrv_get_device_name(bs1));\n\n        }\n\n    }\n\n    monitor_printf(mon, \"\\n\");\n\n\n\n    nb_sns = bdrv_snapshot_list(bs, &sn_tab);\n\n    if (nb_sns < 0) {\n\n        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);\n\n        return;\n\n    }\n\n    monitor_printf(mon, \"Snapshot list (from %s):\\n\",\n\n                   bdrv_get_device_name(bs));\n\n    monitor_printf(mon, \"%s\\n\", bdrv_snapshot_dump(buf, sizeof(buf), NULL));\n\n    for(i = 0; i < nb_sns; i++) {\n\n        sn = &sn_tab[i];\n\n        monitor_printf(mon, \"%s\\n\", bdrv_snapshot_dump(buf, sizeof(buf), sn));\n\n    }\n\n    qemu_free(sn_tab);\n\n}\n", "idx": 13424}
{"project": "qemu", "commit_id": "b08d0ea0446aa91f373c9df4254ba3bc4ee84098", "target": 0, "func": "static SCSIRequest *scsi_block_new_request(SCSIDevice *d, uint32_t tag,\n\n                                           uint32_t lun, uint8_t *buf,\n\n                                           void *hba_private)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n\n\n    switch (buf[0]) {\n\n    case READ_6:\n\n    case READ_10:\n\n    case READ_12:\n\n    case READ_16:\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n    case WRITE_6:\n\n    case WRITE_10:\n\n    case WRITE_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_VERIFY_16:\n\n        /* If we are not using O_DIRECT, we might read stale data from the\n\n\t * host cache if writes were made using other commands than these\n\n\t * ones (such as WRITE SAME or EXTENDED COPY, etc.).  So, without\n\n\t * O_DIRECT everything must go through SG_IO.\n\n         */\n\n        if (bdrv_get_flags(s->qdev.conf.bs) & BDRV_O_NOCACHE) {\n\n            break;\n\n        }\n\n\n\n        /* MMC writing cannot be done via pread/pwrite, because it sometimes\n\n         * involves writing beyond the maximum LBA or to negative LBA (lead-in).\n\n         * And once you do these writes, reading from the block device is\n\n         * unreliable, too.  It is even possible that reads deliver random data\n\n         * from the host page cache (this is probably a Linux bug).\n\n         *\n\n         * We might use scsi_disk_reqops as long as no writing commands are\n\n         * seen, but performance usually isn't paramount on optical media.  So,\n\n         * just make scsi-block operate the same as scsi-generic for them.\n\n         */\n\n        if (s->qdev.type == TYPE_ROM) {\n\n            break;\n\n\t}\n\n        return scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun,\n\n                              hba_private);\n\n    }\n\n\n\n    return scsi_req_alloc(&scsi_generic_req_ops, &s->qdev, tag, lun,\n\n                          hba_private);\n\n}\n", "idx": 13427}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_excp_4xx_softmmu (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_CRITICAL] = 0x00000100;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;\n\n    env->excp_vectors[POWERPC_EXCP_PIT]      = 0x00001000;\n\n    env->excp_vectors[POWERPC_EXCP_FIT]      = 0x00001010;\n\n    env->excp_vectors[POWERPC_EXCP_WDT]      = 0x00001020;\n\n    env->excp_vectors[POWERPC_EXCP_DTLB]     = 0x00001100;\n\n    env->excp_vectors[POWERPC_EXCP_ITLB]     = 0x00001200;\n\n    env->excp_vectors[POWERPC_EXCP_DEBUG]    = 0x00002000;\n\n    env->excp_prefix = 0x00000000;\n\n    env->ivor_mask = 0x0000FFF0;\n\n    env->ivpr_mask = 0xFFFF0000;\n\n    /* Hardware reset vector */\n\n    env->hreset_vector = 0xFFFFFFFCUL;\n\n#endif\n\n}\n", "idx": 13449}
{"project": "FFmpeg", "commit_id": "0c46e958d1fd3817b8e9fa048d0450d509c80378", "target": 1, "func": "static int mxf_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    KLVPacket klv;\n\n\n\n    while (!s->pb->eof_reached) {\n\n        if (klv_read_packet(&klv, s->pb) < 0)\n\n            return -1;\n\n        PRINT_KEY(s, \"read packet\", klv.key);\n\n        av_dlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key)) {\n\n            int res = mxf_decrypt_triplet(s, pkt, &klv);\n\n            if (res < 0) {\n\n                av_log(s, AV_LOG_ERROR, \"invalid encoded triplet\\n\");\n\n                return -1;\n\n            }\n\n            return 0;\n\n        }\n\n        if (IS_KLV_KEY(klv.key, mxf_essence_element_key)) {\n\n            int index = mxf_get_stream_index(s, &klv);\n\n            if (index < 0) {\n\n                av_log(s, AV_LOG_ERROR, \"error getting stream index %d\\n\", AV_RB32(klv.key+12));\n\n                goto skip;\n\n            }\n\n            if (s->streams[index]->discard == AVDISCARD_ALL)\n\n                goto skip;\n\n            /* check for 8 channels AES3 element */\n\n            if (klv.key[12] == 0x06 && klv.key[13] == 0x01 && klv.key[14] == 0x10) {\n\n                if (mxf_get_d10_aes3_packet(s->pb, s->streams[index], pkt, klv.length) < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading D-10 aes3 frame\\n\");\n\n                    return -1;\n\n                }\n\n            } else\n\n                av_get_packet(s->pb, pkt, klv.length);\n\n            pkt->stream_index = index;\n\n            pkt->pos = klv.offset;\n\n            return 0;\n\n        } else\n\n        skip:\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    return AVERROR_EOF;\n\n}\n", "idx": 13457}
{"project": "qemu", "commit_id": "56c4bfb3f07f3107894c00281276aea4f5e8834d", "target": 1, "func": "int cpu_get_dump_info(ArchDumpInfo *info)\n\n{\n\n    return -1;\n\n}\n", "idx": 13459}
{"project": "FFmpeg", "commit_id": "6d556e8327f6275c807c6da7257f617c256fe759", "target": 1, "func": "void ff_ivi_recompose_haar(const IVIPlaneDesc *plane, uint8_t *dst,\n\n                           const int dst_pitch, const int num_bands)\n\n{\n\n    int             x, y, indx, b0, b1, b2, b3, p0, p1, p2, p3;\n\n    const IDWTELEM *b0_ptr, *b1_ptr, *b2_ptr, *b3_ptr;\n\n    int32_t         pitch;\n\n\n\n    /* all bands should have the same pitch */\n\n    pitch = plane->bands[0].pitch;\n\n\n\n    /* get pointers to the wavelet bands */\n\n    b0_ptr = plane->bands[0].buf;\n\n    b1_ptr = plane->bands[1].buf;\n\n    b2_ptr = plane->bands[2].buf;\n\n    b3_ptr = plane->bands[3].buf;\n\n\n\n    for (y = 0; y < plane->height; y += 2) {\n\n        for (x = 0, indx = 0; x < plane->width; x += 2, indx++) {\n\n            /* load coefficients */\n\n            b0 = b0_ptr[indx]; //should be: b0 = (num_bands > 0) ? b0_ptr[indx] : 0;\n\n            b1 = b1_ptr[indx]; //should be: b1 = (num_bands > 1) ? b1_ptr[indx] : 0;\n\n            b2 = b2_ptr[indx]; //should be: b2 = (num_bands > 2) ? b2_ptr[indx] : 0;\n\n            b3 = b3_ptr[indx]; //should be: b3 = (num_bands > 3) ? b3_ptr[indx] : 0;\n\n\n\n            /* haar wavelet recomposition */\n\n            p0 = (b0 + b1 + b2 + b3 + 2) >> 2;\n\n            p1 = (b0 + b1 - b2 - b3 + 2) >> 2;\n\n            p2 = (b0 - b1 + b2 - b3 + 2) >> 2;\n\n            p3 = (b0 - b1 - b2 + b3 + 2) >> 2;\n\n\n\n            /* bias, convert and output four pixels */\n\n            dst[x]                 = av_clip_uint8(p0 + 128);\n\n            dst[x + 1]             = av_clip_uint8(p1 + 128);\n\n            dst[dst_pitch + x]     = av_clip_uint8(p2 + 128);\n\n            dst[dst_pitch + x + 1] = av_clip_uint8(p3 + 128);\n\n        }// for x\n\n\n\n        dst += dst_pitch << 1;\n\n\n\n        b0_ptr += pitch;\n\n        b1_ptr += pitch;\n\n        b2_ptr += pitch;\n\n        b3_ptr += pitch;\n\n    }// for y\n\n}\n", "idx": 13460}
{"project": "qemu", "commit_id": "eb513f82f04fab442cdef9db698dafc852275f7f", "target": 1, "func": "void helper_st_asi(CPUSPARCState *env, target_ulong addr, target_ulong val,\n\n                   int asi, int size)\n\n{\n\n#ifdef DEBUG_ASI\n\n    dump_asi(\"write\", addr, asi, size, val);\n\n#endif\n\n    if (asi < 0x80) {\n\n        helper_raise_exception(env, TT_PRIV_ACT);\n\n    }\n\n\n\n    helper_check_align(env, addr, size - 1);\n\n    addr = asi_address_mask(env, asi, addr);\n\n\n\n    /* Convert to little endian */\n\n    switch (asi) {\n\n    case 0x88: /* Primary LE */\n\n    case 0x89: /* Secondary LE */\n\n        switch (size) {\n\n        case 2:\n\n            val = bswap16(val);\n\n            break;\n\n        case 4:\n\n            val = bswap32(val);\n\n            break;\n\n        case 8:\n\n            val = bswap64(val);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    default:\n\n        break;\n\n    }\n\n\n\n    switch (asi) {\n\n    case 0x80: /* Primary */\n\n    case 0x88: /* Primary LE */\n\n        {\n\n            switch (size) {\n\n            case 1:\n\n                stb_raw(addr, val);\n\n                break;\n\n            case 2:\n\n                stw_raw(addr, val);\n\n                break;\n\n            case 4:\n\n                stl_raw(addr, val);\n\n                break;\n\n            case 8:\n\n            default:\n\n                stq_raw(addr, val);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 0x81: /* Secondary */\n\n    case 0x89: /* Secondary LE */\n\n        /* XXX */\n\n        return;\n\n\n\n    case 0x82: /* Primary no-fault, RO */\n\n    case 0x83: /* Secondary no-fault, RO */\n\n    case 0x8a: /* Primary no-fault LE, RO */\n\n    case 0x8b: /* Secondary no-fault LE, RO */\n\n    default:\n\n        helper_raise_exception(env, TT_DATA_ACCESS);\n\n        return;\n\n    }\n\n}\n", "idx": 13467}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mcf_intc_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    int offset;\n\n    mcf_intc_state *s = (mcf_intc_state *)opaque;\n\n    offset = addr & 0xff;\n\n    if (offset >= 0x40 && offset < 0x80) {\n\n        int n = offset - 0x40;\n\n        s->icr[n] = val;\n\n        if (val == 0)\n\n            s->enabled &= ~(1ull << n);\n\n        else\n\n            s->enabled |= (1ull << n);\n\n        mcf_intc_update(s);\n\n        return;\n\n    }\n\n    switch (offset) {\n\n    case 0x00: case 0x04:\n\n        /* Ignore IPR writes.  */\n\n        return;\n\n    case 0x08:\n\n        s->imr = (s->imr & 0xffffffff) | ((uint64_t)val << 32);\n\n        break;\n\n    case 0x0c:\n\n        s->imr = (s->imr & 0xffffffff00000000ull) | (uint32_t)val;\n\n        break;\n\n    default:\n\n        hw_error(\"mcf_intc_write: Bad write offset %d\\n\", offset);\n\n        break;\n\n    }\n\n    mcf_intc_update(s);\n\n}\n", "idx": 13499}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_write(BlockDriverState *bs, int64_t sector_num,\n\n                     const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVCowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    ret = bdrv_pwrite(bs->file, s->cow_sectors_offset + sector_num * 512,\n\n                      buf, nb_sectors * 512);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return cow_update_bitmap(bs, sector_num, nb_sectors);\n\n}\n", "idx": 13515}
{"project": "qemu", "commit_id": "afff2b15e89ac81c113f2ebfd729aaa02b40edb6", "target": 1, "func": "QemuConsole *qemu_console_lookup_by_device(DeviceState *dev, uint32_t head)\n\n{\n\n    Error *local_err = NULL;\n\n    Object *obj;\n\n    uint32_t h;\n\n    int i;\n\n\n\n    for (i = 0; i < nb_consoles; i++) {\n\n        if (!consoles[i]) {\n\n            continue;\n\n        }\n\n        obj = object_property_get_link(OBJECT(consoles[i]),\n\n                                       \"device\", &local_err);\n\n        if (DEVICE(obj) != dev) {\n\n            continue;\n\n        }\n\n        h = object_property_get_int(OBJECT(consoles[i]),\n\n                                    \"head\", &local_err);\n\n        if (h != head) {\n\n            continue;\n\n        }\n\n        return consoles[i];\n\n    }\n\n    return NULL;\n\n}\n", "idx": 13529}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int qemu_file_get_error(QEMUFile *f)\n\n{\n\n    return f->last_error;\n\n}\n", "idx": 13546}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static void platform_fixed_ioport_init(PCIXenPlatformState* s)\n\n{\n\n    register_ioport_write(XEN_PLATFORM_IOPORT, 16, 4, platform_fixed_ioport_writel, s);\n\n    register_ioport_write(XEN_PLATFORM_IOPORT, 16, 2, platform_fixed_ioport_writew, s);\n\n    register_ioport_write(XEN_PLATFORM_IOPORT, 16, 1, platform_fixed_ioport_writeb, s);\n\n    register_ioport_read(XEN_PLATFORM_IOPORT, 16, 2, platform_fixed_ioport_readw, s);\n\n    register_ioport_read(XEN_PLATFORM_IOPORT, 16, 1, platform_fixed_ioport_readb, s);\n\n}\n", "idx": 13565}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fctidz(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN conversion */\n\n        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN |\n\n                                        POWERPC_EXCP_FP_VXCVI);\n\n    } else if (unlikely(float64_is_quiet_nan(farg.d) ||\n\n                        float64_is_infinity(farg.d))) {\n\n        /* qNan / infinity conversion */\n\n        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXCVI);\n\n    } else {\n\n        farg.ll = float64_to_int64_round_to_zero(farg.d, &env->fp_status);\n\n    }\n\n    return farg.ll;\n\n}\n", "idx": 13569}
{"project": "qemu", "commit_id": "7ad4c7200111d20eb97eed4f46b6026e3f0b0eef", "target": 0, "func": "void g_free(void *ptr)\n\n{\n\n    __coverity_free__(ptr);\n\n    __coverity_mark_as_afm_freed__(ptr, AFM_free);\n\n}\n", "idx": 13592}
{"project": "FFmpeg", "commit_id": "bd8e16f2e6f069dd8f63b5c22821b581ffe3151a", "target": 0, "func": "static void build_file_streams(void)\n\n{\n\n    FFServerStream *stream, *stream_next;\n\n    int i, ret;\n\n\n\n    /* gather all streams */\n\n    for(stream = config.first_stream; stream; stream = stream_next) {\n\n        AVFormatContext *infile = NULL;\n\n        stream_next = stream->next;\n\n        if (stream->stream_type == STREAM_TYPE_LIVE &&\n\n            !stream->feed) {\n\n            /* the stream comes from a file */\n\n            /* try to open the file */\n\n            /* open stream */\n\n            if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\")) {\n\n                /* specific case : if transport stream output to RTP,\n\n                   we use a raw transport stream reader */\n\n                av_dict_set(&stream->in_opts, \"mpeg2ts_compute_pcr\", \"1\", 0);\n\n            }\n\n\n\n            if (!stream->feed_filename[0]) {\n\n                http_log(\"Unspecified feed file for stream '%s'\\n\",\n\n                         stream->filename);\n\n                goto fail;\n\n            }\n\n\n\n            http_log(\"Opening feed file '%s' for stream '%s'\\n\",\n\n                     stream->feed_filename, stream->filename);\n\n            if ((ret = avformat_open_input(&infile, stream->feed_filename, stream->ifmt, &stream->in_opts)) < 0) {\n\n                http_log(\"Could not open '%s': %s\\n\", stream->feed_filename,\n\n                         av_err2str(ret));\n\n                /* remove stream (no need to spend more time on it) */\n\n            fail:\n\n                remove_stream(stream);\n\n            } else {\n\n                /* find all the AVStreams inside and reference them in\n\n                   'stream' */\n\n                if (avformat_find_stream_info(infile, NULL) < 0) {\n\n                    http_log(\"Could not find codec parameters from '%s'\\n\",\n\n                             stream->feed_filename);\n\n                    avformat_close_input(&infile);\n\n                    goto fail;\n\n                }\n\n                extract_mpeg4_header(infile);\n\n\n\n                for(i=0;i<infile->nb_streams;i++)\n\n                    add_av_stream1(stream, infile->streams[i]->codec, 1);\n\n\n\n                avformat_close_input(&infile);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 13612}
{"project": "FFmpeg", "commit_id": "7b03b65bf0d02519c86750d2da33f413e11cf0c6", "target": 1, "func": "int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)\n{\n    int ret, flush = 0;\n    if (pkt) {\n        AVStream *st = s->streams[pkt->stream_index];\n        //FIXME/XXX/HACK drop zero sized packets\n        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO && pkt->size == 0)\n            return 0;\n        av_dlog(s, \"av_interleaved_write_frame size:%d dts:%\" PRId64 \" pts:%\" PRId64 \"\\n\",\n                pkt->size, pkt->dts, pkt->pts);\n        if ((ret = compute_pkt_fields2(s, st, pkt)) < 0 && !(s->oformat->flags & AVFMT_NOTIMESTAMPS))\n        if (pkt->dts == AV_NOPTS_VALUE && !(s->oformat->flags & AVFMT_NOTIMESTAMPS))\n            return AVERROR(EINVAL);\n    } else {\n        av_dlog(s, \"av_interleaved_write_frame FLUSH\\n\");\n        flush = 1;\n    }\n    for (;; ) {\n        AVPacket opkt;\n        int ret = interleave_packet(s, &opkt, pkt, flush);\n        if (ret <= 0) //FIXME cleanup needed for ret<0 ?\n        ret = write_packet(s, &opkt);\n        if (ret >= 0)\n            s->streams[opkt.stream_index]->nb_frames++;\n        av_free_packet(&opkt);\n        pkt = NULL;\n    }\n}", "idx": 13623}
{"project": "FFmpeg", "commit_id": "be2b927a6f5311cd5dbf25bd34a029c5d376d9cd", "target": 0, "func": "static void unref_buffer(InputStream *ist, FrameBuffer *buf)\n\n{\n\n    av_assert0(buf->refcount);\n\n    buf->refcount--;\n\n    if (!buf->refcount) {\n\n        buf->next = ist->buffer_pool;\n\n        ist->buffer_pool = buf;\n\n    }\n\n}\n", "idx": 13648}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_buffer(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_get_buffer(f, v, size);\n\n    return 0;\n\n}\n", "idx": 13660}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int flashsv_decode_init(AVCodecContext *avctx)\n\n{\n\n    FlashSVContext *s = avctx->priv_data;\n\n    int zret; // Zlib return code\n\n\n\n    s->avctx          = avctx;\n\n    s->zstream.zalloc = Z_NULL;\n\n    s->zstream.zfree  = Z_NULL;\n\n    s->zstream.opaque = Z_NULL;\n\n    zret = inflateInit(&s->zstream);\n\n    if (zret != Z_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Inflate init error: %d\\n\", zret);\n\n        return 1;\n\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_BGR24;\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 13673}
{"project": "FFmpeg", "commit_id": "9a5ac36b69ede4563e9ecd734141b12ea3280fbc", "target": 1, "func": "static int mov_write_trak_tag(AVIOContext *pb, MOVMuxContext *mov,\n\n                              MOVTrack *track, AVStream *st)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"trak\");\n\n    mov_write_tkhd_tag(pb, mov, track, st);\n\n    if (track->mode == MODE_PSP || track->flags & MOV_TRACK_CTTS ||\n\n        (track->entry && track->cluster[0].dts) ||\n\n        is_clcp_track(track)) {\n\n        if (mov->use_editlist)\n\n            mov_write_edts_tag(pb, mov, track);  // PSP Movies require edts box\n\n        else if ((track->entry && track->cluster[0].dts) || track->mode == MODE_PSP || is_clcp_track(track))\n\n            av_log(mov->fc, AV_LOG_WARNING,\n\n                   \"Not writing any edit list even though one would have been required\\n\");\n\n    }\n\n    if (track->tref_tag)\n\n        mov_write_tref_tag(pb, track);\n\n    mov_write_mdia_tag(pb, mov, track);\n\n    if (track->mode == MODE_PSP)\n\n        mov_write_uuid_tag_psp(pb, track); // PSP Movies require this uuid box\n\n    if (track->tag == MKTAG('r','t','p',' '))\n\n        mov_write_udta_sdp(pb, track);\n\n    if (track->mode == MODE_MOV) {\n\n        if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            double sample_aspect_ratio = av_q2d(st->sample_aspect_ratio);\n\n            if ((0.0 != sample_aspect_ratio && 1.0 != sample_aspect_ratio)) {\n\n                mov_write_tapt_tag(pb, track);\n\n            }\n\n        }\n\n        if (is_clcp_track(track)) {\n\n            mov_write_tapt_tag(pb, track);\n\n        }\n\n    }\n\n    mov_write_track_udta_tag(pb, mov, st);\n\n    return update_size(pb, pos);\n\n}\n", "idx": 13678}
{"project": "qemu", "commit_id": "94d81ae896810beafa60c85b88e991daa986e1fc", "target": 1, "func": "static void quit_handler(int sig)\n{\n    /* if we're frozen, don't exit unless we're absolutely forced to,\n     * because it's basically impossible for graceful exit to complete\n     * unless all log/pid files are on unfreezable filesystems. there's\n     * also a very likely chance killing the agent before unfreezing\n     * the filesystems is a mistake (or will be viewed as one later).\n     */\n    if (ga_is_frozen(ga_state)) {\n        return;\n    g_debug(\"received signal num %d, quitting\", sig);\n    if (g_main_loop_is_running(ga_state->main_loop)) {\n        g_main_loop_quit(ga_state->main_loop);", "idx": 13713}
{"project": "qemu", "commit_id": "61a5872fd66be718ad022102bf813d7e4e9324c5", "target": 1, "func": "static int tcp_close(MigrationState *s)\n\n{\n\n    DPRINTF(\"tcp_close\\n\");\n\n    if (s->fd != -1) {\n\n        close(s->fd);\n\n        s->fd = -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 13714}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void cpu_breakpoint_remove_by_ref(CPUState *env, CPUBreakpoint *breakpoint)\n\n{\n\n#if defined(TARGET_HAS_ICE)\n\n    TAILQ_REMOVE(&env->breakpoints, breakpoint, entry);\n\n\n\n    breakpoint_invalidate(env, breakpoint->pc);\n\n\n\n    qemu_free(breakpoint);\n\n#endif\n\n}\n", "idx": 13753}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_conditional_store(DisasContext *ctx, TCGv EA,\n\n                                  int reg, int size)\n\n{\n\n    int l1;\n\n\n\n    tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);\n\n    l1 = gen_new_label();\n\n    tcg_gen_brcond_tl(TCG_COND_NE, EA, cpu_reserve, l1);\n\n    tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 1 << CRF_EQ);\n\n#if defined(TARGET_PPC64)\n\n    if (size == 8) {\n\n        gen_qemu_st64(ctx, cpu_gpr[reg], EA);\n\n    } else\n\n#endif\n\n    if (size == 4) {\n\n        gen_qemu_st32(ctx, cpu_gpr[reg], EA);\n\n    } else if (size == 2) {\n\n        gen_qemu_st16(ctx, cpu_gpr[reg], EA);\n\n#if defined(TARGET_PPC64)\n\n    } else if (size == 16) {\n\n        TCGv gpr1, gpr2 , EA8;\n\n        if (unlikely(ctx->le_mode)) {\n\n            gpr1 = cpu_gpr[reg+1];\n\n            gpr2 = cpu_gpr[reg];\n\n        } else {\n\n            gpr1 = cpu_gpr[reg];\n\n            gpr2 = cpu_gpr[reg+1];\n\n        }\n\n        gen_qemu_st64(ctx, gpr1, EA);\n\n        EA8 = tcg_temp_local_new();\n\n        gen_addr_add(ctx, EA8, EA, 8);\n\n        gen_qemu_st64(ctx, gpr2, EA8);\n\n        tcg_temp_free(EA8);\n\n#endif\n\n    } else {\n\n        gen_qemu_st8(ctx, cpu_gpr[reg], EA);\n\n    }\n\n    gen_set_label(l1);\n\n    tcg_gen_movi_tl(cpu_reserve, -1);\n\n}\n", "idx": 13758}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t cirrus_linear_bitblt_read(void *opaque,\n\n                                          target_phys_addr_t addr,\n\n                                          unsigned size)\n\n{\n\n    CirrusVGAState *s = opaque;\n\n    uint32_t ret;\n\n\n\n    /* XXX handle bitblt */\n\n    (void)s;\n\n    ret = 0xff;\n\n    return ret;\n\n}\n", "idx": 13773}
{"project": "qemu", "commit_id": "a03ef88f77af045a2eb9629b5ce774a3fb973c5e", "target": 0, "func": "bochs_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n\n                QEMUIOVector *qiov, int flags)\n\n{\n\n    BDRVBochsState *s = bs->opaque;\n\n    uint64_t sector_num = offset >> BDRV_SECTOR_BITS;\n\n    int nb_sectors = bytes >> BDRV_SECTOR_BITS;\n\n    uint64_t bytes_done = 0;\n\n    QEMUIOVector local_qiov;\n\n    int ret;\n\n\n\n    assert((offset & (BDRV_SECTOR_SIZE - 1)) == 0);\n\n    assert((bytes & (BDRV_SECTOR_SIZE - 1)) == 0);\n\n\n\n    qemu_iovec_init(&local_qiov, qiov->niov);\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (nb_sectors > 0) {\n\n        int64_t block_offset = seek_to_sector(bs, sector_num);\n\n        if (block_offset < 0) {\n\n            ret = block_offset;\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&local_qiov);\n\n        qemu_iovec_concat(&local_qiov, qiov, bytes_done, 512);\n\n\n\n        if (block_offset > 0) {\n\n            ret = bdrv_co_preadv(bs->file->bs, block_offset, 512,\n\n                                 &local_qiov, 0);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        } else {\n\n            qemu_iovec_memset(&local_qiov, 0, 0, 512);\n\n        }\n\n        nb_sectors--;\n\n        sector_num++;\n\n        bytes_done += 512;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    qemu_iovec_destroy(&local_qiov);\n\n\n\n    return ret;\n\n}\n", "idx": 13802}
{"project": "qemu", "commit_id": "b6fcf32d9b851a83dedcb609091236b97cc4a985", "target": 0, "func": "static void nested_struct_cleanup(UserDefNested *udnp)\n\n{\n\n    qapi_free_UserDefNested(udnp);\n\n}\n", "idx": 13820}
{"project": "FFmpeg", "commit_id": "1dd488e9559bbe411c6933fd8ff02450a4b3be7e", "target": 0, "func": "static void hl_decode_mb(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy= h->mb_xy;\n\n    const int mb_type= s->current_picture.mb_type[mb_xy];\n\n    int is_complex = h->is_complex || IS_INTRA_PCM(mb_type) || s->qscale == 0;\n\n\n\n    if(ENABLE_H264_ENCODER && !s->decode)\n\n        return;\n\n\n\n    if (is_complex)\n\n        hl_decode_mb_complex(h);\n\n    else hl_decode_mb_simple(h);\n\n}\n", "idx": 13833}
{"project": "FFmpeg", "commit_id": "2f11aa141a01f97c5d2a015bd9dbdb27314b79c4", "target": 1, "func": "static int query_format(struct vf_instance *vf, unsigned int fmt)\n\n{\n\n        /* FIXME - really any YUV 4:2:0 input format should work */\n\n        switch (fmt) {\n\n        case IMGFMT_YV12:\n\n        case IMGFMT_IYUV:\n\n        case IMGFMT_I420:\n\n                return ff_vf_next_query_format(vf, IMGFMT_YV12);\n\n        }\n\n        return 0;\n\n}\n", "idx": 13836}
{"project": "FFmpeg", "commit_id": "32baeafeee4f8446c2c3720b9223ad2166ca9d30", "target": 1, "func": "void ff_jref_idct_add(uint8_t *dest, ptrdiff_t line_size, int16_t *block)\n\n{\n\n    ff_j_rev_dct(block);\n\n    ff_add_pixels_clamped(block, dest, line_size);\n\n}\n", "idx": 13857}
{"project": "FFmpeg", "commit_id": "5331773cc33ba26b9e26ace643d926219e46a17b", "target": 0, "func": "static void get_id3_tag(AVFormatContext *s, int len)\n\n{\n\n    ID3v2ExtraMeta *id3v2_extra_meta = NULL;\n\n\n\n    ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta);\n\n    if (id3v2_extra_meta)\n\n        ff_id3v2_parse_apic(s, &id3v2_extra_meta);\n\n    ff_id3v2_free_extra_meta(&id3v2_extra_meta);\n\n}\n", "idx": 13869}
{"project": "qemu", "commit_id": "f94b3f64e6572c8cec73a538588f7cd754bcfa88", "target": 1, "func": "static void test_qga_fsfreeze_and_thaw(gconstpointer fix)\n\n{\n\n    const TestFixture *fixture = fix;\n\n    QDict *ret;\n\n    const gchar *status;\n\n\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-fsfreeze-freeze'}\");\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n    QDECREF(ret);\n\n\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-fsfreeze-status'}\");\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n    status = qdict_get_try_str(ret, \"return\");\n\n    g_assert_cmpstr(status, ==, \"frozen\");\n\n    QDECREF(ret);\n\n\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-fsfreeze-thaw'}\");\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n    QDECREF(ret);\n\n}\n", "idx": 13886}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static void flush_buffer(ByteIOContext *s)\n\n{\n\n    if (s->buf_ptr > s->buffer) {\n\n        if (s->write_packet)\n\n            s->write_packet(s->opaque, s->buffer, s->buf_ptr - s->buffer);\n\n        if(s->checksum_ptr){\n\n            s->checksum= s->update_checksum(s->checksum, s->checksum_ptr, s->buf_ptr - s->checksum_ptr);\n\n            s->checksum_ptr= s->buffer;\n\n        }\n\n        s->pos += s->buf_ptr - s->buffer;\n\n    }\n\n    s->buf_ptr = s->buffer;\n\n}\n", "idx": 13893}
{"project": "FFmpeg", "commit_id": "679a315424e6ffaafd21ebf7a86108bd4e743793", "target": 1, "func": "static int daala_packet(AVFormatContext *s, int idx)\n\n{\n\n    int seg, duration = 1;\n\n    struct ogg *ogg = s->priv_data;\n\n    struct ogg_stream *os = ogg->streams + idx;\n\n\n\n    /*\n\n     * first packet handling: here we parse the duration of each packet in the\n\n     * first page and compare the total duration to the page granule to find the\n\n     * encoder delay and set the first timestamp\n\n     */\n\n\n\n    if ((!os->lastpts || os->lastpts == AV_NOPTS_VALUE) && !(os->flags & OGG_FLAG_EOS)) {\n\n        for (seg = os->segp; seg < os->nsegs; seg++)\n\n            if (os->segments[seg] < 255)\n\n                duration++;\n\n\n\n        os->lastpts = os->lastdts = daala_gptopts(s, idx, os->granule, NULL) - duration;\n\n        if(s->streams[idx]->start_time == AV_NOPTS_VALUE) {\n\n            s->streams[idx]->start_time = os->lastpts;\n\n            if (s->streams[idx]->duration)\n\n                s->streams[idx]->duration -= s->streams[idx]->start_time;\n\n        }\n\n    }\n\n\n\n    /* parse packet duration */\n\n    if (os->psize > 0)\n\n        os->pduration = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 13914}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int stdio_pclose(void *opaque)\n\n{\n\n    QEMUFileStdio *s = opaque;\n\n    int ret;\n\n    ret = pclose(s->stdio_file);\n\n    if (ret == -1) {\n\n        ret = -errno;\n\n    } else if (!WIFEXITED(ret) || WEXITSTATUS(ret) != 0) {\n\n        /* close succeeded, but non-zero exit code: */\n\n        ret = -EIO; /* fake errno value */\n\n    }\n\n    g_free(s);\n\n    return ret;\n\n}\n", "idx": 14027}
{"project": "FFmpeg", "commit_id": "b93d96a07be40f8e5d267d55fe961285586c0fd7", "target": 1, "func": "static int nvdec_vp8_start_frame(AVCodecContext *avctx, const uint8_t *buffer, uint32_t size)\n\n{\n\n    VP8Context *h = avctx->priv_data;\n\n\n\n    NVDECContext      *ctx = avctx->internal->hwaccel_priv_data;\n\n    CUVIDPICPARAMS     *pp = &ctx->pic_params;\n\n    FrameDecodeData *fdd;\n\n    NVDECFrame *cf;\n\n    AVFrame *cur_frame = h->framep[VP56_FRAME_CURRENT]->tf.f;\n\n\n\n    int ret;\n\n\n\n    ret = ff_nvdec_start_frame(avctx, cur_frame);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    fdd = (FrameDecodeData*)cur_frame->private_ref->data;\n\n    cf  = (NVDECFrame*)fdd->hwaccel_priv;\n\n\n\n    *pp = (CUVIDPICPARAMS) {\n\n        .PicWidthInMbs     = (cur_frame->width  + 15) / 16,\n\n        .FrameHeightInMbs  = (cur_frame->height + 15) / 16,\n\n        .CurrPicIdx        = cf->idx,\n\n\n\n        .CodecSpecific.vp8 = {\n\n            .width                       = cur_frame->width,\n\n            .height                      = cur_frame->height,\n\n\n\n            .first_partition_size        = h->header_partition_size,\n\n\n\n            .LastRefIdx                  = safe_get_ref_idx(h->framep[VP56_FRAME_PREVIOUS]),\n\n            .GoldenRefIdx                = safe_get_ref_idx(h->framep[VP56_FRAME_GOLDEN]),\n\n            .AltRefIdx                   = safe_get_ref_idx(h->framep[VP56_FRAME_GOLDEN2]),\n\n\n\n            .frame_type                  = !h->keyframe,\n\n            .version                     = h->profile,\n\n            .show_frame                  = !h->invisible,\n\n            .update_mb_segmentation_data = h->segmentation.enabled ? h->segmentation.update_feature_data : 0,\n\n       }\n\n    };\n\n\n\n    return 0;\n\n}\n", "idx": 14030}
{"project": "qemu", "commit_id": "bd16430777cc3d25930e479fdbe290d92cec0888", "target": 1, "func": "static void ahci_irq_lower(AHCIState *s, AHCIDevice *dev)\n\n{\n\n    AHCIPCIState *d = container_of(s, AHCIPCIState, ahci);\n\n\n\n    DPRINTF(0, \"lower irq\\n\");\n\n\n\n    if (!msi_enabled(PCI_DEVICE(d))) {\n\n        qemu_irq_lower(s->irq);\n\n    }\n\n}\n", "idx": 14034}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static void adb_mouse_realizefn(DeviceState *dev, Error **errp)\n\n{\n\n    MouseState *s = ADB_MOUSE(dev);\n\n    ADBMouseClass *amc = ADB_MOUSE_GET_CLASS(dev);\n\n\n\n    amc->parent_realize(dev, errp);\n\n\n\n    qemu_add_mouse_event_handler(adb_mouse_event, s, 0, \"QEMU ADB Mouse\");\n\n}\n", "idx": 14044}
{"project": "qemu", "commit_id": "c9f82d013be0d8d9c5d9f51bb76e337a0a5a5cac", "target": 1, "func": "static void gen_dcbz(DisasContext *ctx)\n\n{\n\n    TCGv tcgv_addr;\n\n    TCGv_i32 tcgv_is_dcbzl;\n\n    int is_dcbzl = ctx->opcode & 0x00200000 ? 1 : 0;\n\n\n\n    gen_set_access_type(ctx, ACCESS_CACHE);\n\n    tcgv_addr = tcg_temp_new();\n\n    tcgv_is_dcbzl = tcg_const_i32(is_dcbzl);\n\n\n\n    gen_addr_reg_index(ctx, tcgv_addr);\n\n    gen_helper_dcbz(cpu_env, tcgv_addr, tcgv_is_dcbzl);\n\n\n\n    tcg_temp_free(tcgv_addr);\n\n    tcg_temp_free_i32(tcgv_is_dcbzl);\n\n}\n", "idx": 14099}
{"project": "FFmpeg", "commit_id": "1bc1cfdddf7ab8ef50d0fc888808d6b609eb5d8d", "target": 1, "func": "static void rtsp_cmd_pause(HTTPContext *c, const char *url, RTSPHeader *h)\n\n{\n\n    HTTPContext *rtp_c;\n\n\n\n    rtp_c = find_rtp_session_with_url(url, h->session_id);\n\n    if (!rtp_c) {\n\n        rtsp_reply_error(c, RTSP_STATUS_SESSION);\n\n        return;\n\n    }\n\n    \n\n    if (rtp_c->state != HTTPSTATE_SEND_DATA &&\n\n        rtp_c->state != HTTPSTATE_WAIT_FEED) {\n\n        rtsp_reply_error(c, RTSP_STATUS_STATE);\n\n        return;\n\n    }\n\n    \n\n    rtp_c->state = HTTPSTATE_READY;\n\n    \n\n    /* now everything is OK, so we can send the connection parameters */\n\n    rtsp_reply_header(c, RTSP_STATUS_OK);\n\n    /* session ID */\n\n    url_fprintf(c->pb, \"Session: %s\\r\\n\", rtp_c->session_id);\n\n    url_fprintf(c->pb, \"\\r\\n\");\n\n}\n", "idx": 14102}
{"project": "qemu", "commit_id": "a83000f5e3fac30a7f213af1ba6a8f827622854d", "target": 0, "func": "static void spapr_vio_quiesce_one(VIOsPAPRDevice *dev)\n\n{\n\n    if (dev->tcet) {\n\n        spapr_tce_reset(dev->tcet);\n\n    }\n\n    free_crq(dev);\n\n}\n", "idx": 14118}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "PXA2xxMMCIState *pxa2xx_mmci_init(MemoryRegion *sysmem,\n\n                hwaddr base,\n\n                BlockDriverState *bd, qemu_irq irq,\n\n                qemu_irq rx_dma, qemu_irq tx_dma)\n\n{\n\n    PXA2xxMMCIState *s;\n\n\n\n    s = (PXA2xxMMCIState *) g_malloc0(sizeof(PXA2xxMMCIState));\n\n    s->irq = irq;\n\n    s->rx_dma = rx_dma;\n\n    s->tx_dma = tx_dma;\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &pxa2xx_mmci_ops, s,\n\n                          \"pxa2xx-mmci\", 0x00100000);\n\n    memory_region_add_subregion(sysmem, base, &s->iomem);\n\n\n\n    /* Instantiate the actual storage */\n\n    s->card = sd_init(bd, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    register_savevm(NULL, \"pxa2xx_mmci\", 0, 0,\n\n                    pxa2xx_mmci_save, pxa2xx_mmci_load, s);\n\n\n\n    return s;\n\n}\n", "idx": 14121}
{"project": "qemu", "commit_id": "978f2205c791de0e02c8802a645bea657408abfd", "target": 0, "func": "int64_t timerlist_deadline_ns(QEMUTimerList *timer_list)\n\n{\n\n    int64_t delta;\n\n\n\n    if (!timer_list->clock->enabled || !timer_list->active_timers) {\n\n        return -1;\n\n    }\n\n\n\n    delta = timer_list->active_timers->expire_time -\n\n        qemu_clock_get_ns(timer_list->clock->type);\n\n\n\n    if (delta <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    return delta;\n\n}\n", "idx": 14130}
{"project": "qemu", "commit_id": "17e2377abf16c3951d7d34521ceade4d7dc31d01", "target": 0, "func": "void *qemu_mallocz(size_t size)\n\n{\n\n    void *ptr;\n\n    ptr = qemu_malloc(size);\n\n    if (!ptr)\n\n        return NULL;\n\n    memset(ptr, 0, size);\n\n    return ptr;\n\n}\n", "idx": 14132}
{"project": "qemu", "commit_id": "0b466065eba289c437e3edc2e97144fc5cd6a889", "target": 0, "func": "sosendoob(struct socket *so)\n\n{\n\n\tstruct sbuf *sb = &so->so_rcv;\n\n\tchar buff[2048]; /* XXX Shouldn't be sending more oob data than this */\n\n\n\n\tint n, len;\n\n\n\n\tDEBUG_CALL(\"sosendoob\");\n\n\tDEBUG_ARG(\"so = %p\", so);\n\n\tDEBUG_ARG(\"sb->sb_cc = %d\", sb->sb_cc);\n\n\n\n\tif (so->so_urgc > 2048)\n\n\t   so->so_urgc = 2048; /* XXXX */\n\n\n\n\tif (sb->sb_rptr < sb->sb_wptr) {\n\n\t\t/* We can send it directly */\n\n\t\tn = slirp_send(so, sb->sb_rptr, so->so_urgc, (MSG_OOB)); /* |MSG_DONTWAIT)); */\n\n\t\tso->so_urgc -= n;\n\n\n\n\t\tDEBUG_MISC((dfd, \" --- sent %d bytes urgent data, %d urgent bytes left\\n\", n, so->so_urgc));\n\n\t} else {\n\n\t\t/*\n\n\t\t * Since there's no sendv or sendtov like writev,\n\n\t\t * we must copy all data to a linear buffer then\n\n\t\t * send it all\n\n\t\t */\n\n\t\tlen = (sb->sb_data + sb->sb_datalen) - sb->sb_rptr;\n\n\t\tif (len > so->so_urgc) len = so->so_urgc;\n\n\t\tmemcpy(buff, sb->sb_rptr, len);\n\n\t\tso->so_urgc -= len;\n\n\t\tif (so->so_urgc) {\n\n\t\t\tn = sb->sb_wptr - sb->sb_data;\n\n\t\t\tif (n > so->so_urgc) n = so->so_urgc;\n\n\t\t\tmemcpy((buff + len), sb->sb_data, n);\n\n\t\t\tso->so_urgc -= n;\n\n\t\t\tlen += n;\n\n\t\t}\n\n\t\tn = slirp_send(so, buff, len, (MSG_OOB)); /* |MSG_DONTWAIT)); */\n\n#ifdef DEBUG\n\n\t\tif (n != len)\n\n\t\t   DEBUG_ERROR((dfd, \"Didn't send all data urgently XXXXX\\n\"));\n\n#endif\n\n\t\tDEBUG_MISC((dfd, \" ---2 sent %d bytes urgent data, %d urgent bytes left\\n\", n, so->so_urgc));\n\n\t}\n\n\n\n\tsb->sb_cc -= n;\n\n\tsb->sb_rptr += n;\n\n\tif (sb->sb_rptr >= (sb->sb_data + sb->sb_datalen))\n\n\t\tsb->sb_rptr -= sb->sb_datalen;\n\n\n\n\treturn n;\n\n}\n", "idx": 14133}
{"project": "FFmpeg", "commit_id": "a717f9904227d7979473bad40c50eb40af41d01d", "target": 1, "func": "void ff_mpegts_parse_close(MpegTSContext *ts)\n\n{\n\n    int i;\n\n\n\n    for(i=0;i<NB_PID_MAX;i++)\n\n        av_free(ts->pids[i]);\n\n    av_free(ts);\n\n}\n", "idx": 14146}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbiel(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_tlbie(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 14147}
{"project": "qemu", "commit_id": "f9aef99b3e6df88036436b0d3dc3d504b9346c8c", "target": 1, "func": "static void local_mapped_file_attr(FsContext *ctx, const char *path,\n\n                                   struct stat *stbuf)\n\n{\n\n    FILE *fp;\n\n    char buf[ATTR_MAX];\n\n    char *attr_path;\n\n\n\n    attr_path = local_mapped_attr_path(ctx, path);\n\n    fp = local_fopen(attr_path, \"r\");\n\n    g_free(attr_path);\n\n    if (!fp) {\n\n        return;\n\n    }\n\n    memset(buf, 0, ATTR_MAX);\n\n    while (fgets(buf, ATTR_MAX, fp)) {\n\n        if (!strncmp(buf, \"virtfs.uid\", 10)) {\n\n            stbuf->st_uid = atoi(buf+11);\n\n        } else if (!strncmp(buf, \"virtfs.gid\", 10)) {\n\n            stbuf->st_gid = atoi(buf+11);\n\n        } else if (!strncmp(buf, \"virtfs.mode\", 11)) {\n\n            stbuf->st_mode = atoi(buf+12);\n\n        } else if (!strncmp(buf, \"virtfs.rdev\", 11)) {\n\n            stbuf->st_rdev = atoi(buf+12);\n\n        }\n\n        memset(buf, 0, ATTR_MAX);\n\n    }\n\n    fclose(fp);\n\n}\n", "idx": 14176}
{"project": "FFmpeg", "commit_id": "e8f814a907036e43f755f35e885bfadf94c4d63b", "target": 1, "func": "AVRational av_guess_frame_rate(AVFormatContext *format, AVStream *st, AVFrame *frame)\n\n{\n\n    AVRational fr = st->r_frame_rate;\n\n    AVRational codec_fr = st->codec->framerate;\n\n    AVRational   avg_fr = st->avg_frame_rate;\n\n\n\n    if (avg_fr.num > 0 && avg_fr.den > 0 && fr.num > 0 && fr.den > 0 &&\n\n        av_q2d(avg_fr) < 70 && av_q2d(fr) > 210) {\n\n        fr = avg_fr;\n\n    }\n\n\n\n\n\n    if (st->codec->ticks_per_frame > 1) {\n\n        if (   codec_fr.num > 0 && codec_fr.den > 0 && av_q2d(codec_fr) < av_q2d(fr)*0.7\n\n            && fabs(1.0 - av_q2d(av_div_q(avg_fr, fr))) > 0.1)\n\n            fr = codec_fr;\n\n    }\n\n\n\n    return fr;\n\n}\n", "idx": 14180}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void apply_mid_side_stereo(ChannelElement *cpe)\n\n{\n\n    int w, w2, g, i;\n\n    IndividualChannelStream *ics = &cpe->ch[0].ics;\n\n    if (!cpe->common_window)\n\n        return;\n\n    for (w = 0; w < ics->num_windows; w += ics->group_len[w]) {\n\n        for (w2 =  0; w2 < ics->group_len[w]; w2++) {\n\n            int start = (w+w2) * 128;\n\n            for (g = 0; g < ics->num_swb; g++) {\n\n                if (!cpe->ms_mask[w*16 + g]) {\n\n                    start += ics->swb_sizes[g];\n\n                    continue;\n\n                }\n\n                for (i = 0; i < ics->swb_sizes[g]; i++) {\n\n                    float L = (cpe->ch[0].coeffs[start+i] + cpe->ch[1].coeffs[start+i]) * 0.5f;\n\n                    float R = L - cpe->ch[1].coeffs[start+i];\n\n                    cpe->ch[0].coeffs[start+i] = L;\n\n                    cpe->ch[1].coeffs[start+i] = R;\n\n                }\n\n                start += ics->swb_sizes[g];\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 14192}
{"project": "FFmpeg", "commit_id": "ab89dbd43e2898c7af99387cfb15fff608b02ab5", "target": 0, "func": "static int ea_read_header(AVFormatContext *s,\n\n                          AVFormatParameters *ap)\n\n{\n\n    EaDemuxContext *ea = s->priv_data;\n\n    AVStream *st;\n\n\n\n    if (!process_ea_header(s))\n\n        return AVERROR(EIO);\n\n\n\n    if (ea->time_base.num && ea->time_base.den) {\n\n        /* initialize the video decoder stream */\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        ea->video_stream_index = st->index;\n\n        st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n        st->codec->codec_id = ea->video_codec;\n\n        st->codec->codec_tag = 0;  /* no fourcc */\n\n        st->codec->time_base = ea->time_base;\n\n    }\n\n\n\n    if (ea->audio_codec) {\n\n        /* initialize the audio decoder stream */\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        av_set_pts_info(st, 33, 1, ea->sample_rate);\n\n        st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n        st->codec->codec_id = ea->audio_codec;\n\n        st->codec->codec_tag = 0;  /* no tag */\n\n        st->codec->channels = ea->num_channels;\n\n        st->codec->sample_rate = ea->sample_rate;\n\n        st->codec->bits_per_sample = ea->bytes * 8;\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_sample / 4;\n\n        st->codec->block_align = st->codec->channels*st->codec->bits_per_sample;\n\n        ea->audio_stream_index = st->index;\n\n        ea->audio_frame_counter = 0;\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 14194}
{"project": "qemu", "commit_id": "30ca440eec9fe1d7eec5a48addac656438778278", "target": 0, "func": "static QOSState *qvirtio_scsi_start(const char *extra_opts)\n\n{\n\n    const char *cmd = \"-drive id=drv0,if=none,file=/dev/null,format=raw \"\n\n                      \"-device virtio-scsi-pci,id=vs0 \"\n\n                      \"-device scsi-hd,bus=vs0.0,drive=drv0 %s\";\n\n\n\n    return qtest_pc_boot(cmd, extra_opts ? : \"\");\n\n}\n", "idx": 14231}
{"project": "qemu", "commit_id": "45a50b1668822c23afc2a89f724654e176518bc4", "target": 0, "func": "int fread_targphys_ok(target_phys_addr_t dst_addr, size_t nbytes, FILE *f)\n\n{\n\n    return fread_targphys(dst_addr, nbytes, f) == nbytes;\n\n}\n", "idx": 14236}
{"project": "FFmpeg", "commit_id": "c9ff32215b433d505f251c1f212b1fa0a5e17b73", "target": 0, "func": "static int set_format(void *obj, const char *name, int fmt, int search_flags,\n\n                      enum AVOptionType type, const char *desc, int max)\n\n{\n\n    void *target_obj;\n\n    const AVOption *o = av_opt_find2(obj, name, NULL, 0,\n\n                                     search_flags, &target_obj);\n\n    if (!o || !target_obj)\n\n        return AVERROR_OPTION_NOT_FOUND;\n\n    if (o->type != type) {\n\n        av_log(obj, AV_LOG_ERROR,\n\n               \"The value set by option '%s' is not a %s format\", name, desc);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (fmt < -1 || fmt > max) {\n\n        av_log(obj, AV_LOG_ERROR,\n\n               \"Value %d for parameter '%s' out of %s format range [-1 - %d]\\n\",\n\n               fmt, name, desc, max);\n\n        return AVERROR(ERANGE);\n\n    }\n\n    *(int *)(((uint8_t *)target_obj) + o->offset) = fmt;\n\n    return 0;\n\n}\n", "idx": 14240}
{"project": "qemu", "commit_id": "71200fb9664c2967a1cdd22b68b0da3a8b2b3eb7", "target": 1, "func": "static CharDriverState *qemu_chr_open_stdio(const char *id,\n\n                                            ChardevBackend *backend,\n\n                                            ChardevReturn *ret,\n\n                                            Error **errp)\n\n{\n\n    ChardevStdio *opts = backend->u.stdio.data;\n\n    CharDriverState *chr;\n\n    struct sigaction act;\n\n    ChardevCommon *common = qapi_ChardevStdio_base(opts);\n\n\n\n    if (is_daemonized()) {\n\n        error_setg(errp, \"cannot use stdio with -daemonize\");\n\n\n\n\n\n    if (stdio_in_use) {\n\n        error_setg(errp, \"cannot use stdio by multiple character devices\");\n\n\n\n\n\n    stdio_in_use = true;\n\n    old_fd0_flags = fcntl(0, F_GETFL);\n\n    tcgetattr(0, &oldtty);\n\n    qemu_set_nonblock(0);\n\n    atexit(term_exit);\n\n\n\n    memset(&act, 0, sizeof(act));\n\n    act.sa_handler = term_stdio_handler;\n\n    sigaction(SIGCONT, &act, NULL);\n\n\n\n    chr = qemu_chr_open_fd(0, 1, common, errp);\n\n\n\n\n    chr->chr_close = qemu_chr_close_stdio;\n\n    chr->chr_set_echo = qemu_chr_set_echo_stdio;\n\n    if (opts->has_signal) {\n\n        stdio_allow_signal = opts->signal;\n\n\n    qemu_chr_fe_set_echo(chr, false);\n\n\n\n    return chr;\n", "idx": 14244}
{"project": "FFmpeg", "commit_id": "a5ef7960fc96ed773acc4149104d6acf534e8a87", "target": 1, "func": "static int ape_read_packet(AVFormatContext * s, AVPacket * pkt)\n\n{\n\n    int ret;\n\n    int nblocks;\n\n    APEContext *ape = s->priv_data;\n\n    uint32_t extra_size = 8;\n\n\n\n    if (url_feof(s->pb))\n\n        return AVERROR_EOF;\n\n    if (ape->currentframe >= ape->totalframes)\n\n        return AVERROR_EOF;\n\n\n\n    if (avio_seek(s->pb, ape->frames[ape->currentframe].pos, SEEK_SET) < 0)\n\n        return AVERROR(EIO);\n\n\n\n    /* Calculate how many blocks there are in this frame */\n\n    if (ape->currentframe == (ape->totalframes - 1))\n\n        nblocks = ape->finalframeblocks;\n\n    else\n\n        nblocks = ape->blocksperframe;\n\n\n\n    if (ape->frames[ape->currentframe].size <= 0 ||\n\n        ape->frames[ape->currentframe].size > INT_MAX - extra_size) {\n\n        av_log(s, AV_LOG_ERROR, \"invalid packet size: %d\\n\",\n\n               ape->frames[ape->currentframe].size);\n\n        ape->currentframe++;\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    if (av_new_packet(pkt,  ape->frames[ape->currentframe].size + extra_size) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    AV_WL32(pkt->data    , nblocks);\n\n    AV_WL32(pkt->data + 4, ape->frames[ape->currentframe].skip);\n\n    ret = avio_read(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);\n\n\n\n\n\n    pkt->pts = ape->frames[ape->currentframe].pts;\n\n    pkt->stream_index = 0;\n\n\n\n    /* note: we need to modify the packet size here to handle the last\n\n       packet */\n\n    pkt->size = ret + extra_size;\n\n\n\n    ape->currentframe++;\n\n\n\n    return 0;\n\n}", "idx": 14254}
{"project": "qemu", "commit_id": "cf7c0ff521b0710079aa28f21937fb7dbb3f5224", "target": 0, "func": "static GSList *nvdimm_get_plugged_device_list(void)\n\n{\n\n    GSList *list = NULL;\n\n\n\n    object_child_foreach(qdev_get_machine(), nvdimm_plugged_device_list,\n\n                         &list);\n\n    return list;\n\n}\n", "idx": 14267}
{"project": "qemu", "commit_id": "38d8dfa193e9a45f0f08b06aab2ba2a94f40a041", "target": 0, "func": "void ide_dma_cancel(BMDMAState *bm)\n\n{\n\n    if (bm->status & BM_STATUS_DMAING) {\n\n        bm->status &= ~BM_STATUS_DMAING;\n\n        /* cancel DMA request */\n\n        bm->unit = -1;\n\n        bm->dma_cb = NULL;\n\n        if (bm->aiocb) {\n\n#ifdef DEBUG_AIO\n\n            printf(\"aio_cancel\\n\");\n\n#endif\n\n            bdrv_aio_cancel(bm->aiocb);\n\n            bm->aiocb = NULL;\n\n        }\n\n    }\n\n}\n", "idx": 14271}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fre(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN reciprocal */\n\n        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n    }\n\n    farg.d = float64_div(float64_one, farg.d, &env->fp_status);\n\n    return farg.d;\n\n}\n", "idx": 14272}
{"project": "qemu", "commit_id": "7bb6edb0e3dd78d74e0ac980cf6c0a07307f61bf", "target": 1, "func": "static int virtio_rng_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIORNG *vrng = VIRTIO_RNG(qdev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);\n\n\n\n    timer_del(vrng->rate_limit_timer);\n\n    timer_free(vrng->rate_limit_timer);\n\n    unregister_savevm(qdev, \"virtio-rng\", vrng);\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 14312}
{"project": "qemu", "commit_id": "bc5008a832f95aae86efce844382e64d54da2146", "target": 1, "func": "static struct pathelem *add_entry(struct pathelem *root, const char *name,\n\n                                  unsigned type)\n\n{\n\n    struct pathelem **e;\n\n\n\n    root->num_entries++;\n\n\n\n    root = realloc(root, sizeof(*root)\n\n                   + sizeof(root->entries[0])*root->num_entries);\n\n    e = &root->entries[root->num_entries-1];\n\n\n\n    *e = new_entry(root->pathname, root, name);\n\n    if (is_dir_maybe(type)) {\n\n        *e = add_dir_maybe(*e);\n\n    }\n\n\n\n    return root;\n\n}\n", "idx": 14354}
{"project": "qemu", "commit_id": "baa61b9870dd7e0bb07e0ae61c6ec805db13f699", "target": 1, "func": "static void virtio_balloon_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n    dc->exit = virtio_balloon_device_exit;\n\n    dc->props = virtio_balloon_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->init = virtio_balloon_device_init;\n\n    vdc->get_config = virtio_balloon_get_config;\n\n    vdc->set_config = virtio_balloon_set_config;\n\n    vdc->get_features = virtio_balloon_get_features;\n\n}\n", "idx": 14360}
{"project": "qemu", "commit_id": "1d5b8d770d1215b41ae32c881984b1d048b2f932", "target": 1, "func": "static KeyValue *copy_key_value(KeyValue *src)\n\n{\n\n    KeyValue *dst = g_new(KeyValue, 1);\n\n    memcpy(dst, src, sizeof(*src));\n\n\n\n\n\n\n    return dst;\n", "idx": 14367}
{"project": "qemu", "commit_id": "85d604af5f96c32734af9974ec6ddb625b6716a2", "target": 1, "func": "target_ulong helper_sub_suov(CPUTriCoreState *env, target_ulong r1,\n\n                             target_ulong r2)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t result = t1 - t2;\n\n    return suov32(env, result);\n\n}\n", "idx": 14373}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,\n\n                             unsigned size)\n\n{\n\n    icp_pit_state *s = (icp_pit_state *)opaque;\n\n    int n;\n\n\n\n    /* ??? Don't know the PrimeCell ID for this device.  */\n\n    n = offset >> 8;\n\n    if (n > 2) {\n\n        hw_error(\"%s: Bad timer %d\\n\", __func__, n);\n\n    }\n\n\n\n    return arm_timer_read(s->timer[n], offset & 0xff);\n\n}\n", "idx": 14386}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static void v9fs_synth_direntry(V9fsSynthNode *node,\n\n                                struct dirent *entry, off_t off)\n\n{\n\n    strcpy(entry->d_name, node->name);\n\n    entry->d_ino = node->attr->inode;\n\n    entry->d_off = off + 1;\n\n}\n", "idx": 14390}
{"project": "qemu", "commit_id": "2399d4e7cec22ecf1c51062d2ebfd45220dbaace", "target": 0, "func": "static void gen_nop_hint(DisasContext *s, int val)\n\n{\n\n    switch (val) {\n\n    case 1: /* yield */\n\n        if (!parallel_cpus) {\n\n            gen_set_pc_im(s, s->pc);\n\n            s->base.is_jmp = DISAS_YIELD;\n\n        }\n\n        break;\n\n    case 3: /* wfi */\n\n        gen_set_pc_im(s, s->pc);\n\n        s->base.is_jmp = DISAS_WFI;\n\n        break;\n\n    case 2: /* wfe */\n\n        if (!parallel_cpus) {\n\n            gen_set_pc_im(s, s->pc);\n\n            s->base.is_jmp = DISAS_WFE;\n\n        }\n\n        break;\n\n    case 4: /* sev */\n\n    case 5: /* sevl */\n\n        /* TODO: Implement SEV, SEVL and WFE.  May help SMP performance.  */\n\n    default: /* nop */\n\n        break;\n\n    }\n\n}\n", "idx": 14396}
{"project": "qemu", "commit_id": "1d3323de5fe5656844ea57a16eb432f09a366140", "target": 0, "func": "static void vnc_dpy_setdata(DisplayState *ds)\n\n{\n\n    /* We don't have to do anything */\n\n}\n", "idx": 14402}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int64_t ftp_seek(URLContext *h, int64_t pos, int whence)\n\n{\n\n    FTPContext *s = h->priv_data;\n\n    int err;\n\n    int64_t new_pos, fake_pos;\n\n\n\n    av_dlog(h, \"ftp protocol seek %\"PRId64\" %d\\n\", pos, whence);\n\n\n\n    switch(whence) {\n\n    case AVSEEK_SIZE:\n\n        return s->filesize;\n\n    case SEEK_SET:\n\n        new_pos = pos;\n\n        break;\n\n    case SEEK_CUR:\n\n        new_pos = s->position + pos;\n\n        break;\n\n    case SEEK_END:\n\n        if (s->filesize < 0)\n\n            return AVERROR(EIO);\n\n        new_pos = s->filesize + pos;\n\n        break;\n\n    default:\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (h->is_streamed)\n\n        return AVERROR(EIO);\n\n\n\n    if (new_pos < 0) {\n\n        av_log(h, AV_LOG_ERROR, \"Seeking to nagative position.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    fake_pos = s->filesize != -1 ? FFMIN(new_pos, s->filesize) : new_pos;\n\n    if (fake_pos != s->position) {\n\n        if ((err = ftp_abort(h)) < 0)\n\n            return err;\n\n        s->position = fake_pos;\n\n    }\n\n    return new_pos;\n\n}\n", "idx": 14405}
{"project": "qemu", "commit_id": "cf528b89580797050b8cf60fee6247f35531a675", "target": 0, "func": "struct vhost_net *vhost_net_init(NetClientState *backend, int devfd,\n\n                                 bool force)\n\n{\n\n    int r;\n\n    struct vhost_net *net = g_malloc(sizeof *net);\n\n    if (!backend) {\n\n        fprintf(stderr, \"vhost-net requires backend to be setup\\n\");\n\n        goto fail;\n\n    }\n\n    r = vhost_net_get_fd(backend);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    net->nc = backend;\n\n    net->dev.backend_features = tap_has_vnet_hdr(backend) ? 0 :\n\n        (1 << VHOST_NET_F_VIRTIO_NET_HDR);\n\n    net->backend = r;\n\n\n\n    net->dev.nvqs = 2;\n\n    net->dev.vqs = net->vqs;\n\n\n\n    r = vhost_dev_init(&net->dev, devfd, \"/dev/vhost-net\", force);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    if (!tap_has_vnet_hdr_len(backend,\n\n                              sizeof(struct virtio_net_hdr_mrg_rxbuf))) {\n\n        net->dev.features &= ~(1 << VIRTIO_NET_F_MRG_RXBUF);\n\n    }\n\n    if (~net->dev.features & net->dev.backend_features) {\n\n        fprintf(stderr, \"vhost lacks feature mask %\" PRIu64 \" for backend\\n\",\n\n                (uint64_t)(~net->dev.features & net->dev.backend_features));\n\n        vhost_dev_cleanup(&net->dev);\n\n        goto fail;\n\n    }\n\n\n\n    /* Set sane init value. Override when guest acks. */\n\n    vhost_net_ack_features(net, 0);\n\n    return net;\n\nfail:\n\n    g_free(net);\n\n    return NULL;\n\n}\n", "idx": 14410}
{"project": "qemu", "commit_id": "a1f0cce2ac0243572ff72aa561da67fe3766a395", "target": 1, "func": "static void scsi_read_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n", "idx": 14445}
{"project": "qemu", "commit_id": "1ecf47bf0a091700e45f1b7d1f5ad85abc0acd22", "target": 0, "func": "static void qemu_kvm_start_vcpu(CPUState *env)\n\n{\n\n    env->thread = g_malloc0(sizeof(QemuThread));\n\n    env->halt_cond = g_malloc0(sizeof(QemuCond));\n\n    qemu_cond_init(env->halt_cond);\n\n    qemu_thread_create(env->thread, qemu_kvm_cpu_thread_fn, env,\n\n                       QEMU_THREAD_DETACHED);\n\n    while (env->created == 0) {\n\n        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n\n    }\n\n}\n", "idx": 14472}
{"project": "qemu", "commit_id": "04bf2526ce87f21b32c9acba1c5518708c243ad0", "target": 0, "func": "static MemTxResult address_space_write_continue(AddressSpace *as, hwaddr addr,\n\n                                                MemTxAttrs attrs,\n\n                                                const uint8_t *buf,\n\n                                                int len, hwaddr addr1,\n\n                                                hwaddr l, MemoryRegion *mr)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemTxResult result = MEMTX_OK;\n\n    bool release_lock = false;\n\n\n\n    for (;;) {\n\n        if (!memory_access_is_direct(mr, true)) {\n\n            release_lock |= prepare_mmio_access(mr);\n\n            l = memory_access_size(mr, l, addr1);\n\n            /* XXX: could force current_cpu to NULL to avoid\n\n               potential bugs */\n\n            switch (l) {\n\n            case 8:\n\n                /* 64 bit write access */\n\n                val = ldq_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 8,\n\n                                                       attrs);\n\n                break;\n\n            case 4:\n\n                /* 32 bit write access */\n\n                val = (uint32_t)ldl_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 4,\n\n                                                       attrs);\n\n                break;\n\n            case 2:\n\n                /* 16 bit write access */\n\n                val = lduw_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 2,\n\n                                                       attrs);\n\n                break;\n\n            case 1:\n\n                /* 8 bit write access */\n\n                val = ldub_p(buf);\n\n                result |= memory_region_dispatch_write(mr, addr1, val, 1,\n\n                                                       attrs);\n\n                break;\n\n            default:\n\n                abort();\n\n            }\n\n        } else {\n\n            /* RAM case */\n\n            ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n\n            memcpy(ptr, buf, l);\n\n            invalidate_and_set_dirty(mr, addr1, l);\n\n        }\n\n\n\n        if (release_lock) {\n\n            qemu_mutex_unlock_iothread();\n\n            release_lock = false;\n\n        }\n\n\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n\n\n        if (!len) {\n\n            break;\n\n        }\n\n\n\n        l = len;\n\n        mr = address_space_translate(as, addr, &addr1, &l, true);\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 14496}
{"project": "FFmpeg", "commit_id": "8992029fc0a4dd9df16f8cb46cfb641c98fc9f6c", "target": 0, "func": "static int g729_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                     const uint8_t **poutbuf, int *poutbuf_size,\n\n                     const uint8_t *buf, int buf_size)\n\n{\n\n    G729ParseContext *s = s1->priv_data;\n\n    ParseContext *pc = &s->pc;\n\n    int next;\n\n\n\n    if (!s->block_size) {\n\n        switch (avctx->codec_id) {\n\n        case AV_CODEC_ID_G729:\n\n            /* FIXME: replace this heuristic block_size with more precise estimate */\n\n            s->block_size = (avctx->bit_rate < 8000) ? G729D_6K4_BLOCK_SIZE : G729_8K_BLOCK_SIZE;\n\n            s->duration   = avctx->frame_size;\n\n            break;\n\n        default:\n\n            *poutbuf      = buf;\n\n            *poutbuf_size = buf_size;\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid codec_id\\n\");\n\n            return buf_size;\n\n        }\n\n    }\n\n\n\n    if (!s->remaining)\n\n        s->remaining = s->block_size;\n\n    if (s->remaining <= buf_size) {\n\n        next = s->remaining;\n\n        s->remaining = 0;\n\n    } else {\n\n        next = END_NOT_FOUND;\n\n        s->remaining -= buf_size;\n\n    }\n\n\n\n    if (ff_combine_frame(pc, next, &buf, &buf_size) < 0 || !buf_size) {\n\n        *poutbuf      = NULL;\n\n        *poutbuf_size = 0;\n\n        return buf_size;\n\n    }\n\n\n\n    s1->duration = s->duration;\n\n\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return next;\n\n}\n", "idx": 14509}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t timerblock_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    timerblock *tb = (timerblock *)opaque;\n\n    int64_t val;\n\n    switch (addr) {\n\n    case 0: /* Load */\n\n        return tb->load;\n\n    case 4: /* Counter.  */\n\n        if (((tb->control & 1) == 0) || (tb->count == 0)) {\n\n            return 0;\n\n        }\n\n        /* Slow and ugly, but hopefully won't happen too often.  */\n\n        val = tb->tick - qemu_get_clock_ns(vm_clock);\n\n        val /= timerblock_scale(tb);\n\n        if (val < 0) {\n\n            val = 0;\n\n        }\n\n        return val;\n\n    case 8: /* Control.  */\n\n        return tb->control;\n\n    case 12: /* Interrupt status.  */\n\n        return tb->status;\n\n    default:\n\n        return 0;\n\n    }\n\n}\n", "idx": 14532}
{"project": "qemu", "commit_id": "ae08792301c182bdec48656dee3dce38b3391a1a", "target": 0, "func": "setup_return(CPUARMState *env, struct target_sigaction *ka,\n\n\t     abi_ulong *rc, abi_ulong frame_addr, int usig, abi_ulong rc_addr)\n\n{\n\n\tabi_ulong handler = ka->_sa_handler;\n\n\tabi_ulong retcode;\n\n\tint thumb = handler & 1;\n\n\tuint32_t cpsr = cpsr_read(env);\n\n\n\n\tcpsr &= ~CPSR_IT;\n\n\tif (thumb) {\n\n\t\tcpsr |= CPSR_T;\n\n\t} else {\n\n\t\tcpsr &= ~CPSR_T;\n\n\t}\n\n\n\n\tif (ka->sa_flags & TARGET_SA_RESTORER) {\n\n\t\tretcode = ka->sa_restorer;\n\n\t} else {\n\n\t\tunsigned int idx = thumb;\n\n\n\n\t\tif (ka->sa_flags & TARGET_SA_SIGINFO)\n\n\t\t\tidx += 2;\n\n\n\n        __put_user(retcodes[idx], rc);\n\n\n\n\t\tretcode = rc_addr + thumb;\n\n\t}\n\n\n\n\tenv->regs[0] = usig;\n\n\tenv->regs[13] = frame_addr;\n\n\tenv->regs[14] = retcode;\n\n\tenv->regs[15] = handler & (thumb ? ~1 : ~3);\n\n        cpsr_write(env, cpsr, 0xffffffff, CPSRWriteByInstr);\n\n}\n", "idx": 14543}
{"project": "qemu", "commit_id": "e76d1798faa6d29f54c0930a034b67f3ecdb947d", "target": 0, "func": "static void tcg_exec_all(void)\n\n{\n\n    int r;\n\n\n\n    /* Account partial waits to QEMU_CLOCK_VIRTUAL.  */\n\n    qemu_clock_warp(QEMU_CLOCK_VIRTUAL);\n\n\n\n    if (next_cpu == NULL) {\n\n        next_cpu = first_cpu;\n\n    }\n\n    for (; next_cpu != NULL && !exit_request; next_cpu = CPU_NEXT(next_cpu)) {\n\n        CPUState *cpu = next_cpu;\n\n\n\n        qemu_clock_enable(QEMU_CLOCK_VIRTUAL,\n\n                          (cpu->singlestep_enabled & SSTEP_NOTIMER) == 0);\n\n\n\n        if (cpu_can_run(cpu)) {\n\n            r = tcg_cpu_exec(cpu);\n\n            if (r == EXCP_DEBUG) {\n\n                cpu_handle_guest_debug(cpu);\n\n                break;\n\n            }\n\n        } else if (cpu->stop || cpu->stopped) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Pairs with smp_wmb in qemu_cpu_kick.  */\n\n    atomic_mb_set(&exit_request, 0);\n\n}\n", "idx": 14556}
{"project": "qemu", "commit_id": "1048c88f03545fa42bdebb077871a743a614d2ab", "target": 0, "func": "static int get_keycode(const char *key)\n\n{\n\n    const KeyDef *p;\n\n    char *endp;\n\n    int ret;\n\n\n\n    for(p = key_defs; p->name != NULL; p++) {\n\n        if (!strcmp(key, p->name))\n\n            return p->keycode;\n\n    }\n\n    if (strstart(key, \"0x\", NULL)) {\n\n        ret = strtoul(key, &endp, 0);\n\n        if (*endp == '\\0' && ret >= 0x01 && ret <= 0xff)\n\n            return ret;\n\n    }\n\n    return -1;\n\n}\n", "idx": 14563}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_cm_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *) opaque;\n\n\n\n    switch (addr) {\n\n    case CCCR:\n\n    case CKEN:\n\n    case OSCC:\n\n        return s->cm_regs[addr >> 2];\n\n\n\n    case CCSR:\n\n        return s->cm_regs[CCCR >> 2] | (3 << 28);\n\n\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14587}
{"project": "FFmpeg", "commit_id": "179308768a8742d215eb8450f0718dc2ee8ea133", "target": 0, "func": "static int mxf_write_header_metadata_sets(AVFormatContext *s)\n\n{\n\n    AVStream *st;\n\n    MXFStreamContext *sc = NULL;\n\n    int i;\n\n\n\n    mxf_write_preface(s);\n\n    mxf_write_identification(s);\n\n    mxf_write_content_storage(s);\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        st = s->streams[i];\n\n        sc = av_mallocz(sizeof(MXFStreamContext));\n\n        if (!sc)\n\n            return AVERROR(ENOMEM);\n\n        st->priv_data = sc;\n\n        // set pts information\n\n        if (st->codec->codec_type == CODEC_TYPE_VIDEO)\n\n            av_set_pts_info(st, 64, 1, st->codec->time_base.den);\n\n        else if (st->codec->codec_type == CODEC_TYPE_AUDIO)\n\n            av_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n    }\n\n\n\n    mxf_build_structural_metadata(s, MaterialPackage);\n\n    mxf_build_structural_metadata(s, SourcePackage);\n\n    return 0;\n\n}\n", "idx": 14611}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_buffer_write_image(cl_mem dst_cl_buf, size_t cl_buffer_size, int dst_cl_offset,\n\n                                                    uint8_t **src_data, int *plane_size, int plane_num)\n\n{\n\n    int i, buffer_size = 0;\n\n    uint8_t *temp;\n\n    cl_int status;\n\n    void *mapped;\n\n    if ((unsigned int)plane_num > 8) {\n\n        return AVERROR(EINVAL);\n\n    }\n\n    for (i = 0;i < plane_num;i++) {\n\n        buffer_size += plane_size[i];\n\n    }\n\n    if (buffer_size > cl_buffer_size) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Cannot write image to OpenCL buffer: buffer too small\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,\n\n                                      CL_TRUE,CL_MAP_WRITE, 0, buffer_size + dst_cl_offset,\n\n                                      0, NULL, NULL, &status);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    temp = mapped;\n\n    temp += dst_cl_offset;\n\n    for (i = 0; i < plane_num; i++) {\n\n        memcpy(temp, src_data[i], plane_size[i]);\n\n        temp += plane_size[i];\n\n    }\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14622}
{"project": "FFmpeg", "commit_id": "5bc223b15d064e328ff90b0241fa1191f1d2786d", "target": 1, "func": "static int r3d_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    R3DContext *r3d = s->priv_data;\n\n    Atom atom;\n\n    int err = 0;\n\n\n\n    while (!err) {\n\n        if (read_atom(s, &atom) < 0) {\n\n            err = -1;\n\n            break;\n\n        }\n\n        switch (atom.tag) {\n\n        case MKTAG('R','E','D','V'):\n\n            if (s->streams[0]->discard == AVDISCARD_ALL)\n\n                goto skip;\n\n            if (!(err = r3d_read_redv(s, pkt, &atom)))\n\n                return 0;\n\n            break;\n\n        case MKTAG('R','E','D','A'):\n\n            if (!r3d->audio_channels)\n\n                return -1;\n\n            if (s->streams[1]->discard == AVDISCARD_ALL)\n\n                goto skip;\n\n            if (!(err = r3d_read_reda(s, pkt, &atom)))\n\n                return 0;\n\n            break;\n\n        default:\n\n        skip:\n\n            avio_skip(s->pb, atom.size-8);\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 14630}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(test_ctrz_true)\n\n{\n\n    T0 = (regs->ctr == 0 && (T0 & PARAM(1)) != 0);\n\n    RETURN();\n\n}\n", "idx": 14634}
{"project": "qemu", "commit_id": "47116d1c90cdac94cb9da270320dcf0d5ce1cfe2", "target": 1, "func": "static void monitor_control_event(void *opaque, int event)\n\n{\n\n    if (event == CHR_EVENT_OPENED) {\n\n        QObject *data;\n\n        Monitor *mon = opaque;\n\n\n\n        mon->mc->command_mode = 0;\n\n        json_message_parser_init(&mon->mc->parser, handle_qmp_command);\n\n\n\n        data = get_qmp_greeting();\n\n        monitor_json_emitter(mon, data);\n\n        qobject_decref(data);\n\n    }\n\n}\n", "idx": 14643}
{"project": "qemu", "commit_id": "6f2d8978728c48ca46f5c01835438508aace5c64", "target": 1, "func": "void cpu_ppc_reset (void *opaque)\n\n{\n\n    CPUPPCState *env;\n\n    target_ulong msr;\n\n\n\n    env = opaque;\n\n    msr = (target_ulong)0;\n\n#if defined(TARGET_PPC64)\n\n    msr |= (target_ulong)0 << MSR_HV; /* Should be 1... */\n\n#endif\n\n    msr |= (target_ulong)0 << MSR_AP; /* TO BE CHECKED */\n\n    msr |= (target_ulong)0 << MSR_SA; /* TO BE CHECKED */\n\n    msr |= (target_ulong)1 << MSR_EP;\n\n#if defined (DO_SINGLE_STEP) && 0\n\n    /* Single step trace mode */\n\n    msr |= (target_ulong)1 << MSR_SE;\n\n    msr |= (target_ulong)1 << MSR_BE;\n\n#endif\n\n#if defined(CONFIG_USER_ONLY)\n\n    msr |= (target_ulong)1 << MSR_FP; /* Allow floating point usage */\n\n    msr |= (target_ulong)1 << MSR_PR;\n\n#else\n\n    env->nip = env->hreset_vector | env->excp_prefix;\n\n    if (env->mmu_model != POWERPC_MMU_REAL_4xx)\n\n        ppc_tlb_invalidate_all(env);\n\n#endif\n\n    env->msr = msr;\n\n    hreg_compute_hflags(env);\n\n    env->reserve = -1;\n\n    /* Be sure no exception or interrupt is pending */\n\n    env->pending_interrupts = 0;\n\n    env->exception_index = POWERPC_EXCP_NONE;\n\n    env->error_code = 0;\n\n    /* Flush all TLBs */\n\n    tlb_flush(env, 1);\n\n}\n", "idx": 14652}
{"project": "FFmpeg", "commit_id": "3518925a9127e368b6d0c7e8fd86510d34af40a1", "target": 1, "func": "static int mov_create_timecode_track(AVFormatContext *s, int index, int src_index, const char *tcstr)\n\n{\n\n    int ret;\n\n    MOVMuxContext *mov  = s->priv_data;\n\n    MOVTrack *track     = &mov->tracks[index];\n\n    AVStream *src_st    = s->streams[src_index];\n\n    AVTimecode tc;\n\n    AVPacket pkt    = {.stream_index = index, .flags = AV_PKT_FLAG_KEY, .size = 4};\n\n    AVRational rate = find_fps(s, src_st);\n\n\n\n    /* compute the frame number */\n\n    ret = av_timecode_init_from_string(&tc, rate, tcstr, s);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* tmcd track based on video stream */\n\n    track->mode      = mov->mode;\n\n    track->tag       = MKTAG('t','m','c','d');\n\n    track->src_track = src_index;\n\n    track->timescale = mov->tracks[src_index].timescale;\n\n    if (tc.flags & AV_TIMECODE_FLAG_DROPFRAME)\n\n        track->timecode_flags |= MOV_TIMECODE_FLAG_DROPFRAME;\n\n\n\n    /* set st to src_st for metadata access*/\n\n    track->st = src_st;\n\n\n\n    /* encode context: tmcd data stream */\n\n    track->enc = avcodec_alloc_context3(NULL);\n\n\n\n    track->enc->codec_type = AVMEDIA_TYPE_DATA;\n\n    track->enc->codec_tag  = track->tag;\n\n    track->enc->time_base  = av_inv_q(rate);\n\n\n\n    /* the tmcd track just contains one packet with the frame number */\n\n    pkt.data = av_malloc(pkt.size);\n\n\n\n    AV_WB32(pkt.data, tc.start);\n\n    ret = ff_mov_write_packet(s, &pkt);\n\n    av_free(pkt.data);\n\n    return ret;\n\n}", "idx": 14653}
{"project": "FFmpeg", "commit_id": "956472a3236cc8eaeba5147c55b51bde6005c898", "target": 1, "func": "static int rv40_decode_intra_types(RV34DecContext *r, GetBitContext *gb, int8_t *dst)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int i, j, k, v;\n\n    int A, B, C;\n\n    int pattern;\n\n    int8_t *ptr;\n\n\n\n    for(i = 0; i < 4; i++, dst += r->intra_types_stride){\n\n        if(!i && s->first_slice_line){\n\n            pattern = get_vlc2(gb, aic_top_vlc.table, AIC_TOP_BITS, 1);\n\n            dst[0] = (pattern >> 2) & 2;\n\n            dst[1] = (pattern >> 1) & 2;\n\n            dst[2] =  pattern       & 2;\n\n            dst[3] = (pattern << 1) & 2;\n\n            continue;\n\n        }\n\n        ptr = dst;\n\n        for(j = 0; j < 4; j++){\n\n            /* Coefficients are read using VLC chosen by the prediction pattern\n\n             * The first one (used for retrieving a pair of coefficients) is\n\n             * constructed from the top, top right and left coefficients\n\n             * The second one (used for retrieving only one coefficient) is\n\n             * top + 10 * left.\n\n             */\n\n            A = ptr[-r->intra_types_stride + 1]; // it won't be used for the last coefficient in a row\n\n            B = ptr[-r->intra_types_stride];\n\n            C = ptr[-1];\n\n            pattern = A + (B << 4) + (C << 8);\n\n            for(k = 0; k < MODE2_PATTERNS_NUM; k++)\n\n                if(pattern == rv40_aic_table_index[k])\n\n                    break;\n\n            if(j < 3 && k < MODE2_PATTERNS_NUM){ //pattern is found, decoding 2 coefficients\n\n                v = get_vlc2(gb, aic_mode2_vlc[k].table, AIC_MODE2_BITS, 2);\n\n                *ptr++ = v/9;\n\n                *ptr++ = v%9;\n\n                j++;\n\n            }else{\n\n                if(B != -1 && C != -1)\n\n                    v = get_vlc2(gb, aic_mode1_vlc[B + C*10].table, AIC_MODE1_BITS, 1);\n\n                else{ // tricky decoding\n\n                    v = 0;\n\n                    switch(C){\n\n                    case -1: // code 0 -> 1, 1 -> 0\n\n                        if(B < 2)\n\n                            v = get_bits1(gb) ^ 1;\n\n                        break;\n\n                    case  0:\n\n                    case  2: // code 0 -> 2, 1 -> 0\n\n                        v = (get_bits1(gb) ^ 1) << 1;\n\n                        break;\n\n                    }\n\n                }\n\n                *ptr++ = v;\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 14657}
{"project": "qemu", "commit_id": "758ead31c7e17bf17a9ef2e0ca1c3e86ab296b43", "target": 1, "func": "void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)\n\n{\n\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n\n\n    /* virtio-1 compliant devices cannot change the alignment */\n\n    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {\n\n        error_report(\"tried to modify queue alignment for virtio-1 device\");\n\n        return;\n\n    }\n\n    /* Check that the transport told us it was going to do this\n\n     * (so a buggy transport will immediately assert rather than\n\n     * silently failing to migrate this state)\n\n     */\n\n    assert(k->has_variable_vring_alignment);\n\n\n\n    vdev->vq[n].vring.align = align;\n\n    virtio_queue_update_rings(vdev, n);\n\n}\n", "idx": 14661}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void isa_mmio_writew(void *opaque, target_phys_addr_t addr,\n\n                               uint32_t val)\n\n{\n\n    cpu_outw(addr & IOPORTS_MASK, val);\n\n}\n", "idx": 14713}
{"project": "qemu", "commit_id": "31ce5e0c49821d92fb30cce2f3055ef33613b287", "target": 1, "func": "int kvm_on_sigbus(int code, void *addr)\n\n{\n\n#if defined(KVM_CAP_MCE)\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        uint64_t status;\n\n        void *vaddr;\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        vaddr = addr;\n\n        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr, &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n        status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN\n\n            | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S\n\n            | 0xc0;\n\n        kvm_inject_x86_mce(first_cpu, 9, status,\n\n                           MCG_STATUS_MCIP | MCG_STATUS_RIPV, paddr,\n\n                           (MCM_ADDR_PHYS << 6) | 0xc, 1);\n\n        kvm_mce_broadcast_rest(first_cpu);\n\n    } else\n\n#endif\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 14770}
{"project": "FFmpeg", "commit_id": "ef0d779706c77ca9007527bd8d41e9400682f4e4", "target": 1, "func": "static int ogg_save(AVFormatContext *s)\n\n{\n\n    struct ogg *ogg = s->priv_data;\n\n    struct ogg_state *ost =\n\n        av_malloc(sizeof (*ost) + (ogg->nstreams-1) * sizeof (*ogg->streams));\n\n    int i;\n\n    ost->pos = avio_tell (s->pb);\n\n    ost->curidx = ogg->curidx;\n\n    ost->next = ogg->state;\n\n    ost->nstreams = ogg->nstreams;\n\n    memcpy(ost->streams, ogg->streams, ogg->nstreams * sizeof(*ogg->streams));\n\n\n\n    for (i = 0; i < ogg->nstreams; i++){\n\n        struct ogg_stream *os = ogg->streams + i;\n\n        os->buf = av_malloc (os->bufsize);\n\n        memset (os->buf, 0, os->bufsize);\n\n        memcpy (os->buf, ost->streams[i].buf, os->bufpos);\n\n    }\n\n\n\n    ogg->state = ost;\n\n\n\n    return 0;\n\n}\n", "idx": 14772}
{"project": "FFmpeg", "commit_id": "a392bf657015c9a79a5a13adfbfb15086c1943b9", "target": 1, "func": "static int dxtory_decode_v1_444(AVCodecContext *avctx, AVFrame *pic,\n\n                                const uint8_t *src, int src_size)\n\n{\n\n    int h, w;\n\n    uint8_t *Y, *U, *V;\n\n    int ret;\n\n\n\n    if (src_size < avctx->width * avctx->height * 3) {\n\n        av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    Y = pic->data[0];\n\n    U = pic->data[1];\n\n    V = pic->data[2];\n\n    for (h = 0; h < avctx->height; h++) {\n\n        for (w = 0; w < avctx->width; w++) {\n\n            Y[w] = *src++;\n\n            U[w] = *src++ ^ 0x80;\n\n            V[w] = *src++ ^ 0x80;\n\n        }\n\n        Y += pic->linesize[0];\n\n        U += pic->linesize[1];\n\n        V += pic->linesize[2];\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14776}
{"project": "qemu", "commit_id": "3d002df33eb034757d98e1ae529318f57df78f91", "target": 0, "func": "static size_t buffered_set_rate_limit(void *opaque, size_t new_rate)\n\n{\n\n    QEMUFileBuffered *s = opaque;\n\n\n\n    if (s->has_error)\n\n        goto out;\n\n\n\n    s->xfer_limit = new_rate / 10;\n\n    \n\nout:\n\n    return s->xfer_limit;\n\n}\n", "idx": 14781}
{"project": "qemu", "commit_id": "d2eae20790e825656b205dbe347826ff991fb3d8", "target": 0, "func": "static void ccw_init(MachineState *machine)\n\n{\n\n    int ret;\n\n    VirtualCssBus *css_bus;\n\n    DeviceState *dev;\n\n\n\n    s390_sclp_init();\n\n    s390_memory_init(machine->ram_size);\n\n\n\n    /* get a BUS */\n\n    css_bus = virtual_css_bus_init();\n\n    s390_init_ipl_dev(machine->kernel_filename, machine->kernel_cmdline,\n\n                      machine->initrd_filename, \"s390-ccw.img\", true);\n\n    s390_flic_init();\n\n\n\n    dev = qdev_create(NULL, TYPE_S390_PCI_HOST_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), TYPE_S390_PCI_HOST_BRIDGE,\n\n                              OBJECT(dev), NULL);\n\n    qdev_init_nofail(dev);\n\n\n\n    /* register hypercalls */\n\n    virtio_ccw_register_hcalls();\n\n\n\n    /* init CPUs */\n\n    s390_init_cpus(machine->cpu_model);\n\n\n\n    if (kvm_enabled()) {\n\n        kvm_s390_enable_css_support(s390_cpu_addr2state(0));\n\n    }\n\n    /*\n\n     * Create virtual css and set it as default so that non mcss-e\n\n     * enabled guests only see virtio devices.\n\n     */\n\n    ret = css_create_css_image(VIRTUAL_CSSID, true);\n\n    assert(ret == 0);\n\n\n\n    /* Create VirtIO network adapters */\n\n    s390_create_virtio_net(BUS(css_bus), \"virtio-net-ccw\");\n\n\n\n    /* Register savevm handler for guest TOD clock */\n\n    register_savevm(NULL, \"todclock\", 0, 1,\n\n                    gtod_save, gtod_load, kvm_state);\n\n}\n", "idx": 14788}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_load_vmstate(BlockDriverState *bs, uint8_t *buf,\n\n                      int64_t pos, int size)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (drv->bdrv_load_vmstate)\n\n        return drv->bdrv_load_vmstate(bs, buf, pos, size);\n\n    if (bs->file)\n\n        return bdrv_load_vmstate(bs->file, buf, pos, size);\n\n    return -ENOTSUP;\n\n}\n", "idx": 14789}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static av_cold int vaapi_encode_h265_init(AVCodecContext *avctx)\n\n{\n\n    return ff_vaapi_encode_init(avctx, &vaapi_encode_type_h265);\n\n}\n", "idx": 14791}
{"project": "qemu", "commit_id": "47e8dd8fe9d83e8b51d40c2b87d7983bd0a78206", "target": 1, "func": "char **breakline(char *input, int *count)\n\n{\n\n    int c = 0;\n\n    char *p;\n\n    char **rval = calloc(sizeof(char *), 1);\n\n\n\n    while (rval && (p = qemu_strsep(&input, \" \")) != NULL) {\n\n        if (!*p) {\n\n            continue;\n\n        }\n\n        c++;\n\n        rval = realloc(rval, sizeof(*rval) * (c + 1));\n\n        if (!rval) {\n\n            c = 0;\n\n            break;\n\n        }\n\n        rval[c - 1] = p;\n\n        rval[c] = NULL;\n\n    }\n\n    *count = c;\n\n    return rval;\n\n}\n", "idx": 14818}
{"project": "qemu", "commit_id": "089f26bb735fb414b79f5fa3753910d5339d2a1d", "target": 1, "func": "static gsize calc_float_string_storage(double value)\n\n{\n\n    int whole_value = value;\n\n    gsize i = 0;\n\n    do {\n\n        i++;\n\n    } while (whole_value /= 10);\n\n    return i + 2 + FLOAT_STRING_PRECISION;\n\n}\n", "idx": 14829}
{"project": "qemu", "commit_id": "7f9744812291853425b614f68668f48d49882a1f", "target": 0, "func": "static void virtio_net_vmstate_change(void *opaque, int running, int reason)\n\n{\n\n    VirtIONet *n = opaque;\n\n    if (!running) {\n\n        return;\n\n    }\n\n    /* This is called when vm is started, it will start vhost backend if\n\n     * appropriate e.g. after migration. */\n\n    virtio_net_set_status(&n->vdev, n->vdev.status);\n\n}\n", "idx": 14850}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int coroutine_fn raw_co_pdiscard(BlockDriverState *bs,\n\n                                        int64_t offset, int count)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    if (offset > UINT64_MAX - s->offset) {\n\n        return -EINVAL;\n\n    }\n\n    offset += s->offset;\n\n    return bdrv_co_pdiscard(bs->file->bs, offset, count);\n\n}\n", "idx": 14854}
{"project": "qemu", "commit_id": "6fa2c95f279dda62aa7e3292cc424ff3fab6a602", "target": 0, "func": "static int scsi_write_data(SCSIDevice *d, uint32_t tag)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n    SCSIDiskReq *r;\n\n\n\n    DPRINTF(\"Write data tag=0x%x\\n\", tag);\n\n    r = scsi_find_request(s, tag);\n\n    if (!r) {\n\n        BADF(\"Bad write tag 0x%x\\n\", tag);\n\n        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);\n\n        return 1;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    scsi_write_request(r);\n\n\n\n    return 0;\n\n}\n", "idx": 14887}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "void replay_account_executed_instructions(void)\n\n{\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        replay_mutex_lock();\n\n        if (replay_state.instructions_count > 0) {\n\n            int count = (int)(replay_get_current_step()\n\n                              - replay_state.current_step);\n\n            replay_state.instructions_count -= count;\n\n            replay_state.current_step += count;\n\n            if (replay_state.instructions_count == 0) {\n\n                assert(replay_data_kind == EVENT_INSTRUCTION);\n\n                replay_finish_event();\n\n                /* Wake up iothread. This is required because\n\n                   timers will not expire until clock counters\n\n                   will be read from the log. */\n\n                qemu_notify_event();\n\n            }\n\n        }\n\n        replay_mutex_unlock();\n\n    }\n\n}\n", "idx": 14890}
{"project": "qemu", "commit_id": "e8ee5e4c476d5b0654d8f1271a2b7c065acc486e", "target": 0, "func": "void qemu_co_rwlock_unlock(CoRwlock *lock)\n\n{\n\n    assert(qemu_in_coroutine());\n\n    if (lock->writer) {\n\n        lock->writer = false;\n\n        while (!qemu_co_queue_empty(&lock->queue)) {\n\n            /*\n\n             * Wakeup every body. This will include some\n\n             * writers too.\n\n             */\n\n            qemu_co_queue_next(&lock->queue);\n\n        }\n\n    } else {\n\n        lock->reader--;\n\n        assert(lock->reader >= 0);\n\n        /* Wakeup only one waiting writer */\n\n        if (!lock->reader) {\n\n            qemu_co_queue_next(&lock->queue);\n\n        }\n\n    }\n\n}\n", "idx": 14902}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_sf2si)(float32 x, CPUUniCore32State *env)\n\n{\n\n    return ucf64_itos(float32_to_int32(x, &env->ucf64.fp_status));\n\n}\n", "idx": 14918}
{"project": "qemu", "commit_id": "a35faa94c8e8d851a1d07e17c98f4ab2202b8a38", "target": 0, "func": "static int pl061_init(SysBusDevice *dev, const unsigned char *id)\n\n{\n\n    int iomemtype;\n\n    pl061_state *s = FROM_SYSBUS(pl061_state, dev);\n\n    s->id = id;\n\n    iomemtype = cpu_register_io_memory(pl061_readfn,\n\n                                       pl061_writefn, s,\n\n                                       DEVICE_NATIVE_ENDIAN);\n\n    sysbus_init_mmio(dev, 0x1000, iomemtype);\n\n    sysbus_init_irq(dev, &s->irq);\n\n    qdev_init_gpio_in(&dev->qdev, pl061_set_irq, 8);\n\n    qdev_init_gpio_out(&dev->qdev, s->out, 8);\n\n    pl061_reset(s);\n\n    register_savevm(&dev->qdev, \"pl061_gpio\", -1, 1, pl061_save, pl061_load, s);\n\n    return 0;\n\n}\n", "idx": 14933}
{"project": "qemu", "commit_id": "69795d6769910eaee4416470744e65ae066aeb54", "target": 0, "func": "void qemu_chr_reset(CharDriverState *s)\n\n{\n\n    if (s->bh == NULL && initial_reset_issued) {\n\n\ts->bh = qemu_bh_new(qemu_chr_reset_bh, s);\n\n\tqemu_bh_schedule(s->bh);\n\n    }\n\n}\n", "idx": 14939}
{"project": "qemu", "commit_id": "d0bce760e04b1658a3b4ac95be2839ae20fd86db", "target": 1, "func": "static void omap_i2c_set_slave_addr(OMAPI2C *s, uint8_t addr)\n\n{\n\n    uint16_t data = addr;\n\n\n\n    memwrite(s->addr + OMAP_I2C_SA, &data, 2);\n\n    memread(s->addr + OMAP_I2C_SA, &data, 2);\n\n    g_assert_cmphex(data, ==, addr);\n\n}\n", "idx": 14943}
{"project": "FFmpeg", "commit_id": "1731c3530bffb876deb9e00dfffdf9841a8412cd", "target": 1, "func": "static int read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    MmDemuxContext *mm = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    unsigned char preamble[MM_PREAMBLE_SIZE];\n\n    unsigned int type, length;\n\n\n\n    while(1) {\n\n\n\n        if (avio_read(pb, preamble, MM_PREAMBLE_SIZE) != MM_PREAMBLE_SIZE) {\n\n            return AVERROR(EIO);\n\n\n\n\n        type = AV_RL16(&preamble[0]);\n\n        length = AV_RL16(&preamble[2]);\n\n\n\n        switch(type) {\n\n        case MM_TYPE_PALETTE :\n\n        case MM_TYPE_INTER :\n\n        case MM_TYPE_INTRA :\n\n        case MM_TYPE_INTRA_HH :\n\n        case MM_TYPE_INTER_HH :\n\n        case MM_TYPE_INTRA_HHV :\n\n        case MM_TYPE_INTER_HHV :\n\n            /* output preamble + data */\n\n            if (av_new_packet(pkt, length + MM_PREAMBLE_SIZE))\n\n                return AVERROR(ENOMEM);\n\n            memcpy(pkt->data, preamble, MM_PREAMBLE_SIZE);\n\n            if (avio_read(pb, pkt->data + MM_PREAMBLE_SIZE, length) != length)\n\n                return AVERROR(EIO);\n\n            pkt->size = length + MM_PREAMBLE_SIZE;\n\n            pkt->stream_index = 0;\n\n            pkt->pts = mm->video_pts;\n\n            if (type!=MM_TYPE_PALETTE)\n\n                mm->video_pts++;\n\n            return 0;\n\n\n\n        case MM_TYPE_AUDIO :\n\n\n\n\n\n\n\n            if (av_get_packet(s->pb, pkt, length)<0)\n\n                return AVERROR(ENOMEM);\n\n            pkt->size = length;\n\n            pkt->stream_index = 1;\n\n            pkt->pts = mm->audio_pts++;\n\n            return 0;\n\n\n\n        default :\n\n            av_log(s, AV_LOG_INFO, \"unknown chunk type 0x%x\\n\", type);\n\n\n\n", "idx": 14947}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static int coroutine_fn qed_aio_write_cow(QEDAIOCB *acb)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    uint64_t start, len, offset;\n\n    int ret;\n\n\n\n    /* Populate front untouched region of new data cluster */\n\n    start = qed_start_of_cluster(s, acb->cur_pos);\n\n    len = qed_offset_into_cluster(s, acb->cur_pos);\n\n\n\n    trace_qed_aio_write_prefill(s, acb, start, len, acb->cur_cluster);\n\n    ret = qed_copy_from_backing_file(s, start, len, acb->cur_cluster);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Populate back untouched region of new data cluster */\n\n    start = acb->cur_pos + acb->cur_qiov.size;\n\n    len = qed_start_of_cluster(s, start + s->header.cluster_size - 1) - start;\n\n    offset = acb->cur_cluster +\n\n             qed_offset_into_cluster(s, acb->cur_pos) +\n\n             acb->cur_qiov.size;\n\n\n\n    trace_qed_aio_write_postfill(s, acb, start, len, offset);\n\n    ret = qed_copy_from_backing_file(s, start, len, offset);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    ret = qed_aio_write_main(acb);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (s->bs->backing) {\n\n        /*\n\n         * Flush new data clusters before updating the L2 table\n\n         *\n\n         * This flush is necessary when a backing file is in use.  A crash\n\n         * during an allocating write could result in empty clusters in the\n\n         * image.  If the write only touched a subregion of the cluster,\n\n         * then backing image sectors have been lost in the untouched\n\n         * region.  The solution is to flush after writing a new data\n\n         * cluster and before updating the L2 table.\n\n         */\n\n        ret = bdrv_co_flush(s->bs->file->bs);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14958}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "static void end_list(Visitor *v)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n    siv->head = true;\n\n}\n", "idx": 14962}
{"project": "qemu", "commit_id": "c0f4ce7751f0b9a9a7815f931a09a6c3de127cee", "target": 0, "func": "static void do_cont(void)\n\n{\n\n    vm_start();\n\n}\n", "idx": 14965}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void AUD_remove_card (QEMUSoundCard *card)\n\n{\n\n    LIST_REMOVE (card, entries);\n\n    qemu_free (card->name);\n\n}\n", "idx": 14968}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void phys_page_set_level(PhysPageEntry *lp, target_phys_addr_t *index,\n\n                                target_phys_addr_t *nb, uint16_t leaf,\n\n                                int level)\n\n{\n\n    PhysPageEntry *p;\n\n    int i;\n\n    target_phys_addr_t step = (target_phys_addr_t)1 << (level * L2_BITS);\n\n\n\n    if (!lp->is_leaf && lp->ptr == PHYS_MAP_NODE_NIL) {\n\n        lp->ptr = phys_map_node_alloc();\n\n        p = phys_map_nodes[lp->ptr];\n\n        if (level == 0) {\n\n            for (i = 0; i < L2_SIZE; i++) {\n\n                p[i].is_leaf = 1;\n\n                p[i].ptr = phys_section_unassigned;\n\n            }\n\n        }\n\n    } else {\n\n        p = phys_map_nodes[lp->ptr];\n\n    }\n\n    lp = &p[(*index >> (level * L2_BITS)) & (L2_SIZE - 1)];\n\n\n\n    while (*nb && lp < &p[L2_SIZE]) {\n\n        if ((*index & (step - 1)) == 0 && *nb >= step) {\n\n            lp->is_leaf = true;\n\n            lp->ptr = leaf;\n\n            *index += step;\n\n            *nb -= step;\n\n        } else {\n\n            phys_page_set_level(lp, index, nb, leaf, level - 1);\n\n        }\n\n        ++lp;\n\n    }\n\n}\n", "idx": 14971}
{"project": "FFmpeg", "commit_id": "d584533cf38141172e20bae5436629ee17c8ce50", "target": 0, "func": "static int queue_attached_pictures(AVFormatContext *s)\n\n{\n\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++)\n\n        if (s->streams[i]->disposition & AV_DISPOSITION_ATTACHED_PIC &&\n\n            s->streams[i]->discard < AVDISCARD_ALL) {\n\n            AVPacket copy = s->streams[i]->attached_pic;\n\n            copy.buf = av_buffer_ref(copy.buf);\n\n            if (!copy.buf)\n\n                return AVERROR(ENOMEM);\n\n\n\n            add_to_pktbuf(&s->internal->raw_packet_buffer, &copy,\n\n                          &s->internal->raw_packet_buffer_end);\n\n        }\n\n    return 0;\n\n}\n", "idx": 14988}
{"project": "qemu", "commit_id": "82a41186941c419afde977f477f19c545b40c1c5", "target": 1, "func": "AioContext *aio_context_new(Error **errp)\n\n{\n\n    int ret;\n\n    AioContext *ctx;\n\n\n\n    ctx = (AioContext *) g_source_new(&aio_source_funcs, sizeof(AioContext));\n\n    aio_context_setup(ctx);\n\n\n\n    ret = event_notifier_init(&ctx->notifier, false);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Failed to initialize event notifier\");\n\n        goto fail;\n\n    }\n\n    g_source_set_can_recurse(&ctx->source, true);\n\n    aio_set_event_notifier(ctx, &ctx->notifier,\n\n                           false,\n\n                           (EventNotifierHandler *)\n\n                           event_notifier_dummy_cb,\n\n                           event_notifier_poll);\n\n#ifdef CONFIG_LINUX_AIO\n\n    ctx->linux_aio = NULL;\n\n#endif\n\n    ctx->thread_pool = NULL;\n\n    qemu_mutex_init(&ctx->bh_lock);\n\n    qemu_rec_mutex_init(&ctx->lock);\n\n    timerlistgroup_init(&ctx->tlg, aio_timerlist_notify, ctx);\n\n\n\n\n    ctx->poll_max_ns = 0;\n\n\n\n\n\n    return ctx;\n\nfail:\n\n    g_source_destroy(&ctx->source);\n\n    return NULL;\n\n}", "idx": 15000}
{"project": "FFmpeg", "commit_id": "0c22311b56e66115675c4a96e4c78547886a4171", "target": 0, "func": "static void opt_frame_pad_top(const char *arg)\n\n{\n\n    frame_padtop = atoi(arg);\n\n    if (frame_padtop < 0) {\n\n        fprintf(stderr, \"Incorrect top pad size\\n\");\n\n        av_exit(1);\n\n    }\n\n}\n", "idx": 15022}
{"project": "qemu", "commit_id": "17ec9921a7e40d47c05effcf2c254f162bd63aad", "target": 0, "func": "static void chr_event(void *opaque, int event)\n\n{\n\n    Terminal3270 *t = opaque;\n\n    CcwDevice *ccw_dev = CCW_DEVICE(t);\n\n    SubchDev *sch = ccw_dev->sch;\n\n\n\n    /* Ensure the initial status correct, always reset them. */\n\n    t->in_len = 0;\n\n    t->out_len = 0;\n\n    t->handshake_done = false;\n\n    if (t->timer_tag) {\n\n        g_source_remove(t->timer_tag);\n\n        t->timer_tag = 0;\n\n    }\n\n\n\n    switch (event) {\n\n    case CHR_EVENT_OPENED:\n\n        /*\n\n         * 3270 does handshake firstly by the negotiate options in\n\n         * char-socket.c. Once qemu receives the terminal-type of the\n\n         * client, mark handshake done and trigger everything rolling again.\n\n         */\n\n        t->timer_tag = g_timeout_add_seconds(600, send_timing_mark_cb, t);\n\n        break;\n\n    case CHR_EVENT_CLOSED:\n\n        sch->curr_status.scsw.dstat = SCSW_DSTAT_DEVICE_END;\n\n        css_conditional_io_interrupt(sch);\n\n        break;\n\n    }\n\n}\n", "idx": 15023}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static void tgen_ext8u(TCGContext *s, TCGType type, TCGReg dest, TCGReg src)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        tcg_out_insn(s, RRE, LLGCR, dest, src);\n\n        return;\n\n    }\n\n\n\n    if (dest == src) {\n\n        tcg_out_movi(s, type, TCG_TMP0, 0xff);\n\n        src = TCG_TMP0;\n\n    } else {\n\n        tcg_out_movi(s, type, dest, 0xff);\n\n    }\n\n    if (type == TCG_TYPE_I32) {\n\n        tcg_out_insn(s, RR, NR, dest, src);\n\n    } else {\n\n        tcg_out_insn(s, RRE, NGR, dest, src);\n\n    }\n\n}\n", "idx": 15026}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static bool esp_mem_accepts(void *opaque, target_phys_addr_t addr,\n\n                            unsigned size, bool is_write)\n\n{\n\n    return (size == 1) || (is_write && size == 4);\n\n}\n", "idx": 15027}
{"project": "qemu", "commit_id": "16b781aaef69c90d5f4f5456615f0c26a4f45740", "target": 0, "func": "SDState *sd_init(BlockBackend *blk, bool is_spi)\n\n{\n\n    SDState *sd;\n\n\n\n    if (blk && blk_is_read_only(blk)) {\n\n        fprintf(stderr, \"sd_init: Cannot use read-only drive\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    sd = (SDState *) g_malloc0(sizeof(SDState));\n\n    sd->buf = blk_blockalign(blk, 512);\n\n    sd->spi = is_spi;\n\n    sd->enable = true;\n\n    sd_reset(sd, blk);\n\n    if (sd->blk) {\n\n        blk_attach_dev_nofail(sd->blk, sd);\n\n        blk_set_dev_ops(sd->blk, &sd_block_ops, sd);\n\n    }\n\n    vmstate_register(NULL, -1, &sd_vmstate, sd);\n\n    return sd;\n\n}\n", "idx": 15041}
{"project": "qemu", "commit_id": "f0d2a4d4d63dd2f0f3ecb2d591b979b0e7f24a22", "target": 0, "func": "iscsi_synccache10_cb(struct iscsi_context *iscsi, int status,\n\n                     void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    if (acb->canceled != 0) {\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status != 0) {\n\n        if (status == SCSI_STATUS_CHECK_CONDITION\n\n            && acb->task->sense.key == SCSI_SENSE_UNIT_ATTENTION\n\n            && acb->retries-- > 0) {\n\n            if (acb->task != NULL) {\n\n                scsi_free_scsi_task(acb->task);\n\n                acb->task = NULL;\n\n            }\n\n            if (iscsi_aio_flush_acb(acb) == 0) {\n\n                iscsi_set_events(acb->iscsilun);\n\n                return;\n\n            }\n\n        }\n\n        error_report(\"Failed to sync10 data on iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(acb);\n\n}\n", "idx": 15069}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "static void virtio_net_set_config(VirtIODevice *vdev, const uint8_t *config)\n\n{\n\n    VirtIONet *n = VIRTIO_NET(vdev);\n\n    struct virtio_net_config netcfg = {};\n\n\n\n    memcpy(&netcfg, config, n->config_size);\n\n\n\n    if (!(vdev->guest_features >> VIRTIO_NET_F_CTRL_MAC_ADDR & 1) &&\n\n        memcmp(netcfg.mac, n->mac, ETH_ALEN)) {\n\n        memcpy(n->mac, netcfg.mac, ETH_ALEN);\n\n        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);\n\n    }\n\n}\n", "idx": 15086}
{"project": "qemu", "commit_id": "2bfe11c8fac96db4f94abbe818fbc964a6744130", "target": 1, "func": "void trace_init_vcpu_events(void)\n\n{\n\n    TraceEvent *ev = NULL;\n\n    while ((ev = trace_event_pattern(\"*\", ev)) != NULL) {\n\n        if (trace_event_is_vcpu(ev) &&\n\n            trace_event_get_state_static(ev) &&\n\n            trace_event_get_state_dynamic(ev)) {\n\n            TraceEventID id = trace_event_get_id(ev);\n\n            /* check preconditions */\n\n            assert(trace_events_dstate[id] == 1);\n\n            /* disable early-init state ... */\n\n            trace_events_dstate[id] = 0;\n\n            trace_events_enabled_count--;\n\n            /* ... and properly re-enable */\n\n            trace_event_set_state_dynamic(ev, true);\n\n        }\n\n    }\n\n}\n", "idx": 15130}
{"project": "qemu", "commit_id": "95b5edcd92d64c7b8fe9f2e3e0725fdf84be0dfa", "target": 0, "func": "static int scsi_disk_initfn(SCSIDevice *dev)\n\n{\n\n    SCSIDriveKind kind;\n\n\n\n    if (!dev->conf.bs) {\n\n        kind = SCSI_HD;         /* will die in scsi_initfn() */\n\n    } else {\n\n        kind = bdrv_get_type_hint(dev->conf.bs) == BDRV_TYPE_CDROM\n\n            ? SCSI_CD : SCSI_HD;\n\n    }\n\n\n\n    return scsi_initfn(dev, kind);\n\n}\n", "idx": 15172}
{"project": "qemu", "commit_id": "5cd230819ec26caf199bf73d38cf2407344e4443", "target": 0, "func": "static int cloop_read(BlockDriverState *bs, int64_t sector_num,\n\n                    uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVCloopState *s = bs->opaque;\n\n    int i;\n\n\n\n    for (i = 0; i < nb_sectors; i++) {\n\n        uint32_t sector_offset_in_block =\n\n            ((sector_num + i) % s->sectors_per_block),\n\n            block_num = (sector_num + i) / s->sectors_per_block;\n\n        if (cloop_read_block(bs, block_num) != 0) {\n\n            return -1;\n\n        }\n\n        memcpy(buf + i * 512,\n\n            s->uncompressed_block + sector_offset_in_block * 512, 512);\n\n    }\n\n    return 0;\n\n}\n", "idx": 15179}
{"project": "qemu", "commit_id": "b6dcbe086c77ec683f5ff0b693593cda1d61f3a1", "target": 0, "func": "ram_addr_t ppc4xx_sdram_adjust(ram_addr_t ram_size, int nr_banks,\n\n                               target_phys_addr_t ram_bases[],\n\n                               target_phys_addr_t ram_sizes[],\n\n                               const unsigned int sdram_bank_sizes[])\n\n{\n\n    ram_addr_t size_left = ram_size;\n\n    int i;\n\n    int j;\n\n\n\n    for (i = 0; i < nr_banks; i++) {\n\n        for (j = 0; sdram_bank_sizes[j] != 0; j++) {\n\n            unsigned int bank_size = sdram_bank_sizes[j];\n\n\n\n            if (bank_size <= size_left) {\n\n                char name[32];\n\n                snprintf(name, sizeof(name), \"ppc4xx.sdram%d\", i);\n\n                ram_bases[i] = qemu_ram_alloc(NULL, name, bank_size);\n\n                ram_sizes[i] = bank_size;\n\n                size_left -= bank_size;\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (!size_left) {\n\n            /* No need to use the remaining banks. */\n\n            break;\n\n        }\n\n    }\n\n\n\n    ram_size -= size_left;\n\n    if (size_left)\n\n        printf(\"Truncating memory to %d MiB to fit SDRAM controller limits.\\n\",\n\n               (int)(ram_size >> 20));\n\n\n\n    return ram_size;\n\n}\n", "idx": 15183}
{"project": "qemu", "commit_id": "57e49b40745ceb6c198cc58274b705afb5f20493", "target": 0, "func": "static inline int check_fit(tcg_target_long val, unsigned int bits)\n\n{\n\n    return ((val << ((sizeof(tcg_target_long) * 8 - bits))\n\n             >> (sizeof(tcg_target_long) * 8 - bits)) == val);\n\n}\n", "idx": 15187}
{"project": "qemu", "commit_id": "d644f8beaa268a4e36b473f283f0b5a5ff66d8c2", "target": 0, "func": "void *qemu_memalign(size_t alignment, size_t size)\n\n{\n\n    return VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);\n\n}\n", "idx": 15191}
{"project": "qemu", "commit_id": "661e32fb3cb71c7e019daee375be4bb487b9917c", "target": 1, "func": "static void virtio_scsi_handle_ctrl_req(VirtIOSCSI *s, VirtIOSCSIReq *req)\n\n{\n\n    VirtIODevice *vdev = (VirtIODevice *)s;\n\n    uint32_t type;\n\n    int r = 0;\n\n\n\n    if (iov_to_buf(req->elem.out_sg, req->elem.out_num, 0,\n\n                &type, sizeof(type)) < sizeof(type)) {\n\n        virtio_scsi_bad_req();\n\n        return;\n\n    }\n\n\n\n    virtio_tswap32s(vdev, &type);\n\n    if (type == VIRTIO_SCSI_T_TMF) {\n\n        if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICtrlTMFReq),\n\n                    sizeof(VirtIOSCSICtrlTMFResp)) < 0) {\n\n            virtio_scsi_bad_req();\n\n        } else {\n\n            r = virtio_scsi_do_tmf(s, req);\n\n        }\n\n\n\n    } else if (type == VIRTIO_SCSI_T_AN_QUERY ||\n\n               type == VIRTIO_SCSI_T_AN_SUBSCRIBE) {\n\n        if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICtrlANReq),\n\n                    sizeof(VirtIOSCSICtrlANResp)) < 0) {\n\n            virtio_scsi_bad_req();\n\n        } else {\n\n            req->resp.an.event_actual = 0;\n\n            req->resp.an.response = VIRTIO_SCSI_S_OK;\n\n        }\n\n    }\n\n    if (r == 0) {\n\n        virtio_scsi_complete_req(req);\n\n    } else {\n\n        assert(r == -EINPROGRESS);\n\n    }\n\n}\n", "idx": 15198}
{"project": "qemu", "commit_id": "20c334a797bf46a4ee59a6e42be6d5e7c3cda585", "target": 1, "func": "static inline uint32_t mipsdsp_sub32(int32_t a, int32_t b, CPUMIPSState *env)\n\n{\n\n    int32_t temp;\n\n\n\n    temp = a - b;\n\n    if (MIPSDSP_OVERFLOW(a, -b, temp, 0x80000000)) {\n\n        set_DSPControl_overflow_flag(1, 20, env);\n\n    }\n\n\n\n    return temp;\n\n}\n", "idx": 15204}
{"project": "qemu", "commit_id": "c7e35da348e2e4df072e6979c48fa5283e07d1db", "target": 1, "func": "static inline abi_long host_to_target_timespec(abi_ulong target_addr,\n\n                                               struct timespec *host_ts)\n\n{\n\n    struct target_timespec *target_ts;\n\n\n\n    if (!lock_user_struct(VERIFY_WRITE, target_ts, target_addr, 0))\n\n        return -TARGET_EFAULT;\n\n    target_ts->tv_sec = tswapal(host_ts->tv_sec);\n\n    target_ts->tv_nsec = tswapal(host_ts->tv_nsec);\n\n    unlock_user_struct(target_ts, target_addr, 1);\n\n    return 0;\n\n}\n", "idx": 15217}
{"project": "FFmpeg", "commit_id": "e5cf100d3daaf3fa48d44ae575af916473f85544", "target": 0, "func": "static int mpegvideo_probe(AVProbeData *p)\n\n{\n\n    uint32_t code= -1;\n\n    int pic=0, seq=0, slice=0, pspack=0, vpes=0, apes=0, res=0;\n\n    int i;\n\n\n\n    for(i=0; i<p->buf_size; i++){\n\n        code = (code<<8) + p->buf[i];\n\n        if ((code & 0xffffff00) == 0x100) {\n\n            switch(code){\n\n            case     SEQ_START_CODE:   seq++; break;\n\n            case PICTURE_START_CODE:   pic++; break;\n\n            case    PACK_START_CODE: pspack++; break;\n\n            case              0x1b6:\n\n                                        res++; break;\n\n            }\n\n            if (code >= SLICE_START_CODE && code <= 0x1af) slice++;\n\n            if     ((code & 0x1f0) == VIDEO_ID)   vpes++;\n\n            else if((code & 0x1e0) == AUDIO_ID)   apes++;\n\n        }\n\n    }\n\n    if(seq && seq*9<=pic*10 && pic*9<=slice*10 && !pspack && !apes && !res) {\n\n        if(vpes) return AVPROBE_SCORE_MAX/8;\n\n        else     return pic>1 ? AVPROBE_SCORE_MAX/2+1 : AVPROBE_SCORE_MAX/4; // +1 for .mpg\n\n    }\n\n    return 0;\n\n}\n", "idx": 15219}
{"project": "FFmpeg", "commit_id": "fb93e61e2b7baa44ff991bc0ce96291490a0188e", "target": 0, "func": "av_cold void ff_yadif_init_x86(YADIFContext *yadif)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (HAVE_MMX && cpu_flags & AV_CPU_FLAG_MMX)\n\n        yadif->filter_line = yadif_filter_line_mmx;\n\n    if (HAVE_SSE && cpu_flags & AV_CPU_FLAG_SSE2)\n\n        yadif->filter_line = yadif_filter_line_sse2;\n\n    if (HAVE_SSSE3 && cpu_flags & AV_CPU_FLAG_SSSE3)\n\n        yadif->filter_line = yadif_filter_line_ssse3;\n\n}\n", "idx": 15222}
{"project": "FFmpeg", "commit_id": "feb6a94f740bccc8e369f8b74714b940490f3901", "target": 1, "func": "void av_frame_unref(AVFrame *frame)\n{\n    int i;\n    wipe_side_data(frame);\n    for (i = 0; i < FF_ARRAY_ELEMS(frame->buf); i++)\n        av_buffer_unref(&frame->buf[i]);\n    for (i = 0; i < frame->nb_extended_buf; i++)\n        av_buffer_unref(&frame->extended_buf[i]);\n    av_freep(&frame->extended_buf);\n    av_dict_free(&frame->metadata);\n    av_buffer_unref(&frame->qp_table_buf);\n    get_frame_defaults(frame);\n}", "idx": 15225}
{"project": "qemu", "commit_id": "dac23a6c05e543590508b48b8ed31d89b0c99c61", "target": 1, "func": "static bool load_asl(GArray *sdts, AcpiSdtTable *sdt)\n\n{\n\n    AcpiSdtTable *temp;\n\n    GError *error = NULL;\n\n    GString *command_line = g_string_new(iasl);\n\n    gint fd;\n\n    gchar *out, *out_err;\n\n    gboolean ret;\n\n    int i;\n\n\n\n    fd = g_file_open_tmp(\"asl-XXXXXX.dsl\", &sdt->asl_file, &error);\n\n    g_assert_no_error(error);\n\n    close(fd);\n\n\n\n    /* build command line */\n\n    g_string_append_printf(command_line, \" -p %s \", sdt->asl_file);\n\n    if (compare_signature(sdt, \"DSDT\") ||\n\n        compare_signature(sdt, \"SSDT\")) {\n\n        for (i = 0; i < sdts->len; ++i) {\n\n            temp = &g_array_index(sdts, AcpiSdtTable, i);\n\n            if (compare_signature(temp, \"DSDT\") ||\n\n                compare_signature(temp, \"SSDT\")) {\n\n                g_string_append_printf(command_line, \"-e %s \", temp->aml_file);\n\n            }\n\n        }\n\n    }\n\n    g_string_append_printf(command_line, \"-d %s\", sdt->aml_file);\n\n\n\n    /* pass 'out' and 'out_err' in order to be redirected */\n\n    ret = g_spawn_command_line_sync(command_line->str, &out, &out_err, NULL, &error);\n\n    g_assert_no_error(error);\n\n\n\n    if (ret) {\n\n        ret = g_file_get_contents(sdt->asl_file, (gchar **)&sdt->asl,\n\n                                  &sdt->asl_len, &error);\n\n        g_assert(ret);\n\n        g_assert_no_error(error);\n\n        g_assert(sdt->asl_len);\n\n    }\n\n\n\n    g_free(out);\n\n    g_free(out_err);\n\n    g_string_free(command_line, true);\n\n\n\n    return !ret;\n\n}\n", "idx": 15226}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "MemoryRegionSection memory_region_find(MemoryRegion *address_space,\n\n                                       target_phys_addr_t addr, uint64_t size)\n\n{\n\n    AddressSpace *as = memory_region_to_address_space(address_space);\n\n    AddrRange range = addrrange_make(int128_make64(addr),\n\n                                     int128_make64(size));\n\n    FlatRange *fr = address_space_lookup(as, range);\n\n    MemoryRegionSection ret = { .mr = NULL, .size = 0 };\n\n\n\n    if (!fr) {\n\n        return ret;\n\n    }\n\n\n\n    while (fr > as->current_map.ranges\n\n           && addrrange_intersects(fr[-1].addr, range)) {\n\n        --fr;\n\n    }\n\n\n\n    ret.mr = fr->mr;\n\n    range = addrrange_intersection(range, fr->addr);\n\n    ret.offset_within_region = fr->offset_in_region;\n\n    ret.offset_within_region += int128_get64(int128_sub(range.start,\n\n                                                        fr->addr.start));\n\n    ret.size = int128_get64(range.size);\n\n    ret.offset_within_address_space = int128_get64(range.start);\n\n    ret.readonly = fr->readonly;\n\n    return ret;\n\n}\n", "idx": 15245}
{"project": "FFmpeg", "commit_id": "e1ba29c76430ce511fd901c8b7a1bd199b169dc0", "target": 1, "func": "static int decode_i_block(FourXContext *f, DCTELEM *block){\n    int code, i, j, level, val;\n    /* DC coef */\n    val = get_vlc2(&f->pre_gb, f->pre_vlc.table, ACDC_VLC_BITS, 3);\n    if (val>>4){\n        av_log(f->avctx, AV_LOG_ERROR, \"error dc run != 0\\n\");\n    if(val)\n        val = get_xbits(&f->gb, val);\n    val = val * dequant_table[0] + f->last_dc;\n    f->last_dc =\n    block[0] = val;\n    /* AC coefs */\n    i = 1;\n    for(;;) {\n        code = get_vlc2(&f->pre_gb, f->pre_vlc.table, ACDC_VLC_BITS, 3);\n        /* EOB */\n        if (code == 0)\n            break;\n        if (code == 0xf0) {\n            i += 16;\n        } else {\n            level = get_xbits(&f->gb, code & 0xf);\n            i += code >> 4;\n            if (i >= 64) {\n                av_log(f->avctx, AV_LOG_ERROR, \"run %d oveflow\\n\", i);\n                return 0;\n            j= ff_zigzag_direct[i];\n            block[j] = level * dequant_table[j];\n            i++;\n            if (i >= 64)\n                break;\n    return 0;", "idx": 15262}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "uint64_t qpci_io_readq(QPCIDevice *dev, void *data)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    if (addr < QPCI_PIO_LIMIT) {\n\n        return dev->bus->pio_readq(dev->bus, addr);\n\n    } else {\n\n        uint64_t val;\n\n        dev->bus->memread(dev->bus, addr, &val, sizeof(val));\n\n        return le64_to_cpu(val);\n\n    }\n\n}\n", "idx": 15264}
{"project": "FFmpeg", "commit_id": "f738140807f504c9af7850042067777832f05e88", "target": 1, "func": "static int decode_nal_sei_prefix(GetBitContext *gb, HEVCSEIContext *s, const HEVCParamSets *ps,\n\n                                 int type, int size, void *logctx)\n\n{\n\n    switch (type) {\n\n    case 256:  // Mismatched value from HM 8.1\n\n        return decode_nal_sei_decoded_picture_hash(&s->picture_hash, gb);\n\n    case HEVC_SEI_TYPE_FRAME_PACKING:\n\n        return decode_nal_sei_frame_packing_arrangement(&s->frame_packing, gb);\n\n    case HEVC_SEI_TYPE_DISPLAY_ORIENTATION:\n\n        return decode_nal_sei_display_orientation(&s->display_orientation, gb);\n\n    case HEVC_SEI_TYPE_PICTURE_TIMING:\n\n        {\n\n            int ret = decode_pic_timing(s, gb, ps, logctx);\n\n            av_log(logctx, AV_LOG_DEBUG, \"Skipped PREFIX SEI %d\\n\", type);\n\n            skip_bits(gb, 8 * size);\n\n            return ret;\n\n        }\n\n    case HEVC_SEI_TYPE_MASTERING_DISPLAY_INFO:\n\n        return decode_nal_sei_mastering_display_info(&s->mastering_display, gb);\n\n    case HEVC_SEI_TYPE_CONTENT_LIGHT_LEVEL_INFO:\n\n        return decode_nal_sei_content_light_info(&s->content_light, gb);\n\n    case HEVC_SEI_TYPE_ACTIVE_PARAMETER_SETS:\n\n        active_parameter_sets(s, gb, logctx);\n\n        av_log(logctx, AV_LOG_DEBUG, \"Skipped PREFIX SEI %d\\n\", type);\n\n        return 0;\n\n    case HEVC_SEI_TYPE_USER_DATA_REGISTERED_ITU_T_T35:\n\n        return decode_nal_sei_user_data_registered_itu_t_t35(s, gb, size);\n\n    default:\n\n        av_log(logctx, AV_LOG_DEBUG, \"Skipped PREFIX SEI %d\\n\", type);\n\n        skip_bits_long(gb, 8 * size);\n\n        return 0;\n\n    }\n\n}\n", "idx": 15296}
{"project": "qemu", "commit_id": "6c1fef6b59563cc415f21e03f81539ed4b33ad90", "target": 1, "func": "static void handle_satn_stop(ESPState *s)\n\n{\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_satn_stop;\n\n        return;\n\n    }\n\n    s->cmdlen = get_cmd(s, s->cmdbuf);\n\n    if (s->cmdlen) {\n\n        trace_esp_handle_satn_stop(s->cmdlen);\n\n        s->do_cmd = 1;\n\n        s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;\n\n        s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n        s->rregs[ESP_RSEQ] = SEQ_CD;\n\n        esp_raise_irq(s);\n\n    }\n\n}\n", "idx": 15312}
{"project": "FFmpeg", "commit_id": "c617c669e9fce59905915c3ba1053f535add6a06", "target": 1, "func": "static int xv_write_trailer(AVFormatContext *s)\n\n{\n\n    XVContext *xv = s->priv_data;\n\n\n\n    XShmDetach(xv->display, &xv->yuv_shminfo);\n\n    shmdt(xv->yuv_image->data);\n\n    XFree(xv->yuv_image);\n\n\n    XCloseDisplay(xv->display);\n\n    return 0;\n\n}", "idx": 15319}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "void ff_biweight_h264_pixels16_8_msa(uint8_t *dst, uint8_t *src,\n\n                                     int stride, int height,\n\n                                     int log2_denom, int weight_dst,\n\n                                     int weight_src, int offset)\n\n{\n\n    avc_biwgt_16width_msa(src, stride,\n\n                          dst, stride,\n\n                          height, log2_denom,\n\n                          weight_src, weight_dst, offset);\n\n}\n", "idx": 15330}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static void vt82c686b_write_config(PCIDevice * d, uint32_t address,\n\n                                   uint32_t val, int len)\n\n{\n\n    VT82C686BState *vt686 = DO_UPCAST(VT82C686BState, dev, d);\n\n\n\n    DPRINTF(\"vt82c686b_write_config  address 0x%x  val 0x%x len 0x%x \\n\",\n\n           address, val, len);\n\n\n\n    pci_default_write_config(d, address, val, len);\n\n    if (address == 0x85) {  /* enable or disable super IO configure */\n\n        if (val & 0x2) {\n\n            /* floppy also uses 0x3f0 and 0x3f1.\n\n             * But we do not emulate flopy,so just set it here. */\n\n            isa_unassign_ioport(0x3f0, 2);\n\n            register_ioport_read(0x3f0, 2, 1, superio_ioport_readb,\n\n                                 &vt686->superio_conf);\n\n            register_ioport_write(0x3f0, 2, 1, superio_ioport_writeb,\n\n                                  &vt686->superio_conf);\n\n        } else {\n\n            isa_unassign_ioport(0x3f0, 2);\n\n        }\n\n    }\n\n}\n", "idx": 15337}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stl_le_phys(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    stl_phys_internal(addr, val, DEVICE_LITTLE_ENDIAN);\n\n}\n", "idx": 15358}
{"project": "qemu", "commit_id": "31ce5e0c49821d92fb30cce2f3055ef33613b287", "target": 1, "func": "static void kvm_mce_broadcast_rest(CPUState *env)\n\n{\n\n    CPUState *cenv;\n\n    int family, model, cpuver = env->cpuid_version;\n\n\n\n    family = (cpuver >> 8) & 0xf;\n\n    model = ((cpuver >> 12) & 0xf0) + ((cpuver >> 4) & 0xf);\n\n\n\n    /* Broadcast MCA signal for processor version 06H_EH and above */\n\n    if ((family == 6 && model >= 14) || family > 6) {\n\n        for (cenv = first_cpu; cenv != NULL; cenv = cenv->next_cpu) {\n\n            if (cenv == env) {\n\n                continue;\n\n            }\n\n            kvm_inject_x86_mce(cenv, 1, MCI_STATUS_VAL | MCI_STATUS_UC,\n\n                               MCG_STATUS_MCIP | MCG_STATUS_RIPV, 0, 0, 1);\n\n        }\n\n    }\n\n}\n", "idx": 15397}
{"project": "FFmpeg", "commit_id": "6a4832caaede15e3d918b1408ff83fe30324507b", "target": 0, "func": "void ff_put_dirac_pixels32_sse2(uint8_t *dst, const uint8_t *src[5], int stride, int h)\n\n{\n\n    if (h&3) {\n\n        ff_put_dirac_pixels32_c(dst, src, stride, h);\n\n    } else {\n\n    ff_put_pixels16_sse2(dst   , src[0]   , stride, h);\n\n    ff_put_pixels16_sse2(dst+16, src[0]+16, stride, h);\n\n    }\n\n}\n", "idx": 15403}
{"project": "qemu", "commit_id": "9db1c0f7a94c6382e2b3e1365566a9a8b8ae74c1", "target": 0, "func": "void bdrv_guess_geometry(BlockDriverState *bs, int *pcyls, int *pheads, int *psecs)\n\n{\n\n    int translation, lba_detected = 0;\n\n    int cylinders, heads, secs;\n\n    uint64_t nb_sectors;\n\n\n\n    /* if a geometry hint is available, use it */\n\n    bdrv_get_geometry(bs, &nb_sectors);\n\n    bdrv_get_geometry_hint(bs, &cylinders, &heads, &secs);\n\n    translation = bdrv_get_translation_hint(bs);\n\n    if (cylinders != 0) {\n\n        *pcyls = cylinders;\n\n        *pheads = heads;\n\n        *psecs = secs;\n\n    } else {\n\n        if (guess_disk_lchs(bs, &cylinders, &heads, &secs) == 0) {\n\n            if (heads > 16) {\n\n                /* if heads > 16, it means that a BIOS LBA\n\n                   translation was active, so the default\n\n                   hardware geometry is OK */\n\n                lba_detected = 1;\n\n                goto default_geometry;\n\n            } else {\n\n                *pcyls = cylinders;\n\n                *pheads = heads;\n\n                *psecs = secs;\n\n                /* disable any translation to be in sync with\n\n                   the logical geometry */\n\n                if (translation == BIOS_ATA_TRANSLATION_AUTO) {\n\n                    bdrv_set_translation_hint(bs,\n\n                                              BIOS_ATA_TRANSLATION_NONE);\n\n                }\n\n            }\n\n        } else {\n\n        default_geometry:\n\n            /* if no geometry, use a standard physical disk geometry */\n\n            cylinders = nb_sectors / (16 * 63);\n\n\n\n            if (cylinders > 16383)\n\n                cylinders = 16383;\n\n            else if (cylinders < 2)\n\n                cylinders = 2;\n\n            *pcyls = cylinders;\n\n            *pheads = 16;\n\n            *psecs = 63;\n\n            if ((lba_detected == 1) && (translation == BIOS_ATA_TRANSLATION_AUTO)) {\n\n                if ((*pcyls * *pheads) <= 131072) {\n\n                    bdrv_set_translation_hint(bs,\n\n                                              BIOS_ATA_TRANSLATION_LARGE);\n\n                } else {\n\n                    bdrv_set_translation_hint(bs,\n\n                                              BIOS_ATA_TRANSLATION_LBA);\n\n                }\n\n            }\n\n        }\n\n        bdrv_set_geometry_hint(bs, *pcyls, *pheads, *psecs);\n\n    }\n\n}\n", "idx": 15421}
{"project": "qemu", "commit_id": "7b595f35d89d73bc69c35bf3980a89c420e8a44b", "target": 0, "func": "static void glib_pollfds_fill(uint32_t *cur_timeout)\n\n{\n\n    GMainContext *context = g_main_context_default();\n\n    int timeout = 0;\n\n    int n;\n\n\n\n    g_main_context_prepare(context, &max_priority);\n\n\n\n    glib_pollfds_idx = gpollfds->len;\n\n    n = glib_n_poll_fds;\n\n    do {\n\n        GPollFD *pfds;\n\n        glib_n_poll_fds = n;\n\n        g_array_set_size(gpollfds, glib_pollfds_idx + glib_n_poll_fds);\n\n        pfds = &g_array_index(gpollfds, GPollFD, glib_pollfds_idx);\n\n        n = g_main_context_query(context, max_priority, &timeout, pfds,\n\n                                 glib_n_poll_fds);\n\n    } while (n != glib_n_poll_fds);\n\n\n\n    if (timeout >= 0 && timeout < *cur_timeout) {\n\n        *cur_timeout = timeout;\n\n    }\n\n}\n", "idx": 15445}
{"project": "qemu", "commit_id": "1c275925bfbbc2de84a8f0e09d1dd70bbefb6da3", "target": 0, "func": "long do_sigreturn(CPUMBState *env)\n\n{\n\n    struct target_signal_frame *frame;\n\n    abi_ulong frame_addr;\n\n    target_sigset_t target_set;\n\n    sigset_t set;\n\n    int i;\n\n\n\n    frame_addr = env->regs[R_SP];\n\n    /* Make sure the guest isn't playing games.  */\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n        goto badframe;\n\n\n\n    /* Restore blocked signals */\n\n    if (__get_user(target_set.sig[0], &frame->uc.tuc_mcontext.oldmask))\n\n        goto badframe;\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n            goto badframe;\n\n    }\n\n    target_to_host_sigset_internal(&set, &target_set);\n\n    sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n    restore_sigcontext(&frame->uc.tuc_mcontext, env);\n\n    /* We got here through a sigreturn syscall, our path back is via an\n\n       rtb insn so setup r14 for that.  */\n\n    env->regs[14] = env->sregs[SR_PC];\n\n \n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return env->regs[10];\n\n  badframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n}\n", "idx": 15458}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static void scsi_device_destroy(SCSIDevice *s)\n\n{\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);\n\n    if (sc->destroy) {\n\n        sc->destroy(s);\n\n    }\n\n}\n", "idx": 15472}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "int ff_h264_get_profile(SPS *sps)\n\n{\n\n    int profile = sps->profile_idc;\n\n\n\n    switch (sps->profile_idc) {\n\n    case FF_PROFILE_H264_BASELINE:\n\n        // constraint_set1_flag set to 1\n\n        profile |= (sps->constraint_set_flags & 1 << 1) ? FF_PROFILE_H264_CONSTRAINED : 0;\n\n        break;\n\n    case FF_PROFILE_H264_HIGH_10:\n\n    case FF_PROFILE_H264_HIGH_422:\n\n    case FF_PROFILE_H264_HIGH_444_PREDICTIVE:\n\n        // constraint_set3_flag set to 1\n\n        profile |= (sps->constraint_set_flags & 1 << 3) ? FF_PROFILE_H264_INTRA : 0;\n\n        break;\n\n    }\n\n\n\n    return profile;\n\n}\n", "idx": 15476}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "void net_tx_pkt_setup_vlan_header(struct NetTxPkt *pkt, uint16_t vlan)\n\n{\n\n    bool is_new;\n\n    assert(pkt);\n\n\n\n    eth_setup_vlan_headers(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n\n        vlan, &is_new);\n\n\n\n    /* update l2hdrlen */\n\n    if (is_new) {\n\n        pkt->hdr_len += sizeof(struct vlan_header);\n\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len +=\n\n            sizeof(struct vlan_header);\n\n    }\n\n}\n", "idx": 15489}
{"project": "qemu", "commit_id": "4c3b22459d3589cf84d1ccadc6b09e586497820d", "target": 1, "func": "int pcnet_common_init(DeviceState *dev, PCNetState *s, NetClientInfo *info)\n\n{\n\n    int i;\n\n    uint16_t checksum;\n\n\n\n    s->poll_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, pcnet_poll_timer, s);\n\n\n\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n\n    s->nic = qemu_new_nic(info, &s->conf, object_get_typename(OBJECT(dev)), dev->id, s);\n\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n\n\n\n    /* Initialize the PROM */\n\n\n\n    /*\n\n      Datasheet: http://pdfdata.datasheetsite.com/web/24528/AM79C970A.pdf\n\n      page 95\n\n    */\n\n    memcpy(s->prom, s->conf.macaddr.a, 6);\n\n    /* Reserved Location: must be 00h */\n\n    s->prom[6] = s->prom[7] = 0x00;\n\n    /* Reserved Location: must be 00h */\n\n    s->prom[8] = 0x00;\n\n    /* Hardware ID: must be 11h if compatibility to AMD drivers is desired */\n\n    s->prom[9] = 0x11;\n\n    /* User programmable space, init with 0 */\n\n    s->prom[10] = s->prom[11] = 0x00;\n\n    /* LSByte of two-byte checksum, which is the sum of bytes 00h-0Bh\n\n       and bytes 0Eh and 0Fh, must therefore be initialized with 0! */\n\n    s->prom[12] = s->prom[13] = 0x00;\n\n    /* Must be ASCII W (57h) if compatibility to AMD\n\n       driver software is desired */\n\n    s->prom[14] = s->prom[15] = 0x57;\n\n\n\n    for (i = 0, checksum = 0; i < 16; i++) {\n\n        checksum += s->prom[i];\n\n    }\n\n    *(uint16_t *)&s->prom[12] = cpu_to_le16(checksum);\n\n\n\n    s->lnkst = 0x40; /* initial link state: up */\n\n\n\n    return 0;\n\n}\n", "idx": 15499}
{"project": "qemu", "commit_id": "b0e90181e4d7244a9466447703acdb2cdd7abdaa", "target": 1, "func": "static int query_memdev(Object *obj, void *opaque)\n\n{\n\n    MemdevList **list = opaque;\n\n    Error *err = NULL;\n\n\n\n    if (object_dynamic_cast(obj, TYPE_MEMORY_BACKEND)) {\n\n        MemdevList *m = g_malloc0(sizeof(*m));\n\n\n\n        m->value = g_malloc0(sizeof(*m->value));\n\n\n\n        m->value->size = object_property_get_int(obj, \"size\",\n\n                                                 &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->value->merge = object_property_get_bool(obj, \"merge\",\n\n                                                   &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->value->dump = object_property_get_bool(obj, \"dump\",\n\n                                                  &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->value->prealloc = object_property_get_bool(obj,\n\n                                                      \"prealloc\", &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->value->policy = object_property_get_enum(obj,\n\n                                                    \"policy\",\n\n                                                    HostMemPolicy_lookup,\n\n                                                    &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        object_property_get_uint16List(obj, \"host-nodes\",\n\n                                       &m->value->host_nodes, &err);\n\n        if (err) {\n\n            goto error;\n\n        }\n\n\n\n        m->next = *list;\n\n        *list = m;\n\n    }\n\n\n\n    return 0;\n\nerror:\n\n    return -1;\n\n}\n", "idx": 15501}
{"project": "FFmpeg", "commit_id": "723b6baaf8db43d0872bad504c4f4c780b53516b", "target": 1, "func": "static int decode_iccp_chunk(PNGDecContext *s, int length, AVFrame *f)\n\n{\n\n    int ret, cnt = 0;\n\n    uint8_t *data, profile_name[82];\n\n    AVBPrint bp;\n\n    AVFrameSideData *sd;\n\n\n\n    while ((profile_name[cnt++] = bytestream2_get_byte(&s->gb)) && cnt < 81);\n\n    if (cnt > 80) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"iCCP with invalid name!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    length = FFMAX(length - cnt, 0);\n\n\n\n    if (bytestream2_get_byte(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"iCCP with invalid compression!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    length = FFMAX(length - 1, 0);\n\n\n\n    if ((ret = decode_zbuf(&bp, s->gb.buffer, s->gb.buffer + length)) < 0)\n\n        return ret;\n\n\n\n    av_bprint_finalize(&bp, (char **)&data);\n\n\n\n\n\n    sd = av_frame_new_side_data(f, AV_FRAME_DATA_ICC_PROFILE, bp.len);\n\n    if (!sd) {\n\n        av_free(data);\n\n\n    }\n\n\n\n    av_dict_set(&sd->metadata, \"name\", profile_name, 0);\n\n    memcpy(sd->data, data, bp.len);\n\n    av_free(data);\n\n\n\n    /* ICC compressed data and CRC */\n\n    bytestream2_skip(&s->gb, length + 4);\n\n\n\n    return 0;\n\n}", "idx": 15514}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fres(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    float32 f32;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN reciprocal */\n\n        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n    }\n\n    farg.d = float64_div(float64_one, farg.d, &env->fp_status);\n\n    f32 = float64_to_float32(farg.d, &env->fp_status);\n\n    farg.d = float32_to_float64(f32, &env->fp_status);\n\n\n\n    return farg.ll;\n\n}\n", "idx": 15523}
{"project": "qemu", "commit_id": "3d0be8a5c135dadcfbd68ed354007a8cece98849", "target": 0, "func": "void HELPER(wsr_lend)(uint32_t v)\n\n{\n\n    if (env->sregs[LEND] != v) {\n\n        tb_invalidate_phys_page_range(\n\n                env->sregs[LEND] - 1, env->sregs[LEND], 0);\n\n        env->sregs[LEND] = v;\n\n        tb_invalidate_phys_page_range(\n\n                env->sregs[LEND] - 1, env->sregs[LEND], 0);\n\n    }\n\n}\n", "idx": 15526}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static int aio_epoll(AioContext *ctx, GPollFD *pfds,\n\n                     unsigned npfd, int64_t timeout)\n\n{\n\n    assert(false);\n\n}\n", "idx": 15550}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static int decode_buffering_period(H264Context *h)\n\n{\n\n    unsigned int sps_id;\n\n    int sched_sel_idx;\n\n    SPS *sps;\n\n\n\n    sps_id = get_ue_golomb_31(&h->gb);\n\n    if (sps_id > 31 || !h->sps_buffers[sps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing SPS %d referenced in buffering period\\n\", sps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sps = h->sps_buffers[sps_id];\n\n\n\n    // NOTE: This is really so duplicated in the standard... See H.264, D.1.1\n\n    if (sps->nal_hrd_parameters_present_flag) {\n\n        for (sched_sel_idx = 0; sched_sel_idx < sps->cpb_cnt; sched_sel_idx++) {\n\n            h->initial_cpb_removal_delay[sched_sel_idx] =\n\n                get_bits(&h->gb, sps->initial_cpb_removal_delay_length);\n\n            // initial_cpb_removal_delay_offset\n\n            skip_bits(&h->gb, sps->initial_cpb_removal_delay_length);\n\n        }\n\n    }\n\n    if (sps->vcl_hrd_parameters_present_flag) {\n\n        for (sched_sel_idx = 0; sched_sel_idx < sps->cpb_cnt; sched_sel_idx++) {\n\n            h->initial_cpb_removal_delay[sched_sel_idx] =\n\n                get_bits(&h->gb, sps->initial_cpb_removal_delay_length);\n\n            // initial_cpb_removal_delay_offset\n\n            skip_bits(&h->gb, sps->initial_cpb_removal_delay_length);\n\n        }\n\n    }\n\n\n\n    h->sei_buffering_period_present = 1;\n\n    return 0;\n\n}\n", "idx": 15567}
{"project": "FFmpeg", "commit_id": "b399816d9c3d0fc3efd742b04f269c1055cc6e2b", "target": 1, "func": "static int ism_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    SmoothStreamingContext *c = s->priv_data;\n\n    AVStream *st = s->streams[pkt->stream_index];\n\n    OutputStream *os = &c->streams[pkt->stream_index];\n\n    int64_t end_dts = (c->nb_fragments + 1) * c->min_frag_duration;\n\n    int ret;\n\n\n\n    if (st->first_dts == AV_NOPTS_VALUE)\n\n        st->first_dts = pkt->dts;\n\n\n\n    if ((!c->has_video || st->codec->codec_type == AVMEDIA_TYPE_VIDEO) &&\n\n        av_compare_ts(pkt->dts - st->first_dts, st->time_base,\n\n                      end_dts, AV_TIME_BASE_Q) >= 0 &&\n\n        pkt->flags & AV_PKT_FLAG_KEY && os->packets_written) {\n\n\n\n        if ((ret = ism_flush(s, 0)) < 0)\n\n            return ret;\n\n        c->nb_fragments++;\n\n    }\n\n\n\n    os->packets_written++;\n\n    return ff_write_chained(os->ctx, 0, pkt, s);\n\n}\n", "idx": 15577}
{"project": "qemu", "commit_id": "413bfb7cfc4e7f886ad35d610056ad8da8deab8a", "target": 0, "func": "static void sdl_resize(DisplayState *ds)\n\n{\n\n    int flags;\n\n\n\n    //    printf(\"resizing to %d %d\\n\", w, h);\n\n\n\n    flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;\n\n    if (gui_fullscreen)\n\n        flags |= SDL_FULLSCREEN;\n\n    if (gui_noframe)\n\n        flags |= SDL_NOFRAME;\n\n\n\n again:\n\n    real_screen = SDL_SetVideoMode(ds_get_width(ds), ds_get_height(ds), 0, flags);\n\n    if (!real_screen) {\n\n        fprintf(stderr, \"Could not open SDL display\\n\");\n\n        exit(1);\n\n    }\n\n    if (!real_screen->pixels && (flags & SDL_HWSURFACE) && (flags & SDL_FULLSCREEN)) {\n\n        flags &= ~SDL_HWSURFACE;\n\n        goto again;\n\n    }\n\n\n\n    if (!real_screen->pixels) {\n\n        fprintf(stderr, \"Could not open SDL display\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    sdl_setdata(ds);\n\n}\n", "idx": 15612}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void do_subfeo (void)\n\n{\n\n    T2 = T0;\n\n    T0 = T1 + ~T0 + xer_ca;\n\n    if (likely(!((~T2 ^ T1 ^ (-1)) & (~T2 ^ T0) & (1 << 31)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n    if (likely(T0 >= T1 && (xer_ca == 0 || T0 != T1))) {\n\n        xer_ca = 0;\n\n    } else {\n\n        xer_ca = 1;\n\n    }\n\n}\n", "idx": 15622}
{"project": "qemu", "commit_id": "acc4af3fec335bb0778456f72bfb2c3591c11da4", "target": 0, "func": "static bool object_is_type(Object *obj, const char *typename)\n\n{\n\n    TypeImpl *target_type = type_get_by_name(typename);\n\n    TypeImpl *type = obj->class->type;\n\n    GSList *i;\n\n\n\n    /* Check if typename is a direct ancestor of type */\n\n    while (type) {\n\n        if (type == target_type) {\n\n            return true;\n\n        }\n\n\n\n        type = type_get_parent(type);\n\n    }\n\n\n\n    /* Check if obj has an interface of typename */\n\n    for (i = obj->interfaces; i; i = i->next) {\n\n        Interface *iface = i->data;\n\n\n\n        if (object_is_type(OBJECT(iface), typename)) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 15628}
{"project": "FFmpeg", "commit_id": "e938637b2ca7587c2b349458189f1f7d7da87040", "target": 0, "func": "static int truespeech_decode_frame(AVCodecContext *avctx,\n\n                void *data, int *data_size,\n\n                uint8_t *buf, int buf_size)\n\n{\n\n    TSContext *c = avctx->priv_data;\n\n\n\n    int i;\n\n    short *samples = data;\n\n    int consumed = 0;\n\n    int16_t out_buf[240];\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    while (consumed < buf_size) {\n\n        truespeech_read_frame(c, buf + consumed);\n\n        consumed += 32;\n\n\n\n        truespeech_correlate_filter(c);\n\n        truespeech_filters_merge(c);\n\n\n\n        memset(out_buf, 0, 240 * 2);\n\n        for(i = 0; i < 4; i++) {\n\n            truespeech_apply_twopoint_filter(c, i);\n\n            truespeech_place_pulses(c, out_buf + i * 60, i);\n\n            truespeech_update_filters(c, out_buf + i * 60, i);\n\n            truespeech_synth(c, out_buf + i * 60, i);\n\n        }\n\n\n\n        truespeech_save_prevvec(c);\n\n\n\n        /* finally output decoded frame */\n\n        for(i = 0; i < 240; i++)\n\n            *samples++ = out_buf[i];\n\n\n\n    }\n\n\n\n    *data_size = consumed * 15;\n\n\n\n    return buf_size;\n\n}\n", "idx": 15635}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t dchip_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    /* Skip this.  It's all related to DRAM timing and setup.  */\n\n    return 0;\n\n}\n", "idx": 15660}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_755 (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    gen_spr_G2_755(env);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* L2 cache control */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2PMCR, \"L2PMCR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Thermal management */\n\n    gen_spr_thrm(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    gen_low_BATs(env);\n\n    gen_high_BATs(env);\n\n    gen_6xx_7xx_soft_tlb(env, 64, 2);\n\n    init_excp_7x5(env);\n\n    env->dcache_line_size = 32;\n\n    env->icache_line_size = 32;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc6xx_irq_init(env);\n\n}\n", "idx": 15686}
{"project": "FFmpeg", "commit_id": "a6ca08f1af31badb7fef93bc1cbfa78bffae6be7", "target": 0, "func": "static int gxf_write_trailer(AVFormatContext *s)\n\n{\n\n    GXFContext *gxf = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int64_t end;\n\n    int i;\n\n\n\n    ff_audio_interleave_close(s);\n\n\n\n    gxf_write_eos_packet(pb);\n\n    end = avio_tell(pb);\n\n    avio_seek(pb, 0, SEEK_SET);\n\n    /* overwrite map, flt and umf packets with new values */\n\n    gxf_write_map_packet(s, 1);\n\n    gxf_write_flt_packet(s);\n\n    gxf_write_umf_packet(s);\n\n    avio_flush(pb);\n\n    /* update duration in all map packets */\n\n    for (i = 1; i < gxf->map_offsets_nb; i++) {\n\n        avio_seek(pb, gxf->map_offsets[i], SEEK_SET);\n\n        gxf_write_map_packet(s, 1);\n\n        avio_flush(pb);\n\n    }\n\n\n\n    avio_seek(pb, end, SEEK_SET);\n\n\n\n    av_freep(&gxf->flt_entries);\n\n    av_freep(&gxf->map_offsets);\n\n\n\n    return 0;\n\n}\n", "idx": 15693}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "static int bdrv_prwv_co(BdrvChild *child, int64_t offset,\n\n                        QEMUIOVector *qiov, bool is_write,\n\n                        BdrvRequestFlags flags)\n\n{\n\n    Coroutine *co;\n\n    RwCo rwco = {\n\n        .child = child,\n\n        .offset = offset,\n\n        .qiov = qiov,\n\n        .is_write = is_write,\n\n        .ret = NOT_DONE,\n\n        .flags = flags,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_rw_co_entry(&rwco);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(child->bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_rw_co_entry, &rwco);\n\n        qemu_coroutine_enter(co);\n\n        while (rwco.ret == NOT_DONE) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n    return rwco.ret;\n\n}\n", "idx": 15719}
{"project": "FFmpeg", "commit_id": "6ff0ad6bfd0f00a3d54705811ee91a7ce3c22cda", "target": 0, "func": "void in_asm_used_var_warning_killer()\n\n{\n\n volatile int i= yCoeff+vrCoeff+ubCoeff+vgCoeff+ugCoeff+bF8+bFC+w400+w80+w10+\n\n bm00001111+bm00000111+bm11111000+b16Mask+g16Mask+r16Mask+b15Mask+g15Mask+r15Mask+asm_yalpha1+ asm_uvalpha1+\n\n M24A+M24B+M24C+w02 + b5Dither+g5Dither+r5Dither+g6Dither+dither4[0]+dither8[0];\n\n if(i) i=0;\n\n}\n", "idx": 15748}
{"project": "FFmpeg", "commit_id": "22d13e4290c8fdba57485e1b501f6a92283a10db", "target": 0, "func": "static double setup_compress_thresh(double threshold)\n\n{\n\n    if ((threshold > DBL_EPSILON) && (threshold < (1.0 - DBL_EPSILON))) {\n\n        double current_threshold = threshold;\n\n        double step_size = 1.0;\n\n\n\n        while (step_size > DBL_EPSILON) {\n\n            while ((current_threshold + step_size > current_threshold) &&\n\n                   (bound(current_threshold + step_size, 1.0) <= threshold)) {\n\n                current_threshold += step_size;\n\n            }\n\n\n\n            step_size /= 2.0;\n\n        }\n\n\n\n        return current_threshold;\n\n    } else {\n\n        return threshold;\n\n    }\n\n}\n", "idx": 15750}
{"project": "FFmpeg", "commit_id": "5626e812d2c1c202f749824905b70cdb8a845e7b", "target": 1, "func": "static av_always_inline int get_decoded_frame(AVFormatContext *fmt_ctx,\n\n                                              AVFrame *frame, int *got_frame,\n\n                                              AVPacket *pkt)\n\n{\n\n    AVCodecContext *dec_ctx = fmt_ctx->streams[pkt->stream_index]->codec;\n\n    int ret = 0;\n\n\n\n    *got_frame = 0;\n\n    if (dec_ctx->codec) {\n\n    switch (dec_ctx->codec_type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        ret = avcodec_decode_video2(dec_ctx, frame, got_frame, pkt);\n\n        break;\n\n\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        ret = avcodec_decode_audio4(dec_ctx, frame, got_frame, pkt);\n\n        break;\n\n\n\n\n\n    return ret;\n", "idx": 15754}
{"project": "qemu", "commit_id": "a9859c90a5db200fd4f63ab2cdc973343348b9ef", "target": 1, "func": "static void xilinx_axidma_realize(DeviceState *dev, Error **errp)\n\n{\n\n    XilinxAXIDMA *s = XILINX_AXI_DMA(dev);\n\n    XilinxAXIDMAStreamSlave *ds = XILINX_AXI_DMA_DATA_STREAM(&s->rx_data_dev);\n\n    XilinxAXIDMAStreamSlave *cs = XILINX_AXI_DMA_CONTROL_STREAM(\n\n                                                            &s->rx_control_dev);\n\n    Error *local_err = NULL;\n\n\n\n    object_property_add_link(OBJECT(ds), \"dma\", TYPE_XILINX_AXI_DMA,\n\n                             (Object **)&ds->dma,\n\n                             object_property_allow_set_link,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &local_err);\n\n    object_property_add_link(OBJECT(cs), \"dma\", TYPE_XILINX_AXI_DMA,\n\n                             (Object **)&cs->dma,\n\n                             object_property_allow_set_link,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &local_err);\n\n    if (local_err) {\n\n        goto xilinx_axidma_realize_fail;\n\n    }\n\n    object_property_set_link(OBJECT(ds), OBJECT(s), \"dma\", &local_err);\n\n    object_property_set_link(OBJECT(cs), OBJECT(s), \"dma\", &local_err);\n\n    if (local_err) {\n\n        goto xilinx_axidma_realize_fail;\n\n    }\n\n\n\n    int i;\n\n\n\n    for (i = 0; i < 2; i++) {\n\n        struct Stream *st = &s->streams[i];\n\n\n\n        st->nr = i;\n\n        st->bh = qemu_bh_new(timer_hit, st);\n\n        st->ptimer = ptimer_init(st->bh, PTIMER_POLICY_DEFAULT);\n\n        ptimer_set_freq(st->ptimer, s->freqhz);\n\n    }\n\n    return;\n\n\n\nxilinx_axidma_realize_fail:\n\n    if (!*errp) {\n\n        *errp = local_err;\n\n    }\n\n}\n", "idx": 15768}
{"project": "qemu", "commit_id": "d5e6f437c5508614803d11e59ee16a758dde09ef", "target": 0, "func": "BdrvChild *bdrv_attach_child(BlockDriverState *parent_bs,\n\n                             BlockDriverState *child_bs,\n\n                             const char *child_name,\n\n                             const BdrvChildRole *child_role,\n\n                             Error **errp)\n\n{\n\n    BdrvChild *child = bdrv_root_attach_child(child_bs, child_name, child_role,\n\n                                              parent_bs);\n\n    QLIST_INSERT_HEAD(&parent_bs->children, child, next);\n\n    return child;\n\n}\n", "idx": 15778}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_visitor_in_native_list_number(TestInputVisitorData *data,\n\n                                               const void *unused)\n\n{\n\n    UserDefNativeListUnion *cvalue = NULL;\n\n    numberList *elem = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n    GString *gstr_list = g_string_new(\"\");\n\n    GString *gstr_union = g_string_new(\"\");\n\n    int i;\n\n\n\n    for (i = 0; i < 32; i++) {\n\n        g_string_append_printf(gstr_list, \"%f\", (double)i / 3);\n\n        if (i != 31) {\n\n            g_string_append(gstr_list, \", \");\n\n        }\n\n    }\n\n    g_string_append_printf(gstr_union,  \"{ 'type': 'number', 'data': [ %s ] }\",\n\n                           gstr_list->str);\n\n    v = visitor_input_test_init_raw(data,  gstr_union->str);\n\n\n\n    visit_type_UserDefNativeListUnion(v, &cvalue, NULL, &err);\n\n    g_assert(err == NULL);\n\n    g_assert(cvalue != NULL);\n\n    g_assert_cmpint(cvalue->type, ==, USER_DEF_NATIVE_LIST_UNION_KIND_NUMBER);\n\n\n\n    for (i = 0, elem = cvalue->u.number; elem; elem = elem->next, i++) {\n\n        GString *double_expected = g_string_new(\"\");\n\n        GString *double_actual = g_string_new(\"\");\n\n\n\n        g_string_printf(double_expected, \"%.6f\", (double)i / 3);\n\n        g_string_printf(double_actual, \"%.6f\", elem->value);\n\n        g_assert_cmpstr(double_expected->str, ==, double_actual->str);\n\n\n\n        g_string_free(double_expected, true);\n\n        g_string_free(double_actual, true);\n\n    }\n\n\n\n    g_string_free(gstr_union, true);\n\n    g_string_free(gstr_list, true);\n\n    qapi_free_UserDefNativeListUnion(cvalue);\n\n}\n", "idx": 15815}
{"project": "qemu", "commit_id": "a3fa1d78cbae2259491b17689812edcb643a3b30", "target": 0, "func": "static void migrate_fd_cleanup(MigrationState *s)\n\n{\n\n    int ret = 0;\n\n\n\n    if (s->file) {\n\n        DPRINTF(\"closing file\\n\");\n\n        ret = qemu_fclose(s->file);\n\n        s->file = NULL;\n\n    }\n\n\n\n    assert(s->fd == -1);\n\n    if (ret < 0 && s->state == MIG_STATE_ACTIVE) {\n\n        s->state = MIG_STATE_ERROR;\n\n    }\n\n\n\n    if (s->state != MIG_STATE_ACTIVE) {\n\n        qemu_savevm_state_cancel();\n\n    }\n\n}\n", "idx": 15835}
{"project": "qemu", "commit_id": "806d102141b99d4f1e55a97d68b7ea8c8ba3129f", "target": 1, "func": "unsigned long init_guest_space(unsigned long host_start,\n\n                               unsigned long host_size,\n\n                               unsigned long guest_start,\n\n                               bool fixed)\n\n{\n\n    unsigned long current_start, real_start;\n\n    int flags;\n\n\n\n    assert(host_start || host_size);\n\n\n\n    /* If just a starting address is given, then just verify that\n\n     * address.  */\n\n    if (host_start && !host_size) {\n\n        if (guest_validate_base(host_start)) {\n\n            return host_start;\n\n        } else {\n\n            return (unsigned long)-1;\n\n        }\n\n    }\n\n\n\n    /* Setup the initial flags and start address.  */\n\n    current_start = host_start & qemu_host_page_mask;\n\n    flags = MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE;\n\n    if (fixed) {\n\n        flags |= MAP_FIXED;\n\n    }\n\n\n\n    /* Otherwise, a non-zero size region of memory needs to be mapped\n\n     * and validated.  */\n\n    while (1) {\n\n        /* Do not use mmap_find_vma here because that is limited to the\n\n         * guest address space.  We are going to make the\n\n         * guest address space fit whatever we're given.\n\n         */\n\n        real_start = (unsigned long)\n\n            mmap((void *)current_start, host_size, PROT_NONE, flags, -1, 0);\n\n        if (real_start == (unsigned long)-1) {\n\n            return (unsigned long)-1;\n\n        }\n\n\n\n        if ((real_start == current_start)\n\n            && guest_validate_base(real_start - guest_start)) {\n\n            break;\n\n        }\n\n\n\n        /* That address didn't work.  Unmap and try a different one.\n\n         * The address the host picked because is typically right at\n\n         * the top of the host address space and leaves the guest with\n\n         * no usable address space.  Resort to a linear search.  We\n\n         * already compensated for mmap_min_addr, so this should not\n\n         * happen often.  Probably means we got unlucky and host\n\n         * address space randomization put a shared library somewhere\n\n         * inconvenient.\n\n         */\n\n        munmap((void *)real_start, host_size);\n\n        current_start += qemu_host_page_size;\n\n        if (host_start == current_start) {\n\n            /* Theoretically possible if host doesn't have any suitably\n\n             * aligned areas.  Normally the first mmap will fail.\n\n             */\n\n            return (unsigned long)-1;\n\n        }\n\n    }\n\n\n\n    return real_start;\n\n}\n", "idx": 15844}
{"project": "qemu", "commit_id": "e58d695e6c3a5cfa0aa2fc91b87ade017ef28b05", "target": 1, "func": "static void qmp_input_start_struct(Visitor *v, const char *name, void **obj,\n\n                                   size_t size, Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true);\n\n    Error *err = NULL;\n\n\n\n\n\n\n    if (!qobj || qobject_type(qobj) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"QDict\");\n\n        return;\n\n\n\n\n    qmp_input_push(qiv, qobj, &err);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n\n\n\n\n        *obj = g_malloc0(size);\n\n", "idx": 15852}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "int l4_register_io_memory(CPUReadMemoryFunc * const *mem_read,\n\n                CPUWriteMemoryFunc * const *mem_write, void *opaque)\n\n{\n\n    omap_l4_io_entry[omap_l4_io_entries].mem_read = mem_read;\n\n    omap_l4_io_entry[omap_l4_io_entries].mem_write = mem_write;\n\n    omap_l4_io_entry[omap_l4_io_entries].opaque = opaque;\n\n\n\n    return omap_l4_io_entries ++;\n\n}\n", "idx": 15869}
{"project": "qemu", "commit_id": "db1e80ee2ed6fc9eb6b203873b39752144f5577f", "target": 0, "func": "static int vhdx_create_new_headers(BlockDriverState *bs, uint64_t image_size,\n\n                                   uint32_t log_size)\n\n{\n\n    int ret = 0;\n\n    VHDXHeader *hdr = NULL;\n\n\n\n    hdr = g_new0(VHDXHeader, 1);\n\n\n\n    hdr->signature       = VHDX_HEADER_SIGNATURE;\n\n    hdr->sequence_number = g_random_int();\n\n    hdr->log_version     = 0;\n\n    hdr->version         = 1;\n\n    hdr->log_length      = log_size;\n\n    hdr->log_offset      = VHDX_HEADER_SECTION_END;\n\n    vhdx_guid_generate(&hdr->file_write_guid);\n\n    vhdx_guid_generate(&hdr->data_write_guid);\n\n\n\n    ret = vhdx_write_header(bs, hdr, VHDX_HEADER1_OFFSET, false);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n    hdr->sequence_number++;\n\n    ret = vhdx_write_header(bs, hdr, VHDX_HEADER2_OFFSET, false);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\nexit:\n\n    g_free(hdr);\n\n    return ret;\n\n}\n", "idx": 15877}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int usb_net_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBNetState *s = (USBNetState *) dev;\n\n    int ret = 0;\n\n\n\n    switch(p->pid) {\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep) {\n\n        case 1:\n\n            ret = usb_net_handle_statusin(s, p);\n\n            break;\n\n\n\n        case 2:\n\n            ret = usb_net_handle_datain(s, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_OUT:\n\n        switch (p->devep) {\n\n        case 2:\n\n            ret = usb_net_handle_dataout(s, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    if (ret == USB_RET_STALL)\n\n        fprintf(stderr, \"usbnet: failed data transaction: \"\n\n                        \"pid 0x%x ep 0x%x len 0x%zx\\n\",\n\n                        p->pid, p->devep, p->iov.size);\n\n    return ret;\n\n}\n", "idx": 15902}
{"project": "qemu", "commit_id": "e1c37d0e94048502f9874e6356ce7136d4b05bdb", "target": 0, "func": "static void migrate_fd_monitor_suspend(MigrationState *s, Monitor *mon)\n\n{\n\n    if (monitor_suspend(mon) == 0) {\n\n        DPRINTF(\"suspending monitor\\n\");\n\n    } else {\n\n        monitor_printf(mon, \"terminal does not allow synchronous \"\n\n                       \"migration, continuing detached\\n\");\n\n    }\n\n}\n", "idx": 15918}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect(struct vmsvga_state_s *s,\n\n                int x, int y, int w, int h)\n\n{\n\n    int line;\n\n    int bypl;\n\n    int width;\n\n    int start;\n\n    uint8_t *src;\n\n    uint8_t *dst;\n\n\n\n    if (x + w > s->width) {\n\n        fprintf(stderr, \"%s: update width too large x: %d, w: %d\\n\",\n\n                        __FUNCTION__, x, w);\n\n        x = MIN(x, s->width);\n\n        w = s->width - x;\n\n    }\n\n\n\n    if (y + h > s->height) {\n\n        fprintf(stderr, \"%s: update height too large y: %d, h: %d\\n\",\n\n                        __FUNCTION__, y, h);\n\n        y = MIN(y, s->height);\n\n        h = s->height - y;\n\n    }\n\n\n\n    line = h;\n\n    bypl = s->bypp * s->width;\n\n    width = s->bypp * w;\n\n    start = s->bypp * x + bypl * y;\n\n    src = s->vga.vram_ptr + start;\n\n    dst = ds_get_data(s->vga.ds) + start;\n\n\n\n    for (; line > 0; line --, src += bypl, dst += bypl)\n\n        memcpy(dst, src, width);\n\n\n\n    dpy_gfx_update(s->vga.ds, x, y, w, h);\n\n}\n", "idx": 15922}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "static void qemu_tcg_init_vcpu(void *_env)\n\n{\n\n    CPUState *env = _env;\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        env->thread = qemu_mallocz(sizeof(QemuThread));\n\n        env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n        qemu_cond_init(env->halt_cond);\n\n        qemu_thread_create(env->thread, qemu_tcg_cpu_thread_fn, env);\n\n        while (env->created == 0)\n\n            qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n        tcg_cpu_thread = env->thread;\n\n        tcg_halt_cond = env->halt_cond;\n\n    } else {\n\n        env->thread = tcg_cpu_thread;\n\n        env->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n", "idx": 15928}
{"project": "FFmpeg", "commit_id": "4ba6a534dc94bd4ff44503de9c7985a456cfe503", "target": 0, "func": "static int64_t http_seek(URLContext *h, int64_t off, int whence)\n\n{\n\n    HTTPContext *s = h->priv_data;\n\n    URLContext *old_hd = s->hd;\n\n    int64_t old_off = s->off;\n\n    uint8_t old_buf[BUFFER_SIZE];\n\n    int old_buf_size;\n\n    AVDictionary *options = NULL;\n\n\n\n    if (whence == AVSEEK_SIZE)\n\n        return s->filesize;\n\n    else if ((whence == SEEK_CUR && off == 0) || (whence == SEEK_SET && off == s->off))\n\n        return s->off;\n\n    else if ((s->filesize == -1 && whence == SEEK_END) || h->is_streamed)\n\n        return -1;\n\n\n\n    /* we save the old context in case the seek fails */\n\n    old_buf_size = s->buf_end - s->buf_ptr;\n\n    memcpy(old_buf, s->buf_ptr, old_buf_size);\n\n    s->hd = NULL;\n\n    if (whence == SEEK_CUR)\n\n        off += s->off;\n\n    else if (whence == SEEK_END)\n\n        off += s->filesize;\n\n    s->off = off;\n\n\n\n    /* if it fails, continue on old connection */\n\n    av_dict_copy(&options, s->chained_options, 0);\n\n    if (http_open_cnx(h, &options) < 0) {\n\n        av_dict_free(&options);\n\n        memcpy(s->buffer, old_buf, old_buf_size);\n\n        s->buf_ptr = s->buffer;\n\n        s->buf_end = s->buffer + old_buf_size;\n\n        s->hd = old_hd;\n\n        s->off = old_off;\n\n        return -1;\n\n    }\n\n    av_dict_free(&options);\n\n    ffurl_close(old_hd);\n\n    return off;\n\n}\n", "idx": 15931}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qdict_del(QDict *qdict, const char *key)\n\n{\n\n    QDictEntry *entry;\n\n\n\n    entry = qdict_find(qdict, key, tdb_hash(key) % QDICT_HASH_SIZE);\n\n    if (entry) {\n\n        LIST_REMOVE(entry, next);\n\n        qentry_destroy(entry);\n\n        qdict->size--;\n\n    }\n\n}\n", "idx": 15952}
{"project": "qemu", "commit_id": "2ff64038a59e8de2baa485806be0838f49f70b79", "target": 0, "func": "static void migration_bitmap_sync_range(ram_addr_t start, ram_addr_t length)\n\n{\n\n    migration_dirty_pages +=\n\n        cpu_physical_memory_sync_dirty_bitmap(migration_bitmap, start, length);\n\n}\n", "idx": 15954}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int pci_unin_map_irq(PCIDevice *pci_dev, int irq_num)\n\n{\n\n    int retval;\n\n    int devfn = pci_dev->devfn & 0x00FFFFFF;\n\n\n\n    retval = (((devfn >> 11) & 0x1F) + irq_num) & 3;\n\n\n\n    return retval;\n\n}\n", "idx": 15973}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "void tcp_start_outgoing_migration(MigrationState *s,\n\n                                  const char *host_port,\n\n                                  Error **errp)\n\n{\n\n    Error *err = NULL;\n\n    SocketAddress *saddr = tcp_build_address(host_port, &err);\n\n    if (!err) {\n\n        socket_start_outgoing_migration(s, saddr, &err);\n\n    }\n\n    error_propagate(errp, err);\n\n}\n", "idx": 16032}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static int ast2400_rambits(AspeedSDMCState *s)\n\n{\n\n    switch (s->ram_size >> 20) {\n\n    case 64:\n\n        return ASPEED_SDMC_DRAM_64MB;\n\n    case 128:\n\n        return ASPEED_SDMC_DRAM_128MB;\n\n    case 256:\n\n        return ASPEED_SDMC_DRAM_256MB;\n\n    case 512:\n\n        return ASPEED_SDMC_DRAM_512MB;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* use a common default */\n\n    error_report(\"warning: Invalid RAM size 0x%\" PRIx64\n\n                 \". Using default 256M\", s->ram_size);\n\n    s->ram_size = 256 << 20;\n\n    return ASPEED_SDMC_DRAM_256MB;\n\n}\n", "idx": 16036}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static ssize_t proxy_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n\n                              char *buf, size_t bufsz)\n\n{\n\n    int retval;\n\n    retval = v9fs_request(fs_ctx->private, T_READLINK, buf, \"sd\",\n\n                          fs_path, bufsz);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        return -1;\n\n    }\n\n    return strlen(buf);\n\n}\n", "idx": 16076}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static void buffer_reset(Buffer *buffer)\n\n{\n\n\tbuffer->offset = 0;\n\n}\n", "idx": 16109}
{"project": "FFmpeg", "commit_id": "5b0fc078191138795e817244555741356f9d12e9", "target": 1, "func": "static int vp9_decode_update_thread_context(AVCodecContext *dst, const AVCodecContext *src)\n\n{\n\n    int i, res;\n\n    VP9Context *s = dst->priv_data, *ssrc = src->priv_data;\n\n\n\n    // FIXME scalability, size, etc.\n\n\n\n    for (i = 0; i < 2; i++) {\n\n        if (s->frames[i].tf.f->data[0])\n\n            vp9_unref_frame(dst, &s->frames[i]);\n\n        if (ssrc->frames[i].tf.f->data[0]) {\n\n            if ((res = vp9_ref_frame(dst, &s->frames[i], &ssrc->frames[i])) < 0)\n\n                return res;\n\n        }\n\n    }\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->refs[i].f->data[0])\n\n            ff_thread_release_buffer(dst, &s->refs[i]);\n\n        if (ssrc->next_refs[i].f->data[0]) {\n\n            if ((res = ff_thread_ref_frame(&s->refs[i], &ssrc->next_refs[i])) < 0)\n\n                return res;\n\n        }\n\n    }\n\n\n\n    s->invisible = ssrc->invisible;\n\n    s->keyframe = ssrc->keyframe;\n\n    s->uses_2pass = ssrc->uses_2pass;\n\n    memcpy(&s->prob_ctx, &ssrc->prob_ctx, sizeof(s->prob_ctx));\n\n    memcpy(&s->lf_delta, &ssrc->lf_delta, sizeof(s->lf_delta));\n\n    if (ssrc->segmentation.enabled) {\n\n        memcpy(&s->segmentation.feat, &ssrc->segmentation.feat,\n\n               sizeof(s->segmentation.feat));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16122}
{"project": "qemu", "commit_id": "8c0a6dc96cd14c48da4a61fe35431f36d6e6e467", "target": 1, "func": "static void test_hash_speed(const void *opaque)\n\n{\n\n    size_t chunk_size = (size_t)opaque;\n\n    uint8_t *in = NULL, *out = NULL;\n\n    size_t out_len = 0;\n\n    double total = 0.0;\n\n    struct iovec iov;\n\n    int ret;\n\n\n\n    in = g_new0(uint8_t, chunk_size);\n\n    memset(in, g_test_rand_int(), chunk_size);\n\n\n\n    iov.iov_base = (char *)in;\n\n    iov.iov_len = chunk_size;\n\n\n\n    g_test_timer_start();\n\n    do {\n\n        ret = qcrypto_hash_bytesv(QCRYPTO_HASH_ALG_SHA256,\n\n                                  &iov, 1, &out, &out_len,\n\n                                  NULL);\n\n        g_assert(ret == 0);\n\n\n\n        total += chunk_size;\n\n    } while (g_test_timer_elapsed() < 5.0);\n\n\n\n    total /= 1024 * 1024; /* to MB */\n\n    g_print(\"sha256: \");\n\n    g_print(\"Testing chunk_size %ld bytes \", chunk_size);\n\n    g_print(\"done: %.2f MB in %.2f secs: \", total, g_test_timer_last());\n\n    g_print(\"%.2f MB/sec\\n\", total / g_test_timer_last());\n\n\n\n    g_free(out);\n\n    g_free(in);\n\n}\n", "idx": 16124}
{"project": "qemu", "commit_id": "08b9e0ba623c4468fe94026a9bdd086526ef62f0", "target": 1, "func": "static int vhost_kernel_memslots_limit(struct vhost_dev *dev)\n\n{\n\n    int limit = 64;\n\n    char *s;\n\n\n\n    if (g_file_get_contents(\"/sys/module/vhost/parameters/max_mem_regions\",\n\n                            &s, NULL, NULL)) {\n\n        uint64_t val = g_ascii_strtoull(s, NULL, 10);\n\n        if (!((val == G_MAXUINT64 || !val) && errno)) {\n\n\n            return val;\n\n        }\n\n        error_report(\"ignoring invalid max_mem_regions value in vhost module:\"\n\n                     \" %s\", s);\n\n    }\n\n\n    return limit;\n\n}", "idx": 16126}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static bool coroutine_fn wait_serialising_requests(BdrvTrackedRequest *self)\n\n{\n\n    BlockDriverState *bs = self->bs;\n\n    BdrvTrackedRequest *req;\n\n    bool retry;\n\n    bool waited = false;\n\n\n\n    if (!bs->serialising_in_flight) {\n\n        return false;\n\n    }\n\n\n\n    do {\n\n        retry = false;\n\n        QLIST_FOREACH(req, &bs->tracked_requests, list) {\n\n            if (req == self || (!req->serialising && !self->serialising)) {\n\n                continue;\n\n            }\n\n            if (tracked_request_overlaps(req, self->overlap_offset,\n\n                                         self->overlap_bytes))\n\n            {\n\n                /* Hitting this means there was a reentrant request, for\n\n                 * example, a block driver issuing nested requests.  This must\n\n                 * never happen since it means deadlock.\n\n                 */\n\n                assert(qemu_coroutine_self() != req->co);\n\n\n\n                /* If the request is already (indirectly) waiting for us, or\n\n                 * will wait for us as soon as it wakes up, then just go on\n\n                 * (instead of producing a deadlock in the former case). */\n\n                if (!req->waiting_for) {\n\n                    self->waiting_for = req;\n\n                    qemu_co_queue_wait(&req->wait_queue);\n\n                    self->waiting_for = NULL;\n\n                    retry = true;\n\n                    waited = true;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    } while (retry);\n\n\n\n    return waited;\n\n}\n", "idx": 16140}
{"project": "qemu", "commit_id": "7d553f27fce284805d7f94603932045ee3bbb979", "target": 0, "func": "static int usb_device_init(USBDevice *dev)\n\n{\n\n    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);\n\n    if (klass->init) {\n\n        return klass->init(dev);\n\n    }\n\n    return 0;\n\n}\n", "idx": 16168}
{"project": "FFmpeg", "commit_id": "2758cdedfb7ac61f8b5e4861f99218b6fd43491d", "target": 0, "func": "static int url_alloc_for_protocol(URLContext **puc, struct URLProtocol *up,\n\n                                  const char *filename, int flags,\n\n                                  const AVIOInterruptCB *int_cb)\n\n{\n\n    URLContext *uc;\n\n    int err;\n\n\n\n#if CONFIG_NETWORK\n\n    if (up->flags & URL_PROTOCOL_FLAG_NETWORK && !ff_network_init())\n\n        return AVERROR(EIO);\n\n#endif\n\n    uc = av_mallocz(sizeof(URLContext) + strlen(filename) + 1);\n\n    if (!uc) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    uc->av_class = &ffurl_context_class;\n\n    uc->filename = (char *)&uc[1];\n\n    strcpy(uc->filename, filename);\n\n    uc->prot            = up;\n\n    uc->flags           = flags;\n\n    uc->is_streamed     = 0; /* default = not streamed */\n\n    uc->max_packet_size = 0; /* default: stream file */\n\n    if (up->priv_data_size) {\n\n        uc->priv_data = av_mallocz(up->priv_data_size);\n\n        if (!uc->priv_data) {\n\n            err = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        if (up->priv_data_class) {\n\n            *(const AVClass **)uc->priv_data = up->priv_data_class;\n\n            av_opt_set_defaults(uc->priv_data);\n\n        }\n\n    }\n\n    if (int_cb)\n\n        uc->interrupt_callback = *int_cb;\n\n\n\n    *puc = uc;\n\n    return 0;\n\nfail:\n\n    *puc = NULL;\n\n    if (uc)\n\n        av_freep(&uc->priv_data);\n\n    av_freep(&uc);\n\n#if CONFIG_NETWORK\n\n    if (up->flags & URL_PROTOCOL_FLAG_NETWORK)\n\n        ff_network_close();\n\n#endif\n\n    return err;\n\n}\n", "idx": 16184}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "int bdrv_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)\n\n{\n\n    BdrvIoctlCoData data = {\n\n        .bs = bs,\n\n        .req = req,\n\n        .buf = buf,\n\n        .ret = -EINPROGRESS,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_co_ioctl_entry(&data);\n\n    } else {\n\n        Coroutine *co = qemu_coroutine_create(bdrv_co_ioctl_entry);\n\n\n\n        qemu_coroutine_enter(co, &data);\n\n        while (data.ret == -EINPROGRESS) {\n\n            aio_poll(bdrv_get_aio_context(bs), true);\n\n        }\n\n    }\n\n    return data.ret;\n\n}\n", "idx": 16214}
{"project": "qemu", "commit_id": "98ee9bedc734e18287902f39e3a3a8adb399386a", "target": 0, "func": "void ioinst_handle_stcrw(S390CPU *cpu, uint32_t ipb, uintptr_t ra)\n\n{\n\n    CRW crw;\n\n    uint64_t addr;\n\n    int cc;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        s390_program_interrupt(env, PGM_SPECIFICATION, 4, ra);\n\n        return;\n\n    }\n\n\n\n    cc = css_do_stcrw(&crw);\n\n    /* 0 - crw stored, 1 - zeroes stored */\n\n\n\n    if (s390_cpu_virt_mem_write(cpu, addr, ar, &crw, sizeof(crw)) == 0) {\n\n        setcc(cpu, cc);\n\n    } else if (cc == 0) {\n\n        /* Write failed: requeue CRW since STCRW is a suppressing instruction */\n\n        css_undo_stcrw(&crw);\n\n    }\n\n}\n", "idx": 16247}
{"project": "qemu", "commit_id": "ba14414174b72fa231997243a9650feaa520d054", "target": 0, "func": "static void migrate_put_status(QDict *qdict, const char *name,\n\n                               uint64_t trans, uint64_t rem, uint64_t total)\n\n{\n\n    QObject *obj;\n\n\n\n    obj = qobject_from_jsonf(\"{ 'transferred': %\" PRId64 \", \"\n\n                               \"'remaining': %\" PRId64 \", \"\n\n                               \"'total': %\" PRId64 \" }\", trans, rem, total);\n\n    assert(obj != NULL);\n\n\n\n    qdict_put_obj(qdict, name, obj);\n\n}\n", "idx": 16252}
{"project": "FFmpeg", "commit_id": "93dfc4f174d89ad4c9a76fb542ddfed138e4f01b", "target": 0, "func": "static int svc_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *got_frame, AVPacket *avpkt)\n\n{\n\n    SVCContext *s = avctx->priv_data;\n\n    SBufferInfo info = { 0 };\n\n    uint8_t* ptrs[3];\n\n    int linesize[3];\n\n    AVFrame *avframe = data;\n\n    DECODING_STATE state;\n\n\n\n    state = (*s->decoder)->DecodeFrame2(s->decoder, avpkt->data, avpkt->size, ptrs, &info);\n\n    if (state != dsErrorFree) {\n\n        av_log(avctx, AV_LOG_ERROR, \"DecodeFrame2 failed\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n    if (info.iBufferStatus != 1) {\n\n        av_log(avctx, AV_LOG_DEBUG, \"No frame produced\\n\");\n\n        return avpkt->size;\n\n    }\n\n\n\n    ff_set_dimensions(avctx, info.UsrData.sSystemBuffer.iWidth, info.UsrData.sSystemBuffer.iHeight);\n\n    // The decoder doesn't (currently) support decoding into a user\n\n    // provided buffer, so do a copy instead.\n\n    if (ff_get_buffer(avctx, avframe, 0) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to allocate buffer\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    linesize[0] = info.UsrData.sSystemBuffer.iStride[0];\n\n    linesize[1] = linesize[2] = info.UsrData.sSystemBuffer.iStride[1];\n\n    av_image_copy(avframe->data, avframe->linesize, (const uint8_t **) ptrs, linesize, avctx->pix_fmt, avctx->width, avctx->height);\n\n\n\n    avframe->pts     = avpkt->pts;\n\n    avframe->pkt_dts = avpkt->dts;\n\n#if FF_API_PKT_PTS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avframe->pkt_pts = avpkt->pts;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    *got_frame = 1;\n\n    return avpkt->size;\n\n}\n", "idx": 16257}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_stack_object_free(StackObject *tos)\n\n{\n\n    if (tos->h) {\n\n        g_hash_table_unref(tos->h);\n\n    }\n\n\n\n    g_free(tos);\n\n}\n", "idx": 16277}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool timer_expired(QEMUTimer *timer_head, int64_t current_time)\n\n{\n\n    return timer_expired_ns(timer_head, current_time * timer_head->scale);\n\n}\n", "idx": 16279}
{"project": "qemu", "commit_id": "ee25595f0126de0f83da86cc29ba2365be7a50d2", "target": 1, "func": "static void check_cmd(AHCIState *s, int port)\n\n{\n\n    AHCIPortRegs *pr = &s->dev[port].port_regs;\n\n    int slot;\n\n\n\n    if ((pr->cmd & PORT_CMD_START) && pr->cmd_issue) {\n\n        for (slot = 0; (slot < 32) && pr->cmd_issue; slot++) {\n\n            if ((pr->cmd_issue & (1 << slot)) &&\n\n                !handle_cmd(s, port, slot)) {\n\n                pr->cmd_issue &= ~(1 << slot);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16283}
{"project": "FFmpeg", "commit_id": "ef8740d8e58dc45950887305307206d27ad413fb", "target": 1, "func": "static av_always_inline void iadst4_1d(const dctcoef *in, ptrdiff_t stride,\n\n                                       dctcoef *out, int pass)\n\n{\n\n    int t0, t1, t2, t3;\n\n\n\n    t0 =  5283 * IN(0) + 15212 * IN(2) +  9929 * IN(3);\n\n    t1 =  9929 * IN(0) -  5283 * IN(2) - 15212 * IN(3);\n\n    t2 = 13377 * (IN(0) - IN(2) + IN(3));\n\n    t3 = 13377 * IN(1);\n\n\n\n    out[0] = (t0 + t3      + (1 << 13)) >> 14;\n\n    out[1] = (t1 + t3      + (1 << 13)) >> 14;\n\n    out[2] = (t2           + (1 << 13)) >> 14;\n\n    out[3] = (t0 + t1 - t3 + (1 << 13)) >> 14;\n\n}\n", "idx": 16290}
{"project": "qemu", "commit_id": "b11e20fb6c658bc13b2e4dfc1b86c2eb8731e374", "target": 1, "func": "static void cleanup_infolist(CommandLineParameterInfoList *head)\n\n{\n\n    CommandLineParameterInfoList *pre_entry, *cur, *del_entry;\n\n\n\n    cur = head;\n\n    while (cur->next) {\n\n        pre_entry = head;\n\n        while (pre_entry != cur->next) {\n\n            if (!strcmp(pre_entry->value->name, cur->next->value->name)) {\n\n                del_entry = cur->next;\n\n                cur->next = cur->next->next;\n\n                g_free(del_entry);\n\n                break;\n\n            }\n\n            pre_entry = pre_entry->next;\n\n        }\n\n        cur = cur->next;\n\n    }\n\n}\n", "idx": 16294}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_check_align(DisasContext *ctx, TCGv EA, int mask)\n\n{\n\n    int l1 = gen_new_label();\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv_i32 t1, t2;\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    tcg_gen_andi_tl(t0, EA, mask);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);\n\n    t1 = tcg_const_i32(POWERPC_EXCP_ALIGN);\n\n    t2 = tcg_const_i32(0);\n\n    gen_helper_raise_exception_err(cpu_env, t1, t2);\n\n    tcg_temp_free_i32(t1);\n\n    tcg_temp_free_i32(t2);\n\n    gen_set_label(l1);\n\n    tcg_temp_free(t0);\n\n}\n", "idx": 16305}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int64_t bdrv_nb_sectors(BlockDriverState *bs)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n    if (drv->has_variable_length) {\n\n        int ret = refresh_total_sectors(bs, bs->total_sectors);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    return bs->total_sectors;\n\n}\n", "idx": 16319}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void udp_chr_update_read_handler(CharDriverState *chr)\n\n{\n\n    NetCharDriver *s = chr->opaque;\n\n\n\n    if (s->tag) {\n\n        g_source_remove(s->tag);\n\n        s->tag = 0;\n\n    }\n\n\n\n    if (s->chan) {\n\n        s->tag = io_add_watch_poll(s->chan, udp_chr_read_poll, udp_chr_read, chr);\n\n    }\n\n}\n", "idx": 16339}
{"project": "qemu", "commit_id": "f47291b7a7ffa8854300283d4773ed17d5d581c1", "target": 1, "func": "void qemu_system_guest_panicked(GuestPanicInformation *info)\n{\n    if (current_cpu) {\n        current_cpu->crash_occurred = true;\n    }\n    qapi_event_send_guest_panicked(GUEST_PANIC_ACTION_PAUSE,\n                                   !!info, info, &error_abort);\n    vm_stop(RUN_STATE_GUEST_PANICKED);\n    if (!no_shutdown) {\n        qapi_event_send_guest_panicked(GUEST_PANIC_ACTION_POWEROFF,\n                                       !!info, info, &error_abort);\n        qemu_system_shutdown_request();\n    }\n    if (info) {\n        if (info->type == GUEST_PANIC_INFORMATION_KIND_HYPER_V) {\n            qemu_log_mask(LOG_GUEST_ERROR, \"HV crash parameters: (%#\"PRIx64\n                          \" %#\"PRIx64\" %#\"PRIx64\" %#\"PRIx64\" %#\"PRIx64\")\\n\",\n                          info->u.hyper_v.data->arg1,\n                          info->u.hyper_v.data->arg2,\n                          info->u.hyper_v.data->arg3,\n                          info->u.hyper_v.data->arg4,\n                          info->u.hyper_v.data->arg5);\n        }\n        qapi_free_GuestPanicInformation(info);\n    }\n}", "idx": 16348}
{"project": "FFmpeg", "commit_id": "bfa0f96586fe2c257cfa574ffb991da493a54da1", "target": 1, "func": "static void vp8_decode_flush(AVCodecContext *avctx)\n\n{\n\n    vp8_decode_flush_impl(avctx, 0, 0);\n\n}\n", "idx": 16358}
{"project": "FFmpeg", "commit_id": "66875798eb88be2f9e49c7d1d1b92aadac1623f6", "target": 1, "func": "static int ipvideo_decode_block_opcode_0x9(IpvideoContext *s, AVFrame *frame)\n{\n    int x, y;\n    unsigned char P[4];\n    /* 4-color encoding */\n    bytestream2_get_buffer(&s->stream_ptr, P, 4);\n    if (P[0] <= P[1]) {\n        if (P[2] <= P[3]) {\n            /* 1 of 4 colors for each pixel, need 16 more bytes */\n            for (y = 0; y < 8; y++) {\n                /* get the next set of 8 2-bit flags */\n                int flags = bytestream2_get_le16(&s->stream_ptr);\n                for (x = 0; x < 8; x++, flags >>= 2)\n                    *s->pixel_ptr++ = P[flags & 0x03];\n                s->pixel_ptr += s->line_inc;\n        } else {\n            uint32_t flags;\n            /* 1 of 4 colors for each 2x2 block, need 4 more bytes */\n            flags = bytestream2_get_le32(&s->stream_ptr);\n            for (y = 0; y < 8; y += 2) {\n                for (x = 0; x < 8; x += 2, flags >>= 2) {\n                    s->pixel_ptr[x                ] =\n                    s->pixel_ptr[x + 1            ] =\n                    s->pixel_ptr[x +     s->stride] =\n                    s->pixel_ptr[x + 1 + s->stride] = P[flags & 0x03];\n                s->pixel_ptr += s->stride * 2;\n    } else {\n        uint64_t flags;\n        /* 1 of 4 colors for each 2x1 or 1x2 block, need 8 more bytes */\n        flags = bytestream2_get_le64(&s->stream_ptr);\n        if (P[2] <= P[3]) {\n            for (y = 0; y < 8; y++) {\n                for (x = 0; x < 8; x += 2, flags >>= 2) {\n                    s->pixel_ptr[x    ] =\n                    s->pixel_ptr[x + 1] = P[flags & 0x03];\n                s->pixel_ptr += s->stride;\n        } else {\n            for (y = 0; y < 8; y += 2) {\n                for (x = 0; x < 8; x++, flags >>= 2) {\n                    s->pixel_ptr[x            ] =\n                    s->pixel_ptr[x + s->stride] = P[flags & 0x03];\n                s->pixel_ptr += s->stride * 2;\n    /* report success */\n    return 0;", "idx": 16361}
{"project": "qemu", "commit_id": "7102fa7073b2cefb33ab4012a11f15fbf297a74b", "target": 0, "func": "static void pc_compat_0_13(MachineState *machine)\n\n{\n\n    pc_compat_1_2(machine);\n\n    kvmclock_enabled = false;\n\n}\n", "idx": 16396}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_gdbserver(int argc, const char **argv)\n\n{\n\n    int port;\n\n\n\n    port = DEFAULT_GDBSTUB_PORT;\n\n    if (argc >= 2)\n\n        port = atoi(argv[1]);\n\n    if (gdbserver_start(port) < 0) {\n\n        qemu_printf(\"Could not open gdbserver socket on port %d\\n\", port);\n\n    } else {\n\n        qemu_printf(\"Waiting gdb connection on port %d\\n\", port);\n\n    }\n\n}\n", "idx": 16408}
{"project": "qemu", "commit_id": "8917c3bdba37d6fe4393db0fad3fabbde9530d6b", "target": 0, "func": "sofcantsendmore(struct socket *so)\n\n{\n\n\tif ((so->so_state & SS_NOFDREF) == 0) {\n\n            shutdown(so->s,1);           /* send FIN to fhost */\n\n            if (global_readfds) {\n\n                FD_CLR(so->s,global_readfds);\n\n            }\n\n            if (global_xfds) {\n\n                FD_CLR(so->s,global_xfds);\n\n            }\n\n\t}\n\n\tso->so_state &= ~(SS_ISFCONNECTING);\n\n\tif (so->so_state & SS_FCANTRCVMORE) {\n\n\t   so->so_state &= SS_PERSISTENT_MASK;\n\n\t   so->so_state |= SS_NOFDREF; /* as above */\n\n\t} else {\n\n\t   so->so_state |= SS_FCANTSENDMORE;\n\n\t}\n\n}\n", "idx": 16409}
{"project": "qemu", "commit_id": "c4d9d19645a484298a67e9021060bc7c2b081d0f", "target": 0, "func": "static void thread_pool_init(void)\n\n{\n\n    thread_pool_init_one(&global_pool, NULL);\n\n}\n", "idx": 16414}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "static void handle_notify(EventNotifier *e)\n\n{\n\n    VirtIOBlockDataPlane *s = container_of(e, VirtIOBlockDataPlane,\n\n                                           host_notifier);\n\n\n\n    VirtQueueElement *elem;\n\n    VirtIOBlockReq *req;\n\n    int ret;\n\n    MultiReqBuffer mrb = {\n\n        .num_writes = 0,\n\n    };\n\n\n\n    event_notifier_test_and_clear(&s->host_notifier);\n\n    bdrv_io_plug(s->blk->conf.bs);\n\n    for (;;) {\n\n        /* Disable guest->host notifies to avoid unnecessary vmexits */\n\n        vring_disable_notification(s->vdev, &s->vring);\n\n\n\n        for (;;) {\n\n            ret = vring_pop(s->vdev, &s->vring, &elem);\n\n            if (ret < 0) {\n\n                assert(elem == NULL);\n\n                break; /* no more requests */\n\n            }\n\n\n\n            trace_virtio_blk_data_plane_process_request(s, elem->out_num,\n\n                                                        elem->in_num, elem->index);\n\n\n\n            req = g_slice_new(VirtIOBlockReq);\n\n            req->dev = VIRTIO_BLK(s->vdev);\n\n            req->elem = elem;\n\n            virtio_blk_handle_request(req, &mrb);\n\n        }\n\n\n\n        virtio_submit_multiwrite(s->blk->conf.bs, &mrb);\n\n\n\n        if (likely(ret == -EAGAIN)) { /* vring emptied */\n\n            /* Re-enable guest->host notifies and stop processing the vring.\n\n             * But if the guest has snuck in more descriptors, keep processing.\n\n             */\n\n            if (vring_enable_notification(s->vdev, &s->vring)) {\n\n                break;\n\n            }\n\n        } else { /* fatal error */\n\n            break;\n\n        }\n\n    }\n\n    bdrv_io_unplug(s->blk->conf.bs);\n\n}\n", "idx": 16425}
{"project": "qemu", "commit_id": "d2164ad35c411d97abd2aa5c6f160283d215e214", "target": 1, "func": "static int get_int32_equal(QEMUFile *f, void *pv, size_t size,\n\n                           VMStateField *field)\n\n{\n\n    int32_t *v = pv;\n\n    int32_t v2;\n\n    qemu_get_sbe32s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n\n    error_report(\"%\" PRIx32 \" != %\" PRIx32, *v, v2);\n\n\n\n\n    return -EINVAL;\n", "idx": 16427}
{"project": "FFmpeg", "commit_id": "87bddba43b725d43767f2a387cdea0936ac1b549", "target": 1, "func": "float ff_amr_set_fixed_gain(float fixed_gain_factor, float fixed_mean_energy,\n\n                            float *prediction_error, float energy_mean,\n\n                            const float *pred_table)\n\n{\n\n    // Equations 66-69:\n\n    // ^g_c = ^gamma_gc * 100.05 (predicted dB + mean dB - dB of fixed vector)\n\n    // Note 10^(0.05 * -10log(average x2)) = 1/sqrt((average x2)).\n\n    float val = fixed_gain_factor *\n\n        ff_exp10(0.05 *\n\n              (avpriv_scalarproduct_float_c(pred_table, prediction_error, 4) +\n\n               energy_mean)) /\n\n        sqrtf(fixed_mean_energy);\n\n\n\n    // update quantified prediction error energy history\n\n    memmove(&prediction_error[0], &prediction_error[1],\n\n            3 * sizeof(prediction_error[0]));\n\n    prediction_error[3] = 20.0 * log10f(fixed_gain_factor);\n\n\n\n    return val;\n\n}\n", "idx": 16464}
{"project": "qemu", "commit_id": "eca1bdf415c454093dfc7eb983cd49287c043967", "target": 1, "func": "static void cpu_sh4_reset(CPUSH4State * env)\n{\n#if defined(CONFIG_USER_ONLY)\n    env->sr = 0;\n#else\n    env->sr = SR_MD | SR_RB | SR_BL | SR_I3 | SR_I2 | SR_I1 | SR_I0;\n#endif\n    env->vbr = 0;\n    env->pc = 0xA0000000;\n#if defined(CONFIG_USER_ONLY)\n    env->fpscr = FPSCR_PR; /* value for userspace according to the kernel */\n    set_float_rounding_mode(float_round_nearest_even, &env->fp_status); /* ?! */\n#else\n    env->fpscr = 0x00040001; /* CPU reset value according to SH4 manual */\n    set_float_rounding_mode(float_round_to_zero, &env->fp_status);\n#endif\n    env->mmucr = 0;", "idx": 16468}
{"project": "qemu", "commit_id": "57407ea44cc0a3d630b9b89a2be011f1955ce5c1", "target": 0, "func": "static void spapr_vlan_cleanup(NetClientState *nc)\n\n{\n\n    VIOsPAPRVLANDevice *dev = qemu_get_nic_opaque(nc);\n\n\n\n    dev->nic = NULL;\n\n}\n", "idx": 16484}
{"project": "qemu", "commit_id": "031380d8770d2df6c386e4aeabd412007d3ebd54", "target": 0, "func": "static int blkdebug_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    int ret;\n\n    char *config, *c;\n\n\n\n    /* Parse the blkdebug: prefix */\n\n    if (strncmp(filename, \"blkdebug:\", strlen(\"blkdebug:\"))) {\n\n        return -EINVAL;\n\n    }\n\n    filename += strlen(\"blkdebug:\");\n\n\n\n    /* Read rules from config file */\n\n    c = strchr(filename, ':');\n\n    if (c == NULL) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    config = strdup(filename);\n\n    config[c - filename] = '\\0';\n\n    ret = read_config(s, config);\n\n    free(config);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    filename = c + 1;\n\n\n\n    /* Set initial state */\n\n    s->vars.state = 1;\n\n\n\n    /* Open the backing file */\n\n    ret = bdrv_file_open(&bs->file, filename, flags);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16500}
{"project": "qemu", "commit_id": "ecbe1576b3287e7907b524901063a8117f544e61", "target": 0, "func": "static inline int seek_to_sector(BlockDriverState *bs, int64_t sector_num)\n\n{\n\n    BDRVBochsState *s = bs->opaque;\n\n    int64_t offset = sector_num * 512;\n\n    int64_t extent_index, extent_offset, bitmap_offset, block_offset;\n\n    char bitmap_entry;\n\n\n\n    // seek to sector\n\n    extent_index = offset / s->extent_size;\n\n    extent_offset = (offset % s->extent_size) / 512;\n\n\n\n    if (s->catalog_bitmap[extent_index] == 0xffffffff)\n\n    {\n\n//\tfprintf(stderr, \"page not allocated [%x - %x:%x]\\n\",\n\n//\t    sector_num, extent_index, extent_offset);\n\n\treturn -1; // not allocated\n\n    }\n\n\n\n    bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n\n\t(s->extent_blocks + s->bitmap_blocks));\n\n    block_offset = bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n\n\n\n//    fprintf(stderr, \"sect: %x [ext i: %x o: %x] -> %x bitmap: %x block: %x\\n\",\n\n//\tsector_num, extent_index, extent_offset,\n\n//\tle32_to_cpu(s->catalog_bitmap[extent_index]),\n\n//\tbitmap_offset, block_offset);\n\n\n\n    // read in bitmap for current extent\n\n    lseek(s->fd, bitmap_offset + (extent_offset / 8), SEEK_SET);\n\n\n\n    if (read(s->fd, &bitmap_entry, 1) != 1)\n\n        return -1;\n\n\n\n    if (!((bitmap_entry >> (extent_offset % 8)) & 1))\n\n    {\n\n//\tfprintf(stderr, \"sector (%x) in bitmap not allocated\\n\",\n\n//\t    sector_num);\n\n\treturn -1; // not allocated\n\n    }\n\n\n\n    lseek(s->fd, block_offset, SEEK_SET);\n\n\n\n    return 0;\n\n}\n", "idx": 16510}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_handshake_io(void *opaque) {\n\n    struct VncState *vs = (struct VncState *)opaque;\n\n\n\n    VNC_DEBUG(\"Handshake IO continue\\n\");\n\n    vnc_continue_handshake(vs);\n\n}\n", "idx": 16511}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_remove(FsContext *ctx, const char *path)\n\n{\n\n    int err;\n\n    struct stat stbuf;\n\n    char buffer[PATH_MAX];\n\n\n\n    if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        err =  lstat(rpath(ctx, path, buffer), &stbuf);\n\n        if (err) {\n\n            goto err_out;\n\n        }\n\n        /*\n\n         * If directory remove .virtfs_metadata contained in the\n\n         * directory\n\n         */\n\n        if (S_ISDIR(stbuf.st_mode)) {\n\n            snprintf(buffer, ARRAY_SIZE(buffer), \"%s/%s/%s\",\n\n                     ctx->fs_root, path, VIRTFS_META_DIR);\n\n            err = remove(buffer);\n\n            if (err < 0 && errno != ENOENT) {\n\n                /*\n\n                 * We didn't had the .virtfs_metadata file. May be file created\n\n                 * in non-mapped mode ?. Ignore ENOENT.\n\n                 */\n\n                goto err_out;\n\n            }\n\n        }\n\n        /*\n\n         * Now remove the name from parent directory\n\n         * .virtfs_metadata directory\n\n         */\n\n        err = remove(local_mapped_attr_path(ctx, path, buffer));\n\n        if (err < 0 && errno != ENOENT) {\n\n            /*\n\n             * We didn't had the .virtfs_metadata file. May be file created\n\n             * in non-mapped mode ?. Ignore ENOENT.\n\n             */\n\n            goto err_out;\n\n        }\n\n    }\n\n    return remove(rpath(ctx, path, buffer));\n\nerr_out:\n\n    return err;\n\n}\n", "idx": 16515}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static void qed_unplug_allocating_write_reqs(BDRVQEDState *s)\n\n{\n\n    assert(s->allocating_write_reqs_plugged);\n\n\n\n    s->allocating_write_reqs_plugged = false;\n\n    qemu_co_enter_next(&s->allocating_write_reqs);\n\n}\n", "idx": 16527}
{"project": "qemu", "commit_id": "d4cd45028898a37afb45fb449954115b4960d4e9", "target": 0, "func": "static int xen_pt_bar_reg_init(XenPCIPassthroughState *s, XenPTRegInfo *reg,\n\n                               uint32_t real_offset, uint32_t *data)\n\n{\n\n    uint32_t reg_field = 0;\n\n    int index;\n\n\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if (index < 0 || index >= PCI_NUM_REGIONS) {\n\n        XEN_PT_ERR(&s->dev, \"Internal error: Invalid BAR index [%d].\\n\", index);\n\n        return -1;\n\n    }\n\n\n\n    /* set BAR flag */\n\n    s->bases[index].bar_flag = xen_pt_bar_reg_parse(s, reg);\n\n    if (s->bases[index].bar_flag == XEN_PT_BAR_FLAG_UNUSED) {\n\n        reg_field = XEN_PT_INVALID_REG;\n\n    }\n\n\n\n    *data = reg_field;\n\n    return 0;\n\n}\n", "idx": 16533}
{"project": "qemu", "commit_id": "f020ed36fef7780e81a94543ae6388d8dc144ab6", "target": 0, "func": "static void ehci_frame_timer(void *opaque)\n\n{\n\n    EHCIState *ehci = opaque;\n\n    int schedules = 0;\n\n    int64_t expire_time, t_now;\n\n    uint64_t ns_elapsed;\n\n    int frames;\n\n    int i;\n\n    int skipped_frames = 0;\n\n\n\n    t_now = qemu_get_clock_ns(vm_clock);\n\n    ns_elapsed = t_now - ehci->last_run_ns;\n\n    frames = ns_elapsed / FRAME_TIMER_NS;\n\n\n\n    if (ehci_periodic_enabled(ehci) || ehci->pstate != EST_INACTIVE) {\n\n        schedules++;\n\n        expire_time = t_now + (get_ticks_per_sec() / FRAME_TIMER_FREQ);\n\n\n\n        for (i = 0; i < frames; i++) {\n\n            ehci_update_frindex(ehci, 1);\n\n\n\n            if (frames - i > ehci->maxframes) {\n\n                skipped_frames++;\n\n            } else {\n\n                ehci_advance_periodic_state(ehci);\n\n            }\n\n\n\n            ehci->last_run_ns += FRAME_TIMER_NS;\n\n        }\n\n    } else {\n\n        if (ehci->async_stepdown < ehci->maxframes / 2) {\n\n            ehci->async_stepdown++;\n\n        }\n\n        expire_time = t_now + (get_ticks_per_sec()\n\n                               * ehci->async_stepdown / FRAME_TIMER_FREQ);\n\n        ehci_update_frindex(ehci, frames);\n\n        ehci->last_run_ns += FRAME_TIMER_NS * frames;\n\n    }\n\n\n\n#if 0\n\n    if (skipped_frames) {\n\n        DPRINTF(\"WARNING - EHCI skipped %d frames\\n\", skipped_frames);\n\n    }\n\n#endif\n\n\n\n    /*  Async is not inside loop since it executes everything it can once\n\n     *  called\n\n     */\n\n    if (ehci_async_enabled(ehci) || ehci->astate != EST_INACTIVE) {\n\n        schedules++;\n\n        qemu_bh_schedule(ehci->async_bh);\n\n    }\n\n\n\n    if (schedules) {\n\n        qemu_mod_timer(ehci->frame_timer, expire_time);\n\n    }\n\n}\n", "idx": 16541}
{"project": "qemu", "commit_id": "a57d23e4f7e7e81c839a7b53a973ac71eefe91da", "target": 0, "func": "void cpu_physical_memory_reset_dirty(ram_addr_t start, ram_addr_t end,\n\n                                     int dirty_flags)\n\n{\n\n    CPUState *env;\n\n    unsigned long length, start1;\n\n    int i;\n\n\n\n    start &= TARGET_PAGE_MASK;\n\n    end = TARGET_PAGE_ALIGN(end);\n\n\n\n    length = end - start;\n\n    if (length == 0)\n\n        return;\n\n    cpu_physical_memory_mask_dirty_range(start, length, dirty_flags);\n\n\n\n    /* we modify the TLB cache so that the dirty bit will be set again\n\n       when accessing the range */\n\n    start1 = (unsigned long)qemu_safe_ram_ptr(start);\n\n    /* Chek that we don't span multiple blocks - this breaks the\n\n       address comparisons below.  */\n\n    if ((unsigned long)qemu_safe_ram_ptr(end - 1) - start1\n\n            != (end - 1) - start) {\n\n        abort();\n\n    }\n\n\n\n    for(env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        int mmu_idx;\n\n        for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n\n            for(i = 0; i < CPU_TLB_SIZE; i++)\n\n                tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n\n                                      start1, length);\n\n        }\n\n    }\n\n}\n", "idx": 16558}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "static void phys_page_set(target_phys_addr_t index, target_phys_addr_t nb,\n\n                          uint16_t leaf)\n\n{\n\n    /* Wildly overreserve - it doesn't matter much. */\n\n    phys_map_node_reserve(3 * P_L2_LEVELS);\n\n\n\n    phys_page_set_level(&phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n\n}\n", "idx": 16569}
{"project": "qemu", "commit_id": "90f998f5f4267a0c22e983f533d19b9de1849283", "target": 0, "func": "void qemu_chr_fe_printf(CharDriverState *s, const char *fmt, ...)\n\n{\n\n    char buf[READ_BUF_LEN];\n\n    va_list ap;\n\n    va_start(ap, fmt);\n\n    vsnprintf(buf, sizeof(buf), fmt, ap);\n\n    qemu_chr_fe_write(s, (uint8_t *)buf, strlen(buf));\n\n    va_end(ap);\n\n}\n", "idx": 16570}
{"project": "FFmpeg", "commit_id": "b0cd14fb1dab4b044f7fe6b53ac635409849de77", "target": 0, "func": "int hw_device_setup_for_decode(InputStream *ist)\n\n{\n\n    enum AVHWDeviceType type;\n\n    HWDevice *dev;\n\n    int err;\n\n\n\n    if (ist->hwaccel_device) {\n\n        dev = hw_device_get_by_name(ist->hwaccel_device);\n\n        if (!dev) {\n\n            char *tmp;\n\n            type = hw_device_match_type_by_hwaccel(ist->hwaccel_id);\n\n            if (type == AV_HWDEVICE_TYPE_NONE) {\n\n                // No match - this isn't necessarily invalid, though,\n\n                // because an explicit device might not be needed or\n\n                // the hwaccel setup could be handled elsewhere.\n\n                return 0;\n\n            }\n\n            tmp = av_asprintf(\"%s:%s\", av_hwdevice_get_type_name(type),\n\n                              ist->hwaccel_device);\n\n            if (!tmp)\n\n                return AVERROR(ENOMEM);\n\n            err = hw_device_init_from_string(tmp, &dev);\n\n            av_free(tmp);\n\n            if (err < 0)\n\n                return err;\n\n        }\n\n    } else {\n\n        if (ist->hwaccel_id != HWACCEL_NONE)\n\n            type = hw_device_match_type_by_hwaccel(ist->hwaccel_id);\n\n        else\n\n            type = hw_device_match_type_in_name(ist->dec->name);\n\n        if (type != AV_HWDEVICE_TYPE_NONE) {\n\n            dev = hw_device_get_by_type(type);\n\n            if (!dev) {\n\n                hw_device_init_from_string(av_hwdevice_get_type_name(type),\n\n                                           &dev);\n\n            }\n\n        } else {\n\n            // No device required.\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    if (!dev) {\n\n        av_log(ist->dec_ctx, AV_LOG_WARNING, \"No device available \"\n\n               \"for decoder (device type %s for codec %s).\\n\",\n\n               av_hwdevice_get_type_name(type), ist->dec->name);\n\n        return 0;\n\n    }\n\n\n\n    ist->dec_ctx->hw_device_ctx = av_buffer_ref(dev->device_ref);\n\n    if (!ist->dec_ctx->hw_device_ctx)\n\n        return AVERROR(ENOMEM);\n\n\n\n    return 0;\n\n}\n", "idx": 16577}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "timer_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n\n{\n\n    struct etrax_timer *t = opaque;\n\n    uint32_t r = 0;\n\n\n\n    switch (addr) {\n\n    case R_TMR0_DATA:\n\n        r = ptimer_get_count(t->ptimer_t0);\n\n        break;\n\n    case R_TMR1_DATA:\n\n        r = ptimer_get_count(t->ptimer_t1);\n\n        break;\n\n    case R_TIME:\n\n        r = qemu_get_clock_ns(vm_clock) / 10;\n\n        break;\n\n    case RW_INTR_MASK:\n\n        r = t->rw_intr_mask;\n\n        break;\n\n    case R_MASKED_INTR:\n\n        r = t->r_intr & t->rw_intr_mask;\n\n        break;\n\n    default:\n\n        D(printf (\"%s %x\\n\", __func__, addr));\n\n        break;\n\n    }\n\n    return r;\n\n}\n", "idx": 16582}
{"project": "qemu", "commit_id": "b92ad3949bc9cacd1652b4e07e7f6003b9e512af", "target": 0, "func": "static void virt_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n\n\n    mc->desc = \"ARM Virtual Machine\",\n\n    mc->init = machvirt_init;\n\n    mc->max_cpus = 8;\n\n    mc->has_dynamic_sysbus = true;\n\n    mc->block_default_type = IF_VIRTIO;\n\n    mc->no_cdrom = 1;\n\n}\n", "idx": 16584}
{"project": "qemu", "commit_id": "cf7c0ff521b0710079aa28f21937fb7dbb3f5224", "target": 0, "func": "static GArray *nvdimm_build_device_structure(void)\n\n{\n\n    GSList *device_list = nvdimm_get_plugged_device_list();\n\n    GArray *structures = g_array_new(false, true /* clear */, 1);\n\n\n\n    for (; device_list; device_list = device_list->next) {\n\n        DeviceState *dev = device_list->data;\n\n\n\n        /* build System Physical Address Range Structure. */\n\n        nvdimm_build_structure_spa(structures, dev);\n\n\n\n        /*\n\n         * build Memory Device to System Physical Address Range Mapping\n\n         * Structure.\n\n         */\n\n        nvdimm_build_structure_memdev(structures, dev);\n\n\n\n        /* build NVDIMM Control Region Structure. */\n\n        nvdimm_build_structure_dcr(structures, dev);\n\n    }\n\n    g_slist_free(device_list);\n\n\n\n    return structures;\n\n}\n", "idx": 16596}
{"project": "qemu", "commit_id": "5d79b80b335c5f65f148d1bb1672d9d534ace73b", "target": 0, "func": "static void pflash_timer (void *opaque)\n\n{\n\n    pflash_t *pfl = opaque;\n\n\n\n    DPRINTF(\"%s: command %02x done\\n\", __func__, pfl->cmd);\n\n    /* Reset flash */\n\n    pfl->status ^= 0x80;\n\n    if (pfl->bypass) {\n\n        pfl->wcycle = 2;\n\n    } else {\n\n        memory_region_rom_device_set_readable(&pfl->mem, true);\n\n        pfl->wcycle = 0;\n\n    }\n\n    pfl->cmd = 0;\n\n}\n", "idx": 16597}
{"project": "qemu", "commit_id": "a8cf66bb393ff420d40ae172a4c817bf2752918a", "target": 0, "func": "void  helper_evaluate_flags_mcp(void)\n\n{\n\n\tuint32_t src;\n\n\tuint32_t dst;\n\n\tuint32_t res;\n\n\tuint32_t flags = 0;\n\n\n\n\tsrc = env->cc_src;\n\n\tdst = env->cc_dest;\n\n\tres = env->cc_result;\n\n\n\n\tif ((res & 0x80000000L) != 0L)\n\n\t{\n\n\t\tflags |= N_FLAG;\n\n\t\tif (((src & 0x80000000L) == 0L)\n\n\t\t    && ((dst & 0x80000000L) == 0L))\n\n\t\t{\n\n\t\t\tflags |= V_FLAG;\n\n\t\t}\n\n\t\telse if (((src & 0x80000000L) != 0L) &&\n\n\t\t\t ((dst & 0x80000000L) != 0L))\n\n\t\t{\n\n\t\t\tflags |= R_FLAG;\n\n\t\t}\n\n\t}\n\n\telse\n\n\t{\n\n\t\tif (res == 0L)\n\n\t\t\tflags |= Z_FLAG;\n\n\t\tif (((src & 0x80000000L) != 0L)\n\n\t\t    && ((dst & 0x80000000L) != 0L))\n\n\t\t\tflags |= V_FLAG;\n\n\t\tif ((dst & 0x80000000L) != 0L\n\n\t\t    || (src & 0x80000000L) != 0L)\n\n\t\t\tflags |= R_FLAG;\n\n\t}\n\n\n\n\tevaluate_flags_writeback(flags);\n\n}\n", "idx": 16624}
{"project": "qemu", "commit_id": "2a74440547ea0a15195224fa2b7784b267cbfe15", "target": 0, "func": "QError *qerror_new(void)\n\n{\n\n    QError *qerr;\n\n\n\n    qerr = g_malloc0(sizeof(*qerr));\n\n    QOBJECT_INIT(qerr, &qerror_type);\n\n\n\n    return qerr;\n\n}\n", "idx": 16648}
{"project": "FFmpeg", "commit_id": "1255eed533b4069db7f205601953ca54c0dc42c9", "target": 1, "func": "static void tgq_decode_mb(TgqContext *s, int mb_y, int mb_x, const uint8_t **bs, const uint8_t *buf_end){\n\n    int mode;\n\n    int i;\n\n    int8_t dc[6];\n\n\n\n    mode = bytestream_get_byte(bs);\n\n    if (mode>buf_end-*bs) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"truncated macroblock\\n\");\n\n        return;\n\n    }\n\n\n\n    if (mode>12) {\n\n        GetBitContext gb;\n\n        init_get_bits(&gb, *bs, mode*8);\n\n        for(i=0; i<6; i++)\n\n            tgq_decode_block(s, s->block[i], &gb);\n\n        tgq_idct_put_mb(s, s->block, mb_x, mb_y);\n\n    }else{\n\n        if (mode==3) {\n\n            memset(dc, (*bs)[0], 4);\n\n            dc[4] = (*bs)[1];\n\n            dc[5] = (*bs)[2];\n\n        }else if (mode==6) {\n\n            memcpy(dc, *bs, 6);\n\n        }else if (mode==12) {\n\n            for(i=0; i<6; i++)\n\n                dc[i] = (*bs)[i*2];\n\n        }else{\n\n            av_log(s->avctx, AV_LOG_ERROR, \"unsupported mb mode %i\\n\", mode);\n\n        }\n\n        tgq_idct_put_mb_dconly(s, mb_x, mb_y, dc);\n\n    }\n\n    *bs += mode;\n\n}\n", "idx": 16659}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void ff_prores_idct(DCTELEM *block, const int16_t *qmat)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 64; i++)\n\n        block[i] *= qmat[i];\n\n\n\n    for (i = 0; i < 8; i++)\n\n        idctRowCondDC_10(block + i*8);\n\n\n\n    for (i = 0; i < 64; i++)\n\n        block[i] >>= 2;\n\n\n\n    for (i = 0; i < 8; i++)\n\n        idctSparseCol_10(block + i);\n\n}\n", "idx": 16660}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_write(BlockDriverState *bs, int64_t sector_num,\n               const uint8_t *buf, int nb_sectors)\n{\n    BlockDriver *drv = bs->drv;\n    if (!bs->drv)\n        return -ENOMEDIUM;\n    if (bs->read_only)\n        return -EACCES;\n    if (drv->bdrv_pwrite) {\n        int ret, len, count = 0;\n        len = nb_sectors * 512;\n        do {\n            ret = drv->bdrv_pwrite(bs, sector_num * 512, buf, len - count);\n            if (ret < 0) {\n                printf(\"bdrv_write ret=%d\\n\", ret);\n                return ret;\n            }\n            count += ret;\n            buf += ret;\n        } while (count != len);\n        bs->wr_bytes += (unsigned) len;\n        bs->wr_ops ++;\n        return 0;\n    }\n    return drv->bdrv_write(bs, sector_num, buf, nb_sectors);\n}", "idx": 16685}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_power8nvl_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PnvChipClass *k = PNV_CHIP_CLASS(klass);\n\n\n\n    k->cpu_model = \"POWER8NVL\";\n\n    k->chip_type = PNV_CHIP_POWER8NVL;\n\n    k->chip_cfam_id = 0x120d304980000000ull;  /* P8 Naples DD1.0 */\n\n    k->cores_mask = POWER8_CORE_MASK;\n\n    k->core_pir = pnv_chip_core_pir_p8;\n\n\n    dc->desc = \"PowerNV Chip POWER8NVL\";\n\n}", "idx": 16698}
{"project": "qemu", "commit_id": "1a01716a307387e5cf1336f61a96f772dddadc90", "target": 1, "func": "static void gd_menu_switch_vc(GtkMenuItem *item, void *opaque)\n{\n    GtkDisplayState *s = opaque;\n    VirtualConsole *vc = gd_vc_find_by_menu(s);\n    GtkNotebook *nb = GTK_NOTEBOOK(s->notebook);\n    gint page;\n    gtk_release_modifiers(s);\n    if (vc) {\n        page = gtk_notebook_page_num(nb, vc->tab_item);\n        gtk_notebook_set_current_page(nb, page);\n        gtk_widget_grab_focus(vc->focus);\n    }\n}", "idx": 16721}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void blockdev_mark_auto_del(BlockDriverState *bs)\n\n{\n\n    BlockBackend *blk = bs->blk;\n\n    DriveInfo *dinfo = blk_legacy_dinfo(blk);\n\n\n\n    if (dinfo && !dinfo->enable_auto_del) {\n\n        return;\n\n    }\n\n\n\n    if (bs->job) {\n\n        block_job_cancel(bs->job);\n\n    }\n\n    if (dinfo) {\n\n        dinfo->auto_del = 1;\n\n    }\n\n}\n", "idx": 16731}
{"project": "qemu", "commit_id": "ddcb73b7782cb6104479503faea04cc224f982b5", "target": 1, "func": "e1000_can_receive(NetClientState *nc)\n\n{\n\n    E1000State *s = qemu_get_nic_opaque(nc);\n\n\n\n    return (s->mac_reg[RCTL] & E1000_RCTL_EN) && e1000_has_rxbufs(s, 1);\n\n}\n", "idx": 16753}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static void rtce_init(VIOsPAPRDevice *dev)\n\n{\n\n    size_t size = (dev->rtce_window_size >> SPAPR_VIO_TCE_PAGE_SHIFT)\n\n        * sizeof(VIOsPAPR_RTCE);\n\n\n\n    if (size) {\n\n        dev->rtce_table = kvmppc_create_spapr_tce(dev->reg,\n\n                                                  dev->rtce_window_size,\n\n                                                  &dev->kvmtce_fd);\n\n\n\n        if (!dev->rtce_table) {\n\n            dev->rtce_table = g_malloc0(size);\n\n        }\n\n    }\n\n}\n", "idx": 16758}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static void vnc_desktop_resize(VncState *vs)\n\n{\n\n    DisplaySurface *ds = vs->vd->ds;\n\n\n\n    if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n\n        return;\n\n    }\n\n    if (vs->client_width == surface_width(ds) &&\n\n        vs->client_height == surface_height(ds)) {\n\n        return;\n\n    }\n\n    vs->client_width = surface_width(ds);\n\n    vs->client_height = surface_height(ds);\n\n    vnc_lock_output(vs);\n\n    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n\n    vnc_write_u8(vs, 0);\n\n    vnc_write_u16(vs, 1); /* number of rects */\n\n    vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,\n\n                           VNC_ENCODING_DESKTOPRESIZE);\n\n    vnc_unlock_output(vs);\n\n    vnc_flush(vs);\n\n}\n", "idx": 16759}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stl_be_phys(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    stl_phys_internal(addr, val, DEVICE_BIG_ENDIAN);\n\n}\n", "idx": 16776}
{"project": "qemu", "commit_id": "bf937a7965c1d1a6dce4f615d0ead2e2ab505004", "target": 0, "func": "static uint8_t *l2cap_bframe_out(struct bt_l2cap_conn_params_s *parm, int len)\n\n{\n\n    struct l2cap_chan_s *chan = (struct l2cap_chan_s *) parm;\n\n\n\n    if (len > chan->params.remote_mtu) {\n\n        fprintf(stderr, \"%s: B-Frame for CID %04x longer than %i octets.\\n\",\n\n                        __func__,\n\n                        chan->remote_cid, chan->params.remote_mtu);\n\n        exit(-1);\n\n    }\n\n\n\n    return l2cap_pdu_out(chan->l2cap, chan->remote_cid, len);\n\n}\n", "idx": 16777}
{"project": "qemu", "commit_id": "bf18bee547d19fde314e7b6b81f21f68b46c8a92", "target": 0, "func": "static int do_open_tray(const char *device, bool force, Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    bool locked;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n\n                  \"Device '%s' not found\", device);\n\n        return -ENODEV;\n\n    }\n\n\n\n    if (!blk_dev_has_removable_media(blk)) {\n\n        error_setg(errp, \"Device '%s' is not removable\", device);\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (!blk_dev_has_tray(blk)) {\n\n        /* Ignore this command on tray-less devices */\n\n        return ENOSYS;\n\n    }\n\n\n\n    if (blk_dev_is_tray_open(blk)) {\n\n        return 0;\n\n    }\n\n\n\n    locked = blk_dev_is_medium_locked(blk);\n\n    if (locked) {\n\n        blk_dev_eject_request(blk, force);\n\n    }\n\n\n\n    if (!locked || force) {\n\n        blk_dev_change_media_cb(blk, false);\n\n    }\n\n\n\n    if (locked && !force) {\n\n        return EINPROGRESS;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16804}
{"project": "qemu", "commit_id": "e5766d6ec7524345f4c0fa284c065b68c5e93049", "target": 0, "func": "static int read_config(BDRVBlkdebugState *s, const char *filename,\n\n                       QDict *options, Error **errp)\n\n{\n\n    FILE *f = NULL;\n\n    int ret;\n\n    struct add_rule_data d;\n\n    Error *local_err = NULL;\n\n\n\n    if (filename) {\n\n        f = fopen(filename, \"r\");\n\n        if (f == NULL) {\n\n            error_setg_errno(errp, errno, \"Could not read blkdebug config file\");\n\n            return -errno;\n\n        }\n\n\n\n        ret = qemu_config_parse(f, config_groups, filename);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Could not parse blkdebug config file\");\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    qemu_config_parse_qdict(options, config_groups, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    d.s = s;\n\n    d.action = ACTION_INJECT_ERROR;\n\n    qemu_opts_foreach(&inject_error_opts, add_rule, &d, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    d.action = ACTION_SET_STATE;\n\n    qemu_opts_foreach(&set_state_opts, add_rule, &d, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_opts_reset(&inject_error_opts);\n\n    qemu_opts_reset(&set_state_opts);\n\n    if (f) {\n\n        fclose(f);\n\n    }\n\n    return ret;\n\n}\n", "idx": 16816}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void kvm_log_start(MemoryListener *listener,\n\n                          MemoryRegionSection *section)\n\n{\n\n    int r;\n\n\n\n    r = kvm_dirty_pages_log_change(section->offset_within_address_space,\n\n                                   int128_get64(section->size), true);\n\n    if (r < 0) {\n\n        abort();\n\n    }\n\n}\n", "idx": 16817}
{"project": "qemu", "commit_id": "02a08fef079469c005d48fe2d181f0e0eb5752ae", "target": 0, "func": "int tcp_socket_outgoing_spec(const char *address_and_port)\n\n{\n\n    return inet_connect(address_and_port, true, NULL);\n\n}\n", "idx": 16821}
{"project": "qemu", "commit_id": "4837a1a51638ef1719bf8149591a57e7207db41a", "target": 1, "func": "static int blk_get_request(struct XenBlkDev *blkdev, struct ioreq *ioreq, RING_IDX rc)\n\n{\n\n    switch (blkdev->protocol) {\n\n    case BLKIF_PROTOCOL_NATIVE:\n\n        memcpy(&ioreq->req, RING_GET_REQUEST(&blkdev->rings.native, rc),\n\n               sizeof(ioreq->req));\n\n        break;\n\n    case BLKIF_PROTOCOL_X86_32:\n\n        blkif_get_x86_32_req(&ioreq->req,\n\n                             RING_GET_REQUEST(&blkdev->rings.x86_32_part, rc));\n\n        break;\n\n    case BLKIF_PROTOCOL_X86_64:\n\n        blkif_get_x86_64_req(&ioreq->req,\n\n                             RING_GET_REQUEST(&blkdev->rings.x86_64_part, rc));\n\n        break;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 16850}
{"project": "qemu", "commit_id": "1f0c461b82d5ec2664ca0cfc9548f80da87a8f8a", "target": 0, "func": "void blk_remove_bs(BlockBackend *blk)\n\n{\n\n    assert(blk->root->bs->blk == blk);\n\n\n\n    notifier_list_notify(&blk->remove_bs_notifiers, blk);\n\n    if (blk->public.throttle_state) {\n\n        throttle_timers_detach_aio_context(&blk->public.throttle_timers);\n\n    }\n\n\n\n    blk_update_root_state(blk);\n\n\n\n    blk->root->bs->blk = NULL;\n\n    bdrv_root_unref_child(blk->root);\n\n    blk->root = NULL;\n\n}\n", "idx": 16868}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_logicq_cc(TCGv val)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    gen_helper_logicq_cc(tmp, val);\n\n    gen_logic_CC(tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 16894}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "BlockAIOCB *dma_bdrv_io(\n\n    BlockDriverState *bs, QEMUSGList *sg, uint64_t sector_num,\n\n    DMAIOFunc *io_func, BlockCompletionFunc *cb,\n\n    void *opaque, DMADirection dir)\n\n{\n\n    DMAAIOCB *dbs = qemu_aio_get(&dma_aiocb_info, bs, cb, opaque);\n\n\n\n    trace_dma_bdrv_io(dbs, bs, sector_num, (dir == DMA_DIRECTION_TO_DEVICE));\n\n\n\n    dbs->acb = NULL;\n\n    dbs->bs = bs;\n\n    dbs->sg = sg;\n\n    dbs->sector_num = sector_num;\n\n    dbs->sg_cur_index = 0;\n\n    dbs->sg_cur_byte = 0;\n\n    dbs->dir = dir;\n\n    dbs->io_func = io_func;\n\n    dbs->bh = NULL;\n\n    qemu_iovec_init(&dbs->iov, sg->nsg);\n\n    dma_bdrv_cb(dbs, 0);\n\n    return &dbs->common;\n\n}\n", "idx": 16898}
{"project": "qemu", "commit_id": "2374e73edafff0586cbfb67c333c5a7588f81fd5", "target": 0, "func": "void helper_ldl_l_raw(uint64_t t0, uint64_t t1)\n\n{\n\n    env->lock = t1;\n\n    ldl_raw(t1, t0);\n\n}\n", "idx": 16909}
{"project": "qemu", "commit_id": "4500bc98a6aab1734d865afaeade3509eb65b560", "target": 0, "func": "static void dump_aml_files(test_data *data)\n\n{\n\n    AcpiSdtTable *sdt;\n\n    GError *error = NULL;\n\n    gint fd;\n\n    ssize_t ret;\n\n    int i;\n\n\n\n    for (i = 0; i < data->ssdt_tables->len; ++i) {\n\n        sdt = &g_array_index(data->ssdt_tables, AcpiSdtTable, i);\n\n        g_assert(sdt->aml);\n\n\n\n        fd = g_file_open_tmp(\"aml-XXXXXX\", &sdt->aml_file, &error);\n\n        g_assert_no_error(error);\n\n\n\n        ret = qemu_write_full(fd, sdt, sizeof(AcpiTableHeader));\n\n        g_assert(ret == sizeof(AcpiTableHeader));\n\n        ret = qemu_write_full(fd, sdt->aml, sdt->aml_len);\n\n        g_assert(ret == sdt->aml_len);\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 16917}
{"project": "FFmpeg", "commit_id": "956c901c68eff78288f40e3c8f41ee2fa081d4a8", "target": 1, "func": "static int matroska_deliver_packet(MatroskaDemuxContext *matroska,\n\n                                   AVPacket *pkt)\n\n{\n\n    if (matroska->num_packets > 0) {\n\n        memcpy(pkt, matroska->packets[0], sizeof(AVPacket));\n\n        av_free(matroska->packets[0]);\n\n        if (matroska->num_packets > 1) {\n\n            memmove(&matroska->packets[0], &matroska->packets[1],\n\n                    (matroska->num_packets - 1) * sizeof(AVPacket *));\n\n            matroska->packets =\n\n                av_realloc(matroska->packets, (matroska->num_packets - 1) *\n\n                           sizeof(AVPacket *));\n\n        } else {\n\n            av_freep(&matroska->packets);\n\n        }\n\n        matroska->num_packets--;\n\n        return 0;\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 16932}
{"project": "FFmpeg", "commit_id": "c742ab4e81bb9dcabfdab006d6b8b09a5808c4ce", "target": 0, "func": "static int vc1_parse_init(AVCodecParserContext *s)\n\n{\n\n    VC1ParseContext *vpc = s->priv_data;\n\n    vpc->v.s.slice_context_count = 1;\n\n    return 0;\n\n}\n", "idx": 16942}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static void sd_erase(SDState *sd)\n\n{\n\n    int i, start, end;\n\n    if (!sd->erase_start || !sd->erase_end) {\n\n        sd->card_status |= ERASE_SEQ_ERROR;\n\n        return;\n\n    }\n\n\n\n    start = sd->erase_start >>\n\n            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT);\n\n    end = sd->erase_end >>\n\n            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT);\n\n    sd->erase_start = 0;\n\n    sd->erase_end = 0;\n\n    sd->csd[14] |= 0x40;\n\n\n\n    for (i = start; i <= end; i ++)\n\n        if (sd->wp_groups[i])\n\n            sd->card_status |= WP_ERASE_SKIP;\n\n}\n", "idx": 16947}
{"project": "qemu", "commit_id": "7e97cd88148876bad36ee7c66d526dcaed328d0d", "target": 0, "func": "static void tcg_init_vcpu(void *_env)\n\n{\n\n    CPUState *env = _env;\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        env->thread = qemu_mallocz(sizeof(QemuThread));\n\n        env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n        qemu_cond_init(env->halt_cond);\n\n        qemu_thread_create(env->thread, tcg_cpu_thread_fn, env);\n\n        while (env->created == 0)\n\n            qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n        tcg_cpu_thread = env->thread;\n\n        tcg_halt_cond = env->halt_cond;\n\n    } else {\n\n        env->thread = tcg_cpu_thread;\n\n        env->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n", "idx": 16948}
{"project": "qemu", "commit_id": "e68c35cfb8088a11300371751e3987f67cac15b1", "target": 0, "func": "static int nbd_negotiate_handle_list(NBDClient *client, uint32_t length,\n\n                                     Error **errp)\n\n{\n\n    NBDExport *exp;\n\n\n\n    if (length) {\n\n        if (nbd_drop(client->ioc, length, errp) < 0) {\n\n            return -EIO;\n\n        }\n\n        return nbd_negotiate_send_rep_err(client->ioc,\n\n                                          NBD_REP_ERR_INVALID, NBD_OPT_LIST,\n\n                                          errp,\n\n                                          \"OPT_LIST should not have length\");\n\n    }\n\n\n\n    /* For each export, send a NBD_REP_SERVER reply. */\n\n    QTAILQ_FOREACH(exp, &exports, next) {\n\n        if (nbd_negotiate_send_rep_list(client->ioc, exp, errp)) {\n\n            return -EINVAL;\n\n        }\n\n    }\n\n    /* Finish with a NBD_REP_ACK. */\n\n    return nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, NBD_OPT_LIST, errp);\n\n}\n", "idx": 16966}
{"project": "qemu", "commit_id": "082c6681b6c4af0035d9dad34a4a784be8c21dbe", "target": 0, "func": "static void init_excp_620 (CPUPPCState *env)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->excp_vectors[POWERPC_EXCP_RESET]    = 0x00000100;\n\n    env->excp_vectors[POWERPC_EXCP_MCHECK]   = 0x00000200;\n\n    env->excp_vectors[POWERPC_EXCP_DSI]      = 0x00000300;\n\n    env->excp_vectors[POWERPC_EXCP_DSEG]     = 0x00000380;\n\n    env->excp_vectors[POWERPC_EXCP_ISI]      = 0x00000400;\n\n    env->excp_vectors[POWERPC_EXCP_ISEG]     = 0x00000480;\n\n    env->excp_vectors[POWERPC_EXCP_EXTERNAL] = 0x00000500;\n\n    env->excp_vectors[POWERPC_EXCP_ALIGN]    = 0x00000600;\n\n    env->excp_vectors[POWERPC_EXCP_PROGRAM]  = 0x00000700;\n\n    env->excp_vectors[POWERPC_EXCP_FPU]      = 0x00000800;\n\n    env->excp_vectors[POWERPC_EXCP_DECR]     = 0x00000900;\n\n    env->excp_vectors[POWERPC_EXCP_SYSCALL]  = 0x00000C00;\n\n    env->excp_vectors[POWERPC_EXCP_TRACE]    = 0x00000D00;\n\n    env->excp_vectors[POWERPC_EXCP_FPA]      = 0x00000E00;\n\n    env->excp_vectors[POWERPC_EXCP_PERFM]    = 0x00000F00;\n\n    env->excp_vectors[POWERPC_EXCP_IABR]     = 0x00001300;\n\n    env->excp_vectors[POWERPC_EXCP_SMI]      = 0x00001400;\n\n    env->excp_prefix = 0xFFF00000UL;\n\n    /* Hardware reset vector */\n\n    env->hreset_vector = 0x0000000000000100ULL;\n\n#endif\n\n}\n", "idx": 16967}
{"project": "FFmpeg", "commit_id": "2f3b028c7117e03267ea7f88d0d612e70f1afc06", "target": 1, "func": "static void json_print_chapter_header(WriterContext *wctx, const char *chapter)\n\n{\n\n    JSONContext *json = wctx->priv;\n\n    char *chapter_esc;\n\n\n\n    if (wctx->nb_chapter)\n\n        printf(\",\");\n\n    json->multiple_entries = !strcmp(chapter, \"packets\") || !strcmp(chapter, \"streams\");\n\n    chapter_esc = json_escape_str(chapter);\n\n    printf(\"\\n  \\\"%s\\\":%s\", chapter_esc ? chapter_esc : \"\",\n\n           json->multiple_entries ? \" [\" : \" \");\n\n    av_free(chapter_esc);\n\n}\n", "idx": 16969}
{"project": "qemu", "commit_id": "2bc22a58e16f0650e56dccfac9495e5aef58e2ef", "target": 1, "func": "void qemu_macaddr_default_if_unset(MACAddr *macaddr)\n\n{\n\n    static int index = 0;\n\n    static const MACAddr zero = { .a = { 0,0,0,0,0,0 } };\n\n\n\n    if (memcmp(macaddr, &zero, sizeof(zero)) != 0)\n\n        return;\n\n    macaddr->a[0] = 0x52;\n\n    macaddr->a[1] = 0x54;\n\n    macaddr->a[2] = 0x00;\n\n    macaddr->a[3] = 0x12;\n\n    macaddr->a[4] = 0x34;\n\n    macaddr->a[5] = 0x56 + index++;\n\n}\n", "idx": 16977}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void axidma_write(void *opaque, hwaddr addr,\n\n                         uint64_t value, unsigned size)\n\n{\n\n    XilinxAXIDMA *d = opaque;\n\n    struct Stream *s;\n\n    int sid;\n\n\n\n    sid = streamid_from_addr(addr);\n\n    s = &d->streams[sid];\n\n\n\n    addr = addr % 0x30;\n\n    addr >>= 2;\n\n    switch (addr) {\n\n        case R_DMACR:\n\n            /* Tailptr mode is always on.  */\n\n            value |= DMACR_TAILPTR_MODE;\n\n            /* Remember our previous reset state.  */\n\n            value |= (s->regs[addr] & DMACR_RESET);\n\n            s->regs[addr] = value;\n\n\n\n            if (value & DMACR_RESET) {\n\n                stream_reset(s);\n\n            }\n\n\n\n            if ((value & 1) && !stream_resetting(s)) {\n\n                /* Start processing.  */\n\n                s->regs[R_DMASR] &= ~(DMASR_HALTED | DMASR_IDLE);\n\n            }\n\n            stream_reload_complete_cnt(s);\n\n            break;\n\n\n\n        case R_DMASR:\n\n            /* Mask away write to clear irq lines.  */\n\n            value &= ~(value & DMASR_IRQ_MASK);\n\n            s->regs[addr] = value;\n\n            break;\n\n\n\n        case R_TAILDESC:\n\n            s->regs[addr] = value;\n\n            s->regs[R_DMASR] &= ~DMASR_IDLE; /* Not idle.  */\n\n            if (!sid) {\n\n                stream_process_mem2s(s, d->tx_dev);\n\n            }\n\n            break;\n\n        default:\n\n            D(qemu_log(\"%s: ch=%d addr=\" TARGET_FMT_plx \" v=%x\\n\",\n\n                  __func__, sid, addr * 4, (unsigned)value));\n\n            s->regs[addr] = value;\n\n            break;\n\n    }\n\n    if (sid == 1 && d->notify) {\n\n        d->notify(d->notify_opaque);\n\n        d->notify = NULL;\n\n    }\n\n    stream_update_irq(s);\n\n}\n", "idx": 17024}
{"project": "qemu", "commit_id": "70ae65f5d91462e1905a53236179fde21cda3a2f", "target": 0, "func": "static uint32_t bmdma_readb(void *opaque, uint32_t addr)\n\n{\n\n    BMDMAState *bm = opaque;\n\n    PCIIDEState *pci_dev = pci_from_bm(bm);\n\n    uint32_t val;\n\n\n\n    switch(addr & 3) {\n\n    case 0:\n\n        val = bm->cmd;\n\n        break;\n\n    case 1:\n\n        val = pci_dev->dev.config[MRDMODE];\n\n        break;\n\n    case 2:\n\n        val = bm->status;\n\n        break;\n\n    case 3:\n\n        if (bm->unit == 0) {\n\n            val = pci_dev->dev.config[UDIDETCR0];\n\n        } else {\n\n            val = pci_dev->dev.config[UDIDETCR1];\n\n        }\n\n        break;\n\n    default:\n\n        val = 0xff;\n\n        break;\n\n    }\n\n#ifdef DEBUG_IDE\n\n    printf(\"bmdma: readb 0x%02x : 0x%02x\\n\", addr, val);\n\n#endif\n\n    return val;\n\n}\n", "idx": 17028}
{"project": "qemu", "commit_id": "7f303adc4f0aaa71b196d9f983150f3ec3367b46", "target": 0, "func": "query_params_append (struct QueryParams *ps,\n\n               const char *name, const char *value)\n\n{\n\n    if (ps->n >= ps->alloc) {\n\n        ps->p = g_renew(QueryParam, ps->p, ps->alloc * 2);\n\n        ps->alloc *= 2;\n\n    }\n\n\n\n    ps->p[ps->n].name = g_strdup(name);\n\n    ps->p[ps->n].value = value ? g_strdup(value) : NULL;\n\n    ps->p[ps->n].ignore = 0;\n\n    ps->n++;\n\n\n\n    return 0;\n\n}\n", "idx": 17033}
{"project": "qemu", "commit_id": "9445673ea67c272616b9f718396e267caa6446b7", "target": 0, "func": "static void nbd_parse_filename(const char *filename, QDict *options,\n\n                               Error **errp)\n\n{\n\n    char *file;\n\n    char *export_name;\n\n    const char *host_spec;\n\n    const char *unixpath;\n\n\n\n    if (nbd_has_filename_options_conflict(options, errp)) {\n\n        return;\n\n    }\n\n\n\n    if (strstr(filename, \"://\")) {\n\n        int ret = nbd_parse_uri(filename, options);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"No valid URL specified\");\n\n        }\n\n        return;\n\n    }\n\n\n\n    file = g_strdup(filename);\n\n\n\n    export_name = strstr(file, EN_OPTSTR);\n\n    if (export_name) {\n\n        if (export_name[strlen(EN_OPTSTR)] == 0) {\n\n            goto out;\n\n        }\n\n        export_name[0] = 0; /* truncate 'file' */\n\n        export_name += strlen(EN_OPTSTR);\n\n\n\n        qdict_put(options, \"export\", qstring_from_str(export_name));\n\n    }\n\n\n\n    /* extract the host_spec - fail if it's not nbd:... */\n\n    if (!strstart(file, \"nbd:\", &host_spec)) {\n\n        error_setg(errp, \"File name string for NBD must start with 'nbd:'\");\n\n        goto out;\n\n    }\n\n\n\n    if (!*host_spec) {\n\n        goto out;\n\n    }\n\n\n\n    /* are we a UNIX or TCP socket? */\n\n    if (strstart(host_spec, \"unix:\", &unixpath)) {\n\n        qdict_put(options, \"server.type\", qstring_from_str(\"unix\"));\n\n        qdict_put(options, \"server.data.path\", qstring_from_str(unixpath));\n\n    } else {\n\n        InetSocketAddress *addr = NULL;\n\n\n\n        addr = inet_parse(host_spec, errp);\n\n        if (!addr) {\n\n            goto out;\n\n        }\n\n\n\n        qdict_put(options, \"server.type\", qstring_from_str(\"inet\"));\n\n        qdict_put(options, \"server.data.host\", qstring_from_str(addr->host));\n\n        qdict_put(options, \"server.data.port\", qstring_from_str(addr->port));\n\n        qapi_free_InetSocketAddress(addr);\n\n    }\n\n\n\nout:\n\n    g_free(file);\n\n}\n", "idx": 17036}
{"project": "FFmpeg", "commit_id": "6a287b739f3a8660d5e4405be1302da8b3e51e88", "target": 1, "func": "static inline int range_get_symbol(APEContext * ctx,\n\n                                   const uint32_t counts[],\n\n                                   const uint16_t counts_diff[])\n\n{\n\n    int symbol, cf;\n\n\n\n    cf = range_decode_culshift(ctx, 16);\n\n\n\n\n\n\n\n\n\n\n    /* figure out the symbol inefficiently; a binary search would be much better */\n\n    for (symbol = 0; counts[symbol + 1] <= cf; symbol++);\n\n\n\n    range_decode_update(ctx, counts_diff[symbol], counts[symbol]);\n\n\n\n", "idx": 17056}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static TCGv new_tmp(void)\n\n{\n\n    TCGv tmp;\n\n    if (num_temps == MAX_TEMPS)\n\n        abort();\n\n\n\n    if (GET_TCGV(temps[num_temps]))\n\n      return temps[num_temps++];\n\n\n\n    tmp = tcg_temp_new(TCG_TYPE_I32);\n\n    temps[num_temps++] = tmp;\n\n    return tmp;\n\n}\n", "idx": 17088}
{"project": "qemu", "commit_id": "9658e4c342e6ae0d775101f8f6bb6efb16789af1", "target": 0, "func": "void cpu_mips_store_status(CPUMIPSState *env, target_ulong val)\n\n{\n\n    uint32_t mask = env->CP0_Status_rw_bitmask;\n\n    target_ulong old = env->CP0_Status;\n\n\n\n    if (env->insn_flags & ISA_MIPS32R6) {\n\n        bool has_supervisor = extract32(mask, CP0St_KSU, 2) == 0x3;\n\n#if defined(TARGET_MIPS64)\n\n        uint32_t ksux = (1 << CP0St_KX) & val;\n\n        ksux |= (ksux >> 1) & val; /* KX = 0 forces SX to be 0 */\n\n        ksux |= (ksux >> 1) & val; /* SX = 0 forces UX to be 0 */\n\n        val = (val & ~(7 << CP0St_UX)) | ksux;\n\n#endif\n\n        if (has_supervisor && extract32(val, CP0St_KSU, 2) == 0x3) {\n\n            mask &= ~(3 << CP0St_KSU);\n\n        }\n\n        mask &= ~(((1 << CP0St_SR) | (1 << CP0St_NMI)) & val);\n\n    }\n\n\n\n    env->CP0_Status = (old & ~mask) | (val & mask);\n\n#if defined(TARGET_MIPS64)\n\n    if ((env->CP0_Status ^ old) & (old & (7 << CP0St_UX))) {\n\n        /* Access to at least one of the 64-bit segments has been disabled */\n\n        cpu_mips_tlb_flush(env);\n\n    }\n\n#endif\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        sync_c0_status(env, env, env->current_tc);\n\n    } else {\n\n        compute_hflags(env);\n\n    }\n\n}\n", "idx": 17091}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static SocketAddress *nbd_config(BDRVNBDState *s, QDict *options, char **export,\n\n                                 Error **errp)\n\n{\n\n    SocketAddress *saddr;\n\n\n\n    if (qdict_haskey(options, \"path\") == qdict_haskey(options, \"host\")) {\n\n        if (qdict_haskey(options, \"path\")) {\n\n            error_setg(errp, \"path and host may not be used at the same time.\");\n\n        } else {\n\n            error_setg(errp, \"one of path and host must be specified.\");\n\n        }\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddress, 1);\n\n\n\n    if (qdict_haskey(options, \"path\")) {\n\n        UnixSocketAddress *q_unix;\n\n        saddr->type = SOCKET_ADDRESS_KIND_UNIX;\n\n        q_unix = saddr->u.q_unix = g_new0(UnixSocketAddress, 1);\n\n        q_unix->path = g_strdup(qdict_get_str(options, \"path\"));\n\n        qdict_del(options, \"path\");\n\n    } else {\n\n        InetSocketAddress *inet;\n\n        saddr->type = SOCKET_ADDRESS_KIND_INET;\n\n        inet = saddr->u.inet = g_new0(InetSocketAddress, 1);\n\n        inet->host = g_strdup(qdict_get_str(options, \"host\"));\n\n        if (!qdict_get_try_str(options, \"port\")) {\n\n            inet->port = g_strdup_printf(\"%d\", NBD_DEFAULT_PORT);\n\n        } else {\n\n            inet->port = g_strdup(qdict_get_str(options, \"port\"));\n\n        }\n\n        qdict_del(options, \"host\");\n\n        qdict_del(options, \"port\");\n\n    }\n\n\n\n    s->client.is_unix = saddr->type == SOCKET_ADDRESS_KIND_UNIX;\n\n\n\n    *export = g_strdup(qdict_get_try_str(options, \"export\"));\n\n    if (*export) {\n\n        qdict_del(options, \"export\");\n\n    }\n\n\n\n    return saddr;\n\n}\n", "idx": 17140}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void add_pollfd(AioHandler *node)\n\n{\n\n    if (npfd == nalloc) {\n\n        if (nalloc == 0) {\n\n            pollfds_cleanup_notifier.notify = pollfds_cleanup;\n\n            qemu_thread_atexit_add(&pollfds_cleanup_notifier);\n\n            nalloc = 8;\n\n        } else {\n\n            g_assert(nalloc <= INT_MAX);\n\n            nalloc *= 2;\n\n        }\n\n        pollfds = g_renew(GPollFD, pollfds, nalloc);\n\n        nodes = g_renew(AioHandler *, nodes, nalloc);\n\n    }\n\n    nodes[npfd] = node;\n\n    pollfds[npfd] = (GPollFD) {\n\n        .fd = node->pfd.fd,\n\n        .events = node->pfd.events,\n\n    };\n\n    npfd++;\n\n}\n", "idx": 17157}
{"project": "FFmpeg", "commit_id": "bd0a9f603d0c1d0f3be782865f72ac29ab89bc5b", "target": 1, "func": "static int find_video_stream_info(AVFormatContext *fmt_ctx, int decode)\n{\n    int ret = 0;\n    int i, done = 0;\n    AVPacket pkt;\n    av_init_packet(&pkt);\n    while (!done) {\n        AVCodecContext *codec_ctx = NULL;\n        AVStream *st;\n        if ((ret = av_read_frame(fmt_ctx, &pkt)) < 0) {\n            av_log(fmt_ctx, AV_LOG_ERROR, \"Failed to read frame\\n\");\n            goto end;\n        st = fmt_ctx->streams[pkt.stream_index];\n        codec_ctx = st->codec;\n        /* Writing to AVStream.codec_info_nb_frames must not be done by\n         * user applications. It is done here for testing purposing as\n         * find_video_stream_info tries to mimic avformat_find_stream_info\n         * which writes to this field.\n         * */\n        if (codec_ctx->codec_type != AVMEDIA_TYPE_VIDEO ||\n            st->codec_info_nb_frames++ > 0) {\n            av_packet_unref(&pkt);\n            continue;\n        ret = try_decode_video_frame(codec_ctx, &pkt, decode);\n        if (ret < 0) {\n            av_log(fmt_ctx, AV_LOG_ERROR, \"Failed to decode video frame\\n\");\n            goto end;\n        av_packet_unref(&pkt);\n        /* check if all video streams have demuxed a packet */\n        done = 1;\n            st = fmt_ctx->streams[i];\n            codec_ctx = st->codec;\n            if (codec_ctx->codec_type != AVMEDIA_TYPE_VIDEO)\n                continue;\n            done &= st->codec_info_nb_frames > 0;\nend:\n    av_packet_unref(&pkt);\n    return ret < 0;", "idx": 17224}
{"project": "qemu", "commit_id": "6e9ea0c0629fe25723494a19498bedf4b781cbfa", "target": 0, "func": "static void calculate_geometry(int64_t total_sectors, uint16_t* cyls,\n\n    uint8_t* heads, uint8_t* secs_per_cyl)\n\n{\n\n    uint32_t cyls_times_heads;\n\n\n\n    if (total_sectors > 65535 * 16 * 255)\n\n        total_sectors = 65535 * 16 * 255;\n\n\n\n    if (total_sectors > 65535 * 16 * 63) {\n\n        *secs_per_cyl = 255;\n\n        *heads = 16;\n\n        cyls_times_heads = total_sectors / *secs_per_cyl;\n\n    } else {\n\n        *secs_per_cyl = 17;\n\n        cyls_times_heads = total_sectors / *secs_per_cyl;\n\n        *heads = (cyls_times_heads + 1023) / 1024;\n\n\n\n        if (*heads < 4)\n\n            *heads = 4;\n\n\n\n        if (cyls_times_heads >= (*heads * 1024) || *heads > 16) {\n\n            *secs_per_cyl = 31;\n\n            *heads = 16;\n\n            cyls_times_heads = total_sectors / *secs_per_cyl;\n\n        }\n\n\n\n        if (cyls_times_heads >= (*heads * 1024)) {\n\n            *secs_per_cyl = 63;\n\n            *heads = 16;\n\n            cyls_times_heads = total_sectors / *secs_per_cyl;\n\n        }\n\n    }\n\n\n\n    // Note: Rounding up deviates from the Virtual PC behaviour\n\n    // However, we need this to avoid truncating images in qemu-img convert\n\n    *cyls = (cyls_times_heads + *heads - 1) / *heads;\n\n}\n", "idx": 17245}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static void h264_v_loop_filter_chroma_c(uint8_t *pix, int stride, int alpha, int beta, int8_t *tc0)\n\n{\n\n    h264_loop_filter_chroma_c(pix, stride, 1, alpha, beta, tc0);\n\n}\n", "idx": 17248}
{"project": "qemu", "commit_id": "6a2a5aae02b9a0b53807b9ad91f15cd4988781f9", "target": 0, "func": "static int within_hwc_y_range(SM501State *state, int y, int crt)\n\n{\n\n    int hwc_y = get_hwc_y(state, crt);\n\n    return (hwc_y <= y && y < hwc_y + SM501_HWC_HEIGHT);\n\n}\n", "idx": 17249}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evmwumi(DisasContext *ctx)\n\n{\n\n    TCGv_i64 t0, t1;\n\n\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new_i64();\n\n    t1 = tcg_temp_new_i64();\n\n\n\n    /* t0 := rA; t1 := rB */\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_ext32u_tl(t0, cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_ext32u_tl(t1, cpu_gpr[rB(ctx->opcode)]);\n\n#else\n\n    tcg_gen_extu_tl_i64(t0, cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_extu_tl_i64(t1, cpu_gpr[rB(ctx->opcode)]);\n\n#endif\n\n\n\n    tcg_gen_mul_i64(t0, t0, t1);  /* t0 := rA * rB */\n\n\n\n    gen_store_gpr64(rD(ctx->opcode), t0); /* rD := t0 */\n\n\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i64(t1);\n\n}\n", "idx": 17251}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int nvdec_vp9_end_frame(AVCodecContext *avctx)\n\n{\n\n    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;\n\n    int ret = ff_nvdec_end_frame(avctx);\n\n    ctx->bitstream = NULL;\n\n    return ret;\n\n}\n", "idx": 17259}
{"project": "FFmpeg", "commit_id": "fe573d1a9b742652f44cdc15b24fdd401eefc5e7", "target": 0, "func": "SwsVector *sws_allocVec(int length)\n\n{\n\n    SwsVector *vec = av_malloc(sizeof(SwsVector));\n\n    if (!vec)\n\n        return NULL;\n\n    vec->length = length;\n\n    vec->coeff  = av_malloc(sizeof(double) * length);\n\n    if (!vec->coeff)\n\n        av_freep(&vec);\n\n    return vec;\n\n}\n", "idx": 17289}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                           uint64_t off, uint32_t max_count)\n\n{\n\n    ssize_t err;\n\n    size_t offset = 7;\n\n    int read_count;\n\n    int64_t xattr_len;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = &v->elems[pdu->idx];\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    read_count = xattr_len - off;\n\n    if (read_count > max_count) {\n\n        read_count = max_count;\n\n    } else if (read_count < 0) {\n\n        /*\n\n         * read beyond XATTR value\n\n         */\n\n        read_count = 0;\n\n    }\n\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n\n                    ((char *)fidp->fs.xattr.value) + off,\n\n                    read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n    return offset;\n\n}\n", "idx": 17299}
{"project": "qemu", "commit_id": "213189ab65d83ecd9072f27c80a15dcb91b6bdbf", "target": 0, "func": "static void virtio_blk_dma_restart_cb(void *opaque, int running, int reason)\n\n{\n\n    VirtIOBlock *s = opaque;\n\n    VirtIOBlockReq *req = s->rq;\n\n\n\n    if (!running)\n\n        return;\n\n\n\n    s->rq = NULL;\n\n\n\n    while (req) {\n\n        virtio_blk_handle_write(req);\n\n        req = req->next;\n\n    }\n\n}\n", "idx": 17305}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_log_state(AudioFrameQueue *afq)\n\n{\n\n    AudioFrame *f;\n\n    av_log(afq->avctx, AV_LOG_DEBUG, \"remaining delay   = %d\\n\",\n\n           afq->remaining_delay);\n\n    av_log(afq->avctx, AV_LOG_DEBUG, \"remaining samples = %d\\n\",\n\n           afq->remaining_samples);\n\n    av_log(afq->avctx, AV_LOG_DEBUG, \"frames:\\n\");\n\n    f = afq->frame_queue;\n\n    while (f) {\n\n        av_log(afq->avctx, AV_LOG_DEBUG, \"  [ pts=%9\"PRId64\" duration=%d ]\\n\",\n\n               f->pts, f->duration);\n\n        f = f->next;\n\n    }\n\n}\n", "idx": 17336}
{"project": "qemu", "commit_id": "c99a55d38dd5b5131f3fcbbaf41828a09ee62544", "target": 1, "func": "static void arm1026_initfn(Object *obj)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(obj);\n\n\n\n    cpu->dtb_compatible = \"arm,arm1026\";\n\n    set_feature(&cpu->env, ARM_FEATURE_V5);\n\n    set_feature(&cpu->env, ARM_FEATURE_VFP);\n\n    set_feature(&cpu->env, ARM_FEATURE_AUXCR);\n\n    set_feature(&cpu->env, ARM_FEATURE_DUMMY_C15_REGS);\n\n    set_feature(&cpu->env, ARM_FEATURE_CACHE_TEST_CLEAN);\n\n\n    cpu->midr = 0x4106a262;\n\n    cpu->reset_fpsid = 0x410110a0;\n\n    cpu->ctr = 0x1dd20d2;\n\n    cpu->reset_sctlr = 0x00090078;\n\n    cpu->reset_auxcr = 1;\n\n    {\n\n        /* The 1026 had an IFAR at c6,c0,0,1 rather than the ARMv6 c6,c0,0,2 */\n\n        ARMCPRegInfo ifar = {\n\n            .name = \"IFAR\", .cp = 15, .crn = 6, .crm = 0, .opc1 = 0, .opc2 = 1,\n\n            .access = PL1_RW,\n\n            .fieldoffset = offsetof(CPUARMState, cp15.ifar_ns),\n\n            .resetvalue = 0\n\n        };\n\n        define_one_arm_cp_reg(cpu, &ifar);\n\n    }\n\n}", "idx": 17355}
{"project": "FFmpeg", "commit_id": "0c22311b56e66115675c4a96e4c78547886a4171", "target": 0, "func": "static void opt_frame_pad_bottom(const char *arg)\n\n{\n\n    frame_padbottom = atoi(arg);\n\n    if (frame_padbottom < 0) {\n\n        fprintf(stderr, \"Incorrect bottom pad size\\n\");\n\n        av_exit(1);\n\n    }\n\n}\n", "idx": 17358}
{"project": "qemu", "commit_id": "0b1bcb00fb2baf5f3227dd9cd849fa69bf50d7a8", "target": 1, "func": "long do_rt_sigreturn(CPUState *env)\n\n{\n\n    fprintf(stderr, \"do_rt_sigreturn: not implemented\\n\");\n\n    return -TARGET_ENOSYS;\n\n}\n", "idx": 17375}
{"project": "qemu", "commit_id": "f81bdefb63243e82d16ce49332f7cf74d10b8f27", "target": 1, "func": "void vga_hw_screen_dump(const char *filename)\n\n{\n\n    TextConsole *previous_active_console;\n\n\n\n    previous_active_console = active_console;\n\n    active_console = consoles[0];\n\n    /* There is currently no way of specifying which screen we want to dump,\n\n       so always dump the first one.  */\n\n    if (consoles[0] && consoles[0]->hw_screen_dump)\n\n        consoles[0]->hw_screen_dump(consoles[0]->hw, filename);\n\n    active_console = previous_active_console;\n\n}\n", "idx": 17376}
{"project": "qemu", "commit_id": "0f8c289ad539feb5135c545bea947b310a893f4b", "target": 1, "func": "static int net_socket_udp_init(NetClientState *peer,\n\n                                 const char *model,\n\n                                 const char *name,\n\n                                 const char *rhost,\n\n                                 const char *lhost)\n\n{\n\n    NetSocketState *s;\n\n    int fd, ret;\n\n    struct sockaddr_in laddr, raddr;\n\n\n\n    if (parse_host_port(&laddr, lhost) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (parse_host_port(&raddr, rhost) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_DGRAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket(PF_INET, SOCK_DGRAM)\");\n\n        return -1;\n\n    }\n\n\n\n    ret = socket_set_fast_reuse(fd);\n\n    if (ret < 0) {\n\n        closesocket(fd);\n\n        return -1;\n\n    }\n\n    ret = bind(fd, (struct sockaddr *)&laddr, sizeof(laddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n        closesocket(fd);\n\n        return -1;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n\n\n    s = net_socket_fd_init(peer, model, name, fd, 0);\n\n    if (!s) {\n\n        return -1;\n\n    }\n\n\n\n    s->dgram_dst = raddr;\n\n\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: udp=%s:%d\",\n\n             inet_ntoa(raddr.sin_addr), ntohs(raddr.sin_port));\n\n    return 0;\n\n}\n", "idx": 17378}
{"project": "qemu", "commit_id": "0d9acba8fddbf970c7353083e6a60b47017ce3e4", "target": 1, "func": "static void audio_init (PCIBus *pci_bus)\n\n{\n\n    struct soundhw *c;\n\n    int audio_enabled = 0;\n\n\n\n    for (c = soundhw; !audio_enabled && c->name; ++c) {\n\n        audio_enabled = c->enabled;\n\n    }\n\n\n\n    if (audio_enabled) {\n\n        AudioState *s;\n\n\n\n        s = AUD_init ();\n\n        if (s) {\n\n            for (c = soundhw; c->name; ++c) {\n\n                if (c->enabled)\n\n                    c->init.init_pci (pci_bus, s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17386}
{"project": "FFmpeg", "commit_id": "bd6ece4609b49eb40f880252452b809bff8f13ec", "target": 1, "func": "static int query_codec(enum CodecID id, int std_compliance)\n\n{\n\n    CodecMime *cm= ff_id3v2_mime_tags;\n\n    while(cm->id != CODEC_ID_NONE) {\n\n        if(id == cm->id)\n\n            return MKTAG('A', 'P', 'I', 'C');\n\n        cm++;\n\n    }\n\n    return -1;\n\n}\n", "idx": 17388}
{"project": "qemu", "commit_id": "9c554c1c0b01642c39232489cef8301a7858824d", "target": 1, "func": "void cuda_init (int *cuda_mem_index, qemu_irq irq)\n\n{\n\n    struct tm tm;\n\n    CUDAState *s = &cuda_state;\n\n\n\n    s->irq = irq;\n\n\n\n    s->timers[0].index = 0;\n\n    s->timers[0].timer = qemu_new_timer(vm_clock, cuda_timer1, s);\n\n\n\n    s->timers[1].index = 1;\n\n\n\n    qemu_get_timedate(&tm, RTC_OFFSET);\n\n    s->tick_offset = mktimegm(&tm);\n\n\n\n    s->adb_poll_timer = qemu_new_timer(vm_clock, cuda_adb_poll, s);\n\n    *cuda_mem_index = cpu_register_io_memory(0, cuda_read, cuda_write, s);\n\n    register_savevm(\"cuda\", -1, 1, cuda_save, cuda_load, s);\n\n    qemu_register_reset(cuda_reset, s);\n\n    cuda_reset(s);\n\n}\n", "idx": 17407}
{"project": "FFmpeg", "commit_id": "e4a1d87ef88d57cca21ec425120c6a370fdb0210", "target": 1, "func": "static void mkv_free(MatroskaMuxContext *mkv) {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    if (mkv->main_seekhead) {\n\n        av_freep(&mkv->main_seekhead->entries);\n\n        av_freep(&mkv->main_seekhead);\n\n\n    if (mkv->cues) {\n\n        av_freep(&mkv->cues->entries);\n\n        av_freep(&mkv->cues);\n\n\n    if (mkv->attachments) {\n\n        av_freep(&mkv->attachments->entries);\n\n        av_freep(&mkv->attachments);\n\n\n    av_freep(&mkv->tracks);\n\n    av_freep(&mkv->stream_durations);\n\n    av_freep(&mkv->stream_duration_offsets);\n", "idx": 17458}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void raven_pcihost_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n    dc->realize = raven_pcihost_realizefn;\n\n    dc->fw_name = \"pci\";\n\n    dc->no_user = 1;\n\n}\n", "idx": 17463}
{"project": "qemu", "commit_id": "760794f784f66e262a9ca32821ba202cdf3a3e4b", "target": 1, "func": "static int chr_can_read(void *opaque)\n\n{\n\n    int can_read;\n\n    SCLPConsole *scon = opaque;\n\n\n\n    can_read = SIZE_BUFFER_VT220 - scon->iov_data_len;\n\n\n\n    return can_read;\n\n}\n", "idx": 17478}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "int show_filters(void *optctx, const char *opt, const char *arg)\n\n{\n\n    AVFilter av_unused(**filter) = NULL;\n\n\n\n    printf(\"Filters:\\n\");\n\n#if CONFIG_AVFILTER\n\n    while ((filter = av_filter_next(filter)) && *filter)\n\n        printf(\"%-16s %s\\n\", (*filter)->name, (*filter)->description);\n\n#endif\n\n    return 0;\n\n}\n", "idx": 17492}
{"project": "FFmpeg", "commit_id": "d934de5c5d9ff1d228d0113e31e182efe2a853aa", "target": 0, "func": "static int cavs_find_frame_end(ParseContext *pc, const uint8_t *buf,\n\n                               int buf_size) {\n\n    int pic_found, i;\n\n    uint32_t state;\n\n\n\n    pic_found= pc->frame_start_found;\n\n    state= pc->state;\n\n\n\n    i=0;\n\n    if(!pic_found){\n\n        for(i=0; i<buf_size; i++){\n\n            state= (state<<8) | buf[i];\n\n            if(state == PIC_I_START_CODE || state == PIC_PB_START_CODE){\n\n                i++;\n\n                pic_found=1;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if(pic_found){\n\n        /* EOF considered as end of frame */\n\n        if (buf_size == 0)\n\n            return 0;\n\n        for(; i<buf_size; i++){\n\n            state= (state<<8) | buf[i];\n\n            if((state&0xFFFFFF00) == 0x100){\n\n                if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){\n\n                    pc->frame_start_found=0;\n\n                    pc->state=-1;\n\n                    return i-3;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pc->frame_start_found= pic_found;\n\n    pc->state= state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 17505}
{"project": "FFmpeg", "commit_id": "004564c930ef60d2f9e8798e820ed7b2a37ba0bd", "target": 0, "func": "static void bwf_write_bext_chunk(AVFormatContext *s)\n\n{\n\n    AVDictionaryEntry *tmp_tag;\n\n    uint64_t time_reference = 0;\n\n    int64_t bext = ff_start_tag(s->pb, \"bext\");\n\n\n\n    bwf_write_bext_string(s, \"description\", 256);\n\n    bwf_write_bext_string(s, \"originator\", 32);\n\n    bwf_write_bext_string(s, \"originator_reference\", 32);\n\n    bwf_write_bext_string(s, \"origination_date\", 10);\n\n    bwf_write_bext_string(s, \"origination_time\", 8);\n\n\n\n    if (tmp_tag = av_dict_get(s->metadata, \"time_reference\", NULL, 0))\n\n        time_reference = strtoll(tmp_tag->value, NULL, 10);\n\n    avio_wl64(s->pb, time_reference);\n\n    avio_wl16(s->pb, 1);  // set version to 1\n\n\n\n    if (tmp_tag = av_dict_get(s->metadata, \"umid\", NULL, 0)) {\n\n        unsigned char umidpart_str[17] = {0};\n\n        int64_t i;\n\n        uint64_t umidpart;\n\n        size_t len = strlen(tmp_tag->value+2);\n\n\n\n        for (i = 0; i < len/16; i++) {\n\n            memcpy(umidpart_str, tmp_tag->value + 2 + (i*16), 16);\n\n            umidpart = strtoll(umidpart_str, NULL, 16);\n\n            avio_wb64(s->pb, umidpart);\n\n        }\n\n        ffio_fill(s->pb, 0, 64 - i*8);\n\n    } else\n\n        ffio_fill(s->pb, 0, 64); // zero UMID\n\n\n\n    ffio_fill(s->pb, 0, 190); // Reserved\n\n\n\n    if (tmp_tag = av_dict_get(s->metadata, \"coding_history\", NULL, 0))\n\n        avio_put_str(s->pb, tmp_tag->value);\n\n\n\n    ff_end_tag(s->pb, bext);\n\n}\n", "idx": 17539}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static void free_schro_frame(SchroFrame *frame, void *priv)\n\n{\n\n    AVFrame *p_pic = priv;\n\n    av_frame_free(&p_pic);\n\n}\n", "idx": 17544}
{"project": "qemu", "commit_id": "6273d1136af913aaf4badc4545ccf942557c747b", "target": 1, "func": "static void qdict_do_flatten(QDict *qdict, QDict *target, const char *prefix)\n\n{\n\n    QObject *value;\n\n    const QDictEntry *entry, *next;\n\n    const char *new_key;\n\n    bool delete;\n\n\n\n    entry = qdict_first(qdict);\n\n\n\n    while (entry != NULL) {\n\n\n\n        next = qdict_next(qdict, entry);\n\n        value = qdict_entry_value(entry);\n\n        new_key = NULL;\n\n        delete = false;\n\n\n\n        if (prefix) {\n\n            qobject_incref(value);\n\n            new_key = g_strdup_printf(\"%s.%s\", prefix, entry->key);\n\n            qdict_put_obj(target, new_key, value);\n\n            delete = true;\n\n        }\n\n\n\n        if (qobject_type(value) == QTYPE_QDICT) {\n\n            qdict_do_flatten(qobject_to_qdict(value), target,\n\n                             new_key ? new_key : entry->key);\n\n            delete = true;\n\n        }\n\n\n\n        if (delete) {\n\n            qdict_del(qdict, entry->key);\n\n\n\n            /* Restart loop after modifying the iterated QDict */\n\n            entry = qdict_first(qdict);\n\n            continue;\n\n        }\n\n\n\n        entry = next;\n\n    }\n\n}\n", "idx": 17558}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_divd)(float64 a, float64 b, CPUUniCore32State *env)\n\n{\n\n    return float64_div(a, b, &env->ucf64.fp_status);\n\n}\n", "idx": 17571}
{"project": "FFmpeg", "commit_id": "aac0eda40754c010ab5156dcd5d0d1554937e9a7", "target": 0, "func": "static void decode_pulses(Pulse * pulse, GetBitContext * gb, const uint16_t * swb_offset) {\n\n    int i;\n\n    pulse->num_pulse = get_bits(gb, 2) + 1;\n\n    pulse->pos[0]    = swb_offset[get_bits(gb, 6)];\n\n    pulse->pos[0]   += get_bits(gb, 5);\n\n    pulse->amp[0]    = get_bits(gb, 4);\n\n    for (i = 1; i < pulse->num_pulse; i++) {\n\n        pulse->pos[i] = get_bits(gb, 5) + pulse->pos[i-1];\n\n        pulse->amp[i] = get_bits(gb, 4);\n\n    }\n\n}\n", "idx": 17585}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_fbuge(TCGv dst, TCGv src,\n\n                                    unsigned int fcc_offset)\n\n{\n\n    gen_mov_reg_FCC0(dst, src, fcc_offset);\n\n    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);\n\n    tcg_gen_xori_tl(cpu_tmp0, cpu_tmp0, 0x1);\n\n    tcg_gen_and_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 17588}
{"project": "qemu", "commit_id": "dbecebddfa4932d1c83915bcb9b5ba5984eb91be", "target": 0, "func": "int bdrv_open_backing_file(BlockDriverState *bs, QDict *options, Error **errp)\n\n{\n\n    char backing_filename[PATH_MAX];\n\n    int back_flags, ret;\n\n    BlockDriver *back_drv = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    if (bs->backing_hd != NULL) {\n\n        QDECREF(options);\n\n        return 0;\n\n    }\n\n\n\n    /* NULL means an empty set of options */\n\n    if (options == NULL) {\n\n        options = qdict_new();\n\n    }\n\n\n\n    bs->open_flags &= ~BDRV_O_NO_BACKING;\n\n    if (qdict_haskey(options, \"file.filename\")) {\n\n        backing_filename[0] = '\\0';\n\n    } else if (bs->backing_file[0] == '\\0' && qdict_size(options) == 0) {\n\n        QDECREF(options);\n\n        return 0;\n\n    }\n\n\n\n    bs->backing_hd = bdrv_new(\"\");\n\n    bdrv_get_full_backing_filename(bs, backing_filename,\n\n                                   sizeof(backing_filename));\n\n\n\n    if (bs->backing_format[0] != '\\0') {\n\n        back_drv = bdrv_find_format(bs->backing_format);\n\n    }\n\n\n\n    /* backing files always opened read-only */\n\n    back_flags = bs->open_flags & ~(BDRV_O_RDWR | BDRV_O_SNAPSHOT);\n\n\n\n    ret = bdrv_open(bs->backing_hd,\n\n                    *backing_filename ? backing_filename : NULL, options,\n\n                    back_flags, back_drv, &local_err);\n\n    if (ret < 0) {\n\n        bdrv_unref(bs->backing_hd);\n\n        bs->backing_hd = NULL;\n\n        bs->open_flags |= BDRV_O_NO_BACKING;\n\n        error_propagate(errp, local_err);\n\n        return ret;\n\n    }\n\n    return 0;\n\n}\n", "idx": 17594}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static OSStatus audioDeviceIOProc(\n\n    AudioDeviceID inDevice,\n\n    const AudioTimeStamp* inNow,\n\n    const AudioBufferList* inInputData,\n\n    const AudioTimeStamp* inInputTime,\n\n    AudioBufferList* outOutputData,\n\n    const AudioTimeStamp* inOutputTime,\n\n    void* hwptr)\n\n{\n\n    UInt32 frame, frameCount;\n\n    float *out = outOutputData->mBuffers[0].mData;\n\n    HWVoiceOut *hw = hwptr;\n\n    coreaudioVoiceOut *core = (coreaudioVoiceOut *) hwptr;\n\n    int rpos, live;\n\n    st_sample_t *src;\n\n#ifndef FLOAT_MIXENG\n\n#ifdef RECIPROCAL\n\n    const float scale = 1.f / UINT_MAX;\n\n#else\n\n    const float scale = UINT_MAX;\n\n#endif\n\n#endif\n\n\n\n    if (coreaudio_lock (core, \"audioDeviceIOProc\")) {\n\n        inInputTime = 0;\n\n        return 0;\n\n    }\n\n\n\n    frameCount = core->audioDevicePropertyBufferFrameSize;\n\n    live = core->live;\n\n\n\n    /* if there are not enough samples, set signal and return */\n\n    if (live < frameCount) {\n\n        inInputTime = 0;\n\n        coreaudio_unlock (core, \"audioDeviceIOProc(empty)\");\n\n        return 0;\n\n    }\n\n\n\n    rpos = core->rpos;\n\n    src = hw->mix_buf + rpos;\n\n\n\n    /* fill buffer */\n\n    for (frame = 0; frame < frameCount; frame++) {\n\n#ifdef FLOAT_MIXENG\n\n        *out++ = src[frame].l; /* left channel */\n\n        *out++ = src[frame].r; /* right channel */\n\n#else\n\n#ifdef RECIPROCAL\n\n        *out++ = src[frame].l * scale; /* left channel */\n\n        *out++ = src[frame].r * scale; /* right channel */\n\n#else\n\n        *out++ = src[frame].l / scale; /* left channel */\n\n        *out++ = src[frame].r / scale; /* right channel */\n\n#endif\n\n#endif\n\n    }\n\n\n\n    rpos = (rpos + frameCount) % hw->samples;\n\n    core->decr += frameCount;\n\n    core->rpos = rpos;\n\n\n\n    coreaudio_unlock (core, \"audioDeviceIOProc\");\n\n    return 0;\n\n}\n", "idx": 17600}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void m68k_cpu_initfn(Object *obj)\n\n{\n\n    CPUState *cs = CPU(obj);\n\n    M68kCPU *cpu = M68K_CPU(obj);\n\n    CPUM68KState *env = &cpu->env;\n\n    static bool inited;\n\n\n\n    cs->env_ptr = env;\n\n    cpu_exec_init(cs, &error_abort);\n\n\n\n    if (tcg_enabled() && !inited) {\n\n        inited = true;\n\n        m68k_tcg_init();\n\n    }\n\n}\n", "idx": 17604}
{"project": "FFmpeg", "commit_id": "5e9a56a0350c518cd4b38845aff49d41a9c952ae", "target": 0, "func": "static int decode_wave_header(AVCodecContext *avctx, const uint8_t *header,\n\n                              int header_size)\n\n{\n\n    int len;\n\n    short wave_format;\n\n\n\n\n\n    if (bytestream_get_le32(&header) != MKTAG('R','I','F','F')) {\n\n        av_log(avctx, AV_LOG_ERROR, \"missing RIFF tag\\n\");\n\n        return -1;\n\n    }\n\n\n\n    header += 4; /* chunk size */;\n\n\n\n    if (bytestream_get_le32(&header) != MKTAG('W','A','V','E')) {\n\n        av_log(avctx, AV_LOG_ERROR, \"missing WAVE tag\\n\");\n\n        return -1;\n\n    }\n\n\n\n    while (bytestream_get_le32(&header) != MKTAG('f','m','t',' ')) {\n\n        len = bytestream_get_le32(&header);\n\n        header += len;\n\n    }\n\n    len = bytestream_get_le32(&header);\n\n\n\n    if (len < 16) {\n\n        av_log(avctx, AV_LOG_ERROR, \"fmt chunk was too short\\n\");\n\n        return -1;\n\n    }\n\n\n\n    wave_format = bytestream_get_le16(&header);\n\n\n\n    switch (wave_format) {\n\n        case WAVE_FORMAT_PCM:\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"unsupported wave format\\n\");\n\n            return -1;\n\n    }\n\n\n\n    header += 2;        // skip channels    (already got from shorten header)\n\n    avctx->sample_rate = bytestream_get_le32(&header);\n\n    header += 4;        // skip bit rate    (represents original uncompressed bit rate)\n\n    header += 2;        // skip block align (not needed)\n\n    avctx->bits_per_coded_sample = bytestream_get_le16(&header);\n\n\n\n    if (avctx->bits_per_coded_sample != 16) {\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported number of bits per sample\\n\");\n\n        return -1;\n\n    }\n\n\n\n    len -= 16;\n\n    if (len > 0)\n\n        av_log(avctx, AV_LOG_INFO, \"%d header bytes unparsed\\n\", len);\n\n\n\n    return 0;\n\n}\n", "idx": 17622}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "static bool bdrv_drain_one(BlockDriverState *bs)\n\n{\n\n    bool bs_busy;\n\n\n\n    bdrv_flush_io_queue(bs);\n\n    bdrv_start_throttled_reqs(bs);\n\n    bs_busy = bdrv_requests_pending(bs);\n\n    bs_busy |= aio_poll(bdrv_get_aio_context(bs), bs_busy);\n\n    return bs_busy;\n\n}\n", "idx": 17623}
{"project": "qemu", "commit_id": "2174f12bdeb3974141784e14bbb7ad8c53178cd9", "target": 0, "func": "static BlockAIOCB *raw_aio_readv(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    return raw_aio_submit(bs, sector_num, qiov, nb_sectors,\n\n                          cb, opaque, QEMU_AIO_READ);\n\n}\n", "idx": 17636}
{"project": "qemu", "commit_id": "4618e658e6dadd1ba53585157984eac71cb706c6", "target": 0, "func": "static int authenticate(BDRVSSHState *s, const char *user)\n\n{\n\n    int r, ret;\n\n    const char *userauthlist;\n\n    LIBSSH2_AGENT *agent = NULL;\n\n    struct libssh2_agent_publickey *identity;\n\n    struct libssh2_agent_publickey *prev_identity = NULL;\n\n\n\n    userauthlist = libssh2_userauth_list(s->session, user, strlen(user));\n\n    if (strstr(userauthlist, \"publickey\") == NULL) {\n\n        ret = -EPERM;\n\n        error_report(\"remote server does not support \\\"publickey\\\" authentication\");\n\n        goto out;\n\n    }\n\n\n\n    /* Connect to ssh-agent and try each identity in turn. */\n\n    agent = libssh2_agent_init(s->session);\n\n    if (!agent) {\n\n        ret = -EINVAL;\n\n        session_error_report(s, \"failed to initialize ssh-agent support\");\n\n        goto out;\n\n    }\n\n    if (libssh2_agent_connect(agent)) {\n\n        ret = -ECONNREFUSED;\n\n        session_error_report(s, \"failed to connect to ssh-agent\");\n\n        goto out;\n\n    }\n\n    if (libssh2_agent_list_identities(agent)) {\n\n        ret = -EINVAL;\n\n        session_error_report(s, \"failed requesting identities from ssh-agent\");\n\n        goto out;\n\n    }\n\n\n\n    for(;;) {\n\n        r = libssh2_agent_get_identity(agent, &identity, prev_identity);\n\n        if (r == 1) {           /* end of list */\n\n            break;\n\n        }\n\n        if (r < 0) {\n\n            ret = -EINVAL;\n\n            session_error_report(s, \"failed to obtain identity from ssh-agent\");\n\n            goto out;\n\n        }\n\n        r = libssh2_agent_userauth(agent, user, identity);\n\n        if (r == 0) {\n\n            /* Authenticated! */\n\n            ret = 0;\n\n            goto out;\n\n        }\n\n        /* Failed to authenticate with this identity, try the next one. */\n\n        prev_identity = identity;\n\n    }\n\n\n\n    ret = -EPERM;\n\n    error_report(\"failed to authenticate using publickey authentication \"\n\n                 \"and the identities held by your ssh-agent\");\n\n\n\n out:\n\n    if (agent != NULL) {\n\n        /* Note: libssh2 implementation implicitly calls\n\n         * libssh2_agent_disconnect if necessary.\n\n         */\n\n        libssh2_agent_free(agent);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 17637}
{"project": "qemu", "commit_id": "f5bebbbb28dc7a149a891f0f1e112fb50bb72664", "target": 0, "func": "static bool bdrv_is_valid_name(const char *name)\n\n{\n\n    return qemu_opts_id_wellformed(name);\n\n}\n", "idx": 17639}
{"project": "qemu", "commit_id": "494cb81741f867319f11ecfa0949168baf9f01d7", "target": 0, "func": "static void vnc_tls_handshake_io(void *opaque) {\n\n    struct VncState *vs = (struct VncState *)opaque;\n\n\n\n    VNC_DEBUG(\"Handshake IO continue\\n\");\n\n    vnc_start_vencrypt_handshake(vs);\n\n}\n", "idx": 17647}
{"project": "qemu", "commit_id": "a0fa2cb8ccf0b73cfd3ac01d557401a2303c0de4", "target": 0, "func": "int sclp_service_call(uint32_t sccb, uint64_t code)\n\n{\n\n    int r = 0;\n\n    SCCB work_sccb;\n\n\n\n    hwaddr sccb_len = sizeof(SCCB);\n\n\n\n    /* first some basic checks on program checks */\n\n    if (cpu_physical_memory_is_io(sccb)) {\n\n        r = -PGM_ADDRESSING;\n\n        goto out;\n\n    }\n\n    if (sccb & ~0x7ffffff8ul) {\n\n        r = -PGM_SPECIFICATION;\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * we want to work on a private copy of the sccb, to prevent guests\n\n     * from playing dirty tricks by modifying the memory content after\n\n     * the host has checked the values\n\n     */\n\n    cpu_physical_memory_read(sccb, &work_sccb, sccb_len);\n\n\n\n    /* Valid sccb sizes */\n\n    if (be16_to_cpu(work_sccb.h.length) < sizeof(SCCBHeader) ||\n\n        be16_to_cpu(work_sccb.h.length) > SCCB_SIZE) {\n\n        r = -PGM_SPECIFICATION;\n\n        goto out;\n\n    }\n\n\n\n    sclp_execute((SCCB *)&work_sccb, code);\n\n\n\n    cpu_physical_memory_write(sccb, &work_sccb,\n\n                              be16_to_cpu(work_sccb.h.length));\n\n\n\n    sclp_service_interrupt(sccb);\n\n\n\nout:\n\n    return r;\n\n}\n", "idx": 17654}
{"project": "qemu", "commit_id": "e2a176dfda32f5cf80703c2921a19fe75850c38c", "target": 0, "func": "static void taihu_cpld_writeb (void *opaque,\n\n                               hwaddr addr, uint32_t value)\n\n{\n\n    taihu_cpld_t *cpld;\n\n\n\n    cpld = opaque;\n\n    switch (addr) {\n\n    case 0x0:\n\n        /* Read only */\n\n        break;\n\n    case 0x1:\n\n        cpld->reg1 = value;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 17663}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void dp8393x_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    uint16_t old_val = dp8393x_readw(opaque, addr & ~0x1);\n\n\n\n    switch (addr & 3) {\n\n    case 0:\n\n        val = val | (old_val & 0xff00);\n\n        break;\n\n    case 1:\n\n        val = (val << 8) | (old_val & 0x00ff);\n\n        break;\n\n    }\n\n    dp8393x_writew(opaque, addr & ~0x1, val);\n\n}\n", "idx": 17688}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void eepro100_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t data, unsigned size)\n\n{\n\n    EEPRO100State *s = opaque;\n\n\n\n    switch (size) {\n\n    case 1:\n\n        eepro100_write1(s, addr, data);\n\n        break;\n\n    case 2:\n\n        eepro100_write2(s, addr, data);\n\n        break;\n\n    case 4:\n\n        eepro100_write4(s, addr, data);\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n}\n", "idx": 17698}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int asf_probe(AVProbeData *pd)\n\n{\n\n    /* check file header */\n\n    if (pd->buf_size <= 32)\n\n        return 0;\n\n\n\n    if (!memcmp(pd->buf, &asf_header, sizeof(GUID)))\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n", "idx": 17734}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline TCGv gen_ld8s(TCGv addr, int index)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_qemu_ld8s(tmp, addr, index);\n\n    return tmp;\n\n}\n", "idx": 17739}
{"project": "qemu", "commit_id": "b2d1fe67d09d2b6c7da647fbcea6ca0148c206d3", "target": 1, "func": "static void usbredir_handle_bulk_data(USBRedirDevice *dev, USBPacket *p,\n\n                                      uint8_t ep)\n\n{\n\n    struct usb_redir_bulk_packet_header bulk_packet;\n\n    size_t size = (p->combined) ? p->combined->iov.size : p->iov.size;\n\n\n\n    DPRINTF(\"bulk-out ep %02X len %zd id %\"PRIu64\"\\n\", ep, size, p->id);\n\n\n\n    if (usbredir_already_in_flight(dev, p->id)) {\n\n        p->status = USB_RET_ASYNC;\n\n        return;\n\n    }\n\n\n\n    bulk_packet.endpoint  = ep;\n\n    bulk_packet.length    = size;\n\n    bulk_packet.stream_id = 0;\n\n    bulk_packet.length_high = size >> 16;\n\n    assert(bulk_packet.length_high == 0 ||\n\n           usbredirparser_peer_has_cap(dev->parser,\n\n                                       usb_redir_cap_32bits_bulk_length));\n\n\n\n    if (ep & USB_DIR_IN) {\n\n        usbredirparser_send_bulk_packet(dev->parser, p->id,\n\n                                        &bulk_packet, NULL, 0);\n\n    } else {\n\n        uint8_t buf[size];\n\n        if (p->combined) {\n\n            iov_to_buf(p->combined->iov.iov, p->combined->iov.niov,\n\n                       0, buf, size);\n\n        } else {\n\n            usb_packet_copy(p, buf, size);\n\n        }\n\n        usbredir_log_data(dev, \"bulk data out:\", buf, size);\n\n        usbredirparser_send_bulk_packet(dev->parser, p->id,\n\n                                        &bulk_packet, buf, size);\n\n    }\n\n    usbredirparser_do_write(dev->parser);\n\n    p->status = USB_RET_ASYNC;\n\n}\n", "idx": 17751}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_fop_dedd(DisasContext *ctx, uint32_t insn,\n\n                                 const DisasInsn *di)\n\n{\n\n    unsigned rt = extract32(insn, 0, 5);\n\n    unsigned rb = extract32(insn, 16, 5);\n\n    unsigned ra = extract32(insn, 21, 5);\n\n    return do_fop_dedd(ctx, rt, ra, rb, di->f_dedd);\n\n}\n", "idx": 17767}
{"project": "FFmpeg", "commit_id": "9b211c43dc5f2e618f204c4a7fd184eb2ea51f02", "target": 1, "func": "static AVStream *add_stream(AVFormatContext *oc, AVCodec **codec,\n\n                            enum AVCodecID codec_id)\n\n{\n\n    AVCodecContext *c;\n\n    AVStream *st;\n\n\n\n    /* find the encoder */\n\n    *codec = avcodec_find_encoder(codec_id);\n\n    if (!(*codec)) {\n\n        fprintf(stderr, \"Could not find encoder for '%s'\\n\",\n\n                avcodec_get_name(codec_id));\n\n        exit(1);\n\n    }\n\n\n\n    st = avformat_new_stream(oc, *codec);\n\n    if (!st) {\n\n        fprintf(stderr, \"Could not allocate stream\\n\");\n\n        exit(1);\n\n    }\n\n    st->id = oc->nb_streams-1;\n\n    c = st->codec;\n\n\n\n    switch ((*codec)->type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        st->id = 1;\n\n        c->sample_fmt  = AV_SAMPLE_FMT_S16;\n\n        c->bit_rate    = 64000;\n\n        c->sample_rate = 44100;\n\n        c->channels    = 2;\n\n        break;\n\n\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        avcodec_get_context_defaults3(c, *codec);\n\n        c->codec_id = codec_id;\n\n\n\n        c->bit_rate = 400000;\n\n        /* Resolution must be a multiple of two. */\n\n        c->width    = 352;\n\n        c->height   = 288;\n\n        /* timebase: This is the fundamental unit of time (in seconds) in terms\n\n         * of which frame timestamps are represented. For fixed-fps content,\n\n         * timebase should be 1/framerate and timestamp increments should be\n\n         * identical to 1. */\n\n        c->time_base.den = STREAM_FRAME_RATE;\n\n        c->time_base.num = 1;\n\n        c->gop_size      = 12; /* emit one intra frame every twelve frames at most */\n\n        c->pix_fmt       = STREAM_PIX_FMT;\n\n        if (c->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n            /* just for testing, we also add B frames */\n\n            c->max_b_frames = 2;\n\n        }\n\n        if (c->codec_id == AV_CODEC_ID_MPEG1VIDEO) {\n\n            /* Needed to avoid using macroblocks in which some coeffs overflow.\n\n             * This does not happen with normal video, it just happens here as\n\n             * the motion of the chroma plane does not match the luma plane. */\n\n            c->mb_decision = 2;\n\n        }\n\n    break;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Some formats want stream headers to be separate. */\n\n    if (oc->oformat->flags & AVFMT_GLOBALHEADER)\n\n        c->flags |= CODEC_FLAG_GLOBAL_HEADER;\n\n\n\n    return st;\n\n}\n", "idx": 17768}
{"project": "qemu", "commit_id": "ad718d01ba0af531d10b0a8685cf5047edfd1891", "target": 1, "func": "int qemu_opt_set_bool(QemuOpts *opts, const char *name, bool val)\n\n{\n\n    QemuOpt *opt;\n\n    const QemuOptDesc *desc = opts->list->desc;\n\n    int i;\n\n\n\n    for (i = 0; desc[i].name != NULL; i++) {\n\n        if (strcmp(desc[i].name, name) == 0) {\n\n            break;\n\n        }\n\n    }\n\n    if (desc[i].name == NULL) {\n\n        if (i == 0) {\n\n            /* empty list -> allow any */;\n\n        } else {\n\n            qerror_report(QERR_INVALID_PARAMETER, name);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    opt = g_malloc0(sizeof(*opt));\n\n    opt->name = g_strdup(name);\n\n    opt->opts = opts;\n\n    QTAILQ_INSERT_TAIL(&opts->head, opt, next);\n\n    if (desc[i].name != NULL) {\n\n        opt->desc = desc+i;\n\n    }\n\n    opt->value.boolean = !!val;\n\n    return 0;\n\n}\n", "idx": 17783}
{"project": "qemu", "commit_id": "2d528d45ecf5ee3c1a566a9f3d664464925ef830", "target": 1, "func": "static CharDriverState *qemu_chr_open_pp_fd(int fd)\n\n{\n\n    CharDriverState *chr;\n\n    ParallelCharDriver *drv;\n\n\n\n    if (ioctl(fd, PPCLAIM) < 0) {\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n\n\n    drv = g_malloc0(sizeof(ParallelCharDriver));\n\n    drv->fd = fd;\n\n    drv->mode = IEEE1284_MODE_COMPAT;\n\n\n\n    chr = qemu_chr_alloc();\n\n    chr->chr_write = null_chr_write;\n\n    chr->chr_ioctl = pp_ioctl;\n\n    chr->chr_close = pp_close;\n\n    chr->opaque = drv;\n\n\n\n    return chr;\n\n}\n", "idx": 17818}
{"project": "FFmpeg", "commit_id": "ffbd1d2b0002576ef0d976a41ff959c635373fdc", "target": 1, "func": "av_cold void ff_vp9dsp_init(VP9DSPContext *dsp)\n\n{\n\n    vp9dsp_intrapred_init(dsp);\n\n    vp9dsp_itxfm_init(dsp);\n\n    vp9dsp_loopfilter_init(dsp);\n\n    vp9dsp_mc_init(dsp);\n\n\n\n\n\n    if (ARCH_X86)\n\n        ff_vp9dsp_init_x86(dsp);\n\n}", "idx": 17825}
{"project": "qemu", "commit_id": "5eb6a3c50185e101f87382f41fb66eed5784e7ac", "target": 1, "func": "void qdev_prop_set_globals(DeviceState *dev)\n\n{\n\n    ObjectClass *class = object_get_class(OBJECT(dev));\n\n\n\n    do {\n\n        qdev_prop_set_globals_for_type(dev, object_class_get_name(class));\n\n        class = object_class_get_parent(class);\n\n    } while (class);\n\n}\n", "idx": 17842}
{"project": "qemu", "commit_id": "5839e53bbc0fec56021d758aab7610df421ed8c8", "target": 1, "func": "BlockDriverState *bdrv_new(const char *device_name, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    int i;\n\n\n\n    if (bdrv_find(device_name)) {\n\n        error_setg(errp, \"Device with id '%s' already exists\",\n\n                   device_name);\n\n        return NULL;\n\n    }\n\n    if (bdrv_find_node(device_name)) {\n\n        error_setg(errp, \"Device with node-name '%s' already exists\",\n\n                   device_name);\n\n        return NULL;\n\n    }\n\n\n\n    bs = g_malloc0(sizeof(BlockDriverState));\n\n    QLIST_INIT(&bs->dirty_bitmaps);\n\n    pstrcpy(bs->device_name, sizeof(bs->device_name), device_name);\n\n    if (device_name[0] != '\\0') {\n\n        QTAILQ_INSERT_TAIL(&bdrv_states, bs, device_list);\n\n    }\n\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n\n        QLIST_INIT(&bs->op_blockers[i]);\n\n    }\n\n    bdrv_iostatus_disable(bs);\n\n    notifier_list_init(&bs->close_notifiers);\n\n    notifier_with_return_list_init(&bs->before_write_notifiers);\n\n    qemu_co_queue_init(&bs->throttled_reqs[0]);\n\n    qemu_co_queue_init(&bs->throttled_reqs[1]);\n\n    bs->refcnt = 1;\n\n    bs->aio_context = qemu_get_aio_context();\n\n\n\n    return bs;\n\n}\n", "idx": 17858}
{"project": "FFmpeg", "commit_id": "221f902f1dc167bdc0bfdff6b6af3214ae3cc1f4", "target": 1, "func": "static void filter_edges(void *dst1, void *prev1, void *cur1, void *next1,\n\n                         int w, int prefs, int mrefs, int parity, int mode)\n\n{\n\n    uint8_t *dst  = dst1;\n\n    uint8_t *prev = prev1;\n\n    uint8_t *cur  = cur1;\n\n    uint8_t *next = next1;\n\n    int x;\n\n    uint8_t *prev2 = parity ? prev : cur ;\n\n    uint8_t *next2 = parity ? cur  : next;\n\n\n\n    /* Only edge pixels need to be processed here.  A constant value of false\n\n     * for is_not_edge should let the compiler ignore the whole branch. */\n\n    FILTER(0, 3, 0)\n\n\n\n    dst  = (uint8_t*)dst1  + w - 3;\n\n    prev = (uint8_t*)prev1 + w - 3;\n\n    cur  = (uint8_t*)cur1  + w - 3;\n\n    next = (uint8_t*)next1 + w - 3;\n\n    prev2 = (uint8_t*)(parity ? prev : cur);\n\n    next2 = (uint8_t*)(parity ? cur  : next);\n\n\n\n    FILTER(w - 3, w, 0)\n\n}\n", "idx": 17866}
{"project": "qemu", "commit_id": "651eb0f41b793021f7de672de78892def5819fb9", "target": 1, "func": "static int kvm_set_user_memory_region(KVMState *s, KVMSlot *slot)\n\n{\n\n    struct kvm_userspace_memory_region mem;\n\n\n\n    mem.slot = slot->slot;\n\n    mem.guest_phys_addr = slot->start_addr;\n\n    mem.userspace_addr = (unsigned long)slot->ram;\n\n    mem.flags = slot->flags;\n\n    if (s->migration_log) {\n\n        mem.flags |= KVM_MEM_LOG_DIRTY_PAGES;\n\n    }\n\n    if (mem.flags & KVM_MEM_READONLY) {\n\n        /* Set the slot size to 0 before setting the slot to the desired\n\n         * value. This is needed based on KVM commit 75d61fbc. */\n\n        mem.memory_size = 0;\n\n        kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);\n\n    }\n\n    mem.memory_size = slot->memory_size;\n\n    return kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);\n\n}\n", "idx": 17871}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "void cpu_exec_init(CPUState *cpu, Error **errp)\n\n{\n\n    CPUClass *cc ATTRIBUTE_UNUSED = CPU_GET_CLASS(cpu);\n\n\n\n    cpu_list_add(cpu);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {\n\n        vmstate_register(NULL, cpu->cpu_index, &vmstate_cpu_common, cpu);\n\n    }\n\n    if (cc->vmsd != NULL) {\n\n        vmstate_register(NULL, cpu->cpu_index, cc->vmsd, cpu);\n\n    }\n\n#endif\n\n}\n", "idx": 17889}
{"project": "FFmpeg", "commit_id": "07339a45a04e5fa0848937090511d69a39a04740", "target": 1, "func": "int ff_packet_split_and_drop_side_data(AVPacket *pkt){\n\n    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){\n\n        int i;\n\n        unsigned int size;\n\n        uint8_t *p;\n\n\n\n        p = pkt->data + pkt->size - 8 - 5;\n\n        for (i=1; ; i++){\n\n            size = AV_RB32(p);\n\n            if (size>INT_MAX - 5 || p - pkt->data < size)\n\n\n            if (p[4]&128)\n\n                break;\n\n            if (p - pkt->data < size + 5)\n\n\n            p-= size+5;\n\n\n\n        }\n\n        pkt->size = p - pkt->data - size;\n\n        av_assert0(pkt->size >= 0);\n\n        return 1;\n\n    }\n\n\n}", "idx": 17925}
{"project": "qemu", "commit_id": "164a101f28a53cd3db60ed874e7c3630e7988ed8", "target": 1, "func": "static bool aio_dispatch(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    bool progress = false;\n\n\n\n    /*\n\n     * We have to walk very carefully in case qemu_aio_set_fd_handler is\n\n     * called while we're walking.\n\n     */\n\n    node = QLIST_FIRST(&ctx->aio_handlers);\n\n    while (node) {\n\n        AioHandler *tmp;\n\n        int revents;\n\n\n\n        ctx->walking_handlers++;\n\n\n\n        revents = node->pfd.revents & node->pfd.events;\n\n        node->pfd.revents = 0;\n\n\n\n        if (!node->deleted &&\n\n            (revents & (G_IO_IN | G_IO_HUP | G_IO_ERR)) &&\n\n            node->io_read) {\n\n            node->io_read(node->opaque);\n\n            progress = true;\n\n        }\n\n        if (!node->deleted &&\n\n            (revents & (G_IO_OUT | G_IO_ERR)) &&\n\n            node->io_write) {\n\n            node->io_write(node->opaque);\n\n            progress = true;\n\n        }\n\n\n\n        tmp = node;\n\n        node = QLIST_NEXT(node, node);\n\n\n\n        ctx->walking_handlers--;\n\n\n\n        if (!ctx->walking_handlers && tmp->deleted) {\n\n            QLIST_REMOVE(tmp, node);\n\n            g_free(tmp);\n\n        }\n\n    }\n\n    return progress;\n\n}\n", "idx": 17933}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void piix4_ide_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->no_hotplug = 1;\n\n    k->init = pci_piix_ide_initfn;\n\n    k->exit = pci_piix_ide_exitfn;\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_82371AB;\n\n    k->class_id = PCI_CLASS_STORAGE_IDE;\n\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n\n    dc->no_user = 1;\n\n}\n", "idx": 17938}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qdict_add_key(const char *key, QObject *obj, void *opaque)\n\n{\n\n    GHashTable *h = opaque;\n\n    g_hash_table_insert(h, (gpointer) key, NULL);\n\n}\n", "idx": 17958}
{"project": "qemu", "commit_id": "3718d8ab65f68de2acccbe6a315907805f54e3cc", "target": 0, "func": "static void eject_device(BlockDriverState *bs, int force, Error **errp)\n\n{\n\n    if (bdrv_in_use(bs)) {\n\n        error_set(errp, QERR_DEVICE_IN_USE, bdrv_get_device_name(bs));\n\n        return;\n\n    }\n\n    if (!bdrv_dev_has_removable_media(bs)) {\n\n        error_setg(errp, \"Device '%s' is not removable\",\n\n                   bdrv_get_device_name(bs));\n\n        return;\n\n    }\n\n\n\n    if (bdrv_dev_is_medium_locked(bs) && !bdrv_dev_is_tray_open(bs)) {\n\n        bdrv_dev_eject_request(bs, force);\n\n        if (!force) {\n\n            error_setg(errp, \"Device '%s' is locked\",\n\n                       bdrv_get_device_name(bs));\n\n            return;\n\n        }\n\n    }\n\n\n\n    bdrv_close(bs);\n\n}\n", "idx": 17964}
{"project": "FFmpeg", "commit_id": "7d204e67e8f991bfdfb6a6e91b6855b6c5a782c0", "target": 1, "func": "void ff_rm_free_rmstream (RMStream *rms)\n\n{\n\n    av_free(rms->videobuf);\n\n    av_free(rms->audiobuf);\n\n}\n", "idx": 17984}
{"project": "qemu", "commit_id": "b53ccc30c40df52d192e469a86c188a8649c6df3", "target": 1, "func": "void qmp_dump_guest_memory(bool paging, const char *file, bool has_begin,\n\n                           int64_t begin, bool has_length, int64_t length,\n\n                           Error **errp)\n\n{\n\n    const char *p;\n\n    int fd = -1;\n\n    DumpState *s;\n\n    int ret;\n\n\n\n    if (has_begin && !has_length) {\n\n        error_set(errp, QERR_MISSING_PARAMETER, \"length\");\n\n        return;\n\n    }\n\n    if (!has_begin && has_length) {\n\n        error_set(errp, QERR_MISSING_PARAMETER, \"begin\");\n\n        return;\n\n    }\n\n\n\n#if !defined(WIN32)\n\n    if (strstart(file, \"fd:\", &p)) {\n\n        fd = monitor_get_fd(cur_mon, p, errp);\n\n        if (fd == -1) {\n\n            return;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if  (strstart(file, \"file:\", &p)) {\n\n        fd = qemu_open(p, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, S_IRUSR);\n\n        if (fd < 0) {\n\n            error_setg_file_open(errp, errno, p);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (fd == -1) {\n\n        error_set(errp, QERR_INVALID_PARAMETER, \"protocol\");\n\n        return;\n\n    }\n\n\n\n    s = g_malloc0(sizeof(DumpState));\n\n\n\n    ret = dump_init(s, fd, paging, has_begin, begin, length, errp);\n\n    if (ret < 0) {\n\n        g_free(s);\n\n        return;\n\n    }\n\n\n\n    if (create_vmcore(s) < 0 && !error_is_set(s->errp)) {\n\n        error_set(errp, QERR_IO_ERROR);\n\n    }\n\n\n\n    g_free(s);\n\n}\n", "idx": 17986}
{"project": "qemu", "commit_id": "10f12e6450407b18b4d5a6b50d3852dcfd7fff75", "target": 1, "func": "static bool spapr_drc_needed(void *opaque)\n\n{\n\n    sPAPRDRConnector *drc = (sPAPRDRConnector *)opaque;\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    /* If no dev is plugged in there is no need to migrate the DRC state */\n\n    if (!drc->dev) {\n\n        return false;\n\n    }\n\n\n\n    /*\n\n     * We need to migrate the state if it's not equal to the expected\n\n     * long-term state, which is the same as the coldplugged initial\n\n     * state */\n\n    return (drc->state != drck->ready_state);\n\n}\n", "idx": 17989}
{"project": "qemu", "commit_id": "39a611a3e035e148257af314a522a6cd169c2d0e", "target": 1, "func": "int qcow2_snapshot_delete(BlockDriverState *bs,\n\n                          const char *snapshot_id,\n\n                          const char *name,\n\n                          Error **errp)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowSnapshot sn;\n\n    int snapshot_index, ret;\n\n\n\n    /* Search the snapshot */\n\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n\n    if (snapshot_index < 0) {\n\n        error_setg(errp, \"Can't find the snapshot\");\n\n        return -ENOENT;\n\n    }\n\n    sn = s->snapshots[snapshot_index];\n\n\n\n    /* Remove it from the snapshot list */\n\n    memmove(s->snapshots + snapshot_index,\n\n            s->snapshots + snapshot_index + 1,\n\n            (s->nb_snapshots - snapshot_index - 1) * sizeof(sn));\n\n    s->nb_snapshots--;\n\n    ret = qcow2_write_snapshots(bs);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to remove snapshot from snapshot list\");\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * The snapshot is now unused, clean up. If we fail after this point, we\n\n     * won't recover but just leak clusters.\n\n     */\n\n    g_free(sn.id_str);\n\n    g_free(sn.name);\n\n\n\n    /*\n\n     * Now decrease the refcounts of clusters referenced by the snapshot and\n\n     * free the L1 table.\n\n     */\n\n    ret = qcow2_update_snapshot_refcount(bs, sn.l1_table_offset,\n\n                                         sn.l1_size, -1);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to free the cluster and L1 table\");\n\n        return ret;\n\n    }\n\n    qcow2_free_clusters(bs, sn.l1_table_offset, sn.l1_size * sizeof(uint64_t),\n\n                        QCOW2_DISCARD_SNAPSHOT);\n\n\n\n    /* must update the copied flag on the current cluster offsets */\n\n    ret = qcow2_update_snapshot_refcount(bs, s->l1_table_offset, s->l1_size, 0);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to update snapshot status in disk\");\n\n        return ret;\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC\n\n    {\n\n        BdrvCheckResult result = {0};\n\n        qcow2_check_refcounts(bs, &result, 0);\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 17993}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void mcf_uart_mm_init(MemoryRegion *sysmem,\n\n                      target_phys_addr_t base,\n\n                      qemu_irq irq,\n\n                      CharDriverState *chr)\n\n{\n\n    mcf_uart_state *s;\n\n\n\n    s = mcf_uart_init(irq, chr);\n\n    memory_region_init_io(&s->iomem, &mcf_uart_ops, s, \"uart\", 0x40);\n\n    memory_region_add_subregion(sysmem, base, &s->iomem);\n\n}\n", "idx": 18003}
{"project": "qemu", "commit_id": "277acfe8b38de35be8cb6e274678b5a7919c2d44", "target": 0, "func": "static void expr_error(Monitor *mon, const char *msg)\n\n{\n\n    monitor_printf(mon, \"%s\\n\", msg);\n\n    siglongjmp(expr_env, 1);\n\n}\n", "idx": 18005}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static void usb_msd_send_status(MSDState *s, USBPacket *p)\n\n{\n\n    struct usb_msd_csw csw;\n\n    int len;\n\n\n\n    csw.sig = cpu_to_le32(0x53425355);\n\n    csw.tag = cpu_to_le32(s->tag);\n\n    csw.residue = s->residue;\n\n    csw.status = s->result;\n\n\n\n    len = MIN(sizeof(csw), p->len);\n\n    memcpy(p->data, &csw, len);\n\n}\n", "idx": 18028}
{"project": "qemu", "commit_id": "acedcfbf7a9a29c772f613bafac9f3430faa6347", "target": 0, "func": "static NetSocketState *net_socket_fd_init(VLANState *vlan,\n\n                                          const char *model, const char *name,\n\n                                          int fd, int is_connected)\n\n{\n\n    int so_type=-1, optlen=sizeof(so_type);\n\n\n\n    if(getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&so_type,\n\n        (socklen_t *)&optlen)< 0) {\n\n\tfprintf(stderr, \"qemu: error: getsockopt(SO_TYPE) for fd=%d failed\\n\", fd);\n\n\treturn NULL;\n\n    }\n\n    switch(so_type) {\n\n    case SOCK_DGRAM:\n\n        return net_socket_fd_init_dgram(vlan, model, name, fd, is_connected);\n\n    case SOCK_STREAM:\n\n        return net_socket_fd_init_stream(vlan, model, name, fd, is_connected);\n\n    default:\n\n        /* who knows ... this could be a eg. a pty, do warn and continue as stream */\n\n        fprintf(stderr, \"qemu: warning: socket type=%d for fd=%d is not SOCK_DGRAM or SOCK_STREAM\\n\", so_type, fd);\n\n        return net_socket_fd_init_stream(vlan, model, name, fd, is_connected);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 18045}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void ich_ahci_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->init = pci_ich9_ahci_init;\n\n    k->exit = pci_ich9_uninit;\n\n    k->config_write = pci_ich9_write_config;\n\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n\n    k->device_id = PCI_DEVICE_ID_INTEL_82801IR;\n\n    k->revision = 0x02;\n\n    k->class_id = PCI_CLASS_STORAGE_SATA;\n\n    dc->alias = \"ahci\";\n\n    dc->vmsd = &vmstate_ahci;\n\n}\n", "idx": 18061}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int sol_probe(AVProbeData *p)\n\n{\n\n    /* check file header */\n\n    uint16_t magic;\n\n    if (p->buf_size <= 14)\n\n        return 0;\n\n    magic=le2me_16(*((uint16_t*)p->buf));\n\n    if ((magic == 0x0B8D || magic == 0x0C0D || magic == 0x0C8D) &&\n\n        p->buf[2] == 'S' && p->buf[3] == 'O' &&\n\n        p->buf[4] == 'L' && p->buf[5] == 0)\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n", "idx": 18064}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_psr (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return GET_PSR(env);\n\n}\n", "idx": 18078}
{"project": "qemu", "commit_id": "d9f62dde1303286b24ac8ce88be27e2b9b9c5f46", "target": 0, "func": "opts_start_list(Visitor *v, const char *name, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n\n\n    /* we can't traverse a list in a list */\n\n    assert(ov->list_mode == LM_NONE);\n\n    ov->repeated_opts = lookup_distinct(ov, name, errp);\n\n    if (ov->repeated_opts != NULL) {\n\n        ov->list_mode = LM_STARTED;\n\n    }\n\n}\n", "idx": 18102}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "static bool bdrv_drain_recurse(BlockDriverState *bs)\n\n{\n\n    BdrvChild *child;\n\n    bool waited;\n\n\n\n    waited = bdrv_drain_poll(bs);\n\n\n\n    if (bs->drv && bs->drv->bdrv_drain) {\n\n        bs->drv->bdrv_drain(bs);\n\n    }\n\n\n\n    QLIST_FOREACH(child, &bs->children, next) {\n\n        waited |= bdrv_drain_recurse(child->bs);\n\n    }\n\n\n\n    return waited;\n\n}\n", "idx": 18114}
{"project": "qemu", "commit_id": "9e41bade85ef338afd983c109368d1bbbe931f80", "target": 0, "func": "static void pxa2xx_i2c_slave_class_init(ObjectClass *klass, void *data)\n\n{\n\n    I2CSlaveClass *k = I2C_SLAVE_CLASS(klass);\n\n\n\n    k->init = pxa2xx_i2c_slave_init;\n\n    k->event = pxa2xx_i2c_event;\n\n    k->recv = pxa2xx_i2c_rx;\n\n    k->send = pxa2xx_i2c_tx;\n\n}\n", "idx": 18127}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "static inline int32_t efsctsi(uint32_t val)\n\n{\n\n    CPU_FloatU u;\n\n\n\n    u.l = val;\n\n    /* NaN are not treated the same way IEEE 754 does */\n\n    if (unlikely(float32_is_nan(u.f)))\n\n        return 0;\n\n\n\n    return float32_to_int32(u.f, &env->vec_status);\n\n}\n", "idx": 18129}
{"project": "qemu", "commit_id": "03d843ddf271e96b6f8b2cd8a58f7a2004fcfaf9", "target": 0, "func": "static inline int handle_cpu_signal(unsigned long pc,\n\n                                    unsigned long address,\n\n                                    int is_write,\n\n                                    sigset_t *old_set)\n\n{\n\n#if defined(DEBUG_SIGNAL)\n\n    printf(\"qemu: SIGSEGV pc=0x%08lx address=%08lx wr=%d oldset=0x%08lx\\n\", \n\n           pc, address, is_write, *(unsigned long *)old_set);\n\n#endif\n\n    /* XXX: locking issue */\n\n    if (is_write && page_unprotect(address)) {\n\n        sigprocmask(SIG_SETMASK, old_set, NULL);\n\n        return 1;\n\n    }\n\n    if (pc >= (unsigned long)code_gen_buffer &&\n\n        pc < (unsigned long)code_gen_buffer + CODE_GEN_BUFFER_SIZE) {\n\n        /* the PC is inside the translated code. It means that we have\n\n           a virtual CPU fault */\n\n        /* we restore the process signal mask as the sigreturn should\n\n           do it */\n\n        sigprocmask(SIG_SETMASK, old_set, NULL);\n\n        /* XXX: need to compute virtual pc position by retranslating\n\n           code. The rest of the CPU state should be correct. */\n\n        env->cr2 = address;\n\n        raise_exception_err(EXCP0E_PAGE, 4 | (is_write << 1));\n\n        /* never comes here */\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 18130}
{"project": "qemu", "commit_id": "3098dba01c7daab60762b6f6624ea88c0d6cb65a", "target": 0, "func": "void DBDMA_schedule(void)\n\n{\n\n    CPUState *env = cpu_single_env;\n\n    if (env)\n\n        cpu_interrupt(env, CPU_INTERRUPT_EXIT);\n\n}\n", "idx": 18133}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "void helper_fdmulq(CPUSPARCState *env, float64 src1, float64 src2)\n\n{\n\n    clear_float_exceptions(env);\n\n    QT0 = float128_mul(float64_to_float128(src1, &env->fp_status),\n\n                       float64_to_float128(src2, &env->fp_status),\n\n                       &env->fp_status);\n\n    check_ieee_exceptions(env);\n\n}\n", "idx": 18146}
{"project": "qemu", "commit_id": "3b22c4707decb706b10ce023534f8b79413ff9fe", "target": 0, "func": "void helper_iret_real(int shift)\n\n{\n\n    uint32_t sp, new_cs, new_eip, new_eflags, new_esp;\n\n    uint8_t *ssp;\n\n    int eflags_mask;\n\n    \n\n    sp = env->regs[R_ESP] & 0xffff;\n\n    ssp = env->segs[R_SS].base + sp;\n\n    if (shift == 1) {\n\n        /* 32 bits */\n\n        new_eflags = ldl(ssp + 8);\n\n        new_cs = ldl(ssp + 4) & 0xffff;\n\n        new_eip = ldl(ssp) & 0xffff;\n\n    } else {\n\n        /* 16 bits */\n\n        new_eflags = lduw(ssp + 4);\n\n        new_cs = lduw(ssp + 2);\n\n        new_eip = lduw(ssp);\n\n    }\n\n    new_esp = sp + (6 << shift);\n\n    env->regs[R_ESP] = (env->regs[R_ESP] & 0xffff0000) | \n\n        (new_esp & 0xffff);\n\n    load_seg_vm(R_CS, new_cs);\n\n    env->eip = new_eip;\n\n    eflags_mask = FL_UPDATE_CPL0_MASK;\n\n    if (shift == 0)\n\n        eflags_mask &= 0xffff;\n\n    load_eflags(new_eflags, eflags_mask);\n\n}\n", "idx": 18149}
{"project": "qemu", "commit_id": "33e66b86d89040f0a9e99aa53deb74ce8936a649", "target": 1, "func": "USBDevice *usb_msd_init(const char *filename)\n\n{\n\n    static int nr=0;\n\n    char id[8];\n\n    QemuOpts *opts;\n\n    DriveInfo *dinfo;\n\n    USBDevice *dev;\n\n    int fatal_error;\n\n    const char *p1;\n\n    char fmt[32];\n\n\n\n    /* parse -usbdevice disk: syntax into drive opts */\n\n    snprintf(id, sizeof(id), \"usb%d\", nr++);\n\n    opts = qemu_opts_create(&qemu_drive_opts, id, 0);\n\n\n\n    p1 = strchr(filename, ':');\n\n    if (p1++) {\n\n        const char *p2;\n\n\n\n        if (strstart(filename, \"format=\", &p2)) {\n\n            int len = MIN(p1 - p2, sizeof(fmt));\n\n            pstrcpy(fmt, len, p2);\n\n            qemu_opt_set(opts, \"format\", fmt);\n\n        } else if (*filename != ':') {\n\n            printf(\"unrecognized USB mass-storage option %s\\n\", filename);\n\n            return NULL;\n\n        }\n\n        filename = p1;\n\n    }\n\n    if (!*filename) {\n\n        printf(\"block device specification needed\\n\");\n\n        return NULL;\n\n    }\n\n    qemu_opt_set(opts, \"file\", filename);\n\n    qemu_opt_set(opts, \"if\", \"none\");\n\n\n\n    /* create host drive */\n\n    dinfo = drive_init(opts, NULL, &fatal_error);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n        return NULL;\n\n    }\n\n\n\n    /* create guest device */\n\n    dev = usb_create(NULL /* FIXME */, \"QEMU USB MSD\");\n\n    qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n    qdev_init(&dev->qdev);\n\n\n\n    return dev;\n\n}\n", "idx": 18179}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "static void rtc_get_date(Object *obj, Visitor *v, void *opaque,\n\n                         const char *name, Error **errp)\n\n{\n\n    Error *err = NULL;\n\n    RTCState *s = MC146818_RTC(obj);\n\n    struct tm current_tm;\n\n\n\n    rtc_update_time(s);\n\n    rtc_get_time(s, &current_tm);\n\n    visit_start_struct(v, NULL, \"struct tm\", name, 0, &err);\n\n    if (err) {\n\n        goto out;\n\n    }\n\n    visit_type_int32(v, &current_tm.tm_year, \"tm_year\", &err);\n\n    visit_type_int32(v, &current_tm.tm_mon, \"tm_mon\", &err);\n\n    visit_type_int32(v, &current_tm.tm_mday, \"tm_mday\", &err);\n\n    visit_type_int32(v, &current_tm.tm_hour, \"tm_hour\", &err);\n\n    visit_type_int32(v, &current_tm.tm_min, \"tm_min\", &err);\n\n    visit_type_int32(v, &current_tm.tm_sec, \"tm_sec\", &err);\n\n    visit_end_struct(v, &err);\n\n\n\nout:\n\n    error_propagate(errp, err);\n\n}\n", "idx": 18191}
{"project": "FFmpeg", "commit_id": "97cfa55eea39cef30abe14682c56c1e4e7f6f10d", "target": 1, "func": "static void ff_compute_band_indexes(MPADecodeContext *s, GranuleDef *g)\n\n{\n\n    if (g->block_type == 2) {\n\n        if (g->switch_point) {\n\n            /* if switched mode, we handle the 36 first samples as\n\n                long blocks.  For 8000Hz, we handle the 72 first\n\n                exponents as long blocks */\n\n            if (s->sample_rate_index <= 2)\n\n                g->long_end = 8;\n\n            else\n\n                g->long_end = 6;\n\n\n\n            g->short_start = 2 + (s->sample_rate_index != 8);\n\n        } else {\n\n            g->long_end    = 0;\n\n            g->short_start = 0;\n\n        }\n\n    } else {\n\n        g->short_start = 13;\n\n        g->long_end    = 22;\n\n    }\n\n}\n", "idx": 18217}
{"project": "qemu", "commit_id": "53cb28cbfea038f8ad50132dc8a684e638c7d48b", "target": 0, "func": "static uint16_t phys_section_add(MemoryRegionSection *section)\n\n{\n\n    /* The physical section number is ORed with a page-aligned\n\n     * pointer to produce the iotlb entries.  Thus it should\n\n     * never overflow into the page-aligned value.\n\n     */\n\n    assert(next_map.sections_nb < TARGET_PAGE_SIZE);\n\n\n\n    if (next_map.sections_nb == next_map.sections_nb_alloc) {\n\n        next_map.sections_nb_alloc = MAX(next_map.sections_nb_alloc * 2,\n\n                                         16);\n\n        next_map.sections = g_renew(MemoryRegionSection, next_map.sections,\n\n                                    next_map.sections_nb_alloc);\n\n    }\n\n    next_map.sections[next_map.sections_nb] = *section;\n\n    memory_region_ref(section->mr);\n\n    return next_map.sections_nb++;\n\n}\n", "idx": 18221}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint32_t intel_hda_mmio_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    return intel_hda_reg_read(d, reg, 0xff);\n\n}\n", "idx": 18232}
{"project": "FFmpeg", "commit_id": "80a5d05108cb218e8cd2e25c6621a3bfef0a832e", "target": 0, "func": "static av_cold int vaapi_encode_h264_init_fixed_qp(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext      *ctx = avctx->priv_data;\n\n    VAAPIEncodeH264Context *priv = ctx->priv_data;\n\n    VAAPIEncodeH264Options  *opt = ctx->codec_options;\n\n\n\n    priv->fixed_qp_p = opt->qp;\n\n    if (avctx->i_quant_factor > 0.0)\n\n        priv->fixed_qp_idr = (int)((priv->fixed_qp_p * avctx->i_quant_factor +\n\n                                    avctx->i_quant_offset) + 0.5);\n\n    else\n\n        priv->fixed_qp_idr = priv->fixed_qp_p;\n\n    if (avctx->b_quant_factor > 0.0)\n\n        priv->fixed_qp_b = (int)((priv->fixed_qp_p * avctx->b_quant_factor +\n\n                                  avctx->b_quant_offset) + 0.5);\n\n    else\n\n        priv->fixed_qp_b = priv->fixed_qp_p;\n\n\n\n    av_log(avctx, AV_LOG_DEBUG, \"Using fixed QP = \"\n\n           \"%d / %d / %d for IDR- / P- / B-frames.\\n\",\n\n           priv->fixed_qp_idr, priv->fixed_qp_p, priv->fixed_qp_b);\n\n    return 0;\n\n}\n", "idx": 18234}
{"project": "qemu", "commit_id": "3182664220571d11d4fe03ecdc10fcc1e842ed32", "target": 0, "func": "static bool is_zero(BlockDriverState *bs, int64_t offset, int64_t bytes)\n\n{\n\n    int nr;\n\n    int64_t res;\n\n    int64_t start;\n\n\n\n    /* TODO: Widening to sector boundaries should only be needed as\n\n     * long as we can't query finer granularity. */\n\n    start = QEMU_ALIGN_DOWN(offset, BDRV_SECTOR_SIZE);\n\n    bytes = QEMU_ALIGN_UP(offset + bytes, BDRV_SECTOR_SIZE) - start;\n\n\n\n    /* Clamp to image length, before checking status of underlying sectors */\n\n    if (start + bytes > bs->total_sectors * BDRV_SECTOR_SIZE) {\n\n        bytes = bs->total_sectors * BDRV_SECTOR_SIZE - start;\n\n    }\n\n\n\n    if (!bytes) {\n\n        return true;\n\n    }\n\n    res = bdrv_get_block_status_above(bs, NULL, start >> BDRV_SECTOR_BITS,\n\n                                      bytes >> BDRV_SECTOR_BITS, &nr, NULL);\n\n    return res >= 0 && (res & BDRV_BLOCK_ZERO) &&\n\n        nr * BDRV_SECTOR_SIZE == bytes;\n\n}\n", "idx": 18238}
{"project": "FFmpeg", "commit_id": "d7cabb3c7e843c2028b398cb19a40db84d40c790", "target": 0, "func": "int ff_bgmc_init(AVCodecContext *avctx, uint8_t **cf_lut, int **cf_lut_status)\n\n{\n\n    *cf_lut        = av_malloc(sizeof(**cf_lut)        * LUT_BUFF * 16 * LUT_SIZE);\n\n    *cf_lut_status = av_malloc(sizeof(**cf_lut_status) * LUT_BUFF);\n\n\n\n    if (!cf_lut || !cf_lut_status) {\n\n        ff_bgmc_end(cf_lut, cf_lut_status);\n\n        av_log(avctx, AV_LOG_ERROR, \"Allocating buffer memory failed.\\n\");\n\n        return AVERROR(ENOMEM);\n\n    } else {\n\n        // initialize lut_status buffer to a value never used to compare against\n\n        memset(*cf_lut_status, -1, sizeof(**cf_lut_status) * LUT_BUFF);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18257}
{"project": "qemu", "commit_id": "fc1c4a5d32e15a4c40c47945da85ef9c1e0c1b54", "target": 0, "func": "void ram_handle_compressed(void *host, uint8_t ch, uint64_t size)\n\n{\n\n    if (ch != 0 || !is_zero_range(host, size)) {\n\n        memset(host, ch, size);\n\n#ifndef _WIN32\n\n        if (ch == 0 && (!kvm_enabled() || kvm_has_sync_mmu())) {\n\n            size = size & ~(getpagesize() - 1);\n\n            if (size > 0) {\n\n                qemu_madvise(host, size, QEMU_MADV_DONTNEED);\n\n            }\n\n        }\n\n#endif\n\n    }\n\n}\n", "idx": 18278}
{"project": "qemu", "commit_id": "c8057f951d64de93bfd01569c0a725baa9f94372", "target": 1, "func": "static QEMUMachine *machine_parse(const char *name)\n\n{\n\n    QEMUMachine *m, *machine = NULL;\n\n\n\n    if (name) {\n\n        machine = find_machine(name);\n\n    }\n\n    if (machine) {\n\n        return machine;\n\n    }\n\n    printf(\"Supported machines are:\\n\");\n\n    for (m = first_machine; m != NULL; m = m->next) {\n\n        if (m->alias) {\n\n            printf(\"%-20s %s (alias of %s)\\n\", m->alias, m->desc, m->name);\n\n        }\n\n        printf(\"%-20s %s%s\\n\", m->name, m->desc,\n\n               m->is_default ? \" (default)\" : \"\");\n\n    }\n\n    exit(!name || *name != '?');\n\n}\n", "idx": 18283}
{"project": "qemu", "commit_id": "e53f27b9d9df73461308618151fa6e6392aebd85", "target": 1, "func": "static int do_getfd(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *fdname = qdict_get_str(qdict, \"fdname\");\n\n    mon_fd_t *monfd;\n\n    int fd;\n\n\n\n    fd = qemu_chr_get_msgfd(mon->chr);\n\n    if (fd == -1) {\n\n        qerror_report(QERR_FD_NOT_SUPPLIED);\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_isdigit(fdname[0])) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"fdname\",\n\n                      \"a name not starting with a digit\");\n\n        return -1;\n\n    }\n\n\n\n    fd = dup(fd);\n\n    if (fd == -1) {\n\n        if (errno == EMFILE)\n\n            qerror_report(QERR_TOO_MANY_FILES);\n\n        else\n\n            qerror_report(QERR_UNDEFINED_ERROR);\n\n        return -1;\n\n    }\n\n\n\n    QLIST_FOREACH(monfd, &mon->fds, next) {\n\n        if (strcmp(monfd->name, fdname) != 0) {\n\n            continue;\n\n        }\n\n\n\n        close(monfd->fd);\n\n        monfd->fd = fd;\n\n        return 0;\n\n    }\n\n\n\n    monfd = qemu_mallocz(sizeof(mon_fd_t));\n\n    monfd->name = qemu_strdup(fdname);\n\n    monfd->fd = fd;\n\n\n\n    QLIST_INSERT_HEAD(&mon->fds, monfd, next);\n\n    return 0;\n\n}\n", "idx": 18290}
{"project": "qemu", "commit_id": "8139626643cbe8dc07bd9acc88057effeedf8064", "target": 1, "func": "uint32_t lm4549_write_samples(lm4549_state *s, uint32_t left, uint32_t right)\n\n{\n\n    /* The left and right samples are in 20-bit resolution.\n\n       The LM4549 has 18-bit resolution and only uses the bits [19:2].\n\n       This model supports 16-bit playback.\n\n    */\n\n\n\n    if (s->buffer_level >= LM4549_BUFFER_SIZE) {\n\n        DPRINTF(\"write_sample Buffer full\\n\");\n\n        return 0;\n\n    }\n\n\n\n    /* Store 16-bit samples in the buffer */\n\n    s->buffer[s->buffer_level++] = (left >> 4);\n\n    s->buffer[s->buffer_level++] = (right >> 4);\n\n\n\n    if (s->buffer_level == LM4549_BUFFER_SIZE) {\n\n        /* Trigger the transfer of the buffer to the audio host */\n\n        lm4549_audio_transfer(s);\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 18300}
{"project": "qemu", "commit_id": "f293709c6af7a65a9bcec09cdba7a60183657a3e", "target": 1, "func": "static inline void code_gen_alloc(size_t tb_size)\n\n{\n\n    tcg_ctx.code_gen_buffer_size = size_code_gen_buffer(tb_size);\n\n    tcg_ctx.code_gen_buffer = alloc_code_gen_buffer();\n\n    if (tcg_ctx.code_gen_buffer == NULL) {\n\n        fprintf(stderr, \"Could not allocate dynamic translator buffer\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    qemu_madvise(tcg_ctx.code_gen_buffer, tcg_ctx.code_gen_buffer_size,\n\n                 QEMU_MADV_HUGEPAGE);\n\n\n\n    /* Estimate a good size for the number of TBs we can support.  We\n\n       still haven't deducted the prologue from the buffer size here,\n\n       but that's minimal and won't affect the estimate much.  */\n\n    tcg_ctx.code_gen_max_blocks\n\n        = tcg_ctx.code_gen_buffer_size / CODE_GEN_AVG_BLOCK_SIZE;\n\n    tcg_ctx.tb_ctx.tbs = g_new(TranslationBlock, tcg_ctx.code_gen_max_blocks);\n\n\n\n    qemu_mutex_init(&tcg_ctx.tb_ctx.tb_lock);\n\n}\n", "idx": 18320}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "QEMUTimerList *qemu_clock_get_main_loop_timerlist(QEMUClockType type)\n\n{\n\n    return main_loop_tlg.tl[type];\n\n}\n", "idx": 18342}
{"project": "qemu", "commit_id": "1945dbc15f0f1ffdc9a10526448e9eba7c599d98", "target": 0, "func": "static void openpic_update_irq(openpic_t *opp, int n_IRQ)\n\n{\n\n    IRQ_src_t *src;\n\n    int i;\n\n\n\n    src = &opp->src[n_IRQ];\n\n\n\n    if (!src->pending) {\n\n        /* no irq pending */\n\n        DPRINTF(\"%s: IRQ %d is not pending\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (test_bit(&src->ipvp, IPVP_MASK)) {\n\n        /* Interrupt source is disabled */\n\n        DPRINTF(\"%s: IRQ %d is disabled\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (IPVP_PRIORITY(src->ipvp) == 0) {\n\n        /* Priority set to zero */\n\n        DPRINTF(\"%s: IRQ %d has 0 priority\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (test_bit(&src->ipvp, IPVP_ACTIVITY)) {\n\n        /* IRQ already active */\n\n        DPRINTF(\"%s: IRQ %d is already active\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ide == 0x00000000) {\n\n        /* No target */\n\n        DPRINTF(\"%s: IRQ %d has no target\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n\n\n    if (src->ide == (1 << src->last_cpu)) {\n\n        /* Only one CPU is allowed to receive this IRQ */\n\n        IRQ_local_pipe(opp, src->last_cpu, n_IRQ);\n\n    } else if (!test_bit(&src->ipvp, IPVP_MODE)) {\n\n        /* Directed delivery mode */\n\n        for (i = 0; i < opp->nb_cpus; i++) {\n\n            if (test_bit(&src->ide, i))\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n        }\n\n    } else {\n\n        /* Distributed delivery mode */\n\n        for (i = src->last_cpu + 1; i != src->last_cpu; i++) {\n\n            if (i == opp->nb_cpus)\n\n                i = 0;\n\n            if (test_bit(&src->ide, i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n                src->last_cpu = i;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 18347}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void kqemu_reset_modified_ram_pages(void)\n\n{\n\n    int i;\n\n    unsigned long page_index;\n\n\n\n    for(i = 0; i < nb_modified_ram_pages; i++) {\n\n        page_index = modified_ram_pages[i] >> TARGET_PAGE_BITS;\n\n        modified_ram_pages_table[page_index] = 0;\n\n    }\n\n    nb_modified_ram_pages = 0;\n\n}\n", "idx": 18349}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void cirrus_mmio_write(void *opaque, target_phys_addr_t addr,\n\n                              uint64_t val, unsigned size)\n\n{\n\n    CirrusVGAState *s = opaque;\n\n\n\n    if (addr >= 0x100) {\n\n\tcirrus_mmio_blt_write(s, addr - 0x100, val);\n\n    } else {\n\n        cirrus_vga_ioport_write(s, addr + 0x3c0, val);\n\n    }\n\n}\n", "idx": 18353}
{"project": "FFmpeg", "commit_id": "6df2c94130b026930d1f7148699925dcaa08759c", "target": 0, "func": "static void yuv_from_cqt(ColorFloat *c, const FFTComplex *v, float gamma, int len)\n\n{\n\n    int x;\n\n    for (x = 0; x < len; x++) {\n\n        float r, g, b;\n\n        r = calculate_gamma(FFMIN(1.0f, v[x].re), gamma);\n\n        g = calculate_gamma(FFMIN(1.0f, 0.5f * (v[x].re + v[x].im)), gamma);\n\n        b = calculate_gamma(FFMIN(1.0f, v[x].im), gamma);\n\n        c[x].yuv.y = 16.0f + 65.481f * r + 128.553f * g + 24.966f * b;\n\n        c[x].yuv.u = 128.0f - 37.797f * r - 74.203f * g + 112.0f * b;\n\n        c[x].yuv.v = 128.0f + 112.0f * r - 93.786f * g - 18.214 * b;\n\n    }\n\n}\n", "idx": 18366}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void tcp_chr_close(CharDriverState *chr)\n\n{\n\n    TCPCharDriver *s = chr->opaque;\n\n    if (s->fd >= 0) {\n\n        if (s->tag) {\n\n            g_source_remove(s->tag);\n\n            s->tag = 0;\n\n        }\n\n        if (s->chan) {\n\n            g_io_channel_unref(s->chan);\n\n        }\n\n        closesocket(s->fd);\n\n    }\n\n    if (s->listen_fd >= 0) {\n\n        if (s->listen_tag) {\n\n            g_source_remove(s->listen_tag);\n\n            s->listen_tag = 0;\n\n        }\n\n        if (s->listen_chan) {\n\n            g_io_channel_unref(s->listen_chan);\n\n        }\n\n        closesocket(s->listen_fd);\n\n    }\n\n    g_free(s);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n}\n", "idx": 18390}
{"project": "qemu", "commit_id": "7e680753cfa2986e0a8b3b222b6bf0b003c5eb69", "target": 1, "func": "static int kvm_put_vcpu_events(CPUState *env, int level)\n\n{\n\n    struct kvm_vcpu_events events;\n\n\n\n    if (!kvm_has_vcpu_events()) {\n\n        return 0;\n\n    }\n\n\n\n    events.exception.injected = (env->exception_injected >= 0);\n\n    events.exception.nr = env->exception_injected;\n\n    events.exception.has_error_code = env->has_error_code;\n\n    events.exception.error_code = env->error_code;\n\n\n\n\n    events.interrupt.injected = (env->interrupt_injected >= 0);\n\n    events.interrupt.nr = env->interrupt_injected;\n\n    events.interrupt.soft = env->soft_interrupt;\n\n\n\n    events.nmi.injected = env->nmi_injected;\n\n    events.nmi.pending = env->nmi_pending;\n\n    events.nmi.masked = !!(env->hflags2 & HF2_NMI_MASK);\n\n    events.nmi.pad = 0;\n\n\n\n    events.sipi_vector = env->sipi_vector;\n\n\n\n    events.flags = 0;\n\n    if (level >= KVM_PUT_RESET_STATE) {\n\n        events.flags |=\n\n            KVM_VCPUEVENT_VALID_NMI_PENDING | KVM_VCPUEVENT_VALID_SIPI_VECTOR;\n\n    }\n\n\n\n    return kvm_vcpu_ioctl(env, KVM_SET_VCPU_EVENTS, &events);\n\n}", "idx": 18402}
{"project": "qemu", "commit_id": "12f8def0e02232d7c6416ad9b66640f973c531d1", "target": 1, "func": "void qemu_cond_signal(QemuCond *cond)\n\n{\n\n    DWORD result;\n\n\n\n    /*\n\n     * Signal only when there are waiters.  cond->waiters is\n\n     * incremented by pthread_cond_wait under the external lock,\n\n     * so we are safe about that.\n\n     */\n\n    if (cond->waiters == 0) {\n\n        return;\n\n    }\n\n\n\n    /*\n\n     * Waiting threads decrement it outside the external lock, but\n\n     * only if another thread is executing pthread_cond_broadcast and\n\n     * has the mutex.  So, it also cannot be decremented concurrently\n\n     * with this particular access.\n\n     */\n\n    cond->target = cond->waiters - 1;\n\n    result = SignalObjectAndWait(cond->sema, cond->continue_event,\n\n                                 INFINITE, FALSE);\n\n    if (result == WAIT_ABANDONED || result == WAIT_FAILED) {\n\n        error_exit(GetLastError(), __func__);\n\n    }\n\n}\n", "idx": 18413}
{"project": "FFmpeg", "commit_id": "d4f7d8386693beb987382ece8bb7499955620388", "target": 0, "func": "static int split_field_half_ref_list(Picture *dest, int dest_len,\n\n                                     Picture *src,  int src_len,  int parity){\n\n    int same_parity   = 1;\n\n    int same_i        = 0;\n\n    int opp_i         = 0;\n\n    int out_i;\n\n    int field_output;\n\n\n\n    for (out_i = 0; out_i < dest_len; out_i += field_output) {\n\n        if (same_parity && same_i < src_len) {\n\n            field_output = split_field_copy(dest + out_i, src + same_i,\n\n                                            parity, 1);\n\n            same_parity = !field_output;\n\n            same_i++;\n\n\n\n        } else if (opp_i < src_len) {\n\n            field_output = split_field_copy(dest + out_i, src + opp_i,\n\n                                            PICT_FRAME - parity, 0);\n\n            same_parity = field_output;\n\n            opp_i++;\n\n\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return out_i;\n\n}\n", "idx": 18419}
{"project": "qemu", "commit_id": "fd8cec932c2ddc687e2da954978954b46a926f90", "target": 1, "func": "int64_t xbzrle_cache_resize(int64_t new_size)\n\n{\n\n    if (new_size < TARGET_PAGE_SIZE) {\n\n        return -1;\n\n    }\n\n\n\n    if (XBZRLE.cache != NULL) {\n\n        return cache_resize(XBZRLE.cache, new_size / TARGET_PAGE_SIZE) *\n\n            TARGET_PAGE_SIZE;\n\n    }\n\n    return pow2floor(new_size);\n\n}\n", "idx": 18425}
{"project": "FFmpeg", "commit_id": "f92f4935acd7d974adfd1deebdf1bb06cbe107ca", "target": 1, "func": "static void count_usage(uint8_t *src, int width,\n\n                        int height, uint32_t *counts)\n\n{\n\n    int i, j;\n\n\n\n    for (j = 0; j < height; j++) {\n\n        for (i = 0; i < width; i++) {\n\n            counts[src[i]]++;\n\n        }\n\n        src += width;\n\n    }\n\n}\n", "idx": 18427}
{"project": "FFmpeg", "commit_id": "c82bf15dca00f67a701d126e47ea9075fc9459cb", "target": 1, "func": "void ff_rtp_send_hevc(AVFormatContext *ctx, const uint8_t *frame_buf, int frame_size)\n\n{\n\n    const uint8_t *next_NAL_unit;\n\n    const uint8_t *buf_ptr, *buf_end = frame_buf + frame_size;\n\n    RTPMuxContext *rtp_ctx = ctx->priv_data;\n\n\n\n    /* use the default 90 KHz time stamp */\n\n    rtp_ctx->timestamp = rtp_ctx->cur_timestamp;\n\n    rtp_ctx->buf_ptr   = rtp_ctx->buf;\n\n\n\n    if (rtp_ctx->nal_length_size)\n\n        buf_ptr = ff_avc_mp4_find_startcode(frame_buf, buf_end, rtp_ctx->nal_length_size) ? frame_buf : buf_end;\n\n    else\n\n        buf_ptr = ff_avc_find_startcode(frame_buf, buf_end);\n\n\n\n    /* find all NAL units and send them as separate packets */\n\n    while (buf_ptr < buf_end) {\n\n        if (rtp_ctx->nal_length_size) {\n\n            next_NAL_unit = ff_avc_mp4_find_startcode(buf_ptr, buf_end, rtp_ctx->nal_length_size);\n\n            if (!next_NAL_unit)\n\n                next_NAL_unit = buf_end;\n\n\n\n            buf_ptr += rtp_ctx->nal_length_size;\n\n        } else {\n\n            while (!*(buf_ptr++))\n\n                ;\n\n            next_NAL_unit = ff_avc_find_startcode(buf_ptr, buf_end);\n\n        }\n\n        /* send the next NAL unit */\n\n        nal_send(ctx, buf_ptr, next_NAL_unit - buf_ptr, next_NAL_unit == buf_end);\n\n\n\n        /* jump to the next NAL unit */\n\n        buf_ptr = next_NAL_unit;\n\n    }\n\n    flush_buffered(ctx, 1);\n\n}\n", "idx": 18451}
{"project": "FFmpeg", "commit_id": "c9454cb643f5404ca8f4f02e1384c863136f7a9e", "target": 1, "func": "int av_tempfile(const char *prefix, char **filename, int log_offset, void *log_ctx) {\n\n    FileLogContext file_log_ctx = { &file_log_ctx_class, log_offset, log_ctx };\n\n    int fd=-1;\n\n#if !HAVE_MKSTEMP\n\n    void *ptr= tempnam(NULL, prefix);\n\n    if(!ptr)\n\n        ptr= tempnam(\".\", prefix);\n\n    *filename = av_strdup(ptr);\n\n#undef free\n\n    free(ptr);\n\n#else\n\n    size_t len = strlen(prefix) + 12; /* room for \"/tmp/\" and \"XXXXXX\\0\" */\n\n    *filename = av_malloc(len);\n\n#endif\n\n    /* -----common section-----*/\n\n    if (*filename == NULL) {\n\n        av_log(&file_log_ctx, AV_LOG_ERROR, \"ff_tempfile: Cannot allocate file name\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n#if !HAVE_MKSTEMP\n\n#   ifndef O_BINARY\n\n#       define O_BINARY 0\n\n#   endif\n\n#   ifndef O_EXCL\n\n#       define O_EXCL 0\n\n#   endif\n\n    fd = open(*filename, O_RDWR | O_BINARY | O_CREAT | O_EXCL, 0600);\n\n#else\n\n    snprintf(*filename, len, \"/tmp/%sXXXXXX\", prefix);\n\n    fd = mkstemp(*filename);\n\n#ifdef _WIN32\n\n    if (fd < 0) {\n\n        snprintf(*filename, len, \"./%sXXXXXX\", prefix);\n\n        fd = mkstemp(*filename);\n\n    }\n\n#endif\n\n#endif\n\n    /* -----common section-----*/\n\n    if (fd < 0) {\n\n        int err = AVERROR(errno);\n\n        av_log(&file_log_ctx, AV_LOG_ERROR, \"ff_tempfile: Cannot open temporary file %s\\n\", *filename);\n\n\n        return err;\n\n    }\n\n    return fd; /* success */\n\n}", "idx": 18472}
{"project": "qemu", "commit_id": "848696bf353750899832c51005f1bd3540da5c29", "target": 1, "func": "static void i82374_isa_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ISAi82374State *isa = I82374(dev);\n\n    I82374State *s = &isa->state;\n\n    PortioList *port_list = g_new(PortioList, 1);\n\n\n\n    portio_list_init(port_list, OBJECT(isa), i82374_portio_list, s, \"i82374\");\n\n    portio_list_add(port_list, isa_address_space_io(&isa->parent_obj),\n\n                    isa->iobase);\n\n\n\n    i82374_realize(s, errp);\n\n\n\n    qdev_init_gpio_out(dev, &s->out, 1);\n\n}\n", "idx": 18481}
{"project": "qemu", "commit_id": "326b9e98a391d542cc33c4c91782ff4ba51edfc5", "target": 1, "func": "floatx80 floatx80_scalbn( floatx80 a, int n STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp;\n\n    uint64_t aSig;\n\n\n\n    aSig = extractFloatx80Frac( a );\n\n    aExp = extractFloatx80Exp( a );\n\n    aSign = extractFloatx80Sign( a );\n\n\n\n    if ( aExp == 0x7FF ) {\n\n        return a;\n\n    }\n\n    if (aExp == 0 && aSig == 0)\n\n        return a;\n\n\n\n    aExp += n;\n\n    return normalizeRoundAndPackFloatx80( STATUS(floatx80_rounding_precision),\n\n                                          aSign, aExp, aSig, 0 STATUS_VAR );\n\n}\n", "idx": 18497}
{"project": "qemu", "commit_id": "8827b0fb66cab9f7978c4e66dad4cf3c0989a72e", "target": 1, "func": "static void pl181_send_command(pl181_state *s)\n\n{\n\n    SDRequest request;\n\n    uint8_t response[16];\n\n    int rlen;\n\n\n\n    request.cmd = s->cmd & PL181_CMD_INDEX;\n\n    request.arg = s->cmdarg;\n\n    DPRINTF(\"Command %d %08x\\n\", request.cmd, request.arg);\n\n    rlen = sd_do_command(s->card, &request, response);\n\n    if (rlen < 0)\n\n        goto error;\n\n    if (s->cmd & PL181_CMD_RESPONSE) {\n\n#define RWORD(n) ((response[n] << 24) | (response[n + 1] << 16) \\\n\n                  | (response[n + 2] << 8) | response[n + 3])\n\n        if (rlen == 0 || (rlen == 4 && (s->cmd & PL181_CMD_LONGRESP)))\n\n            goto error;\n\n        if (rlen != 4 && rlen != 16)\n\n            goto error;\n\n        s->response[0] = RWORD(0);\n\n        if (rlen == 4) {\n\n            s->response[1] = s->response[2] = s->response[3] = 0;\n\n        } else {\n\n            s->response[1] = RWORD(4);\n\n            s->response[2] = RWORD(8);\n\n            s->response[3] = RWORD(12) & ~1;\n\n        }\n\n        DPRINTF(\"Response received\\n\");\n\n        s->status |= PL181_STATUS_CMDRESPEND;\n\n#undef RWORD\n\n    } else {\n\n        DPRINTF(\"Command sent\\n\");\n\n        s->status |= PL181_STATUS_CMDSENT;\n\n    }\n\n    return;\n\n\n\nerror:\n\n    DPRINTF(\"Timeout\\n\");\n\n    s->status |= PL181_STATUS_CMDTIMEOUT;\n\n}\n", "idx": 18528}
{"project": "FFmpeg", "commit_id": "3a8c95f730732b9f1ffacdbfbf79a01b202a67af", "target": 0, "func": "static void print_format_entry(const char *tag,\n\n                               const char *val)\n\n{\n\n    if (!fmt_entries_to_show) {\n\n        if (tag) {\n\n            printf(\"%s=%s\\n\", tag, val);\n\n        } else {\n\n            printf(\"%s\\n\", val);\n\n        }\n\n    } else if (tag && av_dict_get(fmt_entries_to_show, tag, NULL, 0)) {\n\n        if (nb_fmt_entries_to_show > 1)\n\n            printf(\"%s=\", tag);\n\n        printf(\"%s\\n\", val);\n\n    }\n\n}\n", "idx": 18541}
{"project": "FFmpeg", "commit_id": "6f1ccca4ae3b93b6a2a820a7a0e72081ab35767c", "target": 0, "func": "static int dnxhd_decode_dct_block_8(const DNXHDContext *ctx,\n\n                                    RowContext *row, int n)\n\n{\n\n    return dnxhd_decode_dct_block(ctx, row, n, 4, 32, 6);\n\n}\n", "idx": 18543}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void ram_control_load_hook(QEMUFile *f, uint64_t flags)\n\n{\n\n    int ret = -EINVAL;\n\n\n\n    if (f->ops->hook_ram_load) {\n\n        ret = f->ops->hook_ram_load(f, f->opaque, flags);\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n        }\n\n    } else {\n\n        qemu_file_set_error(f, ret);\n\n    }\n\n}\n", "idx": 18557}
{"project": "qemu", "commit_id": "97e89ee914411384dcda771d38bf89f13726d71e", "target": 1, "func": "static void gen_window_check3(DisasContext *dc, unsigned r1, unsigned r2,\n\n        unsigned r3)\n\n{\n\n    gen_window_check2(dc, r1, r2 > r3 ? r2 : r3);\n\n}\n", "idx": 18571}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "int usb_desc_handle_control(USBDevice *dev, int request, int value,\n\n                            int index, int length, uint8_t *data)\n\n{\n\n    const USBDesc *desc = dev->info->usb_desc;\n\n    int ret = -1;\n\n\n\n    assert(desc != NULL);\n\n    switch(request) {\n\n    case DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\n        dev->addr = value;\n\n        trace_usb_set_addr(dev->addr);\n\n        ret = 0;\n\n        break;\n\n\n\n    case DeviceRequest | USB_REQ_GET_DESCRIPTOR:\n\n        ret = usb_desc_get_descriptor(dev, value, data, length);\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 18603}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "static void trigger_prot_fault(CPUS390XState *env, target_ulong vaddr,\n\n                               uint64_t mode)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int ilen = ILEN_LATER_INC;\n\n    int bits = trans_bits(env, mode) | 4;\n\n\n\n    DPRINTF(\"%s: vaddr=%016\" PRIx64 \" bits=%d\\n\", __func__, vaddr, bits);\n\n\n\n    stq_phys(cs->as,\n\n             env->psa + offsetof(LowCore, trans_exc_code), vaddr | bits);\n\n    trigger_pgm_exception(env, PGM_PROTECTION, ilen);\n\n}\n", "idx": 18613}
{"project": "qemu", "commit_id": "e7ca56562990991bc614a43b9351ee0737f3045d", "target": 0, "func": "void string_output_visitor_cleanup(StringOutputVisitor *sov)\n\n{\n\n    if (sov->string) {\n\n        g_string_free(sov->string, true);\n\n    }\n\n\n\n    g_list_foreach(sov->ranges, free_range, NULL);\n\n    g_list_free(sov->ranges);\n\n    g_free(sov);\n\n}\n", "idx": 18621}
{"project": "qemu", "commit_id": "0462faee67eb9ee39e51f764891fb6b767602eed", "target": 1, "func": "void memory_region_allocate_system_memory(MemoryRegion *mr, Object *owner,\n                                          const char *name,\n                                          uint64_t ram_size)\n{\n    uint64_t addr = 0;\n    int i;\n    if (nb_numa_nodes == 0 || !have_memdevs) {\n        allocate_system_memory_nonnuma(mr, owner, name, ram_size);\n        return;\n    memory_region_init(mr, owner, name, ram_size);\n    for (i = 0; i < MAX_NODES; i++) {\n        Error *local_err = NULL;\n        uint64_t size = numa_info[i].node_mem;\n        HostMemoryBackend *backend = numa_info[i].node_memdev;\n        if (!backend) {\n            continue;\n        MemoryRegion *seg = host_memory_backend_get_memory(backend, &local_err);\n        if (local_err) {\n            qerror_report_err(local_err);\n        memory_region_add_subregion(mr, addr, seg);\n        vmstate_register_ram_global(seg);\n        addr += size;", "idx": 18627}
{"project": "FFmpeg", "commit_id": "4cc896ea5f06f8b1ebcde6d876d9c5b59ef9a016", "target": 1, "func": "void av_register_output_format(AVOutputFormat *format)\n\n{\n\n    AVOutputFormat **p = last_oformat;\n\n\n\n    format->next = NULL;\n\n    while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, format))\n\n        p = &(*p)->next;\n\n    last_oformat = &format->next;\n\n}\n", "idx": 18643}
{"project": "qemu", "commit_id": "ccfcdd09bf91aabe039d2dae0b5ec3a05f083e59", "target": 0, "func": "static inline void gen_jcc(DisasContext *s, int b,\n\n                           target_ulong val, target_ulong next_eip)\n\n{\n\n    int l1, l2;\n\n\n\n    gen_update_cc_op(s);\n\n    if (s->jmp_opt) {\n\n        l1 = gen_new_label();\n\n        gen_jcc1(s, b, l1);\n\n        set_cc_op(s, CC_OP_DYNAMIC);\n\n        \n\n        gen_goto_tb(s, 0, next_eip);\n\n\n\n        gen_set_label(l1);\n\n        gen_goto_tb(s, 1, val);\n\n        s->is_jmp = DISAS_TB_JUMP;\n\n    } else {\n\n\n\n        l1 = gen_new_label();\n\n        l2 = gen_new_label();\n\n        gen_jcc1(s, b, l1);\n\n        set_cc_op(s, CC_OP_DYNAMIC);\n\n\n\n        gen_jmp_im(next_eip);\n\n        tcg_gen_br(l2);\n\n\n\n        gen_set_label(l1);\n\n        gen_jmp_im(val);\n\n        gen_set_label(l2);\n\n        gen_eob(s);\n\n    }\n\n}\n", "idx": 18660}
{"project": "qemu", "commit_id": "5edbdbcdf882e4220adc7dbf433351077cd1fbbc", "target": 1, "func": "static int check_shm_size(IVShmemState *s, int fd) {\n\n    /* check that the guest isn't going to try and map more memory than the\n\n     * the object has allocated return -1 to indicate error */\n\n\n\n    struct stat buf;\n\n\n\n    fstat(fd, &buf);\n\n\n\n    if (s->ivshmem_size > buf.st_size) {\n\n        fprintf(stderr,\n\n                \"IVSHMEM ERROR: Requested memory size greater\"\n\n                \" than shared object size (%\" PRIu64 \" > %\" PRIu64\")\\n\",\n\n                s->ivshmem_size, (uint64_t)buf.st_size);\n\n        return -1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 18702}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "static inline uint32_t lduw_phys_internal(target_phys_addr_t addr,\n\n                                          enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* I/O case */\n\n        addr = memory_region_section_addr(section, addr);\n\n        val = io_mem_read(section->mr, addr, 2);\n\n#if defined(TARGET_WORDS_BIGENDIAN)\n\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#else\n\n        if (endian == DEVICE_BIG_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#endif\n\n    } else {\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)\n\n                                & TARGET_PAGE_MASK)\n\n                               + memory_region_section_addr(section, addr));\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            val = lduw_le_p(ptr);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            val = lduw_be_p(ptr);\n\n            break;\n\n        default:\n\n            val = lduw_p(ptr);\n\n            break;\n\n        }\n\n    }\n\n    return val;\n\n}\n", "idx": 18736}
{"project": "FFmpeg", "commit_id": "171ec812235a5d22fa421242351ee2da5a96c3ba", "target": 1, "func": "static void rv34_pred_4x4_block(RV34DecContext *r, uint8_t *dst, int stride, int itype, int up, int left, int down, int right)\n\n{\n\n    uint8_t *prev = dst - stride + 4;\n\n    uint32_t topleft;\n\n\n\n    if(!up && !left)\n\n        itype = DC_128_PRED;\n\n    else if(!up){\n\n        if(itype == VERT_PRED) itype = HOR_PRED;\n\n        if(itype == DC_PRED)   itype = LEFT_DC_PRED;\n\n    }else if(!left){\n\n        if(itype == HOR_PRED)  itype = VERT_PRED;\n\n        if(itype == DC_PRED)   itype = TOP_DC_PRED;\n\n        if(itype == DIAG_DOWN_LEFT_PRED) itype = DIAG_DOWN_LEFT_PRED_RV40_NODOWN;\n\n    }\n\n    if(!down){\n\n        if(itype == DIAG_DOWN_LEFT_PRED) itype = DIAG_DOWN_LEFT_PRED_RV40_NODOWN;\n\n        if(itype == HOR_UP_PRED) itype = HOR_UP_PRED_RV40_NODOWN;\n\n        if(itype == VERT_LEFT_PRED) itype = VERT_LEFT_PRED_RV40_NODOWN;\n\n    }\n\n    if(!right && up){\n\n        topleft = dst[-stride + 3] * 0x01010101;\n\n        prev = (uint8_t*)&topleft;\n\n    }\n\n    r->h.pred4x4[itype](dst, prev, stride);\n\n}\n", "idx": 18753}
{"project": "FFmpeg", "commit_id": "22fa406f384eb9d825b1d691332e1f928750d55b", "target": 1, "func": "static av_cold int MP3lame_encode_init(AVCodecContext *avctx)\n\n{\n\n    Mp3AudioContext *s = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2)\n\n        return -1;\n\n\n\n    s->stereo = avctx->channels > 1 ? 1 : 0;\n\n\n\n    if ((s->gfp = lame_init()) == NULL)\n\n        goto err;\n\n    lame_set_in_samplerate(s->gfp, avctx->sample_rate);\n\n    lame_set_out_samplerate(s->gfp, avctx->sample_rate);\n\n    lame_set_num_channels(s->gfp, avctx->channels);\n\n    if(avctx->compression_level == FF_COMPRESSION_DEFAULT) {\n\n        lame_set_quality(s->gfp, 5);\n\n    } else {\n\n        lame_set_quality(s->gfp, avctx->compression_level);\n\n    }\n\n    lame_set_mode(s->gfp, s->stereo ? JOINT_STEREO : MONO);\n\n    lame_set_brate(s->gfp, avctx->bit_rate/1000);\n\n    if(avctx->flags & CODEC_FLAG_QSCALE) {\n\n        lame_set_brate(s->gfp, 0);\n\n        lame_set_VBR(s->gfp, vbr_default);\n\n        lame_set_VBR_quality(s->gfp, avctx->global_quality/(float)FF_QP2LAMBDA);\n\n    }\n\n    lame_set_bWriteVbrTag(s->gfp,0);\n\n    lame_set_disable_reservoir(s->gfp, avctx->flags2 & CODEC_FLAG2_BIT_RESERVOIR ? 0 : 1);\n\n    if (lame_init_params(s->gfp) < 0)\n\n        goto err_close;\n\n\n\n    avctx->frame_size = lame_get_framesize(s->gfp);\n\n\n\n    avctx->coded_frame= avcodec_alloc_frame();\n\n    avctx->coded_frame->key_frame= 1;\n\n\n\n    return 0;\n\n\n\nerr_close:\n\n    lame_close(s->gfp);\n\nerr:\n\n    return -1;\n\n}\n", "idx": 18756}
{"project": "FFmpeg", "commit_id": "e2959f455850143272f3455a936dfd4d89ae9e03", "target": 0, "func": "int av_strerror(int errnum, char *errbuf, size_t errbuf_size)\n\n{\n\n    int ret = 0;\n\n    const char *errstr = NULL;\n\n\n\n    switch (errnum) {\n\n    case AVERROR_EOF:               errstr = \"End of file\"; break;\n\n    case AVERROR_INVALIDDATA:       errstr = \"Invalid data found when processing input\"; break;\n\n    case AVERROR_NUMEXPECTED:       errstr = \"Number syntax expected in filename\"; break;\n\n    case AVERROR_PATCHWELCOME:      errstr = \"Not yet implemented in FFmpeg, patches welcome\"; break;\n\n    }\n\n\n\n    if (errstr) {\n\n        av_strlcpy(errbuf, errstr, errbuf_size);\n\n    } else {\n\n#if HAVE_STRERROR_R\n\n        ret = strerror_r(AVUNERROR(errnum), errbuf, errbuf_size);\n\n#endif\n\n        if (!HAVE_STRERROR_R || ret < 0)\n\n            snprintf(errbuf, errbuf_size, \"Error number %d occurred\", errnum);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 18766}
{"project": "qemu", "commit_id": "0e8b3cdfbc167f4bb7790ef744eaa1ac0e6959f9", "target": 1, "func": "void *postcopy_get_tmp_page(MigrationIncomingState *mis)\n\n{\n\n    if (!mis->postcopy_tmp_page) {\n\n        mis->postcopy_tmp_page = mmap(NULL, getpagesize(),\n\n                             PROT_READ | PROT_WRITE, MAP_PRIVATE |\n\n                             MAP_ANONYMOUS, -1, 0);\n\n        if (!mis->postcopy_tmp_page) {\n\n            error_report(\"%s: %s\", __func__, strerror(errno));\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    return mis->postcopy_tmp_page;\n\n}\n", "idx": 18776}
{"project": "qemu", "commit_id": "ab431c283e7055bcd6fb622f212bb29e84a6a134", "target": 0, "func": "static int pci_slot_get_pirq(PCIDevice *pci_dev, int irq_num)\n\n{\n\n    int slot_addend;\n\n    slot_addend = (pci_dev->devfn >> 3) - 1;\n\n    return (irq_num + slot_addend) & 3;\n\n}\n", "idx": 18795}
{"project": "FFmpeg", "commit_id": "fbdaebb29861d32acc93fa55fd13554a2ae32eb4", "target": 0, "func": "static int h263_decode_gob_header(MpegEncContext *s)\n\n{\n\n    unsigned int val, gob_number;\n\n    int left;\n\n\n\n    /* Check for GOB Start Code */\n\n    val = show_bits(&s->gb, 16);\n\n    if(val)\n\n        return -1;\n\n\n\n        /* We have a GBSC probably with GSTUFF */\n\n    skip_bits(&s->gb, 16); /* Drop the zeros */\n\n    left= get_bits_left(&s->gb);\n\n    //MN: we must check the bits left or we might end in a infinite loop (or segfault)\n\n    for(;left>13; left--){\n\n        if(get_bits1(&s->gb)) break; /* Seek the '1' bit */\n\n    }\n\n    if(left<=13)\n\n        return -1;\n\n\n\n    if(s->h263_slice_structured){\n\n        if(get_bits1(&s->gb)==0)\n\n            return -1;\n\n\n\n        ff_h263_decode_mba(s);\n\n\n\n        if(s->mb_num > 1583)\n\n            if(get_bits1(&s->gb)==0)\n\n                return -1;\n\n\n\n        s->qscale = get_bits(&s->gb, 5); /* SQUANT */\n\n        if(get_bits1(&s->gb)==0)\n\n            return -1;\n\n        skip_bits(&s->gb, 2); /* GFID */\n\n    }else{\n\n        gob_number = get_bits(&s->gb, 5); /* GN */\n\n        s->mb_x= 0;\n\n        s->mb_y= s->gob_index* gob_number;\n\n        skip_bits(&s->gb, 2); /* GFID */\n\n        s->qscale = get_bits(&s->gb, 5); /* GQUANT */\n\n    }\n\n\n\n    if(s->mb_y >= s->mb_height)\n\n        return -1;\n\n\n\n    if(s->qscale==0)\n\n        return -1;\n\n\n\n    return 0;\n\n}\n", "idx": 18806}
{"project": "qemu", "commit_id": "4c315c27661502a0813b129e41c0bf640c34a8d6", "target": 1, "func": "DevicePropertyInfoList *qmp_device_list_properties(const char *typename,\n                                                   Error **errp)\n{\n    ObjectClass *klass;\n    Object *obj;\n    ObjectProperty *prop;\n    DevicePropertyInfoList *prop_list = NULL;\n    klass = object_class_by_name(typename);\n    if (klass == NULL) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                  \"Device '%s' not found\", typename);\n    klass = object_class_dynamic_cast(klass, TYPE_DEVICE);\n    if (klass == NULL) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"name\", TYPE_DEVICE);\n    if (object_class_is_abstract(klass)) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"name\",\n                   \"non-abstract device type\");\n    obj = object_new(typename);\n    QTAILQ_FOREACH(prop, &obj->properties, node) {\n        DevicePropertyInfo *info;\n        DevicePropertyInfoList *entry;\n        /* Skip Object and DeviceState properties */\n        if (strcmp(prop->name, \"type\") == 0 ||\n            strcmp(prop->name, \"realized\") == 0 ||\n            strcmp(prop->name, \"hotpluggable\") == 0 ||\n            strcmp(prop->name, \"hotplugged\") == 0 ||\n            strcmp(prop->name, \"parent_bus\") == 0) {\n            continue;\n        /* Skip legacy properties since they are just string versions of\n         * properties that we already list.\n         */\n        if (strstart(prop->name, \"legacy-\", NULL)) {\n            continue;\n        info = make_device_property_info(klass, prop->name, prop->type,\n                                         prop->description);\n        if (!info) {\n            continue;\n        entry = g_malloc0(sizeof(*entry));\n        entry->value = info;\n        entry->next = prop_list;\n        prop_list = entry;\n    object_unref(obj);\n    return prop_list;", "idx": 18814}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC(pred4x4_dc)(uint8_t *_src, const uint8_t *topright, int _stride){\n\n    pixel *src = (pixel*)_src;\n\n    int stride = _stride/sizeof(pixel);\n\n    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride]\n\n                   + src[-1+0*stride] + src[-1+1*stride] + src[-1+2*stride] + src[-1+3*stride] + 4) >>3;\n\n\n\n    ((pixel4*)(src+0*stride))[0]=\n\n    ((pixel4*)(src+1*stride))[0]=\n\n    ((pixel4*)(src+2*stride))[0]=\n\n    ((pixel4*)(src+3*stride))[0]= PIXEL_SPLAT_X4(dc);\n\n}\n", "idx": 18828}
{"project": "qemu", "commit_id": "b7fcff01790d25f48d81ef6c8c3399577096a555", "target": 1, "func": "static void test_bmdma_setup(void)\n\n{\n\n    ide_test_start(\n\n        \"-vnc none \"\n\n        \"-drive file=%s,if=ide,serial=%s,cache=writeback \"\n\n        \"-global ide-hd.ver=%s\",\n\n        tmp_path, \"testdisk\", \"version\");\n\n}\n", "idx": 18834}
{"project": "qemu", "commit_id": "336c1c12551ff0a6e1a2af226d6cbdbadd2e02b5", "target": 0, "func": "int bdrv_has_zero_init(BlockDriverState *bs)\n\n{\n\n    assert(bs->drv);\n\n\n\n    if (bs->drv->no_zero_init) {\n\n        return 0;\n\n    } else if (bs->file) {\n\n        return bdrv_has_zero_init(bs->file);\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 18872}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_write(URLContext *h, const unsigned char *buf, int size)\n\n{\n\n    int err;\n\n    FTPContext *s = h->priv_data;\n\n    int written;\n\n\n\n    av_dlog(h, \"ftp protocol write %d bytes\\n\", size);\n\n\n\n    if (s->state == DISCONNECTED) {\n\n        if ((err = ftp_connect_data_connection(h)) < 0)\n\n            return err;\n\n    }\n\n    if (s->state == READY) {\n\n        if ((err = ftp_store(s)) < 0)\n\n            return err;\n\n    }\n\n    if (s->conn_data && s->state == UPLOADING) {\n\n        written = ffurl_write(s->conn_data, buf, size);\n\n        if (written > 0) {\n\n            s->position += written;\n\n            s->filesize = FFMAX(s->filesize, s->position);\n\n        }\n\n        return written;\n\n    }\n\n\n\n    av_log(h, AV_LOG_ERROR, \"FTP write failed\\n\");\n\n    return AVERROR(EIO);\n\n}\n", "idx": 18898}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void integratorcm_write(void *opaque, target_phys_addr_t offset,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    integratorcm_state *s = (integratorcm_state *)opaque;\n\n    switch (offset >> 2) {\n\n    case 2: /* CM_OSC */\n\n        if (s->cm_lock == 0xa05f)\n\n            s->cm_osc = value;\n\n        break;\n\n    case 3: /* CM_CTRL */\n\n        integratorcm_set_ctrl(s, value);\n\n        break;\n\n    case 5: /* CM_LOCK */\n\n        s->cm_lock = value & 0xffff;\n\n        break;\n\n    case 7: /* CM_AUXOSC */\n\n        if (s->cm_lock == 0xa05f)\n\n            s->cm_auxosc = value;\n\n        break;\n\n    case 8: /* CM_SDRAM */\n\n        s->cm_sdram = value;\n\n        break;\n\n    case 9: /* CM_INIT */\n\n        /* ??? This can change the memory bus frequency.  */\n\n        s->cm_init = value;\n\n        break;\n\n    case 12: /* CM_FLAGSS */\n\n        s->cm_flags |= value;\n\n        break;\n\n    case 13: /* CM_FLAGSC */\n\n        s->cm_flags &= ~value;\n\n        break;\n\n    case 14: /* CM_NVFLAGSS */\n\n        s->cm_nvflags |= value;\n\n        break;\n\n    case 15: /* CM_NVFLAGSS */\n\n        s->cm_nvflags &= ~value;\n\n        break;\n\n    case 18: /* CM_IRQ_ENSET */\n\n        s->irq_enabled |= value;\n\n        integratorcm_update(s);\n\n        break;\n\n    case 19: /* CM_IRQ_ENCLR */\n\n        s->irq_enabled &= ~value;\n\n        integratorcm_update(s);\n\n        break;\n\n    case 20: /* CM_SOFT_INTSET */\n\n        s->int_level |= (value & 1);\n\n        integratorcm_update(s);\n\n        break;\n\n    case 21: /* CM_SOFT_INTCLR */\n\n        s->int_level &= ~(value & 1);\n\n        integratorcm_update(s);\n\n        break;\n\n    case 26: /* CM_FIQ_ENSET */\n\n        s->fiq_enabled |= value;\n\n        integratorcm_update(s);\n\n        break;\n\n    case 27: /* CM_FIQ_ENCLR */\n\n        s->fiq_enabled &= ~value;\n\n        integratorcm_update(s);\n\n        break;\n\n    case 32: /* CM_VOLTAGE_CTL0 */\n\n    case 33: /* CM_VOLTAGE_CTL1 */\n\n    case 34: /* CM_VOLTAGE_CTL2 */\n\n    case 35: /* CM_VOLTAGE_CTL3 */\n\n        /* ??? Voltage control unimplemented.  */\n\n        break;\n\n    default:\n\n        hw_error(\"integratorcm_write: Unimplemented offset 0x%x\\n\",\n\n                 (int)offset);\n\n        break;\n\n    }\n\n}\n", "idx": 18905}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static int pci_vpb_map_irq(PCIDevice *d, int irq_num)\n\n{\n\n    PCIVPBState *s = container_of(d->bus, PCIVPBState, pci_bus);\n\n\n\n    if (s->irq_mapping == PCI_VPB_IRQMAP_BROKEN) {\n\n        /* Legacy broken IRQ mapping for compatibility with old and\n\n         * buggy Linux guests\n\n         */\n\n        return irq_num;\n\n    }\n\n\n\n    /* Slot to IRQ mapping for RealView Platform Baseboard 926 backplane\n\n     *      name    slot    IntA    IntB    IntC    IntD\n\n     *      A       31      IRQ28   IRQ29   IRQ30   IRQ27\n\n     *      B       30      IRQ27   IRQ28   IRQ29   IRQ30\n\n     *      C       29      IRQ30   IRQ27   IRQ28   IRQ29\n\n     * Slot C is for the host bridge; A and B the peripherals.\n\n     * Our output irqs 0..3 correspond to the baseboard's 27..30.\n\n     *\n\n     * This mapping function takes account of an oddity in the PB926\n\n     * board wiring, where the FPGA's P_nINTA input is connected to\n\n     * the INTB connection on the board PCI edge connector, P_nINTB\n\n     * is connected to INTC, and so on, so everything is one number\n\n     * further round from where you might expect.\n\n     */\n\n    return pci_swizzle_map_irq_fn(d, irq_num + 2);\n\n}\n", "idx": 18916}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "static uint32_t omap_l4_io_readh(void *opaque, target_phys_addr_t addr)\n\n{\n\n    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;\n\n\n\n    return omap_l4_io_readh_fn[i](omap_l4_io_opaque[i], addr);\n\n}\n", "idx": 18930}
{"project": "qemu", "commit_id": "ba4906a9b64e165a958e12f6208ca834dc7a36dc", "target": 1, "func": "static int ds1338_recv(I2CSlave *i2c)\n\n{\n\n    DS1338State *s = FROM_I2C_SLAVE(DS1338State, i2c);\n\n    uint8_t res;\n\n\n\n    res  = s->nvram[s->ptr];\n\n    s->ptr = (s->ptr + 1) & 0xff;\n\n    return res;\n\n}\n", "idx": 18946}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "size_t qsb_get_length(const QEMUSizedBuffer *qsb)\n\n{\n\n    return qsb->used;\n\n}\n", "idx": 18955}
{"project": "FFmpeg", "commit_id": "9b7a8bddac52bd05dddb28afd4dff92739946d3b", "target": 1, "func": "static int udp_write(URLContext *h, const uint8_t *buf, int size)\n\n{\n\n    UDPContext *s = h->priv_data;\n\n    int ret;\n\n\n\n#if HAVE_PTHREAD_CANCEL\n\n    if (s->fifo) {\n\n        uint8_t tmp[4];\n\n\n\n        pthread_mutex_lock(&s->mutex);\n\n\n\n        /*\n\n          Return error if last tx failed.\n\n          Here we can't know on which packet error was, but it needs to know that error exists.\n\n        */\n\n        if (s->circular_buffer_error<0) {\n\n            int err=s->circular_buffer_error;\n\n            s->circular_buffer_error=0;\n\n            pthread_mutex_unlock(&s->mutex);\n\n            return err;\n\n        }\n\n\n\n        if(av_fifo_space(s->fifo) < size + 4) {\n\n            /* What about a partial packet tx ? */\n\n            pthread_mutex_unlock(&s->mutex);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        AV_WL32(tmp, size);\n\n        av_fifo_generic_write(s->fifo, tmp, 4, NULL); /* size of packet */\n\n        av_fifo_generic_write(s->fifo, (uint8_t *)buf, size, NULL); /* the data */\n\n        pthread_cond_signal(&s->cond);\n\n        pthread_mutex_unlock(&s->mutex);\n\n        return size;\n\n    }\n\n#endif\n\n    if (!(h->flags & AVIO_FLAG_NONBLOCK)) {\n\n        ret = ff_network_wait_fd(s->udp_fd, 1);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    if (!s->is_connected) {\n\n        ret = sendto (s->udp_fd, buf, size, 0,\n\n                      (struct sockaddr *) &s->dest_addr,\n\n                      s->dest_addr_len);\n\n    } else\n\n        ret = send(s->udp_fd, buf, size, 0);\n\n\n\n    return ret < 0 ? ff_neterrno() : ret;\n\n}\n", "idx": 18959}
{"project": "FFmpeg", "commit_id": "aba232cfa9b193604ed98f3fa505378d006b1b3b", "target": 1, "func": "static void compute_frame_duration(int *pnum, int *pden, AVStream *st,\n\n                                   AVCodecParserContext *pc, AVPacket *pkt)\n\n{\n\n    int frame_size;\n\n\n\n    *pnum = 0;\n\n    *pden = 0;\n\n    switch(st->codec->codec_type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        if (st->r_frame_rate.num) {\n\n            *pnum = st->r_frame_rate.den;\n\n            *pden = st->r_frame_rate.num;\n\n        } else if(st->time_base.num*1000LL > st->time_base.den) {\n\n            *pnum = st->time_base.num;\n\n            *pden = st->time_base.den;\n\n        }else if(st->codec->time_base.num*1000LL > st->codec->time_base.den){\n\n            *pnum = st->codec->time_base.num;\n\n            *pden = st->codec->time_base.den;\n\n            if (pc && pc->repeat_pict) {\n\n                *pnum = (*pnum) * (1 + pc->repeat_pict);\n\n            }\n\n            //If this codec can be interlaced or progressive then we need a parser to compute duration of a packet\n\n            //Thus if we have no parser in such case leave duration undefined.\n\n            if(st->codec->ticks_per_frame>1 && !pc){\n\n                *pnum = *pden = 0;\n\n            }\n\n        }\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        frame_size = get_audio_frame_size(st->codec, pkt->size, 0);\n\n        if (frame_size <= 0 || st->codec->sample_rate <= 0)\n\n            break;\n\n        *pnum = frame_size;\n\n        *pden = st->codec->sample_rate;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 18965}
{"project": "qemu", "commit_id": "ad96090a01d848df67d70c5259ed8aa321fa8716", "target": 0, "func": "static int ram_save_live(Monitor *mon, QEMUFile *f, int stage, void *opaque)\n\n{\n\n    ram_addr_t addr;\n\n    uint64_t bytes_transferred_last;\n\n    double bwidth = 0;\n\n    uint64_t expected_time = 0;\n\n\n\n    if (stage < 0) {\n\n        cpu_physical_memory_set_dirty_tracking(0);\n\n        return 0;\n\n    }\n\n\n\n    if (cpu_physical_sync_dirty_bitmap(0, TARGET_PHYS_ADDR_MAX) != 0) {\n\n        qemu_file_set_error(f);\n\n        return 0;\n\n    }\n\n\n\n    if (stage == 1) {\n\n        bytes_transferred = 0;\n\n\n\n        /* Make sure all dirty bits are set */\n\n        for (addr = 0; addr < last_ram_offset; addr += TARGET_PAGE_SIZE) {\n\n            if (!cpu_physical_memory_get_dirty(addr, MIGRATION_DIRTY_FLAG))\n\n                cpu_physical_memory_set_dirty(addr);\n\n        }\n\n\n\n        /* Enable dirty memory tracking */\n\n        cpu_physical_memory_set_dirty_tracking(1);\n\n\n\n        qemu_put_be64(f, last_ram_offset | RAM_SAVE_FLAG_MEM_SIZE);\n\n    }\n\n\n\n    bytes_transferred_last = bytes_transferred;\n\n    bwidth = qemu_get_clock_ns(rt_clock);\n\n\n\n    while (!qemu_file_rate_limit(f)) {\n\n        int ret;\n\n\n\n        ret = ram_save_block(f);\n\n        bytes_transferred += ret * TARGET_PAGE_SIZE;\n\n        if (ret == 0) /* no more blocks */\n\n            break;\n\n    }\n\n\n\n    bwidth = qemu_get_clock_ns(rt_clock) - bwidth;\n\n    bwidth = (bytes_transferred - bytes_transferred_last) / bwidth;\n\n\n\n    /* if we haven't transferred anything this round, force expected_time to a\n\n     * a very high value, but without crashing */\n\n    if (bwidth == 0)\n\n        bwidth = 0.000001;\n\n\n\n    /* try transferring iterative blocks of memory */\n\n    if (stage == 3) {\n\n        /* flush all remaining blocks regardless of rate limiting */\n\n        while (ram_save_block(f) != 0) {\n\n            bytes_transferred += TARGET_PAGE_SIZE;\n\n        }\n\n        cpu_physical_memory_set_dirty_tracking(0);\n\n    }\n\n\n\n    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);\n\n\n\n    expected_time = ram_save_remaining() * TARGET_PAGE_SIZE / bwidth;\n\n\n\n    return (stage == 2) && (expected_time <= migrate_max_downtime());\n\n}\n", "idx": 18990}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "float64 helper_fsmuld(CPUSPARCState *env, float32 src1, float32 src2)\n\n{\n\n    float64 ret;\n\n    clear_float_exceptions(env);\n\n    ret = float64_mul(float32_to_float64(src1, &env->fp_status),\n\n                      float32_to_float64(src2, &env->fp_status),\n\n                      &env->fp_status);\n\n    check_ieee_exceptions(env);\n\n    return ret;\n\n}\n", "idx": 18999}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "target_phys_addr_t omap_l4_attach(struct omap_target_agent_s *ta, int region,\n\n                int iotype)\n\n{\n\n    target_phys_addr_t base;\n\n    ssize_t size;\n\n#ifdef L4_MUX_HACK\n\n    int i;\n\n#endif\n\n\n\n    if (region < 0 || region >= ta->regions) {\n\n        fprintf(stderr, \"%s: bad io region (%i)\\n\", __FUNCTION__, region);\n\n        exit(-1);\n\n    }\n\n\n\n    base = ta->bus->base + ta->start[region].offset;\n\n    size = ta->start[region].size;\n\n    if (iotype) {\n\n#ifndef L4_MUX_HACK\n\n        cpu_register_physical_memory(base, size, iotype);\n\n#else\n\n        cpu_register_physical_memory(base, size, omap_cpu_io_entry);\n\n        i = (base - ta->bus->base) / TARGET_PAGE_SIZE;\n\n        for (; size > 0; size -= TARGET_PAGE_SIZE, i ++) {\n\n            omap_l4_io_readb_fn[i] = omap_l4_io_entry[iotype].mem_read[0];\n\n            omap_l4_io_readh_fn[i] = omap_l4_io_entry[iotype].mem_read[1];\n\n            omap_l4_io_readw_fn[i] = omap_l4_io_entry[iotype].mem_read[2];\n\n            omap_l4_io_writeb_fn[i] = omap_l4_io_entry[iotype].mem_write[0];\n\n            omap_l4_io_writeh_fn[i] = omap_l4_io_entry[iotype].mem_write[1];\n\n            omap_l4_io_writew_fn[i] = omap_l4_io_entry[iotype].mem_write[2];\n\n            omap_l4_io_opaque[i] = omap_l4_io_entry[iotype].opaque;\n\n        }\n\n#endif\n\n    }\n\n\n\n    return base;\n\n}\n", "idx": 19002}
{"project": "qemu", "commit_id": "0188fadb7fe460d8c4c743372b1f7b25773e183e", "target": 1, "func": "static void setup_frame(int sig, struct target_sigaction * ka,\n\n                        target_sigset_t *set, CPUMIPSState *regs)\n\n{\n\n    struct sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    int i;\n\n\n\n    frame_addr = get_sigframe(ka, regs, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n\n\tgoto give_sigsegv;\n\n\n\n    install_sigtramp(frame->sf_code, TARGET_NR_sigreturn);\n\n\n\n    setup_sigcontext(regs, &frame->sf_sc);\n\n\n\n    for(i = 0; i < TARGET_NSIG_WORDS; i++) {\n\n\tif(__put_user(set->sig[i], &frame->sf_mask.sig[i]))\n\n\t    goto give_sigsegv;\n\n    }\n\n\n\n    /*\n\n    * Arguments to signal handler:\n\n    *\n\n    *   a0 = signal number\n\n    *   a1 = 0 (should be cause)\n\n    *   a2 = pointer to struct sigcontext\n\n    *\n\n    * $25 and PC point to the signal handler, $29 points to the\n\n    * struct sigframe.\n\n    */\n\n    regs->active_tc.gpr[ 4] = sig;\n\n    regs->active_tc.gpr[ 5] = 0;\n\n    regs->active_tc.gpr[ 6] = frame_addr + offsetof(struct sigframe, sf_sc);\n\n    regs->active_tc.gpr[29] = frame_addr;\n\n    regs->active_tc.gpr[31] = frame_addr + offsetof(struct sigframe, sf_code);\n\n    /* The original kernel code sets CP0_EPC to the handler\n\n    * since it returns to userland using eret\n\n    * we cannot do this here, and we must set PC directly */\n\n    regs->active_tc.PC = regs->active_tc.gpr[25] = ka->_sa_handler;\n\n    mips_set_hflags_isa_mode_from_pc(regs);\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    return;\n\n\n\ngive_sigsegv:\n\n    unlock_user_struct(frame, frame_addr, 1);\n\n    force_sig(TARGET_SIGSEGV/*, current*/);\n\n}\n", "idx": 19006}
{"project": "qemu", "commit_id": "b38ec5ee7a581776bbce0bdaecb397632c3c4791", "target": 1, "func": "static void pci_msix_write(void *opaque, hwaddr addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    XenPCIPassthroughState *s = opaque;\n\n    XenPTMSIX *msix = s->msix;\n\n    XenPTMSIXEntry *entry;\n\n    int entry_nr, offset;\n\n\n\n    entry_nr = addr / PCI_MSIX_ENTRY_SIZE;\n\n    if (entry_nr < 0 || entry_nr >= msix->total_entries) {\n\n        XEN_PT_ERR(&s->dev, \"asked MSI-X entry '%i' invalid!\\n\", entry_nr);\n\n        return;\n\n    }\n\n    entry = &msix->msix_entry[entry_nr];\n\n    offset = addr % PCI_MSIX_ENTRY_SIZE;\n\n\n\n    if (offset != PCI_MSIX_ENTRY_VECTOR_CTRL) {\n\n        const volatile uint32_t *vec_ctrl;\n\n\n\n        if (get_entry_value(entry, offset) == val\n\n            && entry->pirq != XEN_PT_UNASSIGNED_PIRQ) {\n\n            return;\n\n        }\n\n\n\n        /*\n\n         * If Xen intercepts the mask bit access, entry->vec_ctrl may not be\n\n         * up-to-date. Read from hardware directly.\n\n         */\n\n        vec_ctrl = s->msix->phys_iomem_base + entry_nr * PCI_MSIX_ENTRY_SIZE\n\n            + PCI_MSIX_ENTRY_VECTOR_CTRL;\n\n\n\n        if (msix->enabled && !(*vec_ctrl & PCI_MSIX_ENTRY_CTRL_MASKBIT)) {\n\n            XEN_PT_ERR(&s->dev, \"Can't update msix entry %d since MSI-X is\"\n\n                       \" already enabled.\\n\", entry_nr);\n\n            return;\n\n        }\n\n\n\n        entry->updated = true;\n\n    }\n\n\n\n    set_entry_value(entry, offset, val);\n\n\n\n    if (offset == PCI_MSIX_ENTRY_VECTOR_CTRL) {\n\n        if (msix->enabled && !(val & PCI_MSIX_ENTRY_CTRL_MASKBIT)) {\n\n            xen_pt_msix_update_one(s, entry_nr);\n\n        }\n\n    }\n\n}\n", "idx": 19014}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static void seg_free_context(SegmentContext *seg)\n\n{\n\n    avio_closep(&seg->pb);\n\n    avformat_free_context(seg->avf);\n\n    seg->avf = NULL;\n\n}\n", "idx": 19031}
{"project": "FFmpeg", "commit_id": "b69b43e2c471c4febbffaf313875396256b6a51e", "target": 1, "func": "static int transcode_subtitles(InputStream *ist, AVPacket *pkt, int *got_output)\n\n{\n\n    AVSubtitle subtitle;\n\n    int i, ret = avcodec_decode_subtitle2(ist->dec_ctx,\n\n                                          &subtitle, got_output, pkt);\n\n\n\n    check_decode_result(got_output, ret);\n\n\n\n    if (ret < 0 || !*got_output) {\n\n        if (!pkt->size)\n\n            sub2video_flush(ist);\n\n        return ret;\n\n    }\n\n\n\n    if (ist->fix_sub_duration) {\n\n        int end = 1;\n\n        if (ist->prev_sub.got_output) {\n\n            end = av_rescale(subtitle.pts - ist->prev_sub.subtitle.pts,\n\n                             1000, AV_TIME_BASE);\n\n            if (end < ist->prev_sub.subtitle.end_display_time) {\n\n                av_log(ist->dec_ctx, AV_LOG_DEBUG,\n\n                       \"Subtitle duration reduced from %d to %d%s\\n\",\n\n                       ist->prev_sub.subtitle.end_display_time, end,\n\n                       end <= 0 ? \", dropping it\" : \"\");\n\n                ist->prev_sub.subtitle.end_display_time = end;\n\n            }\n\n        }\n\n        FFSWAP(int,        *got_output, ist->prev_sub.got_output);\n\n        FFSWAP(int,        ret,         ist->prev_sub.ret);\n\n        FFSWAP(AVSubtitle, subtitle,    ist->prev_sub.subtitle);\n\n        if (end <= 0)\n\n            goto out;\n\n    }\n\n\n\n    if (!*got_output)\n\n        return ret;\n\n\n\n    sub2video_update(ist, &subtitle);\n\n\n\n    if (!subtitle.num_rects)\n\n        goto out;\n\n\n\n    ist->frames_decoded++;\n\n\n\n    for (i = 0; i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || !ost->encoding_needed\n\n            || ost->enc->type != AVMEDIA_TYPE_SUBTITLE)\n\n            continue;\n\n\n\n        do_subtitle_out(output_files[ost->file_index]->ctx, ost, ist, &subtitle);\n\n    }\n\n\n\nout:\n\n    avsubtitle_free(&subtitle);\n\n    return ret;\n\n}\n", "idx": 19051}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static void tap_set_sndbuf(TAPState *s, const char *sndbuf_str, Monitor *mon)\n\n{\n\n    if (sndbuf_str) {\n\n        config_error(mon, \"No '-net tap,sndbuf=<nbytes>' support available\\n\");\n\n    }\n\n}\n", "idx": 19062}
{"project": "qemu", "commit_id": "bf8d5166395612b4e856fad57606eb0cff97ae2e", "target": 1, "func": "static uint64_t error_mem_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    abort();\n\n}\n", "idx": 19065}
{"project": "qemu", "commit_id": "8caa05d8891d0a09dc4c00908c24c6ddfd872bbe", "target": 0, "func": "static void timer_del_locked(QEMUTimerList *timer_list, QEMUTimer *ts)\n\n{\n\n    QEMUTimer **pt, *t;\n\n\n\n    ts->expire_time = -1;\n\n    pt = &timer_list->active_timers;\n\n    for(;;) {\n\n        t = *pt;\n\n        if (!t)\n\n            break;\n\n        if (t == ts) {\n\n            *pt = t->next;\n\n            break;\n\n        }\n\n        pt = &t->next;\n\n    }\n\n}\n", "idx": 19099}
{"project": "qemu", "commit_id": "fea505221eaf87889000378d4d33ad0dfd5f4d9d", "target": 0, "func": "static void handle_sys(DisasContext *s, uint32_t insn, unsigned int l,\n\n                       unsigned int op1, unsigned int op2,\n\n                       unsigned int crn, unsigned int crm, unsigned int rt)\n\n{\n\n    unsupported_encoding(s, insn);\n\n}\n", "idx": 19120}
{"project": "qemu", "commit_id": "db39fcf1f690b02d612e2bfc00980700887abe03", "target": 0, "func": "static CharDriverState *qemu_chr_open_pp_fd(int fd)\n\n{\n\n    CharDriverState *chr;\n\n    ParallelCharDriver *drv;\n\n\n\n    if (ioctl(fd, PPCLAIM) < 0) {\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n\n\n    drv = g_malloc0(sizeof(ParallelCharDriver));\n\n    drv->fd = fd;\n\n    drv->mode = IEEE1284_MODE_COMPAT;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    chr->chr_write = null_chr_write;\n\n    chr->chr_ioctl = pp_ioctl;\n\n    chr->chr_close = pp_close;\n\n    chr->opaque = drv;\n\n\n\n    return chr;\n\n}\n", "idx": 19130}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "const char *bdrv_get_device_or_node_name(const BlockDriverState *bs)\n\n{\n\n    return bs->blk ? blk_name(bs->blk) : bs->node_name;\n\n}\n", "idx": 19137}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static QObject *qmp_output_pop(QmpOutputVisitor *qov, void *qapi)\n\n{\n\n    QStackEntry *e = QSLIST_FIRST(&qov->stack);\n\n    QObject *value;\n\n\n\n    assert(e);\n\n    assert(e->qapi == qapi);\n\n    QSLIST_REMOVE_HEAD(&qov->stack, node);\n\n    value = e->value;\n\n    assert(value);\n\n    g_free(e);\n\n    return value;\n\n}\n", "idx": 19142}
{"project": "FFmpeg", "commit_id": "1a3598aae768465a8efc8475b6df5a8261bc62fc", "target": 1, "func": "static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n\n                   uint8_t *properties)\n\n{\n\n    int compno;\n\n\n\n    if (s->buf_end - s->buf < 2)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    compno = bytestream_get_byte(&s->buf);\n\n\n\n    c      += compno;\n\n    c->csty = bytestream_get_byte(&s->buf);\n\n    get_cox(s, c);\n\n\n\n    properties[compno] |= HAD_COC;\n\n    return 0;\n\n}\n", "idx": 19156}
{"project": "qemu", "commit_id": "298a1665a2800f7264e483c2dd1f551574243a2f", "target": 0, "func": "int coroutine_fn bdrv_is_allocated(BlockDriverState *bs, int64_t offset,\n\n                                   int64_t bytes, int64_t *pnum)\n\n{\n\n    BlockDriverState *file;\n\n    int64_t sector_num = offset >> BDRV_SECTOR_BITS;\n\n    int nb_sectors = bytes >> BDRV_SECTOR_BITS;\n\n    int64_t ret;\n\n    int psectors;\n\n\n\n    assert(QEMU_IS_ALIGNED(offset, BDRV_SECTOR_SIZE));\n\n    assert(QEMU_IS_ALIGNED(bytes, BDRV_SECTOR_SIZE) && bytes < INT_MAX);\n\n    ret = bdrv_get_block_status(bs, sector_num, nb_sectors, &psectors,\n\n                                &file);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    if (pnum) {\n\n        *pnum = psectors * BDRV_SECTOR_SIZE;\n\n    }\n\n    return !!(ret & BDRV_BLOCK_ALLOCATED);\n\n}\n", "idx": 19165}
{"project": "qemu", "commit_id": "fe40e627c51e38922b64b02b6163aea4b6aad896", "target": 0, "func": "static void object_set_link_property(Object *obj, Visitor *v, void *opaque,\n\n                                     const char *name, Error **errp)\n\n{\n\n    Object **child = opaque;\n\n    bool ambiguous = false;\n\n    const char *type;\n\n    char *path;\n\n\n\n    type = object_property_get_type(obj, name, NULL);\n\n\n\n    visit_type_str(v, &path, name, errp);\n\n\n\n    if (*child) {\n\n        object_unref(*child);\n\n    }\n\n\n\n    if (strcmp(path, \"\") != 0) {\n\n        Object *target;\n\n\n\n        target = object_resolve_path(path, &ambiguous);\n\n        if (target) {\n\n            gchar *target_type;\n\n\n\n            target_type = g_strdup_printf(\"link<%s>\",\n\n                                          object_get_typename(OBJECT(target)));\n\n            if (strcmp(target_type, type) == 0) {\n\n                *child = target;\n\n                object_ref(target);\n\n            } else {\n\n                error_set(errp, QERR_INVALID_PARAMETER_TYPE, name, type);\n\n            }\n\n\n\n            g_free(target_type);\n\n        } else {\n\n            error_set(errp, QERR_DEVICE_NOT_FOUND, path);\n\n        }\n\n    } else {\n\n        *child = NULL;\n\n    }\n\n\n\n    g_free(path);\n\n}\n", "idx": 19181}
{"project": "FFmpeg", "commit_id": "c51c08e0e70c186971385bdbb225f69edd4e3375", "target": 0, "func": "static int decode_frame_packing_arrangement(H264Context *h)\n\n{\n\n    h->sei_fpa.frame_packing_arrangement_id          = get_ue_golomb(&h->gb);\n\n    h->sei_fpa.frame_packing_arrangement_cancel_flag = get_bits1(&h->gb);\n\n    h->sei_frame_packing_present = !h->sei_fpa.frame_packing_arrangement_cancel_flag;\n\n\n\n    if (h->sei_frame_packing_present) {\n\n        h->sei_fpa.frame_packing_arrangement_type =\n\n        h->frame_packing_arrangement_type = get_bits(&h->gb, 7);\n\n        h->sei_fpa.quincunx_sampling_flag         =\n\n        h->quincunx_subsampling           = get_bits1(&h->gb);\n\n        h->sei_fpa.content_interpretation_type    =\n\n        h->content_interpretation_type    = get_bits(&h->gb, 6);\n\n\n\n        // the following skips: spatial_flipping_flag, frame0_flipped_flag,\n\n        // field_views_flag, current_frame_is_frame0_flag,\n\n        // frame0_self_contained_flag, frame1_self_contained_flag\n\n        skip_bits(&h->gb, 6);\n\n\n\n        if (!h->quincunx_subsampling && h->frame_packing_arrangement_type != 5)\n\n            skip_bits(&h->gb, 16);      // frame[01]_grid_position_[xy]\n\n        skip_bits(&h->gb, 8);           // frame_packing_arrangement_reserved_byte\n\n        h->sei_fpa.frame_packing_arrangement_repetition_period = get_ue_golomb(&h->gb) /* frame_packing_arrangement_repetition_period */;\n\n    }\n\n    skip_bits1(&h->gb);                 // frame_packing_arrangement_extension_flag\n\n\n\n    if (h->avctx->debug & FF_DEBUG_PICT_INFO)\n\n        av_log(h->avctx, AV_LOG_DEBUG, \"SEI FPA %d %d %d %d %d %d\\n\",\n\n                                       h->sei_fpa.frame_packing_arrangement_id,\n\n                                       h->sei_fpa.frame_packing_arrangement_cancel_flag,\n\n                                       h->sei_fpa.frame_packing_arrangement_type,\n\n                                       h->sei_fpa.quincunx_sampling_flag,\n\n                                       h->sei_fpa.content_interpretation_type,\n\n                                       h->sei_fpa.frame_packing_arrangement_repetition_period);\n\n\n\n    return 0;\n\n}\n", "idx": 19201}
{"project": "qemu", "commit_id": "88affa1c77c9019f3450f851495997897bd14e40", "target": 1, "func": "static void do_info_trace(Monitor *mon)\n\n{\n\n    st_print_trace((FILE *)mon, &monitor_fprintf);\n\n}\n", "idx": 19213}
{"project": "qemu", "commit_id": "444bc908611ccaf4512dc37c33ac3b54d873a62b", "target": 1, "func": "static void scsi_unmap_complete(void *opaque, int ret)\n\n{\n\n    UnmapCBData *data = opaque;\n\n    SCSIDiskReq *r = data->r;\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint64_t sector_num;\n\n    uint32_t nb_sectors;\n\n\n\n    r->req.aiocb = NULL;\n\n    if (ret < 0) {\n\n        if (scsi_handle_rw_error(r, -ret)) {\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    if (data->count > 0 && !r->req.io_canceled) {\n\n        sector_num = ldq_be_p(&data->inbuf[0]);\n\n        nb_sectors = ldl_be_p(&data->inbuf[8]) & 0xffffffffULL;\n\n        if (sector_num > sector_num + nb_sectors ||\n\n            sector_num + nb_sectors - 1 > s->qdev.max_lba) {\n\n            scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));\n\n            goto done;\n\n        }\n\n\n\n        r->req.aiocb = bdrv_aio_discard(s->qdev.conf.bs,\n\n                                        sector_num * (s->qdev.blocksize / 512),\n\n                                        nb_sectors * (s->qdev.blocksize / 512),\n\n                                        scsi_unmap_complete, data);\n\n        data->count--;\n\n        data->inbuf += 16;\n\n        return;\n\n    }\n\n\n\ndone:\n\n    if (data->count == 0) {\n\n        scsi_req_complete(&r->req, GOOD);\n\n    }\n\n    if (!r->req.io_canceled) {\n\n        scsi_req_unref(&r->req);\n\n    }\n\n    g_free(data);\n\n}\n", "idx": 19227}
{"project": "qemu", "commit_id": "f1710638edb2e98008c2a733ffda63ef32b50411", "target": 1, "func": "int qcrypto_hash_bytesv(QCryptoHashAlgorithm alg,\n\n                        const struct iovec *iov,\n\n                        size_t niov,\n\n                        uint8_t **result,\n\n                        size_t *resultlen,\n\n                        Error **errp)\n\n{\n\n#ifdef CONFIG_AF_ALG\n\n    int ret;\n\n\n\n    ret = qcrypto_hash_afalg_driver.hash_bytesv(alg, iov, niov,\n\n                                                result, resultlen,\n\n                                                errp);\n\n    if (ret == 0) {\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * TODO:\n\n     * Maybe we should treat some afalg errors as fatal\n\n     */\n\n    error_free(*errp);\n\n#endif\n\n\n\n    return qcrypto_hash_lib_driver.hash_bytesv(alg, iov, niov,\n\n                                               result, resultlen,\n\n                                               errp);\n\n}\n", "idx": 19233}
{"project": "qemu", "commit_id": "5c843af22604edecda10d4bb89d4eede9e1bd3d0", "target": 1, "func": "int net_init_slirp(const Netdev *netdev, const char *name,\n\n                   NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    struct slirp_config_str *config;\n\n    char *vnet;\n\n    int ret;\n\n    const NetdevUserOptions *user;\n\n    const char **dnssearch;\n\n    bool ipv4 = true, ipv6 = true;\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_USER);\n\n    user = &netdev->u.user;\n\n\n\n    if ((user->has_ipv6 && user->ipv6 && !user->has_ipv4) ||\n\n        (user->has_ipv4 && !user->ipv4)) {\n\n        ipv4 = 0;\n\n    }\n\n    if ((user->has_ipv4 && user->ipv4 && !user->has_ipv6) ||\n\n        (user->has_ipv6 && !user->ipv6)) {\n\n        ipv6 = 0;\n\n    }\n\n\n\n    vnet = user->has_net ? g_strdup(user->net) :\n\n           user->has_ip  ? g_strdup_printf(\"%s/24\", user->ip) :\n\n           NULL;\n\n\n\n    dnssearch = slirp_dnssearch(user->dnssearch);\n\n\n\n    /* all optional fields are initialized to \"all bits zero\" */\n\n\n\n    net_init_slirp_configs(user->hostfwd, SLIRP_CFG_HOSTFWD);\n\n    net_init_slirp_configs(user->guestfwd, 0);\n\n\n\n    ret = net_slirp_init(peer, \"user\", name, user->q_restrict,\n\n                         ipv4, vnet, user->host,\n\n                         ipv6, user->ipv6_prefix, user->ipv6_prefixlen,\n\n                         user->ipv6_host, user->hostname, user->tftp,\n\n                         user->bootfile, user->dhcpstart,\n\n                         user->dns, user->ipv6_dns, user->smb,\n\n                         user->smbserver, dnssearch);\n\n\n\n    while (slirp_configs) {\n\n        config = slirp_configs;\n\n        slirp_configs = config->next;\n\n        g_free(config);\n\n    }\n\n\n\n    g_free(vnet);\n\n    g_free(dnssearch);\n\n\n\n    return ret;\n\n}\n", "idx": 19248}
{"project": "qemu", "commit_id": "b0ba0b9b6b402d738f11f27eea6c94d97bf84cbf", "target": 0, "func": "int pcnet_can_receive(NetClientState *nc)\n\n{\n\n    PCNetState *s = qemu_get_nic_opaque(nc);\n\n    if (CSR_STOP(s) || CSR_SPND(s))\n\n        return 0;\n\n\n\n    return sizeof(s->buffer)-16;\n\n}\n", "idx": 19252}
{"project": "qemu", "commit_id": "6a81dd172cd5d03fce593741629cb4c78fff10cb", "target": 0, "func": "void *kvmppc_create_spapr_tce(uint32_t liobn, uint32_t window_size, int *pfd,\n\n                              bool vfio_accel)\n\n{\n\n    struct kvm_create_spapr_tce args = {\n\n        .liobn = liobn,\n\n        .window_size = window_size,\n\n    };\n\n    long len;\n\n    int fd;\n\n    void *table;\n\n\n\n    /* Must set fd to -1 so we don't try to munmap when called for\n\n     * destroying the table, which the upper layers -will- do\n\n     */\n\n    *pfd = -1;\n\n    if (!cap_spapr_tce || (vfio_accel && !cap_spapr_vfio)) {\n\n        return NULL;\n\n    }\n\n\n\n    fd = kvm_vm_ioctl(kvm_state, KVM_CREATE_SPAPR_TCE, &args);\n\n    if (fd < 0) {\n\n        fprintf(stderr, \"KVM: Failed to create TCE table for liobn 0x%x\\n\",\n\n                liobn);\n\n        return NULL;\n\n    }\n\n\n\n    len = (window_size / SPAPR_TCE_PAGE_SIZE) * sizeof(uint64_t);\n\n    /* FIXME: round this up to page size */\n\n\n\n    table = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\n    if (table == MAP_FAILED) {\n\n        fprintf(stderr, \"KVM: Failed to map TCE table for liobn 0x%x\\n\",\n\n                liobn);\n\n        close(fd);\n\n        return NULL;\n\n    }\n\n\n\n    *pfd = fd;\n\n    return table;\n\n}\n", "idx": 19264}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void exynos4210_pmu_write(void *opaque, target_phys_addr_t offset,\n\n                                 uint64_t val, unsigned size)\n\n{\n\n    Exynos4210PmuState *s = (Exynos4210PmuState *)opaque;\n\n    unsigned i;\n\n    const Exynos4210PmuReg *reg_p = exynos4210_pmu_regs;\n\n\n\n    for (i = 0; i < PMU_NUM_OF_REGISTERS; i++) {\n\n        if (reg_p->offset == offset) {\n\n            PRINT_DEBUG_EXTEND(\"%s <0x%04x> <- 0x%04x\\n\", reg_p->name,\n\n                    (uint32_t)offset, (uint32_t)val);\n\n            s->reg[i] = val;\n\n            return;\n\n        }\n\n        reg_p++;\n\n    }\n\n    PRINT_DEBUG(\"QEMU PMU ERROR: bad write offset 0x%04x\\n\", (uint32_t)offset);\n\n}\n", "idx": 19278}
{"project": "qemu", "commit_id": "45416789e8ccced568a4984af61974adfbfa0f62", "target": 0, "func": "static int omap_validate_emiff_addr(struct omap_mpu_state_s *s,\n\n                target_phys_addr_t addr)\n\n{\n\n    return addr >= OMAP_EMIFF_BASE && addr < OMAP_EMIFF_BASE + s->sdram_size;\n\n}\n", "idx": 19281}
{"project": "FFmpeg", "commit_id": "83548fe894cdb455cc127f754d09905b6d23c173", "target": 0, "func": "static int au_write_trailer(AVFormatContext *s)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    int64_t file_size;\n\n\n\n    if (s->pb->seekable) {\n\n        /* update file size */\n\n        file_size = avio_tell(pb);\n\n        avio_seek(pb, 8, SEEK_SET);\n\n        avio_wb32(pb, (uint32_t)(file_size - 24));\n\n        avio_seek(pb, file_size, SEEK_SET);\n\n        avio_flush(pb);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19282}
{"project": "qemu", "commit_id": "c96a1c0ba6b88fb47ca734013ae9b9248f78fbb4", "target": 0, "func": "static const CPUArchIdList *pc_possible_cpu_arch_ids(MachineState *machine)\n\n{\n\n    assert(machine->possible_cpus);\n\n    return machine->possible_cpus;\n\n}\n", "idx": 19294}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_update(void)\n\n{\n\n    int i, delta;\n\n\n\n    if (term_cmd_buf_size != term_last_cmd_buf_size ||\n\n        memcmp(term_cmd_buf, term_last_cmd_buf, term_cmd_buf_size) != 0) {\n\n        for(i = 0; i < term_last_cmd_buf_index; i++) {\n\n            term_printf(\"\\033[D\");\n\n        }\n\n        term_cmd_buf[term_cmd_buf_size] = '\\0';\n\n        term_printf(\"%s\", term_cmd_buf);\n\n        term_printf(\"\\033[K\");\n\n        memcpy(term_last_cmd_buf, term_cmd_buf, term_cmd_buf_size);\n\n        term_last_cmd_buf_size = term_cmd_buf_size;\n\n        term_last_cmd_buf_index = term_cmd_buf_size;\n\n    }\n\n    if (term_cmd_buf_index != term_last_cmd_buf_index) {\n\n        delta = term_cmd_buf_index - term_last_cmd_buf_index;\n\n        if (delta > 0) {\n\n            for(i = 0;i < delta; i++) {\n\n                term_printf(\"\\033[C\");\n\n            }\n\n        } else {\n\n            delta = -delta;\n\n            for(i = 0;i < delta; i++) {\n\n                term_printf(\"\\033[D\");\n\n            }\n\n        }\n\n        term_last_cmd_buf_index = term_cmd_buf_index;\n\n    }\n\n    term_flush();\n\n}\n", "idx": 19325}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static uint32_t qvirtio_pci_config_readl(QVirtioDevice *d, uint64_t off)\n\n{\n\n    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;\n\n    uint32_t value;\n\n\n\n    value = qpci_io_readl(dev->pdev, CONFIG_BASE(dev) + off);\n\n    if (qvirtio_is_big_endian(d)) {\n\n        value = bswap32(value);\n\n    }\n\n    return value;\n\n}\n", "idx": 19357}
{"project": "FFmpeg", "commit_id": "cdfc38f43b94e8ec3a9be10de2767778946d6eb5", "target": 1, "func": "static int xa_read_packet(AVFormatContext *s,\n\n                          AVPacket *pkt)\n\n{\n\n    MaxisXADemuxContext *xa = s->priv_data;\n\n    AVStream *st = s->streams[0];\n\n    ByteIOContext *pb = s->pb;\n\n    unsigned int packet_size;\n\n    int ret;\n\n\n\n    if(xa->sent_bytes > xa->out_size)\n\n        return AVERROR(EIO);\n\n    /* 1 byte header and 14 bytes worth of samples * number channels per block */\n\n    packet_size = 15*st->codec->channels;\n\n\n\n    ret = av_get_packet(pb, pkt, packet_size);\n\n    if(ret != packet_size)\n\n        return AVERROR(EIO);\n\n\n\n    pkt->stream_index = st->index;\n\n    xa->sent_bytes += packet_size;\n\n    pkt->pts = xa->audio_frame_counter;\n\n    /* 14 bytes Samples per channel with 2 samples per byte */\n\n    xa->audio_frame_counter += 28 * st->codec->channels;\n\n\n\n    return ret;\n\n}\n", "idx": 19361}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "int blk_mig_active(void)\n\n{\n\n    return !QSIMPLEQ_EMPTY(&block_mig_state.bmds_list);\n\n}\n", "idx": 19366}
{"project": "qemu", "commit_id": "41742767bfa8127954b6f57b39b590adcde3ac6c", "target": 0, "func": "static void isapc_machine_options(MachineClass *m)\n\n{\n\n    pc_common_machine_options(m);\n\n    m->desc = \"ISA-only PC\";\n\n    m->max_cpus = 1;\n\n}\n", "idx": 19372}
{"project": "FFmpeg", "commit_id": "0a82f5275f719e6e369a807720a2c3603aa0ddd9", "target": 1, "func": "static void lag_pred_line(LagarithContext *l, uint8_t *buf,\n\n                          int width, int stride, int line)\n\n{\n\n    int L, TL;\n\n\n\n    /* Left pixel is actually prev_row[width] */\n\n    L = buf[width - stride - 1];\n\n    if (!line) {\n\n        /* Left prediction only for first line */\n\n        L = l->dsp.add_hfyu_left_prediction(buf + 1, buf + 1,\n\n                                            width - 1, buf[0]);\n\n        return;\n\n    } else if (line == 1) {\n\n        /* Second line, left predict first pixel, the rest of the line is median predicted\n\n         * NOTE: In the case of RGB this pixel is top predicted */\n\n        TL = l->avctx->pix_fmt == PIX_FMT_YUV420P ? buf[-stride] : L;\n\n    } else {\n\n        /* Top left is 2 rows back, last pixel */\n\n        TL = buf[width - (2 * stride) - 1];\n\n    }\n\n\n\n    add_lag_median_prediction(buf, buf - stride, buf,\n\n                              width, &L, &TL);\n\n}\n", "idx": 19414}
{"project": "qemu", "commit_id": "b544c1aba8681c2fe5d6715fbd37cf6caf1bc7bb", "target": 1, "func": "static inline AIOReq *alloc_aio_req(BDRVSheepdogState *s, SheepdogAIOCB *acb,\n\n                                    uint64_t oid, unsigned int data_len,\n\n                                    uint64_t offset, uint8_t flags,\n\n                                    uint64_t base_oid, unsigned int iov_offset)\n\n{\n\n    AIOReq *aio_req;\n\n\n\n    aio_req = g_malloc(sizeof(*aio_req));\n\n    aio_req->aiocb = acb;\n\n    aio_req->iov_offset = iov_offset;\n\n    aio_req->oid = oid;\n\n    aio_req->base_oid = base_oid;\n\n    aio_req->offset = offset;\n\n    aio_req->data_len = data_len;\n\n    aio_req->flags = flags;\n\n    aio_req->id = s->aioreq_seq_num++;\n\n\n\n    acb->nr_pending++;\n\n    return aio_req;\n\n}\n", "idx": 19423}
{"project": "qemu", "commit_id": "ded6ddc5a7b95217557fa360913d1213e12d4a6d", "target": 0, "func": "static int32_t scsi_target_send_command(SCSIRequest *req, uint8_t *buf)\n\n{\n\n    SCSITargetReq *r = DO_UPCAST(SCSITargetReq, req, req);\n\n\n\n    switch (buf[0]) {\n\n    case REPORT_LUNS:\n\n        if (!scsi_target_emulate_report_luns(r)) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n        if (!scsi_target_emulate_inquiry(r)) {\n\n            goto illegal_request;\n\n        }\n\n        break;\n\n    case REQUEST_SENSE:\n\n        scsi_target_alloc_buf(&r->req, scsi_sense_len(req));\n\n        r->len = scsi_device_get_sense(r->req.dev, r->buf,\n\n                                       MIN(req->cmd.xfer, r->buf_len),\n\n                                       (req->cmd.buf[1] & 1) == 0);\n\n        if (r->req.dev->sense_is_ua) {\n\n            scsi_device_unit_attention_reported(req->dev);\n\n            r->req.dev->sense_len = 0;\n\n            r->req.dev->sense_is_ua = false;\n\n        }\n\n        break;\n\n    case TEST_UNIT_READY:\n\n        break;\n\n    default:\n\n        scsi_req_build_sense(req, SENSE_CODE(LUN_NOT_SUPPORTED));\n\n        scsi_req_complete(req, CHECK_CONDITION);\n\n        return 0;\n\n    illegal_request:\n\n        scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));\n\n        scsi_req_complete(req, CHECK_CONDITION);\n\n        return 0;\n\n    }\n\n\n\n    if (!r->len) {\n\n        scsi_req_complete(req, GOOD);\n\n    }\n\n    return r->len;\n\n}\n", "idx": 19476}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static inline int onenand_load_spare(OneNANDState *s, int sec, int secn,\n\n                void *dest)\n\n{\n\n    uint8_t buf[512];\n\n\n\n    if (s->bdrv_cur) {\n\n        if (bdrv_read(s->bdrv_cur, s->secs_cur + (sec >> 5), buf, 1) < 0)\n\n            return 1;\n\n        memcpy(dest, buf + ((sec & 31) << 4), secn << 4);\n\n    } else if (sec + secn > s->secs_cur)\n\n        return 1;\n\n    else\n\n        memcpy(dest, s->current + (s->secs_cur << 9) + (sec << 4), secn << 4);\n\n \n\n    return 0;\n\n}\n", "idx": 19479}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "static inline void gen_op_fcmps(int fccno, TCGv_i32 r_rs1, TCGv_i32 r_rs2)\n\n{\n\n    switch (fccno) {\n\n    case 0:\n\n        gen_helper_fcmps(cpu_env, r_rs1, r_rs2);\n\n        break;\n\n    case 1:\n\n        gen_helper_fcmps_fcc1(cpu_env, r_rs1, r_rs2);\n\n        break;\n\n    case 2:\n\n        gen_helper_fcmps_fcc2(cpu_env, r_rs1, r_rs2);\n\n        break;\n\n    case 3:\n\n        gen_helper_fcmps_fcc3(cpu_env, r_rs1, r_rs2);\n\n        break;\n\n    }\n\n}\n", "idx": 19480}
{"project": "qemu", "commit_id": "fd859081453f94c3cbd6527289e41b7fddbf645f", "target": 0, "func": "static void tpm_tis_receive_cb(TPMState *s, uint8_t locty)\n\n{\n\n    TPMTISEmuState *tis = &s->s.tis;\n\n\n\n    assert(s->locty_number == locty);\n\n\n\n    qemu_bh_schedule(tis->bh);\n\n}\n", "idx": 19489}
{"project": "qemu", "commit_id": "f7c11b535040df31cc8bc3b1f0c33f546073ee62", "target": 0, "func": "void cpu_physical_memory_unmap(void *buffer, target_phys_addr_t len,\n\n                               int is_write, target_phys_addr_t access_len)\n\n{\n\n    if (buffer != bounce.buffer) {\n\n        if (is_write) {\n\n            ram_addr_t addr1 = qemu_ram_addr_from_host(buffer);\n\n            while (access_len) {\n\n                unsigned l;\n\n                l = TARGET_PAGE_SIZE;\n\n                if (l > access_len)\n\n                    l = access_len;\n\n                if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                    /* invalidate code */\n\n                    tb_invalidate_phys_page_range(addr1, addr1 + l, 0);\n\n                    /* set dirty bit */\n\n                    phys_ram_dirty[addr1 >> TARGET_PAGE_BITS] |=\n\n                        (0xff & ~CODE_DIRTY_FLAG);\n\n                }\n\n                addr1 += l;\n\n                access_len -= l;\n\n            }\n\n        }\n\n        return;\n\n    }\n\n    if (is_write) {\n\n        cpu_physical_memory_write(bounce.addr, bounce.buffer, access_len);\n\n    }\n\n    qemu_vfree(bounce.buffer);\n\n    bounce.buffer = NULL;\n\n    cpu_notify_map_clients();\n\n}\n", "idx": 19504}
{"project": "qemu", "commit_id": "4f2d3d705c1ae7dce29254e2c4645c84e77a74d4", "target": 0, "func": "void qdev_prop_set_defaults(DeviceState *dev, Property *props)\n\n{\n\n    if (!props)\n\n        return;\n\n    while (props->name) {\n\n        if (props->defval) {\n\n            qdev_prop_cpy(dev, props, props->defval);\n\n        }\n\n        props++;\n\n    }\n\n}\n", "idx": 19520}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_op_evabs(TCGv_i32 ret, TCGv_i32 arg1)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n\n\n    tcg_gen_brcondi_i32(TCG_COND_GE, arg1, 0, l1);\n\n    tcg_gen_neg_i32(ret, arg1);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_mov_i32(ret, arg1);\n\n    gen_set_label(l2);\n\n}\n", "idx": 19523}
{"project": "qemu", "commit_id": "d85fa9eb87ba736d2d5ce342fc35f507c8fe29f2", "target": 1, "func": "static coroutine_fn int qemu_gluster_co_flush_to_disk(BlockDriverState *bs)\n\n{\n\n    int ret;\n\n    GlusterAIOCB acb;\n\n    BDRVGlusterState *s = bs->opaque;\n\n\n\n    acb.size = 0;\n\n    acb.ret = 0;\n\n    acb.coroutine = qemu_coroutine_self();\n\n    acb.aio_context = bdrv_get_aio_context(bs);\n\n\n\n    ret = glfs_fsync_async(s->fd, gluster_finish_aiocb, &acb);\n\n    if (ret < 0) {\n\n        return -errno;\n\n    }\n\n\n\n    qemu_coroutine_yield();\n\n    return acb.ret;\n\n}\n", "idx": 19530}
{"project": "FFmpeg", "commit_id": "e2710e790c09e49e86baa58c6063af0097cc8cb0", "target": 1, "func": "int ff_get_cpu_flags_arm(void)\n{\n    int flags = CORE_CPU_FLAGS;\n    uint32_t hwcap;\n    if (get_hwcap(&hwcap) < 0)\n        if (get_cpuinfo(&hwcap) < 0)\n            return flags;\n#define check_cap(cap, flag) do {               \\\n        if (hwcap & HWCAP_ ## cap)              \\\n            flags |= AV_CPU_FLAG_ ## flag;      \\\n    } while (0)\n    /* No flags explicitly indicate v6 or v6T2 so check others which\n       imply support. */\n    check_cap(EDSP,    ARMV5TE);\n    check_cap(TLS,     ARMV6);\n    check_cap(THUMBEE, ARMV6T2);\n    check_cap(VFP,     VFP);\n    check_cap(VFPv3,   VFPV3);\n    check_cap(NEON,    NEON);\n    /* The v6 checks above are not reliable so let higher flags\n       trickle down. */\n    if (flags & (AV_CPU_FLAG_VFPV3 | AV_CPU_FLAG_NEON))\n        flags |= AV_CPU_FLAG_ARMV6T2;\n    if (flags & AV_CPU_FLAG_ARMV6T2)\n        flags |= AV_CPU_FLAG_ARMV6;\n    return flags;\n}", "idx": 19547}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static inline uint32_t reloc_26_val(tcg_insn_unit *pc, tcg_insn_unit *target)\n\n{\n\n    assert((((uintptr_t)pc ^ (uintptr_t)target) & 0xf0000000) == 0);\n\n    return ((uintptr_t)target >> 2) & 0x3ffffff;\n\n}\n", "idx": 19571}
{"project": "qemu", "commit_id": "9f1d4b1d6939d39fe570d886f6a651f4764bcbcb", "target": 0, "func": "static uint32_t openpic_iack(OpenPICState *opp, IRQDest *dst, int cpu)\n\n{\n\n    IRQSource *src;\n\n    int retval, irq;\n\n\n\n    DPRINTF(\"Lower OpenPIC INT output\\n\");\n\n    qemu_irq_lower(dst->irqs[OPENPIC_OUTPUT_INT]);\n\n\n\n    irq = IRQ_get_next(opp, &dst->raised);\n\n    DPRINTF(\"IACK: irq=%d\\n\", irq);\n\n\n\n    if (irq == -1) {\n\n        /* No more interrupt pending */\n\n        return opp->spve;\n\n    }\n\n\n\n    src = &opp->src[irq];\n\n    if (!(src->ivpr & IVPR_ACTIVITY_MASK) ||\n\n            !(IVPR_PRIORITY(src->ivpr) > dst->ctpr)) {\n\n        /* - Spurious level-sensitive IRQ\n\n         * - Priorities has been changed\n\n         *   and the pending IRQ isn't allowed anymore\n\n         */\n\n        src->ivpr &= ~IVPR_ACTIVITY_MASK;\n\n        retval = opp->spve;\n\n    } else {\n\n        /* IRQ enter servicing state */\n\n        IRQ_setbit(&dst->servicing, irq);\n\n        retval = IVPR_VECTOR(opp, src->ivpr);\n\n    }\n\n    IRQ_resetbit(&dst->raised, irq);\n\n    if (!src->level) {\n\n        /* edge-sensitive IRQ */\n\n        src->ivpr &= ~IVPR_ACTIVITY_MASK;\n\n        src->pending = 0;\n\n    }\n\n\n\n    if ((irq >= opp->irq_ipi0) &&  (irq < (opp->irq_ipi0 + MAX_IPI))) {\n\n        src->idr &= ~(1 << cpu);\n\n        if (src->idr && !src->level) {\n\n            /* trigger on CPUs that didn't know about it yet */\n\n            openpic_set_irq(opp, irq, 1);\n\n            openpic_set_irq(opp, irq, 0);\n\n            /* if all CPUs knew about it, set active bit again */\n\n            src->ivpr |= IVPR_ACTIVITY_MASK;\n\n        }\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 19573}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_tlbie(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr || !ctx->hv)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    if (NARROW_MODE(ctx)) {\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_ext32u_tl(t0, cpu_gpr[rB(ctx->opcode)]);\n\n        gen_helper_tlbie(cpu_env, t0);\n\n        tcg_temp_free(t0);\n\n    } else {\n\n        gen_helper_tlbie(cpu_env, cpu_gpr[rB(ctx->opcode)]);\n\n    }\n\n#endif\n\n}\n", "idx": 19615}
{"project": "FFmpeg", "commit_id": "09d89d940635e34b0f61266d66fbb9802b18564c", "target": 0, "func": "static void decode_subband(DiracContext *s, GetBitContext *gb, int quant,\n\n                           int slice_x, int slice_y, int bits_end,\n\n                           SubBand *b1, SubBand *b2)\n\n{\n\n    int left   = b1->width  * slice_x    / s->num_x;\n\n    int right  = b1->width  *(slice_x+1) / s->num_x;\n\n    int top    = b1->height * slice_y    / s->num_y;\n\n    int bottom = b1->height *(slice_y+1) / s->num_y;\n\n\n\n    int qfactor, qoffset;\n\n\n\n    uint8_t *buf1 =      b1->ibuf + top * b1->stride;\n\n    uint8_t *buf2 = b2 ? b2->ibuf + top * b2->stride: NULL;\n\n    int x, y;\n\n\n\n    if (quant > 115) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Unsupported quant %d\\n\", quant);\n\n        return;\n\n    }\n\n    qfactor = ff_dirac_qscale_tab[quant & 0x7f];\n\n    qoffset = ff_dirac_qoffset_intra_tab[quant & 0x7f] + 2;\n\n    /* we have to constantly check for overread since the spec explicitly\n\n       requires this, with the meaning that all remaining coeffs are set to 0 */\n\n    if (get_bits_count(gb) >= bits_end)\n\n        return;\n\n\n\n    if (s->pshift) {\n\n        for (y = top; y < bottom; y++) {\n\n            for (x = left; x < right; x++) {\n\n                PARSE_VALUES(int32_t, x, gb, bits_end, buf1, buf2);\n\n            }\n\n            buf1 += b1->stride;\n\n            if (buf2)\n\n                buf2 += b2->stride;\n\n        }\n\n    }\n\n    else {\n\n        for (y = top; y < bottom; y++) {\n\n            for (x = left; x < right; x++) {\n\n                PARSE_VALUES(int16_t, x, gb, bits_end, buf1, buf2);\n\n            }\n\n            buf1 += b1->stride;\n\n            if (buf2)\n\n                buf2 += b2->stride;\n\n        }\n\n    }\n\n}\n", "idx": 19625}
{"project": "qemu", "commit_id": "1e9b65bb1bad51735cab6c861c29b592dccabf0e", "target": 1, "func": "void qga_vss_fsfreeze(int *nr_volume, Error **errp, bool freeze)\n\n{\n\n    const char *func_name = freeze ? \"requester_freeze\" : \"requester_thaw\";\n\n    QGAVSSRequesterFunc func;\n\n    ErrorSet errset = {\n\n        .error_setg_win32 = error_setg_win32,\n\n        .errp = errp,\n\n    };\n\n\n\n    g_assert(errp);             /* requester.cpp requires it */\n\n    func = (QGAVSSRequesterFunc)GetProcAddress(provider_lib, func_name);\n\n    if (!func) {\n\n        error_setg_win32(errp, GetLastError(), \"failed to load %s from %s\",\n\n                         func_name, QGA_VSS_DLL);\n\n        return;\n\n    }\n\n\n\n    func(nr_volume, &errset);\n\n}\n", "idx": 19648}
{"project": "qemu", "commit_id": "2ecea9b8de5cd74df314541b87f712ae77f862ec", "target": 1, "func": "static void do_change_block(const char *device, const char *filename)\n\n{\n\n    BlockDriverState *bs;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        term_printf(\"device not found\\n\");\n\n        return;\n\n    }\n\n    if (eject_device(bs, 0) < 0)\n\n        return;\n\n    bdrv_open(bs, filename, 0);\n\n    qemu_key_check(bs, filename);\n\n}\n", "idx": 19659}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static NFSServer *nfs_config(QDict *options, Error **errp)\n\n{\n\n    NFSServer *server = NULL;\n\n    QDict *addr = NULL;\n\n    QObject *crumpled_addr = NULL;\n\n    Visitor *iv = NULL;\n\n    Error *local_error = NULL;\n\n\n\n    qdict_extract_subqdict(options, &addr, \"server.\");\n\n    if (!qdict_size(addr)) {\n\n        error_setg(errp, \"NFS server address missing\");\n\n        goto out;\n\n    }\n\n\n\n    crumpled_addr = qdict_crumple(addr, errp);\n\n    if (!crumpled_addr) {\n\n        goto out;\n\n    }\n\n\n\n\n\n\n\n\n\n\n    iv = qobject_input_visitor_new(crumpled_addr);\n\n    visit_type_NFSServer(iv, NULL, &server, &local_error);\n\n    if (local_error) {\n\n        error_propagate(errp, local_error);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    QDECREF(addr);\n\n    qobject_decref(crumpled_addr);\n\n    visit_free(iv);\n\n    return server;\n\n}", "idx": 19666}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_rfmci(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    /* Restore CPU state */\n\n    gen_helper_rfmci(cpu_env);\n\n    gen_sync_exception(ctx);\n\n#endif\n\n}\n", "idx": 19674}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void memory_region_transaction_commit(void)\n{\n    AddressSpace *as;\n    assert(memory_region_transaction_depth);\n    --memory_region_transaction_depth;\n    if (!memory_region_transaction_depth) {\n        if (memory_region_update_pending) {\n            MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_topology(as);\n            }\n            MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);\n        } else if (ioeventfd_update_pending) {\n            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {\n                address_space_update_ioeventfds(as);\n            }\n        }\n        memory_region_clear_pending();\n   }\n}", "idx": 19689}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static uint64_t block_save_pending(QEMUFile *f, void *opaque, uint64_t max_size)\n\n{\n\n    /* Estimate pending number of bytes to send */\n\n    uint64_t pending;\n\n\n\n    qemu_mutex_lock_iothread();\n\n    blk_mig_lock();\n\n    pending = get_remaining_dirty() +\n\n                       block_mig_state.submitted * BLOCK_SIZE +\n\n                       block_mig_state.read_done * BLOCK_SIZE;\n\n\n\n    /* Report at least one block pending during bulk phase */\n\n    if (pending == 0 && !block_mig_state.bulk_completed) {\n\n        pending = BLOCK_SIZE;\n\n    }\n\n    blk_mig_unlock();\n\n    qemu_mutex_unlock_iothread();\n\n\n\n    DPRINTF(\"Enter save live pending  %\" PRIu64 \"\\n\", pending);\n\n    return pending;\n\n}\n", "idx": 19707}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(cmpli)\n\n{\n\n    if (T0 < PARAM(1)) {\n\n        T0 = 0x08;\n\n    } else if (T0 > PARAM(1)) {\n\n        T0 = 0x04;\n\n    } else {\n\n        T0 = 0x02;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 19712}
{"project": "qemu", "commit_id": "14b6160099f0caf5dc9d62e637b007bc5d719a96", "target": 1, "func": "bool qdict_get_try_bool(const QDict *qdict, const char *key, bool def_value)\n\n{\n\n    QObject *obj;\n\n\n\n    obj = qdict_get(qdict, key);\n\n    if (!obj || qobject_type(obj) != QTYPE_QBOOL)\n\n        return def_value;\n\n\n\n    return qbool_get_bool(qobject_to_qbool(obj));\n\n}\n", "idx": 19734}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void qemu_rdma_dump_id(const char *who, struct ibv_context *verbs)\n\n{\n\n    struct ibv_port_attr port;\n\n\n\n    if (ibv_query_port(verbs, 1, &port)) {\n\n        fprintf(stderr, \"FAILED TO QUERY PORT INFORMATION!\\n\");\n\n        return;\n\n    }\n\n\n\n    printf(\"%s RDMA Device opened: kernel name %s \"\n\n           \"uverbs device name %s, \"\n\n           \"infiniband_verbs class device path %s, \"\n\n           \"infiniband class device path %s, \"\n\n           \"transport: (%d) %s\\n\",\n\n                who,\n\n                verbs->device->name,\n\n                verbs->device->dev_name,\n\n                verbs->device->dev_path,\n\n                verbs->device->ibdev_path,\n\n                port.link_layer,\n\n                (port.link_layer == IBV_LINK_LAYER_INFINIBAND) ? \"Infiniband\" :\n\n                 ((port.link_layer == IBV_LINK_LAYER_ETHERNET) \n\n                    ? \"Ethernet\" : \"Unknown\"));\n\n}\n", "idx": 19748}
{"project": "FFmpeg", "commit_id": "c96bd21227e594856f8fd0610fd213b002056383", "target": 0, "func": "static int mp3_read_probe(AVProbeData *p)\n\n{\n\n    int max_frames, first_frames = 0;\n\n    int fsize, frames, sample_rate;\n\n    uint32_t header;\n\n    uint8_t *buf, *buf2, *end;\n\n    AVCodecContext avctx;\n\n\n\n    if(id3v2_match(p->buf))\n\n        return AVPROBE_SCORE_MAX/2+1; // this must be less than mpeg-ps because some retards put id3v2 tags before mpeg-ps files\n\n\n\n    max_frames = 0;\n\n    buf = p->buf;\n\n    end = buf + p->buf_size - sizeof(uint32_t);\n\n\n\n    for(; buf < end; buf= buf2+1) {\n\n        buf2 = buf;\n\n\n\n        for(frames = 0; buf2 < end; frames++) {\n\n            header = AV_RB32(buf2);\n\n            fsize = ff_mpa_decode_header(&avctx, header, &sample_rate);\n\n            if(fsize < 0)\n\n                break;\n\n            buf2 += fsize;\n\n        }\n\n        max_frames = FFMAX(max_frames, frames);\n\n        if(buf == p->buf)\n\n            first_frames= frames;\n\n    }\n\n    if   (first_frames>=3) return AVPROBE_SCORE_MAX/2+1;\n\n    else if(max_frames>500)return AVPROBE_SCORE_MAX/2;\n\n    else if(max_frames>=3) return AVPROBE_SCORE_MAX/4;\n\n    else if(max_frames>=1) return 1;\n\n    else                   return 0;\n\n}\n", "idx": 19752}
{"project": "FFmpeg", "commit_id": "2862b63783b5556f7f3fb2d097629bc6879f833a", "target": 0, "func": "static int ljpeg_encode_yuv(AVCodecContext *avctx, PutBitContext *pb,\n\n                            const AVFrame *frame)\n\n{\n\n    const int predictor = avctx->prediction_method + 1;\n\n    LJpegEncContext *s  = avctx->priv_data;\n\n    const int mb_width  = (avctx->width  + s->hsample[0] - 1) / s->hsample[0];\n\n    const int mb_height = (avctx->height + s->vsample[0] - 1) / s->vsample[0];\n\n    int mb_x, mb_y;\n\n\n\n    for (mb_y = 0; mb_y < mb_height; mb_y++) {\n\n        if (pb->buf_end - pb->buf - (put_bits_count(pb) >> 3) <\n\n            mb_width * 4 * 3 * s->hsample[0] * s->vsample[0]) {\n\n            av_log(avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n            return -1;\n\n        }\n\n\n\n        for (mb_x = 0; mb_x < mb_width; mb_x++)\n\n            ljpeg_encode_yuv_mb(s, pb, frame, predictor, mb_x, mb_y);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19758}
{"project": "qemu", "commit_id": "5f758366c0710d23e43f4d0f83816b98616a13d0", "target": 1, "func": "static CharDriverState *qmp_chardev_open_serial(ChardevHostdev *serial,\n\n                                                Error **errp)\n\n{\n\n#ifdef HAVE_CHARDEV_TTY\n\n    int fd;\n\n\n\n    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);\n\n    if (error_is_set(errp)) {\n\n        return NULL;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n    return qemu_chr_open_tty_fd(fd);\n\n#else\n\n    error_setg(errp, \"character device backend type 'serial' not supported\");\n\n    return NULL;\n\n#endif\n\n}\n", "idx": 19766}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_mul(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_ov = tcg_temp_new();\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_muls2_tl(dest, sr_ov, srca, srcb);\n\n    tcg_gen_sari_tl(t0, dest, TARGET_LONG_BITS - 1);\n\n    tcg_gen_setcond_tl(TCG_COND_NE, sr_ov, sr_ov, t0);\n\n    tcg_temp_free(t0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_ov, ctz32(SR_OV), 1);\n\n\n\n    gen_ove_ov(dc, sr_ov);\n\n    tcg_temp_free(sr_ov);\n\n}\n", "idx": 19785}
{"project": "FFmpeg", "commit_id": "c3390fd56cf55259ea7665ecea6c8aeddf56e2fc", "target": 1, "func": "static av_cold int ra144_decode_init(AVCodecContext * avctx)\n{\n    RA144Context *ractx = avctx->priv_data;\n    ractx->avctx = avctx;\n    ractx->lpc_coef[0] = ractx->lpc_tables[0];\n    ractx->lpc_coef[1] = ractx->lpc_tables[1];\n    avctx->channels       = 1;\n    avctx->channel_layout = AV_CH_LAYOUT_MONO;\n    avctx->sample_fmt     = AV_SAMPLE_FMT_S16;\n    return 0;\n}", "idx": 19788}
{"project": "qemu", "commit_id": "9a94ee5bb15793ef69692998ef57794a33074134", "target": 1, "func": "static void rtas_start_cpu(PowerPCCPU *cpu_, sPAPRMachineState *spapr,\n                           uint32_t token, uint32_t nargs,\n                           target_ulong args,\n                           uint32_t nret, target_ulong rets)\n{\n    target_ulong id, start, r3;\n    PowerPCCPU *cpu;\n    if (nargs != 3 || nret != 1) {\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n        return;\n    }\n    id = rtas_ld(args, 0);\n    start = rtas_ld(args, 1);\n    r3 = rtas_ld(args, 2);\n    cpu = spapr_find_cpu(id);\n    if (cpu != NULL) {\n        CPUState *cs = CPU(cpu);\n        CPUPPCState *env = &cpu->env;\n        PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n        if (!cs->halted) {\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n            return;\n        }\n        /* This will make sure qemu state is up to date with kvm, and\n         * mark it dirty so our changes get flushed back before the\n         * new cpu enters */\n        kvm_cpu_synchronize_state(cs);\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n        env->nip = start;\n        env->gpr[3] = r3;\n        cs->halted = 0;\n        spapr_cpu_set_endianness(cpu);\n        spapr_cpu_update_tb_offset(cpu);\n        qemu_cpu_kick(cs);\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n        return;\n    }\n    /* Didn't find a matching cpu */\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n}", "idx": 19791}
{"project": "qemu", "commit_id": "f68ec8379e88502b4841a110c070e9b118d3151c", "target": 1, "func": "void ide_flush_cache(IDEState *s)\n\n{\n\n    if (s->bs == NULL) {\n\n        ide_flush_cb(s, 0);\n\n        return;\n\n    }\n\n\n\n\n    bdrv_acct_start(s->bs, &s->acct, 0, BDRV_ACCT_FLUSH);\n\n    bdrv_aio_flush(s->bs, ide_flush_cb, s);\n\n}", "idx": 19823}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static void spapr_phb_hot_unplug_child(HotplugHandler *plug_handler,\n\n                                       DeviceState *plugged_dev, Error **errp)\n\n{\n\n    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));\n\n    PCIDevice *pdev = PCI_DEVICE(plugged_dev);\n\n    sPAPRDRConnectorClass *drck;\n\n    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);\n\n    Error *local_err = NULL;\n\n\n\n    if (!phb->dr_enabled) {\n\n        error_setg(errp, QERR_BUS_NO_HOTPLUG,\n\n                   object_get_typename(OBJECT(phb)));\n\n        return;\n\n    }\n\n\n\n    g_assert(drc);\n\n\n\n    drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    if (!drck->release_pending(drc)) {\n\n        spapr_phb_remove_pci_device(drc, phb, pdev, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        spapr_hotplug_req_remove_by_index(drc);\n\n    }\n\n}\n", "idx": 19825}
{"project": "qemu", "commit_id": "908bcd540f489f7adf2d804347905b0025d808d3", "target": 1, "func": "int bdrv_check(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix)\n\n{\n\n\n\n\n    if (bs->drv->bdrv_check == NULL) {\n\n        return -ENOTSUP;\n\n\n\n\n    memset(res, 0, sizeof(*res));\n\n    return bs->drv->bdrv_check(bs, res, fix);\n", "idx": 19833}
{"project": "qemu", "commit_id": "8a93e519f32c40ebc41503fd18607dcaef1ddf7a", "target": 1, "func": "static void map_linear_vram(CirrusVGAState *s)\n\n{\n\n\n\n\n    if (!s->map_addr && s->lfb_addr && s->lfb_end) {\n\n        s->map_addr = s->lfb_addr;\n\n        s->map_end = s->lfb_end;\n\n        cpu_register_physical_memory(s->map_addr, s->map_end - s->map_addr, s->vram_offset);\n\n    }\n\n\n\n    if (!s->map_addr)\n\n        return;\n\n\n\n    s->lfb_vram_mapped = 0;\n\n\n\n\n\n\n\n    if (!(s->cirrus_srcptr != s->cirrus_srcptr_end)\n\n        && !((s->sr[0x07] & 0x01) == 0)\n\n        && !((s->gr[0x0B] & 0x14) == 0x14)\n\n        && !(s->gr[0x0B] & 0x02)) {\n\n\n\n\n\n                                    (s->vram_offset + s->cirrus_bank_base[0]) | IO_MEM_RAM);\n\n\n                                    (s->vram_offset + s->cirrus_bank_base[1]) | IO_MEM_RAM);\n\n\n\n        s->lfb_vram_mapped = 1;\n\n    }\n\n    else {\n\n        cpu_register_physical_memory(isa_mem_base + 0xa0000, 0x20000,\n\n                                     s->vga_io_memory);\n\n    }\n\n\n\n    vga_dirty_log_start((VGAState *)s);\n\n}", "idx": 19835}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static int adb_kbd_request(ADBDevice *d, uint8_t *obuf,\n\n                           const uint8_t *buf, int len)\n\n{\n\n    KBDState *s = ADB_KEYBOARD(d);\n\n    int cmd, reg, olen;\n\n\n\n    if ((buf[0] & 0x0f) == ADB_FLUSH) {\n\n        /* flush keyboard fifo */\n\n        s->wptr = s->rptr = s->count = 0;\n\n        return 0;\n\n    }\n\n\n\n    cmd = buf[0] & 0xc;\n\n    reg = buf[0] & 0x3;\n\n    olen = 0;\n\n    switch(cmd) {\n\n    case ADB_WRITEREG:\n\n        switch(reg) {\n\n        case 2:\n\n            /* LED status */\n\n            break;\n\n        case 3:\n\n            switch(buf[2]) {\n\n            case ADB_CMD_SELF_TEST:\n\n                break;\n\n            case ADB_CMD_CHANGE_ID:\n\n            case ADB_CMD_CHANGE_ID_AND_ACT:\n\n            case ADB_CMD_CHANGE_ID_AND_ENABLE:\n\n                d->devaddr = buf[1] & 0xf;\n\n                break;\n\n            default:\n\n                d->devaddr = buf[1] & 0xf;\n\n                /* we support handlers:\n\n                 * 1: Apple Standard Keyboard\n\n                 * 2: Apple Extended Keyboard (LShift = RShift)\n\n                 * 3: Apple Extended Keyboard (LShift != RShift)\n\n                 */\n\n                if (buf[2] == 1 || buf[2] == 2 || buf[2] == 3) {\n\n                    d->handler = buf[2];\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case ADB_READREG:\n\n        switch(reg) {\n\n        case 0:\n\n            olen = adb_kbd_poll(d, obuf);\n\n            break;\n\n        case 1:\n\n            break;\n\n        case 2:\n\n            obuf[0] = 0x00; /* XXX: check this */\n\n            obuf[1] = 0x07; /* led status */\n\n            olen = 2;\n\n            break;\n\n        case 3:\n\n            obuf[0] = d->handler;\n\n            obuf[1] = d->devaddr;\n\n            olen = 2;\n\n            break;\n\n        }\n\n        break;\n\n    }\n\n    return olen;\n\n}\n", "idx": 19907}
{"project": "FFmpeg", "commit_id": "a3145d0335b04d143c26832c91dcc7242c758206", "target": 0, "func": "static av_cold int bmv_aud_decode_init(AVCodecContext *avctx)\n\n{\n\n    BMVAudioDecContext *c = avctx->priv_data;\n\n\n\n    if (avctx->channels != 2) {\n\n        av_log(avctx, AV_LOG_INFO, \"invalid number of channels\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    avcodec_get_frame_defaults(&c->frame);\n\n    avctx->coded_frame = &c->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 19919}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int cdrom_open(BlockDriverState *bs, QDict *options, int flags,\n\n                      Error **errp)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int ret;\n\n\n\n    s->type = FTYPE_CD;\n\n\n\n    /* open will not fail even if no CD is inserted, so add O_NONBLOCK */\n\n    ret = raw_open_common(bs, options, flags, O_NONBLOCK, errp);\n\n    return ret;\n\n}\n", "idx": 19932}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void imx_serial_create(int uart, const target_phys_addr_t addr, qemu_irq irq)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *bus;\n\n    CharDriverState *chr;\n\n    const char chr_name[] = \"serial\";\n\n    char label[ARRAY_SIZE(chr_name) + 1];\n\n\n\n    dev = qdev_create(NULL, \"imx-serial\");\n\n\n\n    if (uart >= MAX_SERIAL_PORTS) {\n\n        hw_error(\"Cannot assign uart %d: QEMU supports only %d ports\\n\",\n\n                 uart, MAX_SERIAL_PORTS);\n\n    }\n\n    chr = serial_hds[uart];\n\n    if (!chr) {\n\n        snprintf(label, ARRAY_SIZE(label), \"%s%d\", chr_name, uart);\n\n        chr = qemu_chr_new(label, \"null\", NULL);\n\n        if (!(chr)) {\n\n            hw_error(\"Can't assign serial port to imx-uart%d.\\n\", uart);\n\n        }\n\n    }\n\n\n\n    qdev_prop_set_chr(dev, \"chardev\", chr);\n\n    bus = sysbus_from_qdev(dev);\n\n    qdev_init_nofail(dev);\n\n    if (addr != (target_phys_addr_t)-1) {\n\n        sysbus_mmio_map(bus, 0, addr);\n\n    }\n\n    sysbus_connect_irq(bus, 0, irq);\n\n\n\n}\n", "idx": 19933}
{"project": "qemu", "commit_id": "d07cc1f12d8e15c167857852c39190d770763824", "target": 0, "func": "static KVMMSIRoute *kvm_lookup_msi_route(KVMState *s, MSIMessage msg)\n\n{\n\n    unsigned int hash = kvm_hash_msi(msg.data);\n\n    KVMMSIRoute *route;\n\n\n\n    QTAILQ_FOREACH(route, &s->msi_hashtab[hash], entry) {\n\n        if (route->kroute.u.msi.address_lo == (uint32_t)msg.address &&\n\n            route->kroute.u.msi.address_hi == (msg.address >> 32) &&\n\n            route->kroute.u.msi.data == msg.data) {\n\n            return route;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 19935}
{"project": "qemu", "commit_id": "02b07434bed8360715198b4cbfdfebd17f7cac32", "target": 0, "func": "static int pxb_bus_num(PCIBus *bus)\n\n{\n\n    PXBDev *pxb = PXB_DEV(bus->parent_dev);\n\n\n\n    return pxb->bus_nr;\n\n}\n", "idx": 19949}
{"project": "qemu", "commit_id": "3604a76fea6ff37738d4a8f596be38407be74a83", "target": 1, "func": "static void dec_user(DisasContext *dc)\n\n{\n\n    LOG_DIS(\"user\");\n\n\n\n    cpu_abort(dc->env, \"user insn undefined\\n\");\n\n}\n", "idx": 19963}
{"project": "qemu", "commit_id": "4cc2cc085586cdb787a24d78a7ba032fa657275a", "target": 1, "func": "target_ulong helper_load_slb_esid(CPUPPCState *env, target_ulong rb)\n\n{\n\n    target_ulong rt;\n\n\n\n    if (ppc_load_slb_esid(env, rb, &rt) < 0) {\n\n        helper_raise_exception_err(env, POWERPC_EXCP_PROGRAM,\n\n                                   POWERPC_EXCP_INVAL);\n\n    }\n\n    return rt;\n\n}\n", "idx": 19970}
{"project": "qemu", "commit_id": "f51074cdc6e750daa3b6df727d83449a7e42b391", "target": 1, "func": "void hmp_pci_del(Monitor *mon, const QDict *qdict)\n\n{\n\n    pci_device_hot_remove(mon, qdict_get_str(qdict, \"pci_addr\"));\n\n}\n", "idx": 19991}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "QEMUPutMouseEntry *qemu_add_mouse_event_handler(QEMUPutMouseEvent *func,\n\n                                                void *opaque, int absolute,\n\n                                                const char *name)\n\n{\n\n    QEMUPutMouseEntry *s;\n\n\n\n    s = g_malloc0(sizeof(QEMUPutMouseEntry));\n\n\n\n    s->qemu_put_mouse_event = func;\n\n    s->qemu_put_mouse_event_opaque = opaque;\n\n    s->qemu_put_mouse_event_absolute = absolute;\n\n\n\n    s->h.name = name;\n\n    s->h.mask = INPUT_EVENT_MASK_BTN |\n\n        (absolute ? INPUT_EVENT_MASK_ABS : INPUT_EVENT_MASK_REL);\n\n    s->h.event = legacy_mouse_event;\n\n    s->h.sync = legacy_mouse_sync;\n\n    s->s = qemu_input_handler_register((DeviceState *)s,\n\n                                       &s->h);\n\n\n\n    return s;\n\n}\n", "idx": 19993}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_add(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv t0 = tcg_const_tl(0);\n\n    TCGv res = tcg_temp_new();\n\n    TCGv sr_cy = tcg_temp_new();\n\n    TCGv sr_ov = tcg_temp_new();\n\n\n\n    tcg_gen_add2_tl(res, sr_cy, srca, t0, srcb, t0);\n\n    tcg_gen_xor_tl(sr_ov, srca, srcb);\n\n    tcg_gen_xor_tl(t0, res, srcb);\n\n    tcg_gen_andc_tl(sr_ov, t0, sr_ov);\n\n    tcg_temp_free(t0);\n\n\n\n    tcg_gen_mov_tl(dest, res);\n\n    tcg_temp_free(res);\n\n\n\n    tcg_gen_shri_tl(sr_ov, sr_ov, TARGET_LONG_BITS - 1);\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_ov, ctz32(SR_OV), 1);\n\n\n\n    gen_ove_cyov(dc, sr_ov, sr_cy);\n\n    tcg_temp_free(sr_ov);\n\n    tcg_temp_free(sr_cy);\n\n}\n", "idx": 20009}
{"project": "FFmpeg", "commit_id": "29208e6dcf944bbea696d37a354a8bac9b552709", "target": 0, "func": "int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4],\n\n                         const uint8_t *src,\n\n                         enum AVPixelFormat pix_fmt, int width, int height, int align)\n\n{\n\n    int ret, i;\n\n\n\n    if ((ret = av_image_check_size(width, height, 0, NULL)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = av_image_fill_linesizes(dst_linesize, pix_fmt, width)) < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < 4; i++)\n\n        dst_linesize[i] = FFALIGN(dst_linesize[i], align);\n\n\n\n    if ((ret = av_image_fill_pointers(dst_data, pix_fmt, width, NULL, dst_linesize)) < 0)\n\n        return ret;\n\n\n\n    return av_image_fill_pointers(dst_data, pix_fmt, height, (uint8_t *)src, dst_linesize);\n\n}\n", "idx": 20017}
{"project": "FFmpeg", "commit_id": "271344377a3391c1a8ccc45e021721a56f237612", "target": 1, "func": "static int mov_read_extradata(MOVContext *c, ByteIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st = c->fc->streams[c->fc->nb_streams-1];\n\n    uint64_t size= (uint64_t)st->codec->extradata_size + atom.size + 8 + FF_INPUT_BUFFER_PADDING_SIZE;\n\n    uint8_t *buf;\n\n    if(size > INT_MAX || (uint64_t)atom.size > INT_MAX)\n\n        return -1;\n\n    buf= av_realloc(st->codec->extradata, size);\n\n    if(!buf)\n\n        return -1;\n\n    st->codec->extradata= buf;\n\n    buf+= st->codec->extradata_size;\n\n    st->codec->extradata_size= size - FF_INPUT_BUFFER_PADDING_SIZE;\n\n    AV_WB32(       buf    , atom.size + 8);\n\n    AV_WL32(       buf + 4, atom.type);\n\n    get_buffer(pb, buf + 8, atom.size);\n\n    return 0;\n\n}\n", "idx": 20034}
{"project": "qemu", "commit_id": "576c6eb6700d241c9d4a6883d25720c7bbaaeccd", "target": 1, "func": "int tap_open(char *ifname, int ifname_size, int *vnet_hdr,\n\n             int vnet_hdr_required, int mq_required, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    char  dev[10]=\"\";\n\n    int fd;\n\n    if( (fd = tap_alloc(dev, sizeof(dev))) < 0 ){\n\n       fprintf(stderr, \"Cannot allocate TAP device\\n\");\n\n       return -1;\n\n    }\n\n    pstrcpy(ifname, ifname_size, dev);\n\n    if (*vnet_hdr) {\n\n        /* Solaris doesn't have IFF_VNET_HDR */\n\n        *vnet_hdr = 0;\n\n\n\n        if (vnet_hdr_required && !*vnet_hdr) {\n\n            error_report(\"vnet_hdr=1 requested, but no kernel \"\n\n                         \"support for IFF_VNET_HDR available\");\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    }\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n    return fd;\n\n}\n", "idx": 20036}
{"project": "FFmpeg", "commit_id": "9ecf7fada31aac294dee540abb9a8dcf8131d67d", "target": 1, "func": "static void av_estimate_timings(AVFormatContext *ic)\n\n{\n\n    int64_t file_size;\n\n\n\n    /* get the file size, if possible */\n\n    if (ic->iformat->flags & AVFMT_NOFILE) {\n\n        file_size = 0;\n\n    } else {\n\n        file_size = url_fsize(&ic->pb);\n\n        if (file_size < 0)\n\n            file_size = 0;\n\n    }\n\n    ic->file_size = file_size;\n\n\n\n    if ((!strcmp(ic->iformat->name, \"mpeg\") ||\n\n         !strcmp(ic->iformat->name, \"mpegts\")) &&\n\n        file_size && !ic->pb.is_streamed) {\n\n        /* get accurate estimate from the PTSes */\n\n        av_estimate_timings_from_pts(ic);\n\n    } else if (av_has_timings(ic)) {\n\n        /* at least one components has timings - we use them for all\n\n           the components */\n\n        fill_all_stream_timings(ic);\n\n    } else {\n\n        /* less precise: use bit rate info */\n\n        av_estimate_timings_from_bit_rate(ic);\n\n    }\n\n    av_update_stream_timings(ic);\n\n\n\n#if 0\n\n    {\n\n        int i;\n\n        AVStream *st;\n\n        for(i = 0;i < ic->nb_streams; i++) {\n\n            st = ic->streams[i];\n\n        printf(\"%d: start_time: %0.3f duration: %0.3f\\n\",\n\n               i, (double)st->start_time / AV_TIME_BASE,\n\n               (double)st->duration / AV_TIME_BASE);\n\n        }\n\n        printf(\"stream: start_time: %0.3f duration: %0.3f bitrate=%d kb/s\\n\",\n\n               (double)ic->start_time / AV_TIME_BASE,\n\n               (double)ic->duration / AV_TIME_BASE,\n\n               ic->bit_rate / 1000);\n\n    }\n\n#endif\n\n}\n", "idx": 20040}
{"project": "qemu", "commit_id": "16a9e8a5bcc1fb0796828eb654a4f926734e59af", "target": 0, "func": "static void pc_dimm_plug(HotplugHandler *hotplug_dev,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    HotplugHandlerClass *hhc;\n\n    Error *local_err = NULL;\n\n    PCMachineState *pcms = PC_MACHINE(hotplug_dev);\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(dimm);\n\n    MemoryRegion *mr = ddc->get_memory_region(dimm);\n\n    uint64_t align = TARGET_PAGE_SIZE;\n\n\n\n    if (memory_region_get_alignment(mr) && pcms->enforce_aligned_dimm) {\n\n        align = memory_region_get_alignment(mr);\n\n    }\n\n\n\n    if (!pcms->acpi_dev) {\n\n        error_setg(&local_err,\n\n                   \"memory hotplug is not enabled: missing acpi device\");\n\n        goto out;\n\n    }\n\n\n\n    pc_dimm_memory_plug(dev, &pcms->hotplug_memory, mr, align, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    hhc = HOTPLUG_HANDLER_GET_CLASS(pcms->acpi_dev);\n\n    hhc->plug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, &error_abort);\n\nout:\n\n    error_propagate(errp, local_err);\n\n}\n", "idx": 20060}
{"project": "qemu", "commit_id": "7a2c4b82340d621bff462672b29c88d2020d68c1", "target": 0, "func": "static void cmd_test_unit_ready(IDEState *s, uint8_t *buf)\n\n{\n\n    if (bdrv_is_inserted(s->bs)) {\n\n        ide_atapi_cmd_ok(s);\n\n    } else {\n\n        ide_atapi_cmd_error(s, SENSE_NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n    }\n\n}\n", "idx": 20064}
{"project": "FFmpeg", "commit_id": "436f00b10c062b75c7aab276c4a7d64524bd0444", "target": 0, "func": "static int wrapped_avframe_encode(AVCodecContext *avctx, AVPacket *pkt,\n\n                     const AVFrame *frame, int *got_packet)\n\n{\n\n    AVFrame *wrapped = av_frame_clone(frame);\n\n\n\n    if (!wrapped)\n\n        return AVERROR(ENOMEM);\n\n\n\n    pkt->buf = av_buffer_create((uint8_t *)wrapped, sizeof(*wrapped),\n\n                                wrapped_avframe_release_buffer, NULL,\n\n                                AV_BUFFER_FLAG_READONLY);\n\n    if (!pkt->buf) {\n\n        av_frame_free(&wrapped);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    pkt->data = (uint8_t *)wrapped;\n\n    pkt->size = sizeof(*wrapped);\n\n\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n    return 0;\n\n}\n", "idx": 20067}
{"project": "qemu", "commit_id": "2b147555f78c3c20080b201fd1506467fa0ddf43", "target": 0, "func": "static int kvm_s390_check_enable_cmma(KVMState *s)\n\n{\n\n    struct kvm_device_attr attr = {\n\n        .group = KVM_S390_VM_MEM_CTRL,\n\n        .attr = KVM_S390_VM_MEM_ENABLE_CMMA,\n\n    };\n\n\n\n    return kvm_vm_ioctl(s, KVM_HAS_DEVICE_ATTR, &attr);\n\n}\n", "idx": 20068}
{"project": "qemu", "commit_id": "84007e81814bd1b523eb36b027ef8a84d7f00206", "target": 0, "func": "static int net_host_check_device(const char *device)\n\n{\n\n    int i;\n\n    const char *valid_param_list[] = { \"tap\", \"socket\", \"dump\"\n\n#ifdef CONFIG_NET_BRIDGE\n\n                                       , \"bridge\"\n\n#endif\n\n#ifdef CONFIG_SLIRP\n\n                                       ,\"user\"\n\n#endif\n\n#ifdef CONFIG_VDE\n\n                                       ,\"vde\"\n\n#endif\n\n    };\n\n    for (i = 0; i < ARRAY_SIZE(valid_param_list); i++) {\n\n        if (!strncmp(valid_param_list[i], device,\n\n                     strlen(valid_param_list[i])))\n\n            return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20098}
{"project": "qemu", "commit_id": "5029fe12dccbe261d5bd5bc840110ae48aa112c9", "target": 0, "func": "uint32_t pci_default_read_config(PCIDevice *d,\n\n                                 uint32_t address, int len)\n\n{\n\n    uint32_t val;\n\n\n\n    switch(len) {\n\n    default:\n\n    case 4:\n\n\tif (address <= 0xfc) {\n\n            val = pci_get_long(d->config + address);\n\n\t    break;\n\n\t}\n\n\t/* fall through */\n\n    case 2:\n\n        if (address <= 0xfe) {\n\n            val = pci_get_word(d->config + address);\n\n\t    break;\n\n\t}\n\n\t/* fall through */\n\n    case 1:\n\n        val = pci_get_byte(d->config + address);\n\n        break;\n\n    }\n\n    return val;\n\n}\n", "idx": 20106}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void l2x0_class_init(ObjectClass *klass, void *data)\n\n{\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = l2x0_priv_init;\n\n    dc->vmsd = &vmstate_l2x0;\n\n    dc->no_user = 1;\n\n    dc->props = l2x0_properties;\n\n    dc->reset = l2x0_priv_reset;\n\n}\n", "idx": 20130}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "const char *bdrv_get_format_name(BlockDriverState *bs)\n\n{\n\n    return bs->drv ? bs->drv->format_name : NULL;\n\n}\n", "idx": 20144}
{"project": "FFmpeg", "commit_id": "fefe43ff2c180928348d445abb9696cf2581d953", "target": 1, "func": "static int mov_read_hdlr(MOVContext *c, ByteIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st = c->fc->streams[c->fc->nb_streams-1];\n\n    uint32_t type;\n\n    uint32_t ctype;\n\n\n\n    get_byte(pb); /* version */\n\n    get_be24(pb); /* flags */\n\n\n\n    /* component type */\n\n    ctype = get_le32(pb);\n\n    type = get_le32(pb); /* component subtype */\n\n\n\n    dprintf(c->fc, \"ctype= %c%c%c%c (0x%08x)\\n\", *((char *)&ctype), ((char *)&ctype)[1],\n\n            ((char *)&ctype)[2], ((char *)&ctype)[3], (int) ctype);\n\n    dprintf(c->fc, \"stype= %c%c%c%c\\n\",\n\n            *((char *)&type), ((char *)&type)[1], ((char *)&type)[2], ((char *)&type)[3]);\n\n    if(!ctype)\n\n        c->isom = 1;\n\n    if     (type == MKTAG('v','i','d','e'))\n\n        st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n    else if(type == MKTAG('s','o','u','n'))\n\n        st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n    else if(type == MKTAG('m','1','a',' '))\n\n        st->codec->codec_id = CODEC_ID_MP2;\n\n    else if(type == MKTAG('s','u','b','p')) {\n\n        st->codec->codec_type = CODEC_TYPE_SUBTITLE;\n\n    }\n\n    get_be32(pb); /* component  manufacture */\n\n    get_be32(pb); /* component flags */\n\n    get_be32(pb); /* component flags mask */\n\n\n\n    if(atom.size <= 24)\n\n        return 0; /* nothing left to read */\n\n\n\n    url_fskip(pb, atom.size - (url_ftell(pb) - atom.offset));\n\n    return 0;\n\n}\n", "idx": 20174}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_cryptographic_context(MXFCryptoContext *cryptocontext, ByteIOContext *pb, int tag, int size, UID uid)\n\n{\n\n    if (size != 16)\n\n        return -1;\n\n    if (IS_KLV_KEY(uid, mxf_crypto_source_container_ul))\n\n        get_buffer(pb, cryptocontext->source_container_ul, 16);\n\n    return 0;\n\n}\n", "idx": 20181}
{"project": "qemu", "commit_id": "7f4a930e64b9e69cd340395a7e4f0494aef4fcdd", "target": 1, "func": "static int vhost_user_migration_done(struct vhost_dev *dev, char* mac_addr)\n\n{\n\n    VhostUserMsg msg = { 0 };\n\n    int err;\n\n\n\n    assert(dev->vhost_ops->backend_type == VHOST_BACKEND_TYPE_USER);\n\n\n\n    /* If guest supports GUEST_ANNOUNCE do nothing */\n\n    if (virtio_has_feature(dev->acked_features, VIRTIO_NET_F_GUEST_ANNOUNCE)) {\n\n        return 0;\n\n    }\n\n\n\n    /* if backend supports VHOST_USER_PROTOCOL_F_RARP ask it to send the RARP */\n\n    if (virtio_has_feature(dev->protocol_features,\n\n                           VHOST_USER_PROTOCOL_F_RARP)) {\n\n        msg.request = VHOST_USER_SEND_RARP;\n\n        msg.flags = VHOST_USER_VERSION;\n\n        memcpy((char *)&msg.u64, mac_addr, 6);\n\n        msg.size = sizeof(m.u64);\n\n\n\n        err = vhost_user_write(dev, &msg, NULL, 0);\n\n        return err;\n\n    }\n\n    return -1;\n\n}\n", "idx": 20183}
{"project": "FFmpeg", "commit_id": "2b17c7685fd3ff0bffaf3b45458d4a6283f3935f", "target": 1, "func": "static void assert_file_overwrite(const char *filename)\n\n{\n\n    if (file_overwrite && no_file_overwrite) {\n\n        fprintf(stderr, \"Error, both -y and -n supplied. Exiting.\\n\");\n\n        exit_program(1);\n\n    }\n\n\n\n    if (!file_overwrite &&\n\n        (strchr(filename, ':') == NULL || filename[1] == ':' ||\n\n         av_strstart(filename, \"file:\", NULL))) {\n\n        if (avio_check(filename, 0) == 0) {\n\n            if (stdin_interaction && !no_file_overwrite) {\n\n                fprintf(stderr,\"File '%s' already exists. Overwrite ? [y/N] \", filename);\n\n                fflush(stderr);\n\n                term_exit();\n\n                signal(SIGINT, SIG_DFL);\n\n                if (!read_yesno()) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Not overwriting - exiting\\n\");\n\n                    exit_program(1);\n\n                }\n\n                term_init();\n\n            }\n\n            else {\n\n                av_log(NULL, AV_LOG_FATAL, \"File '%s' already exists. Exiting.\\n\", filename);\n\n                exit_program(1);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 20184}
{"project": "qemu", "commit_id": "2ee4aed86ff2ba38a0e1846de18a9aec38d73015", "target": 0, "func": "void do_tlbwr (void)\n\n{\n\n    int r = cpu_mips_get_random(env);\n\n\n\n    invalidate_tlb(r, 1);\n\n    fill_tlb(r);\n\n}\n", "idx": 20204}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static void raw_close(BlockDriverState *bs)\n\n{\n\n}\n", "idx": 20214}
{"project": "qemu", "commit_id": "1e39d97af086d525cd0408eaa5d19783ea165906", "target": 0, "func": "static void gen_interrupt(DisasContext *s, int intno,\n\n                          target_ulong cur_eip, target_ulong next_eip)\n\n{\n\n    gen_update_cc_op(s);\n\n    gen_jmp_im(cur_eip);\n\n    gen_helper_raise_interrupt(cpu_env, tcg_const_i32(intno),\n\n                               tcg_const_i32(next_eip - cur_eip));\n\n    s->is_jmp = DISAS_TB_JUMP;\n\n}\n", "idx": 20222}
{"project": "qemu", "commit_id": "de00982e9e14e2d6ba3d148f02c5a1e94deaa985", "target": 0, "func": "static uint32_t platform_mmio_read(ReadWriteHandler *handler, pcibus_t addr, int len)\n\n{\n\n    DPRINTF(\"Warning: attempted read from physical address \"\n\n            \"0x\" TARGET_FMT_plx \" in xen platform mmio space\\n\", addr);\n\n\n\n    return 0;\n\n}\n", "idx": 20240}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_sparc_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n\n                              int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong virt_addr, vaddr;\n\n    target_phys_addr_t paddr;\n\n    int error_code = 0, prot, ret = 0, access_index;\n\n\n\n    error_code = get_physical_address(env, &paddr, &prot, &access_index,\n\n                                      address, rw, mmu_idx);\n\n    if (error_code == 0) {\n\n        virt_addr = address & TARGET_PAGE_MASK;\n\n        vaddr = virt_addr + ((address & TARGET_PAGE_MASK) &\n\n                             (TARGET_PAGE_SIZE - 1));\n\n#ifdef DEBUG_MMU\n\n        printf(\"Translate at 0x%\" PRIx64 \" -> 0x%\" PRIx64 \", vaddr 0x%\" PRIx64\n\n               \"\\n\", address, paddr, vaddr);\n\n#endif\n\n        ret = tlb_set_page_exec(env, vaddr, paddr, prot, mmu_idx, is_softmmu);\n\n        return ret;\n\n    }\n\n    // XXX\n\n    return 1;\n\n}\n", "idx": 20241}
{"project": "FFmpeg", "commit_id": "182d4f1f3855460ee8634ea052f33332cf9d174e", "target": 0, "func": "static av_cold int oggvorbis_init_encoder(vorbis_info *vi,\n\n                                          AVCodecContext *avctx)\n\n{\n\n    OggVorbisContext *s = avctx->priv_data;\n\n    double cfreq;\n\n    int ret;\n\n\n\n    if (avctx->flags & CODEC_FLAG_QSCALE) {\n\n        /* variable bitrate\n\n         * NOTE: we use the oggenc range of -1 to 10 for global_quality for\n\n         *       user convenience, but libvorbis uses -0.1 to 1.0\n\n         */\n\n        float q = avctx->global_quality / (float)FF_QP2LAMBDA;\n\n        if ((ret = vorbis_encode_setup_vbr(vi, avctx->channels,\n\n                                           avctx->sample_rate,\n\n                                           q / 10.0)))\n\n            goto error;\n\n    } else {\n\n        int minrate = avctx->rc_min_rate > 0 ? avctx->rc_min_rate : -1;\n\n        int maxrate = avctx->rc_min_rate > 0 ? avctx->rc_max_rate : -1;\n\n\n\n        /* average bitrate */\n\n        if ((ret = vorbis_encode_setup_managed(vi, avctx->channels,\n\n                                               avctx->sample_rate, minrate,\n\n                                               avctx->bit_rate, maxrate)))\n\n            goto error;\n\n\n\n        /* variable bitrate by estimate, disable slow rate management */\n\n        if (minrate == -1 && maxrate == -1)\n\n            if ((ret = vorbis_encode_ctl(vi, OV_ECTL_RATEMANAGE2_SET, NULL)))\n\n                goto error;\n\n    }\n\n\n\n    /* cutoff frequency */\n\n    if (avctx->cutoff > 0) {\n\n        cfreq = avctx->cutoff / 1000.0;\n\n        if ((ret = vorbis_encode_ctl(vi, OV_ECTL_LOWPASS_SET, &cfreq)))\n\n            goto error;\n\n    }\n\n\n\n    /* impulse block bias */\n\n    if (s->iblock) {\n\n        if ((ret = vorbis_encode_ctl(vi, OV_ECTL_IBLOCK_SET, &s->iblock)))\n\n            goto error;\n\n    }\n\n\n\n    if ((ret = vorbis_encode_setup_init(vi)))\n\n        goto error;\n\n\n\n    return 0;\n\nerror:\n\n    return vorbis_error_to_averror(ret);\n\n}\n", "idx": 20243}
{"project": "qemu", "commit_id": "715c54071a43ab978dc12b9da22a5016203ed284", "target": 0, "func": "static int htab_save_setup(QEMUFile *f, void *opaque)\n\n{\n\n    sPAPRMachineState *spapr = opaque;\n\n\n\n    /* \"Iteration\" header */\n\n    qemu_put_be32(f, spapr->htab_shift);\n\n\n\n    if (spapr->htab) {\n\n        spapr->htab_save_index = 0;\n\n        spapr->htab_first_pass = true;\n\n    } else {\n\n        assert(kvm_enabled());\n\n\n\n        spapr->htab_fd = kvmppc_get_htab_fd(false);\n\n        spapr->htab_fd_stale = false;\n\n        if (spapr->htab_fd < 0) {\n\n            fprintf(stderr, \"Unable to open fd for reading hash table from KVM: %s\\n\",\n\n                    strerror(errno));\n\n            return -1;\n\n        }\n\n    }\n\n\n\n\n\n    return 0;\n\n}\n", "idx": 20366}
{"project": "qemu", "commit_id": "79ca616f291124d166ca173e512c4ace1c2fe8b2", "target": 0, "func": "int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)\n\n{\n\n    int dom, pci_bus;\n\n    unsigned slot;\n\n    PCIDevice *dev;\n\n    const char *pci_addr = qdict_get_str(qdict, \"pci_addr\");\n\n\n\n    switch (dinfo->type) {\n\n    case IF_SCSI:\n\n        if (pci_read_devaddr(mon, pci_addr, &dom, &pci_bus, &slot)) {\n\n            goto err;\n\n        }\n\n        dev = pci_find_device(pci_find_root_bus(dom), pci_bus,\n\n                              PCI_DEVFN(slot, 0));\n\n        if (!dev) {\n\n            monitor_printf(mon, \"no pci device with address %s\\n\", pci_addr);\n\n            goto err;\n\n        }\n\n        if (scsi_hot_add(mon, &dev->qdev, dinfo, 1) != 0) {\n\n            goto err;\n\n        }\n\n        break;\n\n    default:\n\n        monitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\n\n        goto err;\n\n    }\n\n\n\n    return 0;\n\nerr:\n\n    return -1;\n\n}\n", "idx": 20367}
{"project": "FFmpeg", "commit_id": "d1b284119bd5c6a52124443de2c45dbe569c25fc", "target": 0, "func": "static int read_ir(AVFilterLink *link, AVFrame *frame)\n\n{\n\n    AVFilterContext *ctx = link->dst;\n\n    AudioFIRContext *s = ctx->priv;\n\n    int nb_taps, max_nb_taps;\n\n\n\n    av_audio_fifo_write(s->fifo[1], (void **)frame->extended_data,\n\n                        frame->nb_samples);\n\n    av_frame_free(&frame);\n\n\n\n    nb_taps = av_audio_fifo_size(s->fifo[1]);\n\n    max_nb_taps = MAX_IR_DURATION * ctx->outputs[0]->sample_rate;\n\n    if (nb_taps > max_nb_taps) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Too big number of coefficients: %d > %d.\\n\", nb_taps, max_nb_taps);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20385}
{"project": "qemu", "commit_id": "ba41249678f8c1504bf07706ddb0eda0d36cccc2", "target": 0, "func": "void cpu_loop(CPUSH4State *env)\n\n{\n\n    CPUState *cs = CPU(sh_env_get_cpu(env));\n\n    int trapnr, ret;\n\n    target_siginfo_t info;\n\n\n\n    while (1) {\n\n        cpu_exec_start(cs);\n\n        trapnr = cpu_sh4_exec(cs);\n\n        cpu_exec_end(cs);\n\n\n\n        switch (trapnr) {\n\n        case 0x160:\n\n            env->pc += 2;\n\n            ret = do_syscall(env,\n\n                             env->gregs[3],\n\n                             env->gregs[4],\n\n                             env->gregs[5],\n\n                             env->gregs[6],\n\n                             env->gregs[7],\n\n                             env->gregs[0],\n\n                             env->gregs[1],\n\n                             0, 0);\n\n            env->gregs[0] = ret;\n\n            break;\n\n        case EXCP_INTERRUPT:\n\n            /* just indicate that signals should be handled asap */\n\n            break;\n\n        case EXCP_DEBUG:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig(cs, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n                  }\n\n            }\n\n            break;\n\n\tcase 0xa0:\n\n\tcase 0xc0:\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            info.si_code = TARGET_SEGV_MAPERR;\n\n            info._sifields._sigfault._addr = env->tea;\n\n            queue_signal(env, info.si_signo, &info);\n\n\t    break;\n\n\n\n        default:\n\n            printf (\"Unhandled trap: 0x%x\\n\", trapnr);\n\n            cpu_dump_state(cs, stderr, fprintf, 0);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n        process_pending_signals (env);\n\n    }\n\n}\n", "idx": 20395}
{"project": "qemu", "commit_id": "7385aed20db5d83979f683b9d0048674411e963c", "target": 0, "func": "static inline void gen_op_fcmps(int fccno, TCGv r_rs1, TCGv r_rs2)\n\n{\n\n    gen_helper_fcmps(cpu_env, r_rs1, r_rs2);\n\n}\n", "idx": 20402}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static void set_sigp_status(SigpInfo *si, uint64_t status)\n\n{\n\n    *si->status_reg &= 0xffffffff00000000ULL;\n\n    *si->status_reg |= status;\n\n    si->cc = SIGP_CC_STATUS_STORED;\n\n}\n", "idx": 20403}
{"project": "qemu", "commit_id": "36b15c79aa1bef5fe7543f9f2629b6413720bbfb", "target": 0, "func": "static VirtIOSCSIReq *virtio_scsi_pop_req(VirtIOSCSI *s, VirtQueue *vq)\n\n{\n\n    VirtIOSCSIReq *req;\n\n    req = g_malloc(sizeof(*req));\n\n    if (!virtqueue_pop(vq, &req->elem)) {\n\n        g_free(req);\n\n        return NULL;\n\n    }\n\n\n\n    virtio_scsi_parse_req(s, vq, req);\n\n    return req;\n\n}\n", "idx": 20407}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void OPPROTO op_divb_AL_T0(void)\n\n{\n\n    unsigned int num, den, q, r;\n\n\n\n    num = (EAX & 0xffff);\n\n    den = (T0 & 0xff);\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n    q = (num / den) & 0xff;\n\n    r = (num % den) & 0xff;\n\n    EAX = (EAX & ~0xffff) | (r << 8) | q;\n\n}\n", "idx": 20417}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_bgu(TCGv dst, TCGv_i32 src)\n\n{\n\n    gen_mov_reg_Z(cpu_tmp0, src);\n\n    gen_mov_reg_C(dst, src);\n\n    tcg_gen_or_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 20436}
{"project": "qemu", "commit_id": "ab06ec43577177a442e8e5ca28d0154efe4ff60f", "target": 0, "func": "static void test_pxe_virtio_pci(void)\n\n{\n\n    test_pxe_one(\"-device virtio-net-pci,netdev=\" NETNAME, false);\n\n}\n", "idx": 20444}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_add_data_offset(DisasContext *s, unsigned int insn,\n\n                                       TCGv var)\n\n{\n\n    int val, rm, shift, shiftop;\n\n    TCGv offset;\n\n\n\n    if (!(insn & (1 << 25))) {\n\n        /* immediate */\n\n        val = insn & 0xfff;\n\n        if (!(insn & (1 << 23)))\n\n            val = -val;\n\n        if (val != 0)\n\n            tcg_gen_addi_i32(var, var, val);\n\n    } else {\n\n        /* shift/register */\n\n        rm = (insn) & 0xf;\n\n        shift = (insn >> 7) & 0x1f;\n\n        shiftop = (insn >> 5) & 3;\n\n        offset = load_reg(s, rm);\n\n        gen_arm_shift_im(offset, shiftop, shift, 0);\n\n        if (!(insn & (1 << 23)))\n\n            tcg_gen_sub_i32(var, var, offset);\n\n        else\n\n            tcg_gen_add_i32(var, var, offset);\n\n        dead_tmp(offset);\n\n    }\n\n}\n", "idx": 20478}
{"project": "qemu", "commit_id": "fdfab37dfeffefbd4533b4158055c9b82d7c3e69", "target": 0, "func": "static int count_contiguous_clusters(int nb_clusters, int cluster_size,\n\n        uint64_t *l2_table, uint64_t stop_flags)\n\n{\n\n    int i;\n\n    QCow2ClusterType first_cluster_type;\n\n    uint64_t mask = stop_flags | L2E_OFFSET_MASK | QCOW_OFLAG_COMPRESSED;\n\n    uint64_t first_entry = be64_to_cpu(l2_table[0]);\n\n    uint64_t offset = first_entry & mask;\n\n\n\n    if (!offset) {\n\n        return 0;\n\n    }\n\n\n\n    /* must be allocated */\n\n    first_cluster_type = qcow2_get_cluster_type(first_entry);\n\n    assert(first_cluster_type == QCOW2_CLUSTER_NORMAL ||\n\n           (first_cluster_type == QCOW2_CLUSTER_ZERO &&\n\n            (first_entry & L2E_OFFSET_MASK) != 0));\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t l2_entry = be64_to_cpu(l2_table[i]) & mask;\n\n        if (offset + (uint64_t) i * cluster_size != l2_entry) {\n\n            break;\n\n        }\n\n    }\n\n\n\n\treturn i;\n\n}\n", "idx": 20497}
{"project": "qemu", "commit_id": "d20423788e3a3d5f6a2aad8315779bf3f952ca36", "target": 0, "func": "static inline int name_to_handle(int dirfd, const char *name,\n\n                                 struct file_handle *fh, int *mnt_id, int flags)\n\n{\n\n    return syscall(__NR_name_to_handle_at, dirfd, name, fh, mnt_id, flags);\n\n}\n", "idx": 20530}
{"project": "qemu", "commit_id": "4fc9af53d88c0a2a810704a06cb39a7182982e4e", "target": 0, "func": "static void generate_bootsect(uint32_t gpr[8], uint16_t segs[6], uint16_t ip)\n\n{\n\n    uint8_t bootsect[512], *p;\n\n    int i;\n\n    int hda;\n\n\n\n    hda = drive_get_index(IF_IDE, 0, 0);\n\n    if (hda == -1) {\n\n\tfprintf(stderr, \"A disk image must be given for 'hda' when booting \"\n\n\t\t\"a Linux kernel\\n(if you really don't want it, use /dev/zero)\\n\");\n\n\texit(1);\n\n    }\n\n\n\n    memset(bootsect, 0, sizeof(bootsect));\n\n\n\n    /* Copy the MSDOS partition table if possible */\n\n    bdrv_read(drives_table[hda].bdrv, 0, bootsect, 1);\n\n\n\n    /* Make sure we have a partition signature */\n\n    bootsect[510] = 0x55;\n\n    bootsect[511] = 0xaa;\n\n\n\n    /* Actual code */\n\n    p = bootsect;\n\n    *p++ = 0xfa;\t\t/* CLI */\n\n    *p++ = 0xfc;\t\t/* CLD */\n\n\n\n    for (i = 0; i < 6; i++) {\n\n\tif (i == 1)\t\t/* Skip CS */\n\n\t    continue;\n\n\n\n\t*p++ = 0xb8;\t\t/* MOV AX,imm16 */\n\n\t*p++ = segs[i];\n\n\t*p++ = segs[i] >> 8;\n\n\t*p++ = 0x8e;\t\t/* MOV <seg>,AX */\n\n\t*p++ = 0xc0 + (i << 3);\n\n    }\n\n\n\n    for (i = 0; i < 8; i++) {\n\n\t*p++ = 0x66;\t\t/* 32-bit operand size */\n\n\t*p++ = 0xb8 + i;\t/* MOV <reg>,imm32 */\n\n\t*p++ = gpr[i];\n\n\t*p++ = gpr[i] >> 8;\n\n\t*p++ = gpr[i] >> 16;\n\n\t*p++ = gpr[i] >> 24;\n\n    }\n\n\n\n    *p++ = 0xea;\t\t/* JMP FAR */\n\n    *p++ = ip;\t\t\t/* IP */\n\n    *p++ = ip >> 8;\n\n    *p++ = segs[1];\t\t/* CS */\n\n    *p++ = segs[1] >> 8;\n\n\n\n    bdrv_set_boot_sector(drives_table[hda].bdrv, bootsect, sizeof(bootsect));\n\n}\n", "idx": 20532}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline int blah (int32_t i)\n\n{\n\n    if (i > 0x43c07fff)\n\n        return 32767;\n\n    else if (i < 0x43bf8000)\n\n        return -32768;\n\n    else\n\n        return i - 0x43c00000;\n\n}\n", "idx": 20536}
{"project": "qemu", "commit_id": "5905fbc9c94ccd744c1b249472eafcc2d827548a", "target": 0, "func": "static bool bdrv_exceed_bps_limits(BlockDriverState *bs, int nb_sectors,\n\n                 bool is_write, double elapsed_time, uint64_t *wait)\n\n{\n\n    uint64_t bps_limit = 0;\n\n    double   bytes_limit, bytes_base, bytes_res;\n\n    double   slice_time, wait_time;\n\n\n\n    if (bs->io_limits.bps[BLOCK_IO_LIMIT_TOTAL]) {\n\n        bps_limit = bs->io_limits.bps[BLOCK_IO_LIMIT_TOTAL];\n\n    } else if (bs->io_limits.bps[is_write]) {\n\n        bps_limit = bs->io_limits.bps[is_write];\n\n    } else {\n\n        if (wait) {\n\n            *wait = 0;\n\n        }\n\n\n\n        return false;\n\n    }\n\n\n\n    slice_time = bs->slice_end - bs->slice_start;\n\n    slice_time /= (NANOSECONDS_PER_SECOND);\n\n    bytes_limit = bps_limit * slice_time;\n\n    bytes_base  = bs->nr_bytes[is_write] - bs->io_base.bytes[is_write];\n\n    if (bs->io_limits.bps[BLOCK_IO_LIMIT_TOTAL]) {\n\n        bytes_base += bs->nr_bytes[!is_write] - bs->io_base.bytes[!is_write];\n\n    }\n\n\n\n    /* bytes_base: the bytes of data which have been read/written; and\n\n     *             it is obtained from the history statistic info.\n\n     * bytes_res: the remaining bytes of data which need to be read/written.\n\n     * (bytes_base + bytes_res) / bps_limit: used to calcuate\n\n     *             the total time for completing reading/writting all data.\n\n     */\n\n    bytes_res   = (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\n\n    if (bytes_base + bytes_res <= bytes_limit) {\n\n        if (wait) {\n\n            *wait = 0;\n\n        }\n\n\n\n        return false;\n\n    }\n\n\n\n    /* Calc approx time to dispatch */\n\n    wait_time = (bytes_base + bytes_res) / bps_limit - elapsed_time;\n\n\n\n    /* When the I/O rate at runtime exceeds the limits,\n\n     * bs->slice_end need to be extended in order that the current statistic\n\n     * info can be kept until the timer fire, so it is increased and tuned\n\n     * based on the result of experiment.\n\n     */\n\n    bs->slice_time = wait_time * BLOCK_IO_SLICE_TIME * 10;\n\n    bs->slice_end += bs->slice_time - 3 * BLOCK_IO_SLICE_TIME;\n\n    if (wait) {\n\n        *wait = wait_time * BLOCK_IO_SLICE_TIME * 10;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 20557}
{"project": "FFmpeg", "commit_id": "fbd91d7cad28915dd7e6061b869b22171ca84101", "target": 1, "func": "static int decode_tns(AACContext * ac, TemporalNoiseShaping * tns,\n\n        GetBitContext * gb, const IndividualChannelStream * ics) {\n\n    int w, filt, i, coef_len, coef_res, coef_compress;\n\n    const int is8 = ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE;\n\n    const int tns_max_order = is8 ? 7 : ac->m4ac.object_type == AOT_AAC_MAIN ? 20 : 12;\n\n    for (w = 0; w < ics->num_windows; w++) {\n\n        tns->n_filt[w] = get_bits(gb, 2 - is8);\n\n\n\n        if (tns->n_filt[w])\n\n            coef_res = get_bits1(gb);\n\n\n\n        for (filt = 0; filt < tns->n_filt[w]; filt++) {\n\n            int tmp2_idx;\n\n            tns->length[w][filt] = get_bits(gb, 6 - 2*is8);\n\n\n\n            if ((tns->order[w][filt] = get_bits(gb, 5 - 2*is8)) > tns_max_order) {\n\n                av_log(ac->avccontext, AV_LOG_ERROR, \"TNS filter order %d is greater than maximum %d.\",\n\n                       tns->order[w][filt], tns_max_order);\n\n                tns->order[w][filt] = 0;\n\n                return -1;\n\n            }\n\n            tns->direction[w][filt] = get_bits1(gb);\n\n            coef_compress = get_bits1(gb);\n\n            coef_len = coef_res + 3 - coef_compress;\n\n            tmp2_idx = 2*coef_compress + coef_res;\n\n\n\n            for (i = 0; i < tns->order[w][filt]; i++)\n\n                tns->coef[w][filt][i] = tns_tmp2_map[tmp2_idx][get_bits(gb, coef_len)];\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 20596}
{"project": "qemu", "commit_id": "e04fb07fd1676e9facd7f3f878c1bbe03bccd26b", "target": 1, "func": "static void qemu_rbd_aio_event_reader(void *opaque)\n\n{\n\n    BDRVRBDState *s = opaque;\n\n\n\n    ssize_t ret;\n\n\n\n    do {\n\n        char *p = (char *)&s->event_rcb;\n\n\n\n        /* now read the rcb pointer that was sent from a non qemu thread */\n\n        ret = read(s->fds[RBD_FD_READ], p + s->event_reader_pos,\n\n                   sizeof(s->event_rcb) - s->event_reader_pos);\n\n        if (ret > 0) {\n\n            s->event_reader_pos += ret;\n\n            if (s->event_reader_pos == sizeof(s->event_rcb)) {\n\n                s->event_reader_pos = 0;\n\n                qemu_rbd_complete_aio(s->event_rcb);\n\n            }\n\n        }\n\n    } while (ret < 0 && errno == EINTR);\n\n}\n", "idx": 20657}
{"project": "FFmpeg", "commit_id": "ecf79c4d3e8baaf2f303278ef81db6f8407656bc", "target": 1, "func": "void ff_vorbis_ready_floor1_list(vorbis_floor1_entry * list, int values)\n\n{\n\n    int i;\n\n    list[0].sort = 0;\n\n    list[1].sort = 1;\n\n    for (i = 2; i < values; i++) {\n\n        int j;\n\n        list[i].low  = 0;\n\n        list[i].high = 1;\n\n        list[i].sort = i;\n\n        for (j = 2; j < i; j++) {\n\n            int tmp = list[j].x;\n\n            if (tmp < list[i].x) {\n\n                if (tmp > list[list[i].low].x)\n\n                    list[i].low  =  j;\n\n            } else {\n\n                if (tmp < list[list[i].high].x)\n\n                    list[i].high = j;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < values - 1; i++) {\n\n        int j;\n\n        for (j = i + 1; j < values; j++) {\n\n            if (list[list[i].sort].x > list[list[j].sort].x) {\n\n                int tmp = list[i].sort;\n\n                list[i].sort = list[j].sort;\n\n                list[j].sort = tmp;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 20670}
{"project": "qemu", "commit_id": "2db59a76c421cdd1039d10e32a9798952d3ff5ba", "target": 1, "func": "static void gen_wsr_windowbase(DisasContext *dc, uint32_t sr, TCGv_i32 v)\n\n{\n\n    gen_helper_wsr_windowbase(cpu_env, v);\n\n    reset_used_window(dc);\n\n}\n", "idx": 20676}
{"project": "qemu", "commit_id": "06a1307379fcd6c551185ad87679cd7ed896b9ea", "target": 1, "func": "static void virtio_pci_exit(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev);\n\n    virtio_pci_stop_ioeventfd(proxy);\n\n    memory_region_destroy(&proxy->bar);\n\n    msix_uninit_exclusive_bar(pci_dev);\n\n}\n", "idx": 20692}
{"project": "FFmpeg", "commit_id": "8babfc033ecb6332155c1f8879e54dee41d16952", "target": 1, "func": "static av_cold void init_cavlc_level_tab(void){\n\n    int suffix_length, mask;\n\n    unsigned int i;\n\n\n\n    for(suffix_length=0; suffix_length<7; suffix_length++){\n\n        for(i=0; i<(1<<LEVEL_TAB_BITS); i++){\n\n            int prefix= LEVEL_TAB_BITS - av_log2(2*i);\n\n            int level_code= (prefix<<suffix_length) + (i>>(LEVEL_TAB_BITS-prefix-1-suffix_length)) - (1<<suffix_length);\n\n\n\n            mask= -(level_code&1);\n\n            level_code= (((2+level_code)>>1) ^ mask) - mask;\n\n            if(prefix + 1 + suffix_length <= LEVEL_TAB_BITS){\n\n                cavlc_level_tab[suffix_length][i][0]= level_code;\n\n                cavlc_level_tab[suffix_length][i][1]= prefix + 1 + suffix_length;\n\n            }else if(prefix + 1 <= LEVEL_TAB_BITS){\n\n                cavlc_level_tab[suffix_length][i][0]= prefix+100;\n\n                cavlc_level_tab[suffix_length][i][1]= prefix + 1;\n\n            }else{\n\n                cavlc_level_tab[suffix_length][i][0]= LEVEL_TAB_BITS+100;\n\n                cavlc_level_tab[suffix_length][i][1]= LEVEL_TAB_BITS;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 20712}
{"project": "FFmpeg", "commit_id": "ce7098b8f2b59c62b5abdb3d74819db75cf67698", "target": 1, "func": "static void yuv_a_to_rgba(const uint8_t *ycbcr, const uint8_t *alpha, uint32_t *rgba, int num_values)\n\n{\n\n    const uint8_t *cm = ff_crop_tab + MAX_NEG_CROP;\n\n    uint8_t r, g, b;\n\n    int i, y, cb, cr;\n\n    int r_add, g_add, b_add;\n\n\n\n    for (i = num_values; i > 0; i--) {\n\n        y = *ycbcr++;\n\n        cr = *ycbcr++;\n\n        cb = *ycbcr++;\n\n        YUV_TO_RGB1_CCIR(cb, cr);\n\n        YUV_TO_RGB2_CCIR(r, g, b, y);\n\n        *rgba++ = (*alpha++ << 24) | (r << 16) | (g << 8) | b;\n\n    }\n\n}\n", "idx": 20720}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "func": "static void gen_stf_asi(DisasContext *dc, TCGv addr,\n\n                        int insn, int size, int rd)\n\n{\n\n    TCGv_i32 r_asi, r_size, r_rd;\n\n\n\n    r_asi = gen_get_asi(dc, insn);\n\n    r_size = tcg_const_i32(size);\n\n    r_rd = tcg_const_i32(rd);\n\n    gen_helper_stf_asi(cpu_env, addr, r_asi, r_size, r_rd);\n\n    tcg_temp_free_i32(r_rd);\n\n    tcg_temp_free_i32(r_size);\n\n    tcg_temp_free_i32(r_asi);\n\n}\n", "idx": 20726}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static int kvm_arch_set_tsc_khz(CPUState *cs)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    int r;\n\n\n\n    if (!env->tsc_khz) {\n\n        return 0;\n\n    }\n\n\n\n    r = kvm_check_extension(cs->kvm_state, KVM_CAP_TSC_CONTROL) ?\n\n        kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :\n\n        -ENOTSUP;\n\n    if (r < 0) {\n\n        /* When KVM_SET_TSC_KHZ fails, it's an error only if the current\n\n         * TSC frequency doesn't match the one we want.\n\n         */\n\n        int cur_freq = kvm_check_extension(cs->kvm_state, KVM_CAP_GET_TSC_KHZ) ?\n\n                       kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) :\n\n                       -ENOTSUP;\n\n        if (cur_freq <= 0 || cur_freq != env->tsc_khz) {\n\n            error_report(\"warning: TSC frequency mismatch between \"\n\n                         \"VM (%\" PRId64 \" kHz) and host (%d kHz), \"\n\n                         \"and TSC scaling unavailable\",\n\n                         env->tsc_khz, cur_freq);\n\n            return r;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 20744}
{"project": "FFmpeg", "commit_id": "d6737539e77e78fca9a04914d51996cfd1ccc55c", "target": 0, "func": "static void intra_predict_mad_cow_dc_0l0_8x8_msa(uint8_t *src, int32_t stride)\n\n{\n\n    uint8_t lp_cnt;\n\n    uint32_t src0 = 0;\n\n    uint64_t out0, out1;\n\n\n\n    for (lp_cnt = 0; lp_cnt < 4; lp_cnt++) {\n\n        src0 += src[(4 + lp_cnt) * stride - 1];\n\n    }\n\n\n\n    src0 = (src0 + 2) >> 2;\n\n\n\n    out0 = 0x8080808080808080;\n\n    out1 = src0 * 0x0101010101010101;\n\n\n\n    for (lp_cnt = 4; lp_cnt--;) {\n\n        SD(out0, src);\n\n        SD(out1, src + stride * 4);\n\n        src += stride;\n\n    }\n\n}\n", "idx": 20773}
{"project": "FFmpeg", "commit_id": "7b94df232a4b76c44e243e618573f8d331a1eb1c", "target": 0, "func": "static void srt_to_ass(AVCodecContext *avctx, AVBPrint *dst,\n\n                       const char *in, int x1, int y1, int x2, int y2)\n\n{\n\n    if (x1 >= 0 && y1 >= 0) {\n\n        /* XXX: here we rescale coordinate assuming they are in DVD resolution\n\n         * (720x480) since we don't have anything better */\n\n\n\n        if (x2 >= 0 && y2 >= 0 && (x2 != x1 || y2 != y1) && x2 >= x1 && y2 >= y1) {\n\n            /* text rectangle defined, write the text at the center of the rectangle */\n\n            const int cx = x1 + (x2 - x1)/2;\n\n            const int cy = y1 + (y2 - y1)/2;\n\n            const int scaled_x = cx * (int64_t)ASS_DEFAULT_PLAYRESX / 720;\n\n            const int scaled_y = cy * (int64_t)ASS_DEFAULT_PLAYRESY / 480;\n\n            av_bprintf(dst, \"{\\\\an5}{\\\\pos(%d,%d)}\", scaled_x, scaled_y);\n\n        } else {\n\n            /* only the top left corner, assume the text starts in that corner */\n\n            const int scaled_x = x1 * (int64_t)ASS_DEFAULT_PLAYRESX / 720;\n\n            const int scaled_y = y1 * (int64_t)ASS_DEFAULT_PLAYRESY / 480;\n\n            av_bprintf(dst, \"{\\\\an1}{\\\\pos(%d,%d)}\", scaled_x, scaled_y);\n\n        }\n\n    }\n\n\n\n    ff_htmlmarkup_to_ass(avctx, dst, in);\n\n}\n", "idx": 20777}
{"project": "FFmpeg", "commit_id": "161ccdaa06d1d109e8f77d2535bda11ce02720f5", "target": 0, "func": "static int msvideo1_decode_frame(AVCodecContext *avctx,\n\n                                void *data, int *got_frame,\n\n                                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    Msvideo1Context *s = avctx->priv_data;\n\n    int ret;\n\n\n\n    s->buf = buf;\n\n    s->size = buf_size;\n\n\n\n    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n\n        return ret;\n\n\n\n    if (s->mode_8bit) {\n\n        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n\n\n\n        if (pal) {\n\n            memcpy(s->pal, pal, AVPALETTE_SIZE);\n\n            s->frame->palette_has_changed = 1;\n\n        }\n\n    }\n\n\n\n    if (s->mode_8bit)\n\n        msvideo1_decode_8bit(s);\n\n    else\n\n        msvideo1_decode_16bit(s);\n\n\n\n    if ((ret = av_frame_ref(data, s->frame)) < 0)\n\n        return ret;\n\n\n\n    *got_frame      = 1;\n\n\n\n    /* report that the buffer was completely consumed */\n\n    return buf_size;\n\n}\n", "idx": 20779}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "pvscsi_realizefn(PCIDevice *pci_dev, Error **errp)\n\n{\n\n    PVSCSIState *s = PVSCSI(pci_dev);\n\n\n\n    trace_pvscsi_state(\"init\");\n\n\n\n    /* PCI subsystem ID, subsystem vendor ID, revision */\n\n    if (PVSCSI_USE_OLD_PCI_CONFIGURATION(s)) {\n\n        pci_set_word(pci_dev->config + PCI_SUBSYSTEM_ID, 0x1000);\n\n    } else {\n\n        pci_set_word(pci_dev->config + PCI_SUBSYSTEM_VENDOR_ID,\n\n                     PCI_VENDOR_ID_VMWARE);\n\n        pci_set_word(pci_dev->config + PCI_SUBSYSTEM_ID,\n\n                     PCI_DEVICE_ID_VMWARE_PVSCSI);\n\n        pci_config_set_revision(pci_dev->config, 0x2);\n\n    }\n\n\n\n    /* PCI latency timer = 255 */\n\n    pci_dev->config[PCI_LATENCY_TIMER] = 0xff;\n\n\n\n    /* Interrupt pin A */\n\n    pci_config_set_interrupt_pin(pci_dev->config, 1);\n\n\n\n    memory_region_init_io(&s->io_space, OBJECT(s), &pvscsi_ops, s,\n\n                          \"pvscsi-io\", PVSCSI_MEM_SPACE_SIZE);\n\n    pci_register_bar(pci_dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->io_space);\n\n\n\n    pvscsi_init_msi(s);\n\n\n\n    if (pci_is_express(pci_dev) && pci_bus_is_express(pci_dev->bus)) {\n\n        pcie_endpoint_cap_init(pci_dev, PVSCSI_EXP_EP_OFFSET);\n\n    }\n\n\n\n    s->completion_worker = qemu_bh_new(pvscsi_process_completion_queue, s);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(pci_dev),\n\n                 &pvscsi_scsi_info, NULL);\n\n    /* override default SCSI bus hotplug-handler, with pvscsi's one */\n\n    qbus_set_hotplug_handler(BUS(&s->bus), DEVICE(s), &error_abort);\n\n    pvscsi_reset_state(s);\n\n}\n", "idx": 20823}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void vde_from_qemu(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    VDEState *s = opaque;\n\n    int ret;\n\n    for(;;) {\n\n        ret = vde_send(s->vde, (const char *)buf, size, 0);\n\n        if (ret < 0 && errno == EINTR) {\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 20826}
{"project": "FFmpeg", "commit_id": "e24c31b656254b2516befbde78aeaca0122a6010", "target": 1, "func": "int ff_dirac_golomb_read_32bit(DiracGolombLUT *lut_ctx, const uint8_t *buf,\n\n                               int bytes, uint8_t *_dst, int coeffs)\n\n{\n\n    int i, b, c_idx = 0;\n\n    int32_t *dst = (int32_t *)_dst;\n\n    DiracGolombLUT *future[4], *l = &lut_ctx[2*LUT_SIZE + buf[0]];\n\n    INIT_RESIDUE(res, 0, 0);\n\n\n\n#define APPEND_RESIDUE(N, M)         \\\n\n    N          |= M >> (N ## _bits); \\\n\n    N ## _bits +=      (M ## _bits)\n\n\n\n    for (b = 1; b <= bytes; b++) {\n\n        future[0] = &lut_ctx[buf[b]];\n\n        future[1] = future[0] + 1*LUT_SIZE;\n\n        future[2] = future[0] + 2*LUT_SIZE;\n\n        future[3] = future[0] + 3*LUT_SIZE;\n\n\n\n        if ((c_idx + 1) > coeffs)\n\n            return c_idx;\n\n\n\n        /* res_bits is a hint for better branch prediction */\n\n        if (res_bits && l->sign) {\n\n            int32_t coeff = 1;\n\n            APPEND_RESIDUE(res, l->preamble);\n\n            for (i = 0; i < (res_bits >> 1) - 1; i++) {\n\n                coeff <<= 1;\n\n                coeff |= (res >> (RSIZE_BITS - 2*i - 2)) & 1;\n\n            }\n\n            dst[c_idx++] = l->sign * (coeff - 1);\n\n            res_bits = res = 0;\n\n        }\n\n\n\n        memcpy(&dst[c_idx], l->ready, LUT_BITS*sizeof(int32_t));\n\n        c_idx += l->ready_num;\n\n\n\n        APPEND_RESIDUE(res, l->leftover);\n\n\n\n        l = future[l->need_s ? 3 : !res_bits ? 2 : res_bits & 1];\n\n    }\n\n\n\n    return c_idx;\n\n}\n", "idx": 20869}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mipsnet_ioport_write(void *opaque, target_phys_addr_t addr,\n\n                                 uint64_t val, unsigned int size)\n\n{\n\n    MIPSnetState *s = opaque;\n\n\n\n    addr &= 0x3f;\n\n    trace_mipsnet_write(addr, val);\n\n    switch (addr) {\n\n    case MIPSNET_TX_DATA_COUNT:\n\n\ts->tx_count = (val <= MAX_ETH_FRAME_SIZE) ? val : 0;\n\n        s->tx_written = 0;\n\n        break;\n\n    case MIPSNET_INT_CTL:\n\n        if (val & MIPSNET_INTCTL_TXDONE) {\n\n            s->intctl &= ~MIPSNET_INTCTL_TXDONE;\n\n        } else if (val & MIPSNET_INTCTL_RXDONE) {\n\n            s->intctl &= ~MIPSNET_INTCTL_RXDONE;\n\n        } else if (val & MIPSNET_INTCTL_TESTBIT) {\n\n            mipsnet_reset(s);\n\n            s->intctl |= MIPSNET_INTCTL_TESTBIT;\n\n        } else if (!val) {\n\n            /* ACK testbit interrupt, flag was cleared on read. */\n\n        }\n\n        s->busy = !!s->intctl;\n\n        mipsnet_update_irq(s);\n\n        break;\n\n    case MIPSNET_TX_DATA_BUFFER:\n\n        s->tx_buffer[s->tx_written++] = val;\n\n        if (s->tx_written == s->tx_count) {\n\n            /* Send buffer. */\n\n            trace_mipsnet_send(s->tx_count);\n\n            qemu_send_packet(&s->nic->nc, s->tx_buffer, s->tx_count);\n\n            s->tx_count = s->tx_written = 0;\n\n            s->intctl |= MIPSNET_INTCTL_TXDONE;\n\n            s->busy = 1;\n\n            mipsnet_update_irq(s);\n\n        }\n\n        break;\n\n    /* Read-only registers */\n\n    case MIPSNET_DEV_ID:\n\n    case MIPSNET_BUSY:\n\n    case MIPSNET_RX_DATA_COUNT:\n\n    case MIPSNET_INTERRUPT_INFO:\n\n    case MIPSNET_RX_DATA_BUFFER:\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 20895}
{"project": "qemu", "commit_id": "90d131fb6504ed12a37dc8433375cc683c30e9da", "target": 0, "func": "mac_writereg(E1000State *s, int index, uint32_t val)\n\n{\n\n    uint32_t macaddr[2];\n\n\n\n    s->mac_reg[index] = val;\n\n\n\n    if (index == RA || index == RA + 1) {\n\n        macaddr[0] = cpu_to_le32(s->mac_reg[RA]);\n\n        macaddr[1] = cpu_to_le32(s->mac_reg[RA + 1]);\n\n        qemu_format_nic_info_str(qemu_get_queue(s->nic), (uint8_t *)macaddr);\n\n    }\n\n}\n", "idx": 20898}
{"project": "qemu", "commit_id": "e2779de053b64f023de382fd87b3596613d47d1e", "target": 0, "func": "static int xen_pt_pmcsr_reg_write(XenPCIPassthroughState *s,\n\n                                  XenPTReg *cfg_entry, uint16_t *val,\n\n                                  uint16_t dev_value, uint16_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint16_t writable_mask = 0;\n\n    uint16_t throughable_mask = get_throughable_mask(s, reg, valid_mask);\n\n\n\n    /* modify emulate register */\n\n    writable_mask = reg->emu_mask & ~reg->ro_mask & valid_mask;\n\n    cfg_entry->data = XEN_PT_MERGE_VALUE(*val, cfg_entry->data, writable_mask);\n\n\n\n    /* create value for writing to I/O device register */\n\n    *val = XEN_PT_MERGE_VALUE(*val, dev_value & ~PCI_PM_CTRL_PME_STATUS,\n\n                              throughable_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 20899}
{"project": "qemu", "commit_id": "c7eb1f02edba91e3eec4682fa1adca877696d11d", "target": 0, "func": "static int net_socket_connect_init(VLANState *vlan,\n\n                                   const char *model,\n\n                                   const char *name,\n\n                                   const char *host_str)\n\n{\n\n    NetSocketState *s;\n\n    int fd, connected, ret, err;\n\n    struct sockaddr_in saddr;\n\n\n\n    if (parse_host_port(&saddr, host_str) < 0)\n\n        return -1;\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n    socket_set_nonblock(fd);\n\n\n\n    connected = 0;\n\n    for(;;) {\n\n        ret = connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n        if (ret < 0) {\n\n            err = socket_error();\n\n            if (err == EINTR || err == EWOULDBLOCK) {\n\n            } else if (err == EINPROGRESS) {\n\n                break;\n\n#ifdef _WIN32\n\n            } else if (err == WSAEALREADY) {\n\n                break;\n\n#endif\n\n            } else {\n\n                perror(\"connect\");\n\n                closesocket(fd);\n\n                return -1;\n\n            }\n\n        } else {\n\n            connected = 1;\n\n            break;\n\n        }\n\n    }\n\n    s = net_socket_fd_init(vlan, model, name, fd, connected);\n\n    if (!s)\n\n        return -1;\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: connect to %s:%d\",\n\n             inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return 0;\n\n}\n", "idx": 20906}
{"project": "qemu", "commit_id": "1f3870ab242018b724b845957f7f928a2d7c1f5b", "target": 0, "func": "static int usb_device_del(const char *devname)\n\n{\n\n    USBPort *port;\n\n    USBPort **lastp;\n\n    USBDevice *dev;\n\n    int bus_num, addr;\n\n    const char *p;\n\n\n\n    if (!used_usb_ports)\n\n        return -1;\n\n\n\n    p = strchr(devname, '.');\n\n    if (!p)\n\n        return -1;\n\n    bus_num = strtoul(devname, NULL, 0);\n\n    addr = strtoul(p + 1, NULL, 0);\n\n    if (bus_num != 0)\n\n        return -1;\n\n\n\n    lastp = &used_usb_ports;\n\n    port = used_usb_ports;\n\n    while (port && port->dev->addr != addr) {\n\n        lastp = &port->next;\n\n        port = port->next;\n\n    }\n\n\n\n    if (!port)\n\n        return -1;\n\n\n\n    dev = port->dev;\n\n    *lastp = port->next;\n\n    usb_attach(port, NULL);\n\n    dev->handle_destroy(dev);\n\n    port->next = free_usb_ports;\n\n    free_usb_ports = port;\n\n    return 0;\n\n}\n", "idx": 20910}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static int drop_sync(QIOChannel *ioc, size_t size, Error **errp)\n\n{\n\n    ssize_t ret = 0;\n\n    char small[1024];\n\n    char *buffer;\n\n\n\n    buffer = sizeof(small) >= size ? small : g_malloc(MIN(65536, size));\n\n    while (size > 0) {\n\n        ssize_t count = MIN(65536, size);\n\n        ret = read_sync(ioc, buffer, MIN(65536, size), errp);\n\n\n\n        if (ret < 0) {\n\n            goto cleanup;\n\n        }\n\n        size -= count;\n\n    }\n\n\n\n cleanup:\n\n    if (buffer != small) {\n\n        g_free(buffer);\n\n    }\n\n    return ret;\n\n}\n", "idx": 20929}
{"project": "qemu", "commit_id": "b78c2b3aad2b42084265c89f93a92733d68e9003", "target": 0, "func": "static void pl061_update(pl061_state *s)\n\n{\n\n    uint8_t changed;\n\n    uint8_t mask;\n\n    uint8_t out;\n\n    int i;\n\n\n\n    /* Outputs float high.  */\n\n    /* FIXME: This is board dependent.  */\n\n    out = (s->data & s->dir) | ~s->dir;\n\n    changed = s->old_data ^ out;\n\n    if (!changed)\n\n        return;\n\n\n\n    s->old_data = out;\n\n    for (i = 0; i < 8; i++) {\n\n        mask = 1 << i;\n\n        if ((changed & mask) && s->out) {\n\n            DPRINTF(\"Set output %d = %d\\n\", i, (out & mask) != 0);\n\n            qemu_set_irq(s->out[i], (out & mask) != 0);\n\n        }\n\n    }\n\n\n\n    /* FIXME: Implement input interrupts.  */\n\n}\n", "idx": 20963}
{"project": "qemu", "commit_id": "8d999995e45c1002aa11f269c98f2e93e6f8c42a", "target": 0, "func": "void gic_set_pending_private(GICState *s, int cpu, int irq)\n\n{\n\n    int cm = 1 << cpu;\n\n\n\n    if (GIC_TEST_PENDING(irq, cm))\n\n        return;\n\n\n\n    DPRINTF(\"Set %d pending cpu %d\\n\", irq, cpu);\n\n    GIC_SET_PENDING(irq, cm);\n\n    gic_update(s);\n\n}\n", "idx": 20981}
{"project": "qemu", "commit_id": "2a1639291bf9f3c88c62d10459fedaa677536ff5", "target": 0, "func": "static uint32_t pxa2xx_pm_read(void *opaque, target_phys_addr_t addr)\n\n{\n\n    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;\n\n    if (addr > s->pm_base + PCMD31) {\n\n        /* Special case: PWRI2C registers appear in the same range.  */\n\n        return pxa2xx_i2c_read(s->i2c[1], addr);\n\n    }\n\n    addr -= s->pm_base;\n\n\n\n    switch (addr) {\n\n    case PMCR ... PCMD31:\n\n        if (addr & 3)\n\n            goto fail;\n\n\n\n        return s->pm_regs[addr >> 2];\n\n    default:\n\n    fail:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 20987}
{"project": "FFmpeg", "commit_id": "03931ecf71710452fc9e89d4f18354f0b5e05395", "target": 0, "func": "static void ssim_4x4x2_core(const uint8_t *main, int main_stride,\n\n                            const uint8_t *ref, int ref_stride,\n\n                            int sums[2][4])\n\n{\n\n    int x, y, z;\n\n\n\n    for (z = 0; z < 2; z++) {\n\n        uint32_t s1 = 0, s2 = 0, ss = 0, s12 = 0;\n\n\n\n        for (y = 0; y < 4; y++) {\n\n            for (x = 0; x < 4; x++) {\n\n                int a = main[x + y * main_stride];\n\n                int b = ref[x + y * ref_stride];\n\n\n\n                s1  += a;\n\n                s2  += b;\n\n                ss  += a*a;\n\n                ss  += b*b;\n\n                s12 += a*b;\n\n            }\n\n        }\n\n\n\n        sums[z][0] = s1;\n\n        sums[z][1] = s2;\n\n        sums[z][2] = ss;\n\n        sums[z][3] = s12;\n\n        main += 4;\n\n        ref += 4;\n\n    }\n\n}\n", "idx": 20992}
{"project": "qemu", "commit_id": "2aece63c8a9d2c3a8ff41d2febc4cdeff2633331", "target": 0, "func": "static void ivshmem_check_memdev_is_busy(Object *obj, const char *name,\n\n                                         Object *val, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(val), &error_abort);\n\n    if (memory_region_is_mapped(mr)) {\n\n        char *path = object_get_canonical_path_component(val);\n\n        error_setg(errp, \"can't use already busy memdev: %s\", path);\n\n        g_free(path);\n\n    } else {\n\n        qdev_prop_allow_set_link_before_realize(obj, name, val, errp);\n\n    }\n\n}\n", "idx": 20997}
{"project": "FFmpeg", "commit_id": "71bd023da5e83e3f65e068d0b12bf5b45050d2d5", "target": 1, "func": "static int seq_parse_frame_data(SeqDemuxContext *seq, ByteIOContext *pb)\n\n{\n\n    unsigned int offset_table[4], buffer_num[4];\n\n    TiertexSeqFrameBuffer *seq_buffer;\n\n    int i, e;\n\n\n\n    seq->current_frame_offs += SEQ_FRAME_SIZE;\n\n    url_fseek(pb, seq->current_frame_offs, SEEK_SET);\n\n\n\n    /* sound data */\n\n    seq->current_audio_data_offs = get_le16(pb);\n\n    if (seq->current_audio_data_offs != 0) {\n\n        seq->current_audio_data_size = SEQ_AUDIO_BUFFER_SIZE * 2;\n\n    } else {\n\n        seq->current_audio_data_size = 0;\n\n    }\n\n\n\n    /* palette data */\n\n    seq->current_pal_data_offs = get_le16(pb);\n\n    if (seq->current_pal_data_offs != 0) {\n\n        seq->current_pal_data_size = 768;\n\n    } else {\n\n        seq->current_pal_data_size = 0;\n\n    }\n\n\n\n    /* video data */\n\n    for (i = 0; i < 4; i++)\n\n        buffer_num[i] = get_byte(pb);\n\n\n\n    for (i = 0; i < 4; i++)\n\n        offset_table[i] = get_le16(pb);\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        if (offset_table[i] != 0) {\n\n            for (e = i + 1; e < 4 && offset_table[e] == 0; e++);\n\n            seq_fill_buffer(seq, pb, buffer_num[1 + i],\n\n              offset_table[i],\n\n              offset_table[e] - offset_table[i]);\n\n        }\n\n    }\n\n\n\n    if (buffer_num[0] != 255) {\n\n        seq_buffer = &seq->frame_buffers[buffer_num[0]];\n\n        seq->current_video_data_size = seq_buffer->fill_size;\n\n        seq->current_video_data_ptr  = seq_buffer->data;\n\n        seq_buffer->fill_size = 0;\n\n    } else {\n\n        seq->current_video_data_size = 0;\n\n        seq->current_video_data_ptr  = 0;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21006}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void fd_chr_close(struct CharDriverState *chr)\n\n{\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    if (s->fd_in_tag) {\n\n        g_source_remove(s->fd_in_tag);\n\n        s->fd_in_tag = 0;\n\n    }\n\n\n\n    if (s->fd_in) {\n\n        g_io_channel_unref(s->fd_in);\n\n    }\n\n    if (s->fd_out) {\n\n        g_io_channel_unref(s->fd_out);\n\n    }\n\n\n\n    g_free(s);\n\n    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);\n\n}\n", "idx": 21008}
{"project": "qemu", "commit_id": "413d463f43fbc4dd3a601e80a5724aa384a265a0", "target": 1, "func": "static void dhcp_decode(const struct bootp_t *bp, int *pmsg_type,\n\n                        struct in_addr *preq_addr)\n\n{\n\n    const uint8_t *p, *p_end;\n\n    int len, tag;\n\n\n\n    *pmsg_type = 0;\n\n    preq_addr->s_addr = htonl(0L);\n\n\n\n    p = bp->bp_vend;\n\n    p_end = p + DHCP_OPT_LEN;\n\n    if (memcmp(p, rfc1533_cookie, 4) != 0)\n\n        return;\n\n    p += 4;\n\n    while (p < p_end) {\n\n        tag = p[0];\n\n        if (tag == RFC1533_PAD) {\n\n            p++;\n\n        } else if (tag == RFC1533_END) {\n\n\n        } else {\n\n            p++;\n\n            if (p >= p_end)\n\n\n            len = *p++;\n\n\n\n\n            DPRINTF(\"dhcp: tag=%d len=%d\\n\", tag, len);\n\n\n\n            switch(tag) {\n\n            case RFC2132_MSG_TYPE:\n\n                if (len >= 1)\n\n                    *pmsg_type = p[0];\n\n\n            case RFC2132_REQ_ADDR:\n\n                if (len >= 4) {\n\n                    memcpy(&(preq_addr->s_addr), p, 4);\n\n\n\n            default:\n\n\n\n            p += len;\n\n\n\n    if (*pmsg_type == DHCPREQUEST && preq_addr->s_addr == htonl(0L) &&\n\n        bp->bp_ciaddr.s_addr) {\n\n        memcpy(&(preq_addr->s_addr), &bp->bp_ciaddr, 4);\n\n", "idx": 21020}
{"project": "qemu", "commit_id": "fc34059f080680b560b3f656988fdd9a75cd0eab", "target": 1, "func": "static void GCC_FMT_ATTR(2, 3) qtest_sendf(CharBackend *chr,\n\n                                           const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    gchar *buffer;\n\n\n\n    va_start(ap, fmt);\n\n    buffer = g_strdup_vprintf(fmt, ap);\n\n    qtest_send(chr, buffer);\n\n\n    va_end(ap);\n\n}", "idx": 21026}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "static int virtio_blk_load_device(VirtIODevice *vdev, QEMUFile *f,\n\n                                  int version_id)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n\n\n    while (qemu_get_sbyte(f)) {\n\n        VirtIOBlockReq *req = virtio_blk_alloc_request(s);\n\n        qemu_get_buffer(f, (unsigned char *)req->elem,\n\n                        sizeof(VirtQueueElement));\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n\n\n        virtqueue_map_sg(req->elem->in_sg, req->elem->in_addr,\n\n            req->elem->in_num, 1);\n\n        virtqueue_map_sg(req->elem->out_sg, req->elem->out_addr,\n\n            req->elem->out_num, 0);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21033}
{"project": "FFmpeg", "commit_id": "088ed4d636e3065bf4fc67ef11bfe8592bcd8c0e", "target": 1, "func": "static Picture * remove_short(H264Context *h, int frame_num){\n\n    MpegEncContext * const s = &h->s;\n\n    int i;\n\n\n\n    if(s->avctx->debug&FF_DEBUG_MMCO)\n\n        av_log(h->s.avctx, AV_LOG_DEBUG, \"remove short %d count %d\\n\", frame_num, h->short_ref_count);\n\n\n\n    for(i=0; i<h->short_ref_count; i++){\n\n        Picture *pic= h->short_ref[i];\n\n        if(s->avctx->debug&FF_DEBUG_MMCO)\n\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"%d %d %p\\n\", i, pic->frame_num, pic);\n\n        if(pic->frame_num == frame_num){\n\n            h->short_ref[i]= NULL;\n\n            memmove(&h->short_ref[i], &h->short_ref[i+1], (h->short_ref_count - i - 1)*sizeof(Picture*));\n\n            h->short_ref_count--;\n\n            return pic;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 21059}
{"project": "qemu", "commit_id": "3ac216270a62418519c08e88c17005a8f1539cf2", "target": 1, "func": "static int hdev_has_zero_init(BlockDriverState *bs)\n\n{\n\n    return 0;\n\n}\n", "idx": 21124}
{"project": "qemu", "commit_id": "a15fcc3cf69ee3d408f60d6cc316488d2b0249b4", "target": 1, "func": "void visit_start_struct(Visitor *v, const char *name, void **obj,\n\n                        size_t size, Error **errp)\n\n{\n\n    Error *err = NULL;\n\n\n\n    if (obj) {\n\n        assert(size);\n\n        assert(v->type != VISITOR_OUTPUT || *obj);\n\n    }\n\n    v->start_struct(v, name, obj, size, &err);\n\n    if (obj && v->type == VISITOR_INPUT) {\n\n        assert(!err != !*obj);\n\n    }\n\n    error_propagate(errp, err);\n\n}\n", "idx": 21160}
{"project": "FFmpeg", "commit_id": "f141b353e60f1081185927a1e74a9ab46cae8bef", "target": 1, "func": "static void celt_search_for_dual_stereo(OpusPsyContext *s, CeltFrame *f)\n{\n    float td1, td2;\n    f->dual_stereo = 0;\n    bands_dist(s, f, &td1);\n    f->dual_stereo = 1;\n    bands_dist(s, f, &td2);\n    f->dual_stereo = td2 < td1;\n    s->dual_stereo_used += td2 < td1;\n}", "idx": 21176}
{"project": "qemu", "commit_id": "42e4126b793d15ec40f3a84017e1d8afecda1b6d", "target": 1, "func": "void pci_default_write_config(PCIDevice *d, uint32_t addr, uint32_t val, int l)\n\n{\n\n    int i, was_irq_disabled = pci_irq_disabled(d);\n\n    uint32_t config_size = pci_config_size(d);\n\n\n\n    for (i = 0; i < l && addr + i < config_size; val >>= 8, ++i) {\n\n        uint8_t wmask = d->wmask[addr + i];\n\n        uint8_t w1cmask = d->w1cmask[addr + i];\n\n        assert(!(wmask & w1cmask));\n\n        d->config[addr + i] = (d->config[addr + i] & ~wmask) | (val & wmask);\n\n        d->config[addr + i] &= ~(val & w1cmask); /* W1C: Write 1 to Clear */\n\n    }\n\n    if (ranges_overlap(addr, l, PCI_BASE_ADDRESS_0, 24) ||\n\n        ranges_overlap(addr, l, PCI_ROM_ADDRESS, 4) ||\n\n        ranges_overlap(addr, l, PCI_ROM_ADDRESS1, 4) ||\n\n        range_covers_byte(addr, l, PCI_COMMAND))\n\n        pci_update_mappings(d);\n\n\n\n    if (range_covers_byte(addr, l, PCI_COMMAND))\n\n        pci_update_irq_disabled(d, was_irq_disabled);\n\n}\n", "idx": 21189}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static inline int check_fit_i32(uint32_t val, unsigned int bits)\n\n{\n\n    return ((val << (32 - bits)) >> (32 - bits)) == val;\n\n}\n", "idx": 21196}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_getattr(void *opaque)\n\n{\n\n    int32_t fid;\n\n    size_t offset = 7;\n\n    ssize_t retval = 0;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    uint64_t request_mask;\n\n    V9fsStatDotl v9stat_dotl;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dq\", &fid, &request_mask);\n\n    trace_v9fs_getattr(pdu->tag, pdu->id, fid, request_mask);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        retval = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    /*\n\n     * Currently we only support BASIC fields in stat, so there is no\n\n     * need to look at request_mask.\n\n     */\n\n    retval = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (retval < 0) {\n\n        goto out;\n\n    }\n\n    stat_to_v9stat_dotl(s, &stbuf, &v9stat_dotl);\n\n\n\n    /*  fill st_gen if requested and supported by underlying fs */\n\n    if (request_mask & P9_STATS_GEN) {\n\n        retval = v9fs_co_st_gen(pdu, &fidp->path, stbuf.st_mode, &v9stat_dotl);\n\n        if (retval < 0) {\n\n            goto out;\n\n        }\n\n        v9stat_dotl.st_result_mask |= P9_STATS_GEN;\n\n    }\n\n    retval = offset;\n\n    retval += pdu_marshal(pdu, offset, \"A\", &v9stat_dotl);\n\n    trace_v9fs_getattr_return(pdu->tag, pdu->id, v9stat_dotl.st_result_mask,\n\n                              v9stat_dotl.st_mode, v9stat_dotl.st_uid,\n\n                              v9stat_dotl.st_gid);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, retval);\n\n}\n", "idx": 21200}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "int qemu_timeout_ns_to_ms(int64_t ns)\n\n{\n\n    int64_t ms;\n\n    if (ns < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (!ns) {\n\n        return 0;\n\n    }\n\n\n\n    /* Always round up, because it's better to wait too long than to wait too\n\n     * little and effectively busy-wait\n\n     */\n\n    ms = DIV_ROUND_UP(ns, SCALE_MS);\n\n\n\n    /* To avoid overflow problems, limit this to 2^31, i.e. approx 25 days */\n\n    if (ms > (int64_t) INT32_MAX) {\n\n        ms = INT32_MAX;\n\n    }\n\n\n\n    return (int) ms;\n\n}\n", "idx": 21215}
{"project": "qemu", "commit_id": "13d1fd44c46629aad672f192abbf02238c6cbf36", "target": 1, "func": "static void qxl_init_ramsize(PCIQXLDevice *qxl, uint32_t ram_min_mb)\n\n{\n\n    /* vga ram (bar 0) */\n\n    if (qxl->ram_size_mb != -1) {\n\n        qxl->vga.vram_size = qxl->ram_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vga.vram_size < ram_min_mb * 1024 * 1024) {\n\n        qxl->vga.vram_size = ram_min_mb * 1024 * 1024;\n\n    }\n\n\n\n    /* vram32 (surfaces, 32bit, bar 1) */\n\n    if (qxl->vram32_size_mb != -1) {\n\n        qxl->vram32_size = qxl->vram32_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vram32_size < 4096) {\n\n        qxl->vram32_size = 4096;\n\n    }\n\n\n\n    /* vram (surfaces, 64bit, bar 4+5) */\n\n    if (qxl->vram_size_mb != -1) {\n\n        qxl->vram_size = qxl->vram_size_mb * 1024 * 1024;\n\n    }\n\n    if (qxl->vram_size < qxl->vram32_size) {\n\n        qxl->vram_size = qxl->vram32_size;\n\n    }\n\n\n\n    if (qxl->revision == 1) {\n\n        qxl->vram32_size = 4096;\n\n        qxl->vram_size = 4096;\n\n    }\n\n    qxl->vga.vram_size = msb_mask(qxl->vga.vram_size * 2 - 1);\n\n    qxl->vram32_size = msb_mask(qxl->vram32_size * 2 - 1);\n\n    qxl->vram_size = msb_mask(qxl->vram_size * 2 - 1);\n\n}\n", "idx": 21230}
{"project": "qemu", "commit_id": "fc5d642fcae392bbc9fed9ac6bc78ac29ed48372", "target": 1, "func": "static void on_vcpu(CPUState *env, void (*func)(void *data), void *data)\n\n{\n\n    if (env == cpu_single_env) {\n\n        func(data);\n\n        return;\n\n    }\n\n    abort();\n\n}\n", "idx": 21282}
{"project": "FFmpeg", "commit_id": "505cb8e390f275830f5f387020207aaf267be800", "target": 1, "func": "static void ogg_free(AVFormatContext *s)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVStream *st = s->streams[i];\n\n        OGGStreamContext *oggstream = st->priv_data;\n\n\n\n        if (st->codecpar->codec_id == AV_CODEC_ID_FLAC ||\n\n            st->codecpar->codec_id == AV_CODEC_ID_SPEEX ||\n\n            st->codecpar->codec_id == AV_CODEC_ID_OPUS ||\n\n            st->codecpar->codec_id == AV_CODEC_ID_VP8) {\n\n            av_freep(&oggstream->header[0]);\n\n        }\n\n        av_freep(&oggstream->header[1]);\n\n        av_freep(&st->priv_data);\n\n    }\n\n}", "idx": 21290}
{"project": "qemu", "commit_id": "d42cf28837801cd1f835089fe9db2a42a1af55cd", "target": 0, "func": "static void bdrv_drain_recurse(BlockDriverState *bs)\n\n{\n\n    BdrvChild *child;\n\n\n\n    if (bs->drv && bs->drv->bdrv_drain) {\n\n        bs->drv->bdrv_drain(bs);\n\n    }\n\n    QLIST_FOREACH(child, &bs->children, next) {\n\n        bdrv_drain_recurse(child->bs);\n\n    }\n\n}\n", "idx": 21313}
{"project": "qemu", "commit_id": "a7c31816288a8f20fc387d69d441413e7a8c9ff1", "target": 0, "func": "static void dump_qobject(fprintf_function func_fprintf, void *f,\n\n                         int comp_indent, QObject *obj)\n\n{\n\n    switch (qobject_type(obj)) {\n\n        case QTYPE_QINT: {\n\n            QInt *value = qobject_to_qint(obj);\n\n            func_fprintf(f, \"%\" PRId64, qint_get_int(value));\n\n            break;\n\n        }\n\n        case QTYPE_QSTRING: {\n\n            QString *value = qobject_to_qstring(obj);\n\n            func_fprintf(f, \"%s\", qstring_get_str(value));\n\n            break;\n\n        }\n\n        case QTYPE_QDICT: {\n\n            QDict *value = qobject_to_qdict(obj);\n\n            dump_qdict(func_fprintf, f, comp_indent, value);\n\n            break;\n\n        }\n\n        case QTYPE_QLIST: {\n\n            QList *value = qobject_to_qlist(obj);\n\n            dump_qlist(func_fprintf, f, comp_indent, value);\n\n            break;\n\n        }\n\n        case QTYPE_QFLOAT: {\n\n            QFloat *value = qobject_to_qfloat(obj);\n\n            func_fprintf(f, \"%g\", qfloat_get_double(value));\n\n            break;\n\n        }\n\n        case QTYPE_QBOOL: {\n\n            QBool *value = qobject_to_qbool(obj);\n\n            func_fprintf(f, \"%s\", qbool_get_int(value) ? \"true\" : \"false\");\n\n            break;\n\n        }\n\n        case QTYPE_QERROR: {\n\n            QString *value = qerror_human((QError *)obj);\n\n            func_fprintf(f, \"%s\", qstring_get_str(value));\n\n            QDECREF(value);\n\n            break;\n\n        }\n\n        case QTYPE_NONE:\n\n            break;\n\n        case QTYPE_MAX:\n\n        default:\n\n            abort();\n\n    }\n\n}\n", "idx": 21319}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_dump_tx_descr(struct Vmxnet3_TxDesc *descr)\n\n{\n\n    VMW_PKPRN(\"TX DESCR: \"\n\n              \"addr %\" PRIx64 \", len: %d, gen: %d, rsvd: %d, \"\n\n              \"dtype: %d, ext1: %d, msscof: %d, hlen: %d, om: %d, \"\n\n              \"eop: %d, cq: %d, ext2: %d, ti: %d, tci: %d\",\n\n              le64_to_cpu(descr->addr), descr->len, descr->gen, descr->rsvd,\n\n              descr->dtype, descr->ext1, descr->msscof, descr->hlen, descr->om,\n\n              descr->eop, descr->cq, descr->ext2, descr->ti, descr->tci);\n\n}\n", "idx": 21334}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "INLINE bits64 extractFloat64Frac( float64 a )\n\n{\n\n\n\n    return a & LIT64( 0x000FFFFFFFFFFFFF );\n\n\n\n}\n", "idx": 21369}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void esp_command_complete(SCSIBus *bus, int reason, uint32_t tag,\n\n                                 uint32_t arg)\n\n{\n\n    ESPState *s = DO_UPCAST(ESPState, busdev.qdev, bus->qbus.parent);\n\n\n\n    if (reason == SCSI_REASON_DONE) {\n\n        DPRINTF(\"SCSI Command complete\\n\");\n\n        if (s->ti_size != 0)\n\n            DPRINTF(\"SCSI command completed unexpectedly\\n\");\n\n        s->ti_size = 0;\n\n        s->dma_left = 0;\n\n        s->async_len = 0;\n\n        if (arg)\n\n            DPRINTF(\"Command failed\\n\");\n\n        s->sense = arg;\n\n        s->rregs[ESP_RSTAT] = STAT_ST;\n\n        esp_dma_done(s);\n\n        s->current_dev = NULL;\n\n    } else {\n\n        DPRINTF(\"transfer %d/%d\\n\", s->dma_left, s->ti_size);\n\n        s->async_len = arg;\n\n        s->async_buf = s->current_dev->info->get_buf(s->current_dev, 0);\n\n        if (s->dma_left) {\n\n            esp_do_dma(s);\n\n        } else if (s->dma_counter != 0 && s->ti_size <= 0) {\n\n            /* If this was the last part of a DMA transfer then the\n\n               completion interrupt is deferred to here.  */\n\n            esp_dma_done(s);\n\n        }\n\n    }\n\n}\n", "idx": 21389}
{"project": "qemu", "commit_id": "6c2d1c32d084320081b0cd047f8cacd6e722d03a", "target": 1, "func": "static void ehci_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    EHCIPCIInfo *i = data;\n\n\n\n    k->init = usb_ehci_pci_initfn;\n\n    k->vendor_id = i->vendor_id;\n\n    k->device_id = i->device_id;\n\n    k->revision = i->revision;\n\n    k->class_id = PCI_CLASS_SERIAL_USB;\n\n    k->config_write = usb_ehci_pci_write_config;\n\n\n    dc->vmsd = &vmstate_ehci_pci;\n\n    dc->props = ehci_pci_properties;\n\n}", "idx": 21407}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static ssize_t proxy_lgetxattr(FsContext *ctx, V9fsPath *fs_path,\n\n                               const char *name, void *value, size_t size)\n\n{\n\n    int retval;\n\n    V9fsString xname;\n\n\n\n    v9fs_string_init(&xname);\n\n    v9fs_string_sprintf(&xname, \"%s\", name);\n\n    retval = v9fs_request(ctx->private, T_LGETXATTR, value, \"dss\", size,\n\n                          fs_path, &xname);\n\n    v9fs_string_free(&xname);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n    }\n\n    return retval;\n\n}\n", "idx": 21434}
{"project": "qemu", "commit_id": "a7ffaf5c96e26820edffa94eeac766fe60bfdd31", "target": 0, "func": "static void cadence_timer_sync(CadenceTimerState *s)\n\n{\n\n    int i;\n\n    int64_t r, x;\n\n    int64_t interval = ((s->reg_count & COUNTER_CTRL_INT) ?\n\n            (int64_t)s->reg_interval + 1 : 0x10000ULL) << 16;\n\n    uint64_t old_time = s->cpu_time;\n\n\n\n    s->cpu_time = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n    DB_PRINT(\"cpu time: %lld ns\\n\", (long long)old_time);\n\n\n\n    if (!s->cpu_time_valid || old_time == s->cpu_time) {\n\n        s->cpu_time_valid = 1;\n\n        return;\n\n    }\n\n\n\n    r = (int64_t)cadence_timer_get_steps(s, s->cpu_time - old_time);\n\n    x = (int64_t)s->reg_value + ((s->reg_count & COUNTER_CTRL_DEC) ? -r : r);\n\n\n\n    for (i = 0; i < 3; ++i) {\n\n        int64_t m = (int64_t)s->reg_match[i] << 16;\n\n        if (m > interval) {\n\n            continue;\n\n        }\n\n        /* check to see if match event has occurred. check m +/- interval\n\n         * to account for match events in wrap around cases */\n\n        if (is_between(m, s->reg_value, x) ||\n\n            is_between(m + interval, s->reg_value, x) ||\n\n            is_between(m - interval, s->reg_value, x)) {\n\n            s->reg_intr |= (2 << i);\n\n        }\n\n    }\n\n    while (x < 0) {\n\n        x += interval;\n\n    }\n\n    s->reg_value = (uint32_t)(x % interval);\n\n\n\n    if (s->reg_value != x) {\n\n        s->reg_intr |= (s->reg_count & COUNTER_CTRL_INT) ?\n\n            COUNTER_INTR_IV : COUNTER_INTR_OV;\n\n    }\n\n    cadence_timer_update(s);\n\n}\n", "idx": 21436}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static void tcg_out_brcond_i64(TCGContext *s, TCGCond cond, TCGReg arg1,\n\n                               int32_t arg2, int const_arg2, int label)\n\n{\n\n    /* For 64-bit signed comparisons vs zero, we can avoid the compare.  */\n\n    if (arg2 == 0 && !is_unsigned_cond(cond)) {\n\n        TCGLabel *l = &s->labels[label];\n\n        int off16;\n\n\n\n        if (l->has_value) {\n\n            off16 = INSN_OFF16(tcg_pcrel_diff(s, l->u.value_ptr));\n\n        } else {\n\n            /* Make sure to preserve destinations during retranslation.  */\n\n            off16 = *s->code_ptr & INSN_OFF16(-1);\n\n            tcg_out_reloc(s, s->code_ptr, R_SPARC_WDISP16, label, 0);\n\n        }\n\n        tcg_out32(s, INSN_OP(0) | INSN_OP2(3) | BPR_PT | INSN_RS1(arg1)\n\n                  | INSN_COND(tcg_cond_to_rcond[cond]) | off16);\n\n    } else {\n\n        tcg_out_cmp(s, arg1, arg2, const_arg2);\n\n        tcg_out_bpcc(s, tcg_cond_to_bcond[cond], BPCC_XCC | BPCC_PT, label);\n\n    }\n\n    tcg_out_nop(s);\n\n}\n", "idx": 21440}
{"project": "qemu", "commit_id": "95be1196030c003a65052fc7b8a3394fdac690a8", "target": 0, "func": "int pci_bridge_initfn(PCIDevice *dev)\n\n{\n\n    PCIBus *parent = dev->bus;\n\n    PCIBridge *br = DO_UPCAST(PCIBridge, dev, dev);\n\n    PCIBus *sec_bus = &br->sec_bus;\n\n\n\n    pci_set_word(dev->config + PCI_STATUS,\n\n                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);\n\n    dev->config[PCI_HEADER_TYPE] =\n\n        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n    pci_set_word(dev->config + PCI_SEC_STATUS,\n\n                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    qbus_create_inplace(&sec_bus->qbus, &pci_bus_info, &dev->qdev,\n\n                        br->bus_name);\n\n    sec_bus->parent_dev = dev;\n\n    sec_bus->map_irq = br->map_irq;\n\n    sec_bus->address_space_mem = &br->address_space_mem;\n\n    memory_region_init(&br->address_space_mem, \"pci_bridge_pci\", INT64_MAX);\n\n    sec_bus->address_space_io = &br->address_space_io;\n\n    memory_region_init(&br->address_space_io, \"pci_bridge_io\", 65536);\n\n    pci_bridge_region_init(br);\n\n    QLIST_INIT(&sec_bus->child);\n\n    QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling);\n\n    return 0;\n\n}\n", "idx": 21453}
{"project": "qemu", "commit_id": "4f298a4b2957b7833bc607c951ca27c458d98d88", "target": 1, "func": "static void clear_sdr_rep(IPMIBmcSim *ibs,\n\n                          uint8_t *cmd, unsigned int cmd_len,\n\n                          uint8_t *rsp, unsigned int *rsp_len,\n\n                          unsigned int max_rsp_len)\n\n{\n\n    IPMI_CHECK_CMD_LEN(8);\n\n    IPMI_CHECK_RESERVATION(2, ibs->sdr.reservation);\n\n    if (cmd[4] != 'C' || cmd[5] != 'L' || cmd[6] != 'R') {\n\n        rsp[2] = IPMI_CC_INVALID_DATA_FIELD;\n\n        return;\n\n    }\n\n    if (cmd[7] == 0xaa) {\n\n        ibs->sdr.next_free = 0;\n\n        ibs->sdr.overflow = 0;\n\n        set_timestamp(ibs, ibs->sdr.last_clear);\n\n        IPMI_ADD_RSP_DATA(1); /* Erasure complete */\n\n        sdr_inc_reservation(&ibs->sdr);\n\n    } else if (cmd[7] == 0) {\n\n        IPMI_ADD_RSP_DATA(1); /* Erasure complete */\n\n    } else {\n\n        rsp[2] = IPMI_CC_INVALID_DATA_FIELD;\n\n        return;\n\n    }\n\n}\n", "idx": 21468}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *qmp_chardev_open_file(const char *id,\n\n                                              ChardevBackend *backend,\n\n                                              ChardevReturn *ret,\n\n                                              Error **errp)\n\n{\n\n    ChardevFile *file = backend->u.file;\n\n    ChardevCommon *common = qapi_ChardevFile_base(file);\n\n    HANDLE out;\n\n\n\n    if (file->has_in) {\n\n        error_setg(errp, \"input file not supported\");\n\n        return NULL;\n\n    }\n\n\n\n    out = CreateFile(file->out, GENERIC_WRITE, FILE_SHARE_READ, NULL,\n\n                     OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n    if (out == INVALID_HANDLE_VALUE) {\n\n        error_setg(errp, \"open %s failed\", file->out);\n\n        return NULL;\n\n    }\n\n    return qemu_chr_open_win_file(out, common, errp);\n\n}\n", "idx": 21483}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_debug_event(BlockDriverState *bs, BlkDebugEvent event)\n\n{\n\n    if (!bs || !bs->drv || !bs->drv->bdrv_debug_event) {\n\n        return;\n\n    }\n\n\n\n    bs->drv->bdrv_debug_event(bs, event);\n\n}\n", "idx": 21531}
{"project": "qemu", "commit_id": "16a9e8a5bcc1fb0796828eb654a4f926734e59af", "target": 0, "func": "static bool pc_machine_get_aligned_dimm(Object *obj, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    return pcms->enforce_aligned_dimm;\n\n}\n", "idx": 21555}
{"project": "qemu", "commit_id": "b192af8acc597a6e8068873434e56e0c7de1b7d3", "target": 0, "func": "static int refresh_total_sectors(BlockDriverState *bs, int64_t hint)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    /* Do not attempt drv->bdrv_getlength() on scsi-generic devices */\n\n    if (bs->sg)\n\n        return 0;\n\n\n\n    /* query actual device if possible, otherwise just trust the hint */\n\n    if (drv->bdrv_getlength) {\n\n        int64_t length = drv->bdrv_getlength(bs);\n\n        if (length < 0) {\n\n            return length;\n\n        }\n\n        hint = DIV_ROUND_UP(length, BDRV_SECTOR_SIZE);\n\n    }\n\n\n\n    bs->total_sectors = hint;\n\n    return 0;\n\n}\n", "idx": 21561}
{"project": "qemu", "commit_id": "13344f3a17e0a785c0eb8e36f69518f21aa8a91a", "target": 1, "func": "BlockStatsList *qmp_query_blockstats(Error **errp)\n{\n    BlockStatsList *head = NULL, **p_next = &head;\n    BlockDriverState *bs = NULL;\n     while ((bs = bdrv_next(bs))) {\n        BlockStatsList *info = g_malloc0(sizeof(*info));\n        info->value = bdrv_query_stats(bs);\n        *p_next = info;\n        p_next = &info->next;\n    }\n    return head;\n}", "idx": 21564}
{"project": "FFmpeg", "commit_id": "0c22311b56e66115675c4a96e4c78547886a4171", "target": 0, "func": "static void opt_pad_color(const char *arg) {\n\n    /* Input is expected to be six hex digits similar to\n\n       how colors are expressed in html tags (but without the #) */\n\n    int rgb = strtol(arg, NULL, 16);\n\n    int r,g,b;\n\n\n\n    r = (rgb >> 16);\n\n    g = ((rgb >> 8) & 255);\n\n    b = (rgb & 255);\n\n\n\n    padcolor[0] = RGB_TO_Y(r,g,b);\n\n    padcolor[1] = RGB_TO_U(r,g,b,0);\n\n    padcolor[2] = RGB_TO_V(r,g,b,0);\n\n}\n", "idx": 21586}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void gen_spr_74xx (CPUPPCState *env)\n\n{\n\n    /* Processor identification */\n\n    spr_register(env, SPR_PIR, \"PIR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_pir,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMCR2, \"MMCR2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_UMMCR2, \"UMMCR2\",\n\n                 &spr_read_ureg, SPR_NOACCESS,\n\n                 &spr_read_ureg, SPR_NOACCESS,\n\n                 0x00000000);\n\n    /* XXX: not implemented */\n\n    spr_register(env, SPR_BAMR, \"BAMR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MSSCR0, \"MSSCR0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Altivec */\n\n    spr_register(env, SPR_VRSAVE, \"VRSAVE\",\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Not strictly an SPR */\n\n    vscr_init(env, 0x00010000);\n\n}\n", "idx": 21587}
{"project": "FFmpeg", "commit_id": "52c959a2376614e4c9089145b8ee69334b663257", "target": 1, "func": "static int read_channels(AVFilterContext *ctx, int channels, uint8_t *item_str, int *nb, double **c, double **cache)\n\n{\n\n    char *p, *arg, *old_str, *prev_arg = NULL, *saveptr = NULL;\n\n    int i, ret;\n\n\n\n    p = old_str = av_strdup(item_str);\n\n    if (!p)\n\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < channels; i++) {\n\n        if (!(arg = av_strtok(p, \"|\", &saveptr)))\n\n            arg = prev_arg;\n\n\n\n        p = NULL;\n\n        count_coefficients(arg, &nb[i]);\n\n        cache[i] = av_calloc(nb[i], sizeof(cache[i]));\n\n        c[i] = av_calloc(nb[i], sizeof(c[i]));\n\n        if (!c[i] || !cache[i])\n\n            return AVERROR(ENOMEM);\n\n\n\n        ret = read_coefficients(ctx, arg, nb[i], c[i]);\n\n        if (ret < 0)\n\n            return ret;\n\n        prev_arg = arg;\n\n    }\n\n\n\n    av_freep(&old_str);\n\n\n\n    return 0;\n\n}\n", "idx": 21589}
{"project": "FFmpeg", "commit_id": "ca16618b01abfde44b4eaf92dc89b01aa1b4a91e", "target": 0, "func": "static int xan_decode_end(AVCodecContext *avctx)\n\n{\n\n    XanContext *s = avctx->priv_data;\n\n\n\n    /* release the last frame */\n\n    avctx->release_buffer(avctx, &s->last_frame);\n\n\n\n    av_free(s->buffer1);\n\n    av_free(s->buffer2);\n\n\n\n    return 0;\n\n}\n", "idx": 21607}
{"project": "qemu", "commit_id": "903585dec63ee83bd8149006e31f92ea789b38e3", "target": 0, "func": "static void ppce500_reset_device_tree(void *opaque)\n\n{\n\n    DeviceTreeParams *p = opaque;\n\n    ppce500_load_device_tree(p->machine, &p->params, p->addr, p->initrd_base,\n\n                             p->initrd_size, false);\n\n}\n", "idx": 21627}
{"project": "qemu", "commit_id": "1bd075f29ea6d11853475c7c42734595720c3ac6", "target": 1, "func": "iscsi_aio_write16_cb(struct iscsi_context *iscsi, int status,\n\n                     void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    trace_iscsi_aio_write16_cb(iscsi, status, acb, acb->canceled);\n\n\n\n    g_free(acb->buf);\n\n\n\n    if (acb->canceled != 0) {\n\n        qemu_aio_release(acb);\n\n        scsi_free_scsi_task(acb->task);\n\n        acb->task = NULL;\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status < 0) {\n\n        error_report(\"Failed to write16 data to iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(acb);\n\n    scsi_free_scsi_task(acb->task);\n\n    acb->task = NULL;\n\n}\n", "idx": 21633}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int apc_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 8)\n\n        return 0;\n\n\n\n    if (!strncmp(p->buf, \"CRYO_APC\", 8))\n\n        return AVPROBE_SCORE_MAX;\n\n\n\n    return 0;\n\n}\n", "idx": 21664}
{"project": "qemu", "commit_id": "7ea2d269cb84ca7a2f4b7c3735634176f7c1dc35", "target": 1, "func": "NBDExport *nbd_export_new(BlockDriverState *bs, off_t dev_offset,\n\n                          off_t size, uint32_t nbdflags,\n\n                          void (*close)(NBDExport *))\n\n{\n\n    NBDExport *exp = g_malloc0(sizeof(NBDExport));\n\n    exp->refcount = 1;\n\n    QTAILQ_INIT(&exp->clients);\n\n    exp->bs = bs;\n\n    exp->dev_offset = dev_offset;\n\n    exp->nbdflags = nbdflags;\n\n    exp->size = size == -1 ? bdrv_getlength(bs) : size;\n\n    exp->close = close;\n\n    exp->ctx = bdrv_get_aio_context(bs);\n\n    bdrv_ref(bs);\n\n    bdrv_add_aio_context_notifier(bs, bs_aio_attached, bs_aio_detach, exp);\n\n\n\n\n\n\n\n    return exp;\n\n}", "idx": 21691}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "static int qemu_reset_requested(void)\n\n{\n\n    int r = reset_requested;\n\n    if (r && replay_checkpoint(CHECKPOINT_RESET_REQUESTED)) {\n\n        reset_requested = 0;\n\n        return r;\n\n    }\n\n    return false;\n\n}\n", "idx": 21704}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_pwt_s *omap_pwt_init(MemoryRegion *system_memory,\n\n                                        target_phys_addr_t base,\n\n                                        omap_clk clk)\n\n{\n\n    struct omap_pwt_s *s = g_malloc0(sizeof(*s));\n\n    s->clk = clk;\n\n    omap_pwt_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_pwt_ops, s,\n\n                          \"omap-pwt\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n    return s;\n\n}\n", "idx": 21746}
{"project": "FFmpeg", "commit_id": "cf1e0786ed64e69614760bfb4ecd7adbde8e6094", "target": 0, "func": "static int init_er(MpegEncContext *s)\n\n{\n\n    ERContext *er = &s->er;\n\n    int mb_array_size = s->mb_height * s->mb_stride;\n\n    int i;\n\n\n\n    er->avctx       = s->avctx;\n\n    er->mecc        = &s->mecc;\n\n\n\n    er->mb_index2xy = s->mb_index2xy;\n\n    er->mb_num      = s->mb_num;\n\n    er->mb_width    = s->mb_width;\n\n    er->mb_height   = s->mb_height;\n\n    er->mb_stride   = s->mb_stride;\n\n    er->b8_stride   = s->b8_stride;\n\n\n\n    er->er_temp_buffer     = av_malloc(s->mb_height * s->mb_stride);\n\n    er->error_status_table = av_mallocz(mb_array_size);\n\n    if (!er->er_temp_buffer || !er->error_status_table)\n\n        goto fail;\n\n\n\n    er->mbskip_table  = s->mbskip_table;\n\n    er->mbintra_table = s->mbintra_table;\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(s->dc_val); i++)\n\n        er->dc_val[i] = s->dc_val[i];\n\n\n\n    er->decode_mb = mpeg_er_decode_mb;\n\n    er->opaque    = s;\n\n\n\n    return 0;\n\nfail:\n\n    av_freep(&er->er_temp_buffer);\n\n    av_freep(&er->error_status_table);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 21760}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int xbm_encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n\n\n    return 0;\n\n}\n", "idx": 21765}
{"project": "FFmpeg", "commit_id": "5f01beb54846de8764c15206aa63086238dde493", "target": 1, "func": "int ff_lzw_decode_init(LZWState *p, int csize, uint8_t *buf, int buf_size, int mode)\n\n{\n\n    struct LZWState *s = (struct LZWState *)p;\n\n\n\n    if(csize < 1 || csize > LZW_MAXBITS)\n\n        return -1;\n\n    /* read buffer */\n\n    s->eob_reached = 0;\n\n    s->pbuf = buf;\n\n    s->ebuf = s->pbuf + buf_size;\n\n    s->bbuf = 0;\n\n    s->bbits = 0;\n\n    s->bs = 0;\n\n\n\n    /* decoder */\n\n    s->codesize = csize;\n\n    s->cursize = s->codesize + 1;\n\n    s->curmask = mask[s->cursize];\n\n    s->top_slot = 1 << s->cursize;\n\n    s->clear_code = 1 << s->codesize;\n\n    s->end_code = s->clear_code + 1;\n\n    s->slot = s->newcodes = s->clear_code + 2;\n\n    s->oc = s->fc = 0;\n\n    s->sp = s->stack;\n\n\n\n    s->mode = mode;\n\n    switch(s->mode){\n\n    case FF_LZW_GIF:\n\n        s->extra_slot= 0;\n\n        break;\n\n    case FF_LZW_TIFF:\n\n        s->extra_slot= 1;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 21815}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static target_long monitor_get_tbl (const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return cpu_ppc_load_tbl(env);\n\n}\n", "idx": 21823}
{"project": "FFmpeg", "commit_id": "7dd44cde2abb156710f26a08b6cd6c8dd9a9793d", "target": 0, "func": "static void sub2video_update(InputStream *ist, AVSubtitle *sub)\n\n{\n\n    AVFrame *frame = ist->sub2video.frame;\n\n    int8_t *dst;\n\n    int     dst_linesize;\n\n    int num_rects, i;\n\n    int64_t pts, end_pts;\n\n\n\n    if (!frame)\n\n        return;\n\n    if (sub) {\n\n        pts       = av_rescale_q(sub->pts + sub->start_display_time * 1000LL,\n\n                                 AV_TIME_BASE_Q, ist->st->time_base);\n\n        end_pts   = av_rescale_q(sub->pts + sub->end_display_time   * 1000LL,\n\n                                 AV_TIME_BASE_Q, ist->st->time_base);\n\n        num_rects = sub->num_rects;\n\n    } else {\n\n        pts       = ist->sub2video.end_pts;\n\n        end_pts   = INT64_MAX;\n\n        num_rects = 0;\n\n    }\n\n    if (sub2video_get_blank_frame(ist) < 0) {\n\n        av_log(ist->dec_ctx, AV_LOG_ERROR,\n\n               \"Impossible to get a blank canvas.\\n\");\n\n        return;\n\n    }\n\n    dst          = frame->data    [0];\n\n    dst_linesize = frame->linesize[0];\n\n    for (i = 0; i < num_rects; i++)\n\n        sub2video_copy_rect(dst, dst_linesize, frame->width, frame->height, sub->rects[i]);\n\n    sub2video_push_ref(ist, pts);\n\n    ist->sub2video.end_pts = end_pts;\n\n}\n", "idx": 21843}
{"project": "qemu", "commit_id": "08a2d4c4ffde60e48819449f461274c43ad6e2d3", "target": 0, "func": "static void sdl_grab_start(void)\n\n{\n\n    if (guest_cursor) {\n\n        SDL_SetCursor(guest_sprite);\n\n        SDL_WarpMouse(guest_x, guest_y);\n\n    } else\n\n        sdl_hide_cursor();\n\n\n\n    if (SDL_WM_GrabInput(SDL_GRAB_ON) == SDL_GRAB_ON) {\n\n        gui_grab = 1;\n\n        sdl_update_caption();\n\n    } else\n\n        sdl_show_cursor();\n\n}\n", "idx": 21858}
{"project": "qemu", "commit_id": "872dd82c83745a603d2e07a03d34313eb6467ae4", "target": 0, "func": "VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size,\n\n                            VirtIOHandleOutput handle_output)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {\n\n        if (vdev->vq[i].vring.num == 0)\n\n            break;\n\n    }\n\n\n\n    if (i == VIRTIO_QUEUE_MAX || queue_size > VIRTQUEUE_MAX_SIZE)\n\n        abort();\n\n\n\n    vdev->vq[i].vring.num = queue_size;\n\n    vdev->vq[i].vring.num_default = queue_size;\n\n    vdev->vq[i].vring.align = VIRTIO_PCI_VRING_ALIGN;\n\n    vdev->vq[i].handle_output = handle_output;\n\n    vdev->vq[i].handle_aio_output = NULL;\n\n\n\n    return &vdev->vq[i];\n\n}\n", "idx": 21860}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void discard_vq_data(VirtQueue *vq, VirtIODevice *vdev)\n\n{\n\n    VirtQueueElement elem;\n\n\n\n    if (!virtio_queue_ready(vq)) {\n\n        return;\n\n    }\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        virtqueue_push(vq, &elem, 0);\n\n    }\n\n    virtio_notify(vdev, vq);\n\n}\n", "idx": 21864}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "void migrate_compress_threads_create(void)\n\n{\n\n    int i, thread_count;\n\n\n\n    if (!migrate_use_compression()) {\n\n        return;\n\n    }\n\n    quit_comp_thread = false;\n\n    compression_switch = true;\n\n    thread_count = migrate_compress_threads();\n\n    compress_threads = g_new0(QemuThread, thread_count);\n\n    comp_param = g_new0(CompressParam, thread_count);\n\n    comp_done_cond = g_new0(QemuCond, 1);\n\n    comp_done_lock = g_new0(QemuMutex, 1);\n\n    qemu_cond_init(comp_done_cond);\n\n    qemu_mutex_init(comp_done_lock);\n\n    for (i = 0; i < thread_count; i++) {\n\n        /* com_param[i].file is just used as a dummy buffer to save data, set\n\n         * it's ops to empty.\n\n         */\n\n        comp_param[i].file = qemu_fopen_ops(NULL, &empty_ops);\n\n        comp_param[i].done = true;\n\n        qemu_mutex_init(&comp_param[i].mutex);\n\n        qemu_cond_init(&comp_param[i].cond);\n\n        qemu_thread_create(compress_threads + i, \"compress\",\n\n                           do_data_compress, comp_param + i,\n\n                           QEMU_THREAD_JOINABLE);\n\n    }\n\n}\n", "idx": 21875}
{"project": "qemu", "commit_id": "703008e81a6ace40f227aae16d630014e5016af1", "target": 0, "func": "void validate_bootdevices(const char *devices)\n\n{\n\n    /* We just do some generic consistency checks */\n\n    const char *p;\n\n    int bitmap = 0;\n\n\n\n    for (p = devices; *p != '\\0'; p++) {\n\n        /* Allowed boot devices are:\n\n         * a-b: floppy disk drives\n\n         * c-f: IDE disk drives\n\n         * g-m: machine implementation dependent drives\n\n         * n-p: network devices\n\n         * It's up to each machine implementation to check if the given boot\n\n         * devices match the actual hardware implementation and firmware\n\n         * features.\n\n         */\n\n        if (*p < 'a' || *p > 'p') {\n\n            fprintf(stderr, \"Invalid boot device '%c'\\n\", *p);\n\n            exit(1);\n\n        }\n\n        if (bitmap & (1 << (*p - 'a'))) {\n\n            fprintf(stderr, \"Boot device '%c' was given twice\\n\", *p);\n\n            exit(1);\n\n        }\n\n        bitmap |= 1 << (*p - 'a');\n\n    }\n\n}\n", "idx": 21876}
{"project": "qemu", "commit_id": "cfb2d02be9413d45b30ed6d8e38800250b6b4b48", "target": 0, "func": "static inline void cpu_loop_exec_tb(CPUState *cpu, TranslationBlock *tb,\n\n                                    TranslationBlock **last_tb, int *tb_exit,\n\n                                    SyncClocks *sc)\n\n{\n\n    uintptr_t ret;\n\n    int32_t insns_left;\n\n\n\n    if (unlikely(atomic_read(&cpu->exit_request))) {\n\n        return;\n\n    }\n\n\n\n    trace_exec_tb(tb, tb->pc);\n\n    ret = cpu_tb_exec(cpu, tb);\n\n    tb = (TranslationBlock *)(ret & ~TB_EXIT_MASK);\n\n    *tb_exit = ret & TB_EXIT_MASK;\n\n    if (*tb_exit != TB_EXIT_REQUESTED) {\n\n        *last_tb = tb;\n\n        return;\n\n    }\n\n\n\n    *last_tb = NULL;\n\n    insns_left = atomic_read(&cpu->icount_decr.u32);\n\n    atomic_set(&cpu->icount_decr.u16.high, 0);\n\n    if (insns_left < 0) {\n\n        /* Something asked us to stop executing\n\n         * chained TBs; just continue round the main\n\n         * loop. Whatever requested the exit will also\n\n         * have set something else (eg exit_request or\n\n         * interrupt_request) which we will handle\n\n         * next time around the loop.  But we need to\n\n         * ensure the zeroing of tcg_exit_req (see cpu_tb_exec)\n\n         * comes before the next read of cpu->exit_request\n\n         * or cpu->interrupt_request.\n\n         */\n\n        smp_mb();\n\n        return;\n\n    }\n\n\n\n    /* Instruction counter expired.  */\n\n    assert(use_icount);\n\n#ifndef CONFIG_USER_ONLY\n\n    if (cpu->icount_extra) {\n\n        /* Refill decrementer and continue execution.  */\n\n        cpu->icount_extra += insns_left;\n\n        insns_left = MIN(0xffff, cpu->icount_extra);\n\n        cpu->icount_extra -= insns_left;\n\n        cpu->icount_decr.u16.low = insns_left;\n\n    } else {\n\n        /* Execute any remaining instructions, then let the main loop\n\n         * handle the next event.\n\n         */\n\n        if (insns_left > 0) {\n\n            cpu_exec_nocache(cpu, insns_left, tb, false);\n\n            align_clocks(sc, cpu);\n\n        }\n\n        cpu->exception_index = EXCP_INTERRUPT;\n\n        cpu_loop_exit(cpu);\n\n    }\n\n#endif\n\n}\n", "idx": 21880}
{"project": "FFmpeg", "commit_id": "e53c9065ca08a9153ecc73a6a8940bcc6d667e58", "target": 0, "func": "static int test_butterflies_float(AVFloatDSPContext *fdsp, AVFloatDSPContext *cdsp,\n\n                                  const float *v1, const float *v2)\n\n{\n\n    LOCAL_ALIGNED(32, float, cv1, [LEN]);\n\n    LOCAL_ALIGNED(32, float, cv2, [LEN]);\n\n    LOCAL_ALIGNED(32, float, ov1, [LEN]);\n\n    LOCAL_ALIGNED(32, float, ov2, [LEN]);\n\n    int ret;\n\n\n\n    memcpy(cv1, v1, LEN * sizeof(*v1));\n\n    memcpy(cv2, v2, LEN * sizeof(*v2));\n\n    memcpy(ov1, v1, LEN * sizeof(*v1));\n\n    memcpy(ov2, v2, LEN * sizeof(*v2));\n\n\n\n    cdsp->butterflies_float(cv1, cv2, LEN);\n\n    fdsp->butterflies_float(ov1, ov2, LEN);\n\n\n\n    if ((ret = compare_floats(cv1, ov1, LEN, FLT_EPSILON)) ||\n\n        (ret = compare_floats(cv2, ov2, LEN, FLT_EPSILON)))\n\n        av_log(NULL, AV_LOG_ERROR, \"butterflies_float failed\\n\");\n\n\n\n    return ret;\n\n}\n", "idx": 21883}
{"project": "FFmpeg", "commit_id": "5faf168940d6a9787552637c260b18329453bda3", "target": 0, "func": "static int64_t mpegps_read_dts(AVFormatContext *s, int stream_index,\n\n                               int64_t *ppos, int64_t pos_limit)\n\n{\n\n    int len, startcode;\n\n    int64_t pos, pts, dts;\n\n\n\n    pos = *ppos;\n\n#ifdef DEBUG_SEEK\n\n    printf(\"read_dts: pos=0x%\"PRIx64\" next=%d -> \", pos, find_next);\n\n#endif\n\n    url_fseek(s->pb, pos, SEEK_SET);\n\n    for(;;) {\n\n        len = mpegps_read_pes_header(s, &pos, &startcode, &pts, &dts);\n\n        if (len < 0) {\n\n#ifdef DEBUG_SEEK\n\n            printf(\"none (ret=%d)\\n\", len);\n\n#endif\n\n            return AV_NOPTS_VALUE;\n\n        }\n\n        if (startcode == s->streams[stream_index]->id &&\n\n            dts != AV_NOPTS_VALUE) {\n\n            break;\n\n        }\n\n        url_fskip(s->pb, len);\n\n    }\n\n#ifdef DEBUG_SEEK\n\n    printf(\"pos=0x%\"PRIx64\" dts=0x%\"PRIx64\" %0.3f\\n\", pos, dts, dts / 90000.0);\n\n#endif\n\n    *ppos = pos;\n\n    return dts;\n\n}\n", "idx": 21885}
{"project": "qemu", "commit_id": "32532f215c49f005aaef942adfae34cbcc5fa678", "target": 1, "func": "static void pc_dimm_realize(DeviceState *dev, Error **errp)\n\n{\n\n    PCDIMMDevice *dimm = PC_DIMM(dev);\n\n\n\n    if (!dimm->hostmem) {\n\n        error_setg(errp, \"'\" PC_DIMM_MEMDEV_PROP \"' property is not set\");\n\n        return;\n\n    }\n\n    if ((nb_numa_nodes > 0) && (dimm->node >= nb_numa_nodes)) {\n\n        error_setg(errp, \"'DIMM property \" PC_DIMM_NODE_PROP \" has value %\"\n\n                   PRIu32 \"' which exceeds the number of numa nodes: %d\",\n\n                   dimm->node, nb_numa_nodes);\n\n        return;\n\n    }\n\n}\n", "idx": 21901}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "void cpu_write_xer(CPUPPCState *env, target_ulong xer)\n\n{\n\n    env->so = (xer >> XER_SO) & 1;\n\n    env->ov = (xer >> XER_OV) & 1;\n\n    env->ca = (xer >> XER_CA) & 1;\n\n    env->xer = xer & ~((1u << XER_SO) | (1u << XER_OV) | (1u << XER_CA));\n\n}\n", "idx": 21918}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "void helper_divq_EAX_T0(void)\n\n{\n\n    uint64_t r0, r1;\n\n    if (T0 == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n    r0 = EAX;\n\n    r1 = EDX;\n\n    div64(&r0, &r1, T0);\n\n    EAX = r0;\n\n    EDX = r1;\n\n}\n", "idx": 21921}
{"project": "FFmpeg", "commit_id": "a5398aa56cfbf80acb409451cd807660402a34d4", "target": 1, "func": "static int hevc_init(AVCodecParserContext *s)\n\n{\n\n    HEVCContext  *h  = &((HEVCParseContext *)s->priv_data)->h;\n\n    h->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n\n\n\n    h->skipped_bytes_pos_size = INT_MAX;\n\n\n\n    return 0;\n\n}", "idx": 21948}
{"project": "FFmpeg", "commit_id": "ebfcf31ddf654b6e44c8cebb51bfe0ba0964b33e", "target": 1, "func": "matroska_probe (AVProbeData *p)\n\n{\n\n    uint64_t total = 0;\n\n    int len_mask = 0x80, size = 1, n = 1;\n\n    uint8_t probe_data[] = { 'm', 'a', 't', 'r', 'o', 's', 'k', 'a' };\n\n\n\n    if (p->buf_size < 5)\n\n        return 0;\n\n\n\n    /* ebml header? */\n\n    if ((p->buf[0] << 24 | p->buf[1] << 16 |\n\n         p->buf[2] << 8 | p->buf[3]) != EBML_ID_HEADER)\n\n        return 0;\n\n\n\n    /* length of header */\n\n    total = p->buf[4];\n\n    while (size <= 8 && !(total & len_mask)) {\n\n        size++;\n\n        len_mask >>= 1;\n\n    }\n\n    if (size > 8)\n\n      return 0;\n\n    total &= (len_mask - 1);\n\n    while (n < size)\n\n        total = (total << 8) | p->buf[4 + n++];\n\n\n\n    /* does the probe data contain the whole header? */\n\n    if (p->buf_size < 4 + size + total)\n\n      return 0;\n\n\n\n    /* the header must contain the document type 'matroska'. For now,\n\n     * we don't parse the whole header but simply check for the\n\n     * availability of that array of characters inside the header.\n\n     * Not fully fool-proof, but good enough. */\n\n    for (n = 4 + size; n < 4 + size + total - sizeof(probe_data); n++)\n\n        if (!memcmp (&p->buf[n], probe_data, sizeof(probe_data)))\n\n            return AVPROBE_SCORE_MAX;\n\n\n\n    return 0;\n\n}\n", "idx": 21951}
{"project": "FFmpeg", "commit_id": "2caf19e90f270abe1e80a3e85acaf0eb5c9d0aac", "target": 1, "func": "static void FUNCC(pred16x16_vertical)(uint8_t *_src, int _stride){\n\n    int i;\n\n    pixel *src = (pixel*)_src;\n\n    int stride = _stride/sizeof(pixel);\n\n    const pixel4 a = ((pixel4*)(src-stride))[0];\n\n    const pixel4 b = ((pixel4*)(src-stride))[1];\n\n    const pixel4 c = ((pixel4*)(src-stride))[2];\n\n    const pixel4 d = ((pixel4*)(src-stride))[3];\n\n\n\n    for(i=0; i<16; i++){\n\n        ((pixel4*)(src+i*stride))[0] = a;\n\n        ((pixel4*)(src+i*stride))[1] = b;\n\n        ((pixel4*)(src+i*stride))[2] = c;\n\n        ((pixel4*)(src+i*stride))[3] = d;\n\n    }\n\n}\n", "idx": 21972}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void rgb24_to_pal8(AVPicture *dst, AVPicture *src,\n\n                          int width, int height)\n\n{\n\n    const unsigned char *p;\n\n    unsigned char *q;\n\n    int r, g, b, dst_wrap, src_wrap;\n\n    int x, y, i;\n\n    static const uint8_t pal_value[6] = { 0x00, 0x33, 0x66, 0x99, 0xcc, 0xff };\n\n    uint32_t *pal;\n\n\n\n    p = src->data[0];\n\n    src_wrap = src->linesize[0] - 3 * width;\n\n\n\n    q = dst->data[0];\n\n    dst_wrap = dst->linesize[0] - width;\n\n\n\n    for(y=0;y<height;y++) {\n\n        for(x=0;x<width;x++) {\n\n            r = p[0];\n\n            g = p[1];\n\n            b = p[2];\n\n\n\n            q[0] = gif_clut_index(r, g, b);\n\n            q++;\n\n            p += 3;\n\n        }\n\n        p += src_wrap;\n\n        q += dst_wrap;\n\n    }\n\n\n\n    /* build palette */\n\n    pal = (uint32_t *)dst->data[1];\n\n    i = 0;\n\n    for(r = 0; r < 6; r++) {\n\n        for(g = 0; g < 6; g++) {\n\n            for(b = 0; b < 6; b++) {\n\n                pal[i++] = (0xff << 24) | (pal_value[r] << 16) | \n\n                    (pal_value[g] << 8) | pal_value[b];\n\n            }\n\n        }\n\n    }\n\n    while (i < 256)\n\n        pal[i++] = 0;\n\n}\n", "idx": 21974}
{"project": "qemu", "commit_id": "640601c7cb1b6b41d3e1a435b986266c2b71e9bc", "target": 1, "func": "vu_queue_flush(VuDev *dev, VuVirtq *vq, unsigned int count)\n\n{\n\n    uint16_t old, new;\n\n\n\n    if (unlikely(dev->broken)) {\n\n        return;\n\n    }\n\n\n\n    /* Make sure buffer is written before we update index. */\n\n    smp_wmb();\n\n\n\n    old = vq->used_idx;\n\n    new = old + count;\n\n    vring_used_idx_set(dev, vq, new);\n\n    vq->inuse -= count;\n\n    if (unlikely((int16_t)(new - vq->signalled_used) < (uint16_t)(new - old))) {\n\n        vq->signalled_used_valid = false;\n\n    }\n\n}\n", "idx": 21980}
{"project": "qemu", "commit_id": "1108b2f8a939fb5778d384149e2f1b99062a72da", "target": 1, "func": "static int ioh3420_initfn(PCIDevice *d)\n\n{\n\n    PCIEPort *p = PCIE_PORT(d);\n\n    PCIESlot *s = PCIE_SLOT(d);\n\n    int rc;\n\n\n\n    pci_bridge_initfn(d, TYPE_PCIE_BUS);\n\n    pcie_port_init_reg(d);\n\n\n\n    rc = pci_bridge_ssvid_init(d, IOH_EP_SSVID_OFFSET,\n\n                               IOH_EP_SSVID_SVID, IOH_EP_SSVID_SSID);\n\n    if (rc < 0) {\n\n        goto err_bridge;\n\n    }\n\n\n\n    rc = msi_init(d, IOH_EP_MSI_OFFSET, IOH_EP_MSI_NR_VECTOR,\n\n                  IOH_EP_MSI_SUPPORTED_FLAGS & PCI_MSI_FLAGS_64BIT,\n\n                  IOH_EP_MSI_SUPPORTED_FLAGS & PCI_MSI_FLAGS_MASKBIT);\n\n    if (rc < 0) {\n\n        goto err_bridge;\n\n    }\n\n\n\n    rc = pcie_cap_init(d, IOH_EP_EXP_OFFSET, PCI_EXP_TYPE_ROOT_PORT, p->port);\n\n    if (rc < 0) {\n\n        goto err_msi;\n\n    }\n\n\n\n    pcie_cap_arifwd_init(d);\n\n    pcie_cap_deverr_init(d);\n\n    pcie_cap_slot_init(d, s->slot);\n\n    pcie_cap_root_init(d);\n\n\n\n    pcie_chassis_create(s->chassis);\n\n    rc = pcie_chassis_add_slot(s);\n\n    if (rc < 0) {\n\n        goto err_pcie_cap;\n\n    }\n\n\n\n    rc = pcie_aer_init(d, IOH_EP_AER_OFFSET, PCI_ERR_SIZEOF);\n\n    if (rc < 0) {\n\n        goto err;\n\n    }\n\n    pcie_aer_root_init(d);\n\n    ioh3420_aer_vector_update(d);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    pcie_chassis_del_slot(s);\n\nerr_pcie_cap:\n\n    pcie_cap_exit(d);\n\nerr_msi:\n\n    msi_uninit(d);\n\nerr_bridge:\n\n    pci_bridge_exitfn(d);\n\n    return rc;\n\n}\n", "idx": 22002}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)\n\n{\n\n    int32_t datalen;\n\n    int lun;\n\n\n\n    DPRINTF(\"do_busid_cmd: busid 0x%x\\n\", busid);\n\n    lun = busid & 7;\n\n    datalen = s->current_dev->info->send_command(s->current_dev, 0, buf, lun);\n\n    s->ti_size = datalen;\n\n    if (datalen != 0) {\n\n        s->rregs[ESP_RSTAT] = STAT_TC;\n\n        s->dma_left = 0;\n\n        s->dma_counter = 0;\n\n        if (datalen > 0) {\n\n            s->rregs[ESP_RSTAT] |= STAT_DI;\n\n            s->current_dev->info->read_data(s->current_dev, 0);\n\n        } else {\n\n            s->rregs[ESP_RSTAT] |= STAT_DO;\n\n            s->current_dev->info->write_data(s->current_dev, 0);\n\n        }\n\n    }\n\n    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;\n\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n\n    esp_raise_irq(s);\n\n}\n", "idx": 22029}
{"project": "FFmpeg", "commit_id": "23edd41a0d6994cb5d9983d8f035e8eef78960ad", "target": 1, "func": "static void decode(AVCodecContext *dec_ctx, AVFrame *frame, AVPacket *pkt,\n\n                   const char *filename)\n\n{\n\n    char buf[1024];\n\n    int ret;\n\n\n\n    ret = avcodec_send_packet(dec_ctx, pkt);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"Error sending a packet for decoding\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    while (ret >= 0) {\n\n        ret = avcodec_receive_frame(dec_ctx, frame);\n\n        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)\n\n            return;\n\n        else if (ret < 0) {\n\n            fprintf(stderr, \"Error during decoding\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        printf(\"saving frame %3d\\n\", dec_ctx->frame_number);\n\n        fflush(stdout);\n\n\n\n        /* the picture is allocated by the decoder. no need to\n\n           free it */\n\n        snprintf(buf, sizeof(buf), filename, dec_ctx->frame_number);\n\n        pgm_save(frame->data[0], frame->linesize[0],\n\n                 frame->width, frame->height, buf);\n\n    }\n\n}\n", "idx": 22043}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static TCGv neon_load_scratch(int scratch)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_ld_i32(tmp, cpu_env, offsetof(CPUARMState, vfp.scratch[scratch]));\n\n    return tmp;\n\n}\n", "idx": 22045}
{"project": "qemu", "commit_id": "234ac1a9025bcfcc532449f72a97b3d4754d466c", "target": 0, "func": "void bdrv_append(BlockDriverState *bs_new, BlockDriverState *bs_top,\n\n                 Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    assert(!atomic_read(&bs_top->in_flight));\n\n    assert(!atomic_read(&bs_new->in_flight));\n\n\n\n    bdrv_set_backing_hd(bs_new, bs_top, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    change_parent_backing_link(bs_top, bs_new);\n\n\n\n    /* bs_new is now referenced by its new parents, we don't need the\n\n     * additional reference any more. */\n\nout:\n\n    bdrv_unref(bs_new);\n\n}\n", "idx": 22080}
{"project": "qemu", "commit_id": "be09ac4194bd0a61c0d9412c32431fbe2273cba1", "target": 0, "func": "static abi_long do_sendto(int fd, abi_ulong msg, size_t len, int flags,\n\n                          abi_ulong target_addr, socklen_t addrlen)\n\n{\n\n    void *addr;\n\n    void *host_msg;\n\n    abi_long ret;\n\n\n\n    if (addrlen < 0 || addrlen > MAX_SOCK_ADDR)\n\n        return -TARGET_EINVAL;\n\n\n\n    host_msg = lock_user(VERIFY_READ, msg, len, 1);\n\n    if (!host_msg)\n\n        return -TARGET_EFAULT;\n\n    if (target_addr) {\n\n        addr = alloca(addrlen);\n\n        target_to_host_sockaddr(addr, target_addr, addrlen);\n\n        ret = get_errno(sendto(fd, host_msg, len, flags, addr, addrlen));\n\n    } else {\n\n        ret = get_errno(send(fd, host_msg, len, flags));\n\n    }\n\n    unlock_user(host_msg, msg, 0);\n\n    return ret;\n\n}\n", "idx": 22081}
{"project": "qemu", "commit_id": "0e2487bd6f56445b43307536a465ee2ba810aed9", "target": 0, "func": "void qxl_render_resize(PCIQXLDevice *qxl)\n\n{\n\n    QXLSurfaceCreate *sc = &qxl->guest_primary.surface;\n\n\n\n    qxl->guest_primary.stride = sc->stride;\n\n    qxl->guest_primary.resized++;\n\n    switch (sc->format) {\n\n    case SPICE_SURFACE_FMT_16_555:\n\n        qxl->guest_primary.bytes_pp = 2;\n\n        qxl->guest_primary.bits_pp = 15;\n\n        break;\n\n    case SPICE_SURFACE_FMT_16_565:\n\n        qxl->guest_primary.bytes_pp = 2;\n\n        qxl->guest_primary.bits_pp = 16;\n\n        break;\n\n    case SPICE_SURFACE_FMT_32_xRGB:\n\n    case SPICE_SURFACE_FMT_32_ARGB:\n\n        qxl->guest_primary.bytes_pp = 4;\n\n        qxl->guest_primary.bits_pp = 32;\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: unhandled format: %x\\n\", __FUNCTION__,\n\n                qxl->guest_primary.surface.format);\n\n        qxl->guest_primary.bytes_pp = 4;\n\n        qxl->guest_primary.bits_pp = 32;\n\n        break;\n\n    }\n\n}\n", "idx": 22083}
{"project": "qemu", "commit_id": "5b8d7289e9e92a0d7bcecb93cd189e245fef10cd", "target": 0, "func": "static bool insn_crosses_page(CPUARMState *env, DisasContext *s)\n\n{\n\n    /* Return true if the insn at dc->pc might cross a page boundary.\n\n     * (False positives are OK, false negatives are not.)\n\n     */\n\n    uint16_t insn;\n\n\n\n    if ((s->pc & 3) == 0) {\n\n        /* At a 4-aligned address we can't be crossing a page */\n\n        return false;\n\n    }\n\n\n\n    /* This must be a Thumb insn */\n\n    insn = arm_lduw_code(env, s->pc, s->sctlr_b);\n\n\n\n    if ((insn >> 11) >= 0x1d) {\n\n        /* Top five bits 0b11101 / 0b11110 / 0b11111 : this is the\n\n         * First half of a 32-bit Thumb insn. Thumb-1 cores might\n\n         * end up actually treating this as two 16-bit insns (see the\n\n         * code at the start of disas_thumb2_insn()) but we don't bother\n\n         * to check for that as it is unlikely, and false positives here\n\n         * are harmless.\n\n         */\n\n        return true;\n\n    }\n\n    /* Definitely a 16-bit insn, can't be crossing a page. */\n\n    return false;\n\n}\n", "idx": 22097}
{"project": "qemu", "commit_id": "c338b6ad609699cf352c8dd6338360b7e3895ad0", "target": 0, "func": "static int vmdk_is_cid_valid(BlockDriverState *bs)\n\n{\n\n#ifdef CHECK_CID\n\n    BDRVVmdkState *s = bs->opaque;\n\n    BlockDriverState *p_bs = bs->backing_hd;\n\n    uint32_t cur_pcid;\n\n\n\n    if (p_bs) {\n\n        cur_pcid = vmdk_read_cid(p_bs, 0);\n\n        if (s->parent_cid != cur_pcid) {\n\n            /* CID not valid */\n\n            return 0;\n\n        }\n\n    }\n\n#endif\n\n    /* CID valid */\n\n    return 1;\n\n}\n", "idx": 22104}
{"project": "qemu", "commit_id": "a702b35388c307ce2364691e2edc14094701c81e", "target": 0, "func": "static uint32_t slavio_timer_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    SLAVIO_TIMERState *s = opaque;\n\n    uint32_t saddr, ret;\n\n\n\n    saddr = (addr & TIMER_MAXADDR) >> 2;\n\n    switch (saddr) {\n\n    case 0:\n\n        // read limit (system counter mode) or read most signifying\n\n        // part of counter (user mode)\n\n        if (slavio_timer_is_user(s)) {\n\n            // read user timer MSW\n\n            slavio_timer_get_out(s);\n\n            ret = s->counthigh;\n\n        } else {\n\n            // read limit\n\n            // clear irq\n\n            qemu_irq_lower(s->irq);\n\n            s->reached = 0;\n\n            ret = s->limit & 0x7fffffff;\n\n        }\n\n        break;\n\n    case 1:\n\n        // read counter and reached bit (system mode) or read lsbits\n\n        // of counter (user mode)\n\n        slavio_timer_get_out(s);\n\n        if (slavio_timer_is_user(s)) // read user timer LSW\n\n            ret = s->count & 0xffffffe00;\n\n        else // read limit\n\n            ret = (s->count & 0x7ffffe00) | s->reached;\n\n        break;\n\n    case 3:\n\n        // only available in processor counter/timer\n\n        // read start/stop status\n\n        ret = s->running;\n\n        break;\n\n    case 4:\n\n        // only available in system counter\n\n        // read user/system mode\n\n        ret = s->slave_mode;\n\n        break;\n\n    default:\n\n        DPRINTF(\"invalid read address \" TARGET_FMT_plx \"\\n\", addr);\n\n        ret = 0;\n\n        break;\n\n    }\n\n    DPRINTF(\"read \" TARGET_FMT_plx \" = %08x\\n\", addr, ret);\n\n\n\n    return ret;\n\n}\n", "idx": 22105}
{"project": "qemu", "commit_id": "9abc62f6445795522d1bf5bf17f642e44eaf032d", "target": 0, "func": "void qemu_system_suspend_request(void)\n\n{\n\n    if (is_suspended) {\n\n        return;\n\n    }\n\n    suspend_requested = 1;\n\n    cpu_stop_current();\n\n    qemu_notify_event();\n\n}\n", "idx": 22109}
{"project": "qemu", "commit_id": "89dbe18089127cf90993359096b659ea6f819848", "target": 0, "func": "static void ssh_parse_filename(const char *filename, QDict *options,\n\n                               Error **errp)\n\n{\n\n    if (qdict_haskey(options, \"user\") ||\n\n        qdict_haskey(options, \"host\") ||\n\n        qdict_haskey(options, \"port\") ||\n\n        qdict_haskey(options, \"path\") ||\n\n        qdict_haskey(options, \"host_key_check\")) {\n\n        error_setg(errp, \"user, host, port, path, host_key_check cannot be used at the same time as a file option\");\n\n        return;\n\n    }\n\n\n\n    parse_uri(filename, options, errp);\n\n}\n", "idx": 22119}
{"project": "FFmpeg", "commit_id": "1c37848f9029985d1271da9a0d161c2ebf0aca81", "target": 1, "func": "static int webm_dash_manifest_write_header(AVFormatContext *s)\n\n{\n\n    int i;\n\n    double start = 0.0;\n\n    WebMDashMuxContext *w = s->priv_data;\n\n    parse_adaptation_sets(s);\n\n    write_header(s);\n\n    avio_printf(s->pb, \"<Period id=\\\"0\\\"\");\n\n    avio_printf(s->pb, \" start=\\\"PT%gS\\\"\", start);\n\n    if (!w->is_live) {\n\n        avio_printf(s->pb, \" duration=\\\"PT%gS\\\"\", get_duration(s));\n\n    }\n\n    avio_printf(s->pb, \" >\\n\");\n\n\n\n    for (i = 0; i < w->nb_as; i++) {\n\n        if (write_adaptation_set(s, i) < 0) return -1;\n\n    }\n\n\n\n    avio_printf(s->pb, \"</Period>\\n\");\n\n    write_footer(s);\n\n    return 0;\n\n}\n", "idx": 22124}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void do_acl_show(Monitor *mon, const QDict *qdict)\n\n{\n\n    const char *aclname = qdict_get_str(qdict, \"aclname\");\n\n    qemu_acl *acl = find_acl(mon, aclname);\n\n    qemu_acl_entry *entry;\n\n    int i = 0;\n\n\n\n    if (acl) {\n\n        monitor_printf(mon, \"policy: %s\\n\",\n\n                       acl->defaultDeny ? \"deny\" : \"allow\");\n\n        TAILQ_FOREACH(entry, &acl->entries, next) {\n\n            i++;\n\n            monitor_printf(mon, \"%d: %s %s\\n\", i,\n\n                           entry->deny ? \"deny\" : \"allow\", entry->match);\n\n        }\n\n    }\n\n}\n", "idx": 22142}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "MemoryRegionSection *phys_page_find(AddressSpaceDispatch *d, target_phys_addr_t index)\n\n{\n\n    PhysPageEntry lp = d->phys_map;\n\n    PhysPageEntry *p;\n\n    int i;\n\n    uint16_t s_index = phys_section_unassigned;\n\n\n\n    for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) {\n\n        if (lp.ptr == PHYS_MAP_NODE_NIL) {\n\n            goto not_found;\n\n        }\n\n        p = phys_map_nodes[lp.ptr];\n\n        lp = p[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n\n\n    s_index = lp.ptr;\n\nnot_found:\n\n    return &phys_sections[s_index];\n\n}\n", "idx": 22143}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int drive_get_max_bus(BlockInterfaceType type)\n\n{\n\n    int max_bus;\n\n    DriveInfo *dinfo;\n\n\n\n    max_bus = -1;\n\n    TAILQ_FOREACH(dinfo, &drives, next) {\n\n        if(dinfo->type == type &&\n\n           dinfo->bus > max_bus)\n\n            max_bus = dinfo->bus;\n\n    }\n\n    return max_bus;\n\n}\n", "idx": 22184}
{"project": "qemu", "commit_id": "c021f8e65f5009a5ab5711d9d5326fcab553ef1c", "target": 0, "func": "PCIBus *pci_find_bus(PCIBus *bus, int bus_num)\n\n{\n\n    PCIBus *sec;\n\n\n\n    if (!bus)\n\n        return NULL;\n\n\n\n    if (pci_bus_num(bus) == bus_num) {\n\n        return bus;\n\n    }\n\n\n\n    /* try child bus */\n\n    QLIST_FOREACH(sec, &bus->child, sibling) {\n\n\n\n        if (!bus->parent_dev /* pci host bridge */\n\n            || (pci_bus_num(sec) <= bus_num &&\n\n                bus->parent_dev->config[PCI_SUBORDINATE_BUS])) {\n\n            return pci_find_bus(sec, bus_num);\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 22187}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "ser_write(void *opaque, target_phys_addr_t addr,\n\n          uint64_t val64, unsigned int size)\n\n{\n\n    struct etrax_serial *s = opaque;\n\n    uint32_t value = val64;\n\n    unsigned char ch = val64;\n\n    D(CPUCRISState *env = s->env);\n\n\n\n    D(qemu_log(\"%s \" TARGET_FMT_plx \"=%x\\n\",  __func__, addr, value));\n\n    addr >>= 2;\n\n    switch (addr)\n\n    {\n\n        case RW_DOUT:\n\n            qemu_chr_fe_write(s->chr, &ch, 1);\n\n            s->regs[R_INTR] |= 3;\n\n            s->pending_tx = 1;\n\n            s->regs[addr] = value;\n\n            break;\n\n        case RW_ACK_INTR:\n\n            if (s->pending_tx) {\n\n                value &= ~1;\n\n                s->pending_tx = 0;\n\n                D(qemu_log(\"fixedup value=%x r_intr=%x\\n\",\n\n                           value, s->regs[R_INTR]));\n\n            }\n\n            s->regs[addr] = value;\n\n            s->regs[R_INTR] &= ~value;\n\n            D(printf(\"r_intr=%x\\n\", s->regs[R_INTR]));\n\n            break;\n\n        default:\n\n            s->regs[addr] = value;\n\n            break;\n\n    }\n\n    ser_update_irq(s);\n\n}\n", "idx": 22189}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_addq_lo(DisasContext *s, TCGv val, int rlow)\n\n{\n\n    TCGv tmp;\n\n    TCGv tmp2;\n\n\n\n    /* Load value and extend to 64 bits.  */\n\n    tmp = tcg_temp_new(TCG_TYPE_I64);\n\n    tmp2 = load_reg(s, rlow);\n\n    tcg_gen_extu_i32_i64(tmp, tmp2);\n\n    dead_tmp(tmp2);\n\n    tcg_gen_add_i64(val, val, tmp);\n\n}\n", "idx": 22213}
{"project": "qemu", "commit_id": "d2d979c628e4b2c4a3cb71a31841875795c79043", "target": 1, "func": "static void nbd_close(BlockDriverState *bs)\n{\n    nbd_teardown_connection(bs);\n}", "idx": 22223}
{"project": "qemu", "commit_id": "5cbab1bfdeab274e5d4e3353fa626ba8697eed10", "target": 1, "func": "static void kvm_s390_flic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    KVMS390FLICState *flic_state = KVM_S390_FLIC(dev);\n\n    struct kvm_create_device cd = {0};\n\n    struct kvm_device_attr test_attr = {0};\n\n    int ret;\n\n    Error *errp_local = NULL;\n\n\n\n\n\n\n\n    flic_state->fd = -1;\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_DEVICE_CTRL)) {\n\n        error_setg_errno(&errp_local, errno, \"KVM is missing capability\"\n\n                         \" KVM_CAP_DEVICE_CTRL\");\n\n        trace_flic_no_device_api(errno);\n\n\n\n\n\n    cd.type = KVM_DEV_TYPE_FLIC;\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_CREATE_DEVICE, &cd);\n\n    if (ret < 0) {\n\n        error_setg_errno(&errp_local, errno, \"Creating the KVM device failed\");\n\n        trace_flic_create_device(errno);\n\n\n\n    flic_state->fd = cd.fd;\n\n\n\n    /* Check clear_io_irq support */\n\n    test_attr.group = KVM_DEV_FLIC_CLEAR_IO_IRQ;\n\n    flic_state->clear_io_supported = !ioctl(flic_state->fd,\n\n                                            KVM_HAS_DEVICE_ATTR, test_attr);\n\n\n\n    return;\n\nfail:\n\n    error_propagate(errp, errp_local);\n", "idx": 22236}
{"project": "qemu", "commit_id": "a86156401559cb4401cf9ecc704faeab6fc8bb19", "target": 1, "func": "static void test_visitor_out_empty(TestOutputVisitorData *data,\n\n                                   const void *unused)\n\n{\n\n    QObject *arg;\n\n\n\n    arg = qmp_output_get_qobject(data->qov);\n\n    g_assert(qobject_type(arg) == QTYPE_QNULL);\n\n\n\n    qobject_decref(arg);\n\n}", "idx": 22244}
{"project": "qemu", "commit_id": "2531088f6c1ce1f620f8d5a545f0af95598e69fc", "target": 1, "func": "uint32_t gic_acknowledge_irq(GICState *s, int cpu, MemTxAttrs attrs)\n\n{\n\n    int ret, irq, src;\n\n    int cm = 1 << cpu;\n\n\n\n    /* gic_get_current_pending_irq() will return 1022 or 1023 appropriately\n\n     * for the case where this GIC supports grouping and the pending interrupt\n\n     * is in the wrong group.\n\n     */\n\n    irq = gic_get_current_pending_irq(s, cpu, attrs);\n\n\n\n\n    if (irq >= GIC_MAXIRQ) {\n\n        DPRINTF(\"ACK, no pending interrupt or it is hidden: %d\\n\", irq);\n\n        return irq;\n\n    }\n\n\n\n    if (GIC_GET_PRIORITY(irq, cpu) >= s->running_priority[cpu]) {\n\n        DPRINTF(\"ACK, pending interrupt (%d) has insufficient priority\\n\", irq);\n\n        return 1023;\n\n    }\n\n\n\n    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n        /* Clear pending flags for both level and edge triggered interrupts.\n\n         * Level triggered IRQs will be reasserted once they become inactive.\n\n         */\n\n        GIC_CLEAR_PENDING(irq, GIC_TEST_MODEL(irq) ? ALL_CPU_MASK : cm);\n\n        ret = irq;\n\n    } else {\n\n        if (irq < GIC_NR_SGIS) {\n\n            /* Lookup the source CPU for the SGI and clear this in the\n\n             * sgi_pending map.  Return the src and clear the overall pending\n\n             * state on this CPU if the SGI is not pending from any CPUs.\n\n             */\n\n            assert(s->sgi_pending[irq][cpu] != 0);\n\n            src = ctz32(s->sgi_pending[irq][cpu]);\n\n            s->sgi_pending[irq][cpu] &= ~(1 << src);\n\n            if (s->sgi_pending[irq][cpu] == 0) {\n\n                GIC_CLEAR_PENDING(irq, GIC_TEST_MODEL(irq) ? ALL_CPU_MASK : cm);\n\n            }\n\n            ret = irq | ((src & 0x7) << 10);\n\n        } else {\n\n            /* Clear pending state for both level and edge triggered\n\n             * interrupts. (level triggered interrupts with an active line\n\n             * remain pending, see gic_test_pending)\n\n             */\n\n            GIC_CLEAR_PENDING(irq, GIC_TEST_MODEL(irq) ? ALL_CPU_MASK : cm);\n\n            ret = irq;\n\n        }\n\n    }\n\n\n\n    gic_activate_irq(s, cpu, irq);\n\n    gic_update(s);\n\n    DPRINTF(\"ACK %d\\n\", irq);\n\n    return ret;\n\n}", "idx": 22261}
{"project": "FFmpeg", "commit_id": "cbba331aa02f29870581ff0b7ded7477b279ae2c", "target": 0, "func": "static inline int writer_print_string(WriterContext *wctx,\n\n                                      const char *key, const char *val, int opt)\n\n{\n\n    const struct section *section = wctx->section[wctx->level];\n\n    int ret = 0;\n\n\n\n    if (opt && !(wctx->writer->flags & WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS))\n\n        return 0;\n\n\n\n    if (section->show_all_entries || av_dict_get(section->entries_to_show, key, NULL, 0)) {\n\n        wctx->writer->print_string(wctx, key, val);\n\n        wctx->nb_item[wctx->level]++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22273}
{"project": "qemu", "commit_id": "0e7b176ae01d5a664d4cbf619a7315819494e6cb", "target": 0, "func": "static void aarch64_any_initfn(Object *obj)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(obj);\n\n\n\n    set_feature(&cpu->env, ARM_FEATURE_V8);\n\n    set_feature(&cpu->env, ARM_FEATURE_VFP4);\n\n    set_feature(&cpu->env, ARM_FEATURE_NEON);\n\n    set_feature(&cpu->env, ARM_FEATURE_AARCH64);\n\n    set_feature(&cpu->env, ARM_FEATURE_V8_AES);\n\n    set_feature(&cpu->env, ARM_FEATURE_V8_SHA1);\n\n    set_feature(&cpu->env, ARM_FEATURE_V8_SHA256);\n\n    set_feature(&cpu->env, ARM_FEATURE_V8_PMULL);\n\n    set_feature(&cpu->env, ARM_FEATURE_CRC);\n\n    cpu->ctr = 0x80030003; /* 32 byte I and D cacheline size, VIPT icache */\n\n    cpu->dcz_blocksize = 7; /*  512 bytes */\n\n}\n", "idx": 22291}
{"project": "qemu", "commit_id": "82342e91b60a4a078811df4e1a545e57abffa11d", "target": 1, "func": "e1000e_set_icr(E1000ECore *core, int index, uint32_t val)\n\n{\n\n    if ((core->mac[ICR] & E1000_ICR_ASSERTED) &&\n\n        (core->mac[CTRL_EXT] & E1000_CTRL_EXT_IAME)) {\n\n        trace_e1000e_irq_icr_process_iame();\n\n        e1000e_clear_ims_bits(core, core->mac[IAM]);\n\n    }\n\n\n\n    trace_e1000e_irq_icr_write(val, core->mac[ICR], core->mac[ICR] & ~val);\n\n    core->mac[ICR] &= ~val;\n\n    e1000e_update_interrupt_state(core);\n\n}\n", "idx": 22315}
{"project": "qemu", "commit_id": "ac1970fbe8ad5a70174f462109ac0f6c7bf1bc43", "target": 0, "func": "MemoryRegionSection *phys_page_find(target_phys_addr_t index)\n\n{\n\n    PhysPageEntry lp = phys_map;\n\n    PhysPageEntry *p;\n\n    int i;\n\n    uint16_t s_index = phys_section_unassigned;\n\n\n\n    for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) {\n\n        if (lp.ptr == PHYS_MAP_NODE_NIL) {\n\n            goto not_found;\n\n        }\n\n        p = phys_map_nodes[lp.ptr];\n\n        lp = p[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];\n\n    }\n\n\n\n    s_index = lp.ptr;\n\nnot_found:\n\n    return &phys_sections[s_index];\n\n}\n", "idx": 22331}
{"project": "qemu", "commit_id": "ef76dc59fa5203d146a2acf85a0ad5a5971a4824", "target": 0, "func": "START_TEST(float_number)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        double decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"32.43\", 32.43 },\n\n        { \"0.222\", 0.222 },\n\n        { \"-32.12313\", -32.12313 },\n\n        { \"-32.20e-10\", -32.20e-10, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QFloat *qfloat;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded);\n\n        fail_unless(obj != NULL);\n\n        fail_unless(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n        qfloat = qobject_to_qfloat(obj);\n\n        fail_unless(qfloat_get_double(qfloat) == test_cases[i].decoded);\n\n\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(obj);\n\n            fail_unless(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qfloat);\n\n    }\n\n}\n", "idx": 22334}
{"project": "qemu", "commit_id": "488d65772ce94aa439f26d7136db384aec460bcb", "target": 1, "func": "static void check_watchpoint(int offset, int len_mask, int flags)\n\n{\n\n    CPUState *env = cpu_single_env;\n\n    target_ulong pc, cs_base;\n\n    TranslationBlock *tb;\n\n    target_ulong vaddr;\n\n    CPUWatchpoint *wp;\n\n    int cpu_flags;\n\n\n\n    if (env->watchpoint_hit) {\n\n        /* We re-entered the check after replacing the TB. Now raise\n\n         * the debug interrupt so that is will trigger after the\n\n         * current instruction. */\n\n        cpu_interrupt(env, CPU_INTERRUPT_DEBUG);\n\n        return;\n\n    }\n\n    vaddr = (env->mem_io_vaddr & TARGET_PAGE_MASK) + offset;\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if ((vaddr == (wp->vaddr & len_mask) ||\n\n             (vaddr & wp->len_mask) == wp->vaddr) && (wp->flags & flags)) {\n\n            wp->flags |= BP_WATCHPOINT_HIT;\n\n            if (!env->watchpoint_hit) {\n\n                env->watchpoint_hit = wp;\n\n                tb = tb_find_pc(env->mem_io_pc);\n\n                if (!tb) {\n\n                    cpu_abort(env, \"check_watchpoint: could not find TB for \"\n\n                              \"pc=%p\", (void *)env->mem_io_pc);\n\n                }\n\n                cpu_restore_state(tb, env, env->mem_io_pc);\n\n                tb_phys_invalidate(tb, -1);\n\n                if (wp->flags & BP_STOP_BEFORE_ACCESS) {\n\n                    env->exception_index = EXCP_DEBUG;\n\n                } else {\n\n                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);\n\n                    tb_gen_code(env, pc, cs_base, cpu_flags, 1);\n\n                }\n\n                cpu_resume_from_signal(env, NULL);\n\n            }\n\n        } else {\n\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n\n        }\n\n    }\n\n}\n", "idx": 22350}
{"project": "qemu", "commit_id": "d4370741402a97b8b6d0c38fef18ab38bf25ab22", "target": 1, "func": "static gboolean gd_vc_in(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    uint8_t buffer[1024];\n\n    ssize_t len;\n\n\n\n    len = read(vc->fd, buffer, sizeof(buffer));\n\n    if (len <= 0) {\n\n        return FALSE;\n\n    }\n\n\n\n    qemu_chr_be_write(vc->chr, buffer, len);\n\n\n\n    return TRUE;\n\n}\n", "idx": 22368}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static void vnc_write_s32(VncState *vs, int32_t value)\n\n{\n\n    vnc_write_u32(vs, *(uint32_t *)&value);\n\n}\n", "idx": 22415}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static int vnc_zlib_stop(VncState *vs)\n\n{\n\n    z_streamp zstream = &vs->zlib_stream;\n\n    int previous_out;\n\n\n\n    // switch back to normal output/zlib buffers\n\n    vs->zlib = vs->output;\n\n    vs->output = vs->zlib_tmp;\n\n\n\n    // compress the zlib buffer\n\n\n\n    // initialize the stream\n\n    // XXX need one stream per session\n\n    if (zstream->opaque != vs) {\n\n        int err;\n\n\n\n        VNC_DEBUG(\"VNC: initializing zlib stream\\n\");\n\n        VNC_DEBUG(\"VNC: opaque = %p | vs = %p\\n\", zstream->opaque, vs);\n\n        zstream->zalloc = vnc_zlib_zalloc;\n\n        zstream->zfree = vnc_zlib_zfree;\n\n\n\n        err = deflateInit2(zstream, vs->tight_compression, Z_DEFLATED, MAX_WBITS,\n\n                           MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n\n\n\n        if (err != Z_OK) {\n\n            fprintf(stderr, \"VNC: error initializing zlib\\n\");\n\n            return -1;\n\n        }\n\n\n\n        vs->zlib_level = vs->tight_compression;\n\n        zstream->opaque = vs;\n\n    }\n\n\n\n    if (vs->tight_compression != vs->zlib_level) {\n\n        if (deflateParams(zstream, vs->tight_compression,\n\n                          Z_DEFAULT_STRATEGY) != Z_OK) {\n\n            return -1;\n\n        }\n\n        vs->zlib_level = vs->tight_compression;\n\n    }\n\n\n\n    // reserve memory in output buffer\n\n    buffer_reserve(&vs->output, vs->zlib.offset + 64);\n\n\n\n    // set pointers\n\n    zstream->next_in = vs->zlib.buffer;\n\n    zstream->avail_in = vs->zlib.offset;\n\n    zstream->next_out = vs->output.buffer + vs->output.offset;\n\n    zstream->avail_out = vs->output.capacity - vs->output.offset;\n\n    zstream->data_type = Z_BINARY;\n\n    previous_out = zstream->total_out;\n\n\n\n    // start encoding\n\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n\n        fprintf(stderr, \"VNC: error during zlib compression\\n\");\n\n        return -1;\n\n    }\n\n\n\n    vs->output.offset = vs->output.capacity - zstream->avail_out;\n\n    return zstream->total_out - previous_out;\n\n}\n", "idx": 22423}
{"project": "FFmpeg", "commit_id": "dbe29db8cb09fb39bd8dc5b25934e92279d0aa8d", "target": 1, "func": "static int skip_data_stream_element(AACContext *ac, GetBitContext *gb)\n\n{\n\n    int byte_align = get_bits1(gb);\n\n    int count = get_bits(gb, 8);\n\n    if (count == 255)\n\n        count += get_bits(gb, 8);\n\n    if (byte_align)\n\n        align_get_bits(gb);\n\n\n\n    if (get_bits_left(gb) < 8 * count) {\n\n        av_log(ac->avctx, AV_LOG_ERROR, overread_err);\n\n        return -1;\n\n    }\n\n    skip_bits_long(gb, 8 * count);\n\n    return 0;\n\n}\n", "idx": 22442}
{"project": "FFmpeg", "commit_id": "c90b88090c260a0af018b6c1e955266e24ebf6f4", "target": 1, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *inbuf)\n\n{\n\n    AudioPhaserContext *s = inlink->dst->priv;\n\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n\n    AVFrame *outbuf;\n\n\n\n    if (av_frame_is_writable(inbuf)) {\n\n        outbuf = inbuf;\n\n    } else {\n\n        outbuf = ff_get_audio_buffer(inlink, inbuf->nb_samples);\n\n        if (!outbuf)\n\n            return AVERROR(ENOMEM);\n\n        av_frame_copy_props(outbuf, inbuf);\n\n    }\n\n\n\n    s->phaser(s, inbuf->extended_data, outbuf->extended_data,\n\n              outbuf->nb_samples, outbuf->channels);\n\n\n\n    if (inbuf != outbuf)\n\n        av_frame_free(&inbuf);\n\n\n\n    return ff_filter_frame(outlink, outbuf);\n\n}\n", "idx": 22445}
{"project": "FFmpeg", "commit_id": "2c1e075308e14810149f53be87959a62cb83a730", "target": 0, "func": "flac_header (AVFormatContext * s, int idx)\n\n{\n\n    struct ogg *ogg = s->priv_data;\n\n    struct ogg_stream *os = ogg->streams + idx;\n\n    AVStream *st = s->streams[idx];\n\n    GetBitContext gb;\n\n    FLACStreaminfo si;\n\n    int mdt;\n\n\n\n    if (os->buf[os->pstart] == 0xff)\n\n        return 0;\n\n\n\n    init_get_bits(&gb, os->buf + os->pstart, os->psize*8);\n\n    skip_bits1(&gb); /* metadata_last */\n\n    mdt = get_bits(&gb, 7);\n\n\n\n    if (mdt == OGG_FLAC_METADATA_TYPE_STREAMINFO) {\n\n        uint8_t *streaminfo_start = os->buf + os->pstart + 5 + 4 + 4 + 4;\n\n        skip_bits_long(&gb, 4*8); /* \"FLAC\" */\n\n        if(get_bits(&gb, 8) != 1) /* unsupported major version */\n\n            return -1;\n\n        skip_bits_long(&gb, 8 + 16); /* minor version + header count */\n\n        skip_bits_long(&gb, 4*8); /* \"fLaC\" */\n\n\n\n        /* METADATA_BLOCK_HEADER */\n\n        if (get_bits_long(&gb, 32) != FLAC_STREAMINFO_SIZE)\n\n            return -1;\n\n\n\n        avpriv_flac_parse_streaminfo(st->codec, &si, streaminfo_start);\n\n\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id = AV_CODEC_ID_FLAC;\n\n        st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n\n\n        ff_alloc_extradata(st->codec, FLAC_STREAMINFO_SIZE);\n\n        memcpy(st->codec->extradata, streaminfo_start, st->codec->extradata_size);\n\n\n\n        avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n    } else if (mdt == FLAC_METADATA_TYPE_VORBIS_COMMENT) {\n\n        ff_vorbis_comment (s, &st->metadata, os->buf + os->pstart + 4, os->psize - 4);\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 22458}
{"project": "qemu", "commit_id": "4828b10bda6a74a22a7695303e0648157d0e3ea4", "target": 0, "func": "void acpi_memory_plug_cb(ACPIREGS *ar, qemu_irq irq, MemHotplugState *mem_st,\n\n                         DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    mdev->dimm = dev;\n\n    mdev->is_enabled = true;\n\n    mdev->is_inserting = true;\n\n\n\n    /* do ACPI magic */\n\n    acpi_send_gpe_event(ar, irq, ACPI_MEMORY_HOTPLUG_STATUS);\n\n    return;\n\n}\n", "idx": 22477}
{"project": "FFmpeg", "commit_id": "e5540b3fd30367ce3cc33b2f34a04b660dbc4b38", "target": 0, "func": "static int decode_i_picture_header(VC9Context *v)\n\n{\n\n  int pqindex, status = 0, ac_pred, condover;\n\n\n\n    /* Prolog common to all frametypes should be done in caller */\n\n    //BF = Buffer Fullness\n\n    if (v->profile <= PROFILE_MAIN && get_bits(&v->gb, 7))\n\n    {\n\n        av_log(v, AV_LOG_DEBUG, \"I BufferFullness not 0\\n\");\n\n    }\n\n\n\n    /* Quantizer stuff */\n\n    pqindex = get_bits(&v->gb, 5);\n\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n\n        v->pq = pquant_table[0][pqindex];\n\n    else\n\n    {\n\n        v->pq = pquant_table[v->quantizer_mode-1][pqindex];\n\n    }\n\n    if (pqindex < 9) v->halfpq = get_bits(&v->gb, 1);\n\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n\n        v->pquantizer = get_bits(&v->gb, 1);\n\n    av_log(v->avctx, AV_LOG_DEBUG, \"I frame: QP=%i (+%i/2)\\n\",\n\n           v->pq, v->halfpq);\n\n#if HAS_ADVANCED_PROFILE\n\n    if (v->profile <= PROFILE_MAIN)\n\n#endif\n\n    {\n\n        if (v->extended_mv) v->mvrange = get_prefix(&v->gb, 0, 3);\n\n        if (v->multires) v->respic = get_bits(&v->gb, 2);\n\n    }\n\n#if HAS_ADVANCED_PROFILE\n\n    else\n\n    {\n\n        ac_pred = get_bits(&v->gb, 1);\n\n        if (v->postprocflag) v->postproc = get_bits(&v->gb, 1);\n\n        /* 7.1.1.34 + 8.5.2 */\n\n        if (v->overlap && v->pq<9)\n\n        {\n\n            condover = get_bits(&v->gb, 1);\n\n            if (condover)\n\n            {\n\n                condover = 2+get_bits(&v->gb, 1);\n\n                if (condover == 3)\n\n                    status = bitplane_decoding(v->over_flags_plane,\n\n                                                   v->width_mb, v->height_mb, v);\n\n            }\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Epilog should be done in caller */\n\n    return status;\n\n}\n", "idx": 22479}
{"project": "qemu", "commit_id": "dd4d607e40dcd2cb7646b510504880a70939d91b", "target": 0, "func": "static int vtd_page_walk(VTDContextEntry *ce, uint64_t start, uint64_t end,\n\n                         vtd_page_walk_hook hook_fn, void *private)\n\n{\n\n    dma_addr_t addr = vtd_get_slpt_base_from_context(ce);\n\n    uint32_t level = vtd_get_level_from_context_entry(ce);\n\n\n\n    if (!vtd_iova_range_check(start, ce)) {\n\n        return -VTD_FR_ADDR_BEYOND_MGAW;\n\n    }\n\n\n\n    if (!vtd_iova_range_check(end, ce)) {\n\n        /* Fix end so that it reaches the maximum */\n\n        end = vtd_iova_limit(ce);\n\n    }\n\n\n\n    return vtd_page_walk_level(addr, start, end, hook_fn, private,\n\n                               level, true, true, false);\n\n}\n", "idx": 22482}
{"project": "qemu", "commit_id": "08844473820c93541fc47bdfeae0f2cc88cfab59", "target": 0, "func": "static int coroutine_fn bdrv_co_readv_em(BlockDriverState *bs,\n\n                                         int64_t sector_num, int nb_sectors,\n\n                                         QEMUIOVector *iov)\n\n{\n\n    return bdrv_co_io_em(bs, sector_num, nb_sectors, iov, false);\n\n}\n", "idx": 22483}
{"project": "FFmpeg", "commit_id": "0491a2a07a44f6e5e6f34081835e402c07025fd2", "target": 0, "func": "static char *time_value_string(char *buf, int buf_size, int64_t val, const AVRational *time_base)\n\n{\n\n    if (val == AV_NOPTS_VALUE) {\n\n        snprintf(buf, buf_size, \"N/A\");\n\n    } else {\n\n        double d = val * av_q2d(*time_base);\n\n        value_string(buf, buf_size, (struct unit_value){.val.d=d, .unit=unit_second_str});\n\n    }\n\n\n\n    return buf;\n\n}\n", "idx": 22511}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void t_gen_cc_jmp(TCGv pc_true, TCGv pc_false)\n\n{\n\n\tTCGv btaken;\n\n\tint l1;\n\n\n\n\tl1 = gen_new_label();\n\n\tbtaken = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t/* Conditional jmp.  */\n\n\ttcg_gen_mov_tl(btaken, env_btaken);\n\n\ttcg_gen_mov_tl(env_pc, pc_false);\n\n\ttcg_gen_brcondi_tl(TCG_COND_EQ, btaken, 0, l1);\n\n\ttcg_gen_mov_tl(env_pc, pc_true);\n\n\tgen_set_label(l1);\n\n\n\n\ttcg_temp_free(btaken);\n\n}\n", "idx": 22546}
{"project": "qemu", "commit_id": "958c717df97ea9ca47a2253b8371130fe5f22980", "target": 0, "func": "NBDClient *nbd_client_new(NBDExport *exp, int csock,\n\n                          void (*close)(NBDClient *))\n\n{\n\n    NBDClient *client;\n\n    client = g_malloc0(sizeof(NBDClient));\n\n    client->refcount = 1;\n\n    client->exp = exp;\n\n    client->sock = csock;\n\n    if (nbd_send_negotiate(client)) {\n\n        g_free(client);\n\n        return NULL;\n\n    }\n\n    client->close = close;\n\n    qemu_co_mutex_init(&client->send_lock);\n\n    qemu_set_fd_handler2(csock, nbd_can_read, nbd_read, NULL, client);\n\n\n\n    if (exp) {\n\n        QTAILQ_INSERT_TAIL(&exp->clients, client, next);\n\n        nbd_export_get(exp);\n\n    }\n\n    return client;\n\n}\n", "idx": 22547}
{"project": "FFmpeg", "commit_id": "625b582d5a9196c582e7702b542b3e0face30ccf", "target": 0, "func": "static int read_sbr_single_channel_element(AACContext *ac,\n\n                                            SpectralBandReplication *sbr,\n\n                                            GetBitContext *gb)\n\n{\n\n    int ret;\n\n\n\n    if (get_bits1(gb)) // bs_data_extra\n\n        skip_bits(gb, 4); // bs_reserved\n\n\n\n    if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]))\n\n        return -1;\n\n    read_sbr_dtdf(sbr, gb, &sbr->data[0]);\n\n    read_sbr_invf(sbr, gb, &sbr->data[0]);\n\n    read_sbr_envelope(sbr, gb, &sbr->data[0], 0);\n\n    if((ret = read_sbr_noise(ac, sbr, gb, &sbr->data[0], 0)) < 0)\n\n        return ret;\n\n\n\n    if ((sbr->data[0].bs_add_harmonic_flag = get_bits1(gb)))\n\n        get_bits1_vector(gb, sbr->data[0].bs_add_harmonic, sbr->n[1]);\n\n\n\n    return 0;\n\n}\n", "idx": 22565}
{"project": "FFmpeg", "commit_id": "29ba091136a5e04574f7bfc1b17536c923958f6f", "target": 0, "func": "const char *swscale_configuration(void)\n\n{\n\n    return FFMPEG_CONFIGURATION;\n\n}\n", "idx": 22573}
{"project": "FFmpeg", "commit_id": "a2f7314ba231cde459c4f33f1a7602ae9d9d2d28", "target": 1, "func": "static inline void RENAME(duplicate)(uint8_t src[], int stride)\n\n{\n\n#if TEMPLATE_PP_MMX\n\n    __asm__ volatile(\n\n        \"movq (%0), %%mm0               \\n\\t\"\n\n        \"add %1, %0                     \\n\\t\"\n\n        \"movq %%mm0, (%0)               \\n\\t\"\n\n        \"movq %%mm0, (%0, %1)           \\n\\t\"\n\n        \"movq %%mm0, (%0, %1, 2)        \\n\\t\"\n\n        : \"+r\" (src)\n\n        : \"r\" ((x86_reg)-stride)\n\n    );\n\n#else\n\n    int i;\n\n    uint8_t *p=src;\n\n    for(i=0; i<3; i++){\n\n        p-= stride;\n\n        memcpy(p, src, 8);\n\n    }\n\n#endif\n\n}\n", "idx": 22591}
{"project": "qemu", "commit_id": "b53dd4495ced2432a0b652ea895e651d07336f7e", "target": 1, "func": "static void usb_xhci_exit(PCIDevice *dev)\n\n{\n\n    int i;\n\n    XHCIState *xhci = XHCI(dev);\n\n\n\n    trace_usb_xhci_exit();\n\n\n\n    for (i = 0; i < xhci->numslots; i++) {\n\n        xhci_disable_slot(xhci, i + 1);\n\n    }\n\n\n\n    if (xhci->mfwrap_timer) {\n\n        timer_del(xhci->mfwrap_timer);\n\n        timer_free(xhci->mfwrap_timer);\n\n        xhci->mfwrap_timer = NULL;\n\n    }\n\n\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n\n\n\n    for (i = 0; i < xhci->numports; i++) {\n\n        XHCIPort *port = &xhci->ports[i];\n\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n\n    }\n\n\n\n    /* destroy msix memory region */\n\n    if (dev->msix_table && dev->msix_pba\n\n        && dev->msix_entry_used) {\n\n        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);\n\n        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);\n\n    }\n\n\n\n    usb_bus_release(&xhci->bus);\n\n}\n", "idx": 22619}
{"project": "FFmpeg", "commit_id": "87ecefdab0097537c5c30014e57b19113ab05eee", "target": 1, "func": "static void evaluate_utility_inc(elbg_data *elbg)\n\n{\n\n    int i, inc=0;\n\n\n\n    for (i=0; i < elbg->numCB; i++) {\n\n        if (elbg->numCB*elbg->utility[i] > elbg->error)\n\n            inc += elbg->utility[i];\n\n        elbg->utility_inc[i] = inc;\n\n    }\n\n}\n", "idx": 22626}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int socket_get_fd(void *opaque)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n\n\n    return s->fd;\n\n}\n", "idx": 22666}
{"project": "qemu", "commit_id": "966439a67830239a6c520c5df6c55627b8153c8b", "target": 1, "func": "void do_addmeo_64 (void)\n\n{\n\n    T1 = T0;\n\n    T0 += xer_ca + (-1);\n\n    if (likely(!((uint64_t)T1 &\n\n                 ((uint64_t)T1 ^ (uint64_t)T0) & (1ULL << 63)))) {\n\n        xer_ov = 0;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n    }\n\n    if (likely(T1 != 0))\n\n        xer_ca = 1;\n\n}\n", "idx": 22688}
{"project": "FFmpeg", "commit_id": "88281a5256f0034451c09acab3aff44acb43c2a3", "target": 0, "func": "static int nppscale_query_formats(AVFilterContext *ctx)\n\n{\n\n    static const enum AVPixelFormat pixel_formats[] = {\n\n        AV_PIX_FMT_CUDA, AV_PIX_FMT_NONE,\n\n    };\n\n    AVFilterFormats *pix_fmts  = ff_make_format_list(pixel_formats);\n\n\n\n    ff_set_common_formats(ctx, pix_fmts);\n\n\n\n    return 0;\n\n}\n", "idx": 22697}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "static void delete_next_frame(AudioFrameQueue *afq)\n\n{\n\n    AudioFrame *f = afq->frame_queue;\n\n    if (f) {\n\n        afq->frame_queue = f->next;\n\n        f->next = NULL;\n\n        av_freep(&f);\n\n    }\n\n}\n", "idx": 22699}
{"project": "FFmpeg", "commit_id": "083300bea935d125b83f60d7030f78a7ffb0f3df", "target": 1, "func": "int ff_thread_get_buffer(AVCodecContext *avctx, ThreadFrame *f, int flags)\n\n{\n\n    f->owner = avctx;\n\n    return ff_get_buffer(avctx, f->f, flags);\n\n}\n", "idx": 22710}
{"project": "qemu", "commit_id": "32c813e6c2a857b93b897901b7e20281397528a3", "target": 0, "func": "size_t qcrypto_cipher_get_key_len(QCryptoCipherAlgorithm alg)\n\n{\n\n    if (alg >= G_N_ELEMENTS(alg_key_len)) {\n\n        return 0;\n\n    }\n\n    return alg_key_len[alg];\n\n}\n", "idx": 22724}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void channel_load_g(struct fs_dma_ctrl *ctrl, int c)\n\n{\n\n\ttarget_phys_addr_t addr = channel_reg(ctrl, c, RW_GROUP);\n\n\n\n\t/* Load and decode. FIXME: handle endianness.  */\n\n\tcpu_physical_memory_read (addr, \n\n\t\t\t\t  (void *) &ctrl->channels[c].current_g, \n\n\t\t\t\t  sizeof ctrl->channels[c].current_g);\n\n}\n", "idx": 22753}
{"project": "qemu", "commit_id": "2c5b1d2a479273cec4c1be491745f48b0808b508", "target": 0, "func": "uint32_t HELPER(rer)(CPUXtensaState *env, uint32_t addr)\n\n{\n\n    return address_space_ldl(env->address_space_er, addr,\n\n                             (MemTxAttrs){0}, NULL);\n\n}\n", "idx": 22774}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void fw_cfg_data_mem_write(void *opaque, target_phys_addr_t addr,\n\n                                  uint64_t value, unsigned size)\n\n{\n\n    fw_cfg_write(opaque, (uint8_t)value);\n\n}\n", "idx": 22787}
{"project": "qemu", "commit_id": "4d9ebf751a5a98e5dc2e26baf2344e744f4fa7b9", "target": 0, "func": "static void do_cpu_reset(void *opaque)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    const struct arm_boot_info *info = env->boot_info;\n\n\n\n    cpu_reset(CPU(cpu));\n\n    if (info) {\n\n        if (!info->is_linux) {\n\n            /* Jump to the entry point.  */\n\n            env->regs[15] = info->entry & 0xfffffffe;\n\n            env->thumb = info->entry & 1;\n\n        } else {\n\n            if (CPU(cpu) == first_cpu) {\n\n                env->regs[15] = info->loader_start;\n\n                if (!info->dtb_filename) {\n\n                    if (old_param) {\n\n                        set_kernel_args_old(info);\n\n                    } else {\n\n                        set_kernel_args(info);\n\n                    }\n\n                }\n\n            } else {\n\n                info->secondary_cpu_reset_hook(cpu, info);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 22794}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void ff_msmpeg4_encode_init(MpegEncContext *s)\n\n{\n\n    static int init_done=0;\n\n    int i;\n\n\n\n    common_init(s);\n\n    if(s->msmpeg4_version>=4){\n\n        s->min_qcoeff= -255;\n\n        s->max_qcoeff=  255;\n\n    }\n\n\n\n    if (!init_done) {\n\n        /* init various encoding tables */\n\n        init_done = 1;\n\n        init_mv_table(&mv_tables[0]);\n\n        init_mv_table(&mv_tables[1]);\n\n        for(i=0;i<NB_RL_TABLES;i++)\n\n            init_rl(&rl_table[i]);\n\n\n\n        for(i=0; i<NB_RL_TABLES; i++){\n\n            int level;\n\n            for(level=0; level<=MAX_LEVEL; level++){\n\n                int run;\n\n                for(run=0; run<=MAX_RUN; run++){\n\n                    int last;\n\n                    for(last=0; last<2; last++){\n\n                        rl_length[i][level][run][last]= get_size_of_code(s, &rl_table[  i], last, run, level, 0);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 22811}
{"project": "FFmpeg", "commit_id": "4a6a29a7fbf023b19797c38a86099d9f81d25524", "target": 0, "func": "static int amr_nb_decode_frame(AVCodecContext *avctx, void *data,\n\n                               int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    AMRContext *s      = avctx->priv_data;\n\n    static const uint8_t block_size[16] = { 12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0 };\n\n    enum Mode dec_mode;\n\n    int packet_size;\n\n\n\n    av_dlog(avctx, \"amr_decode_frame buf=%p buf_size=%d frame_count=%d!!\\n\",\n\n            buf, buf_size, avctx->frame_number);\n\n\n\n    dec_mode    = (buf[0] >> 3) & 0x000F;\n\n    packet_size = block_size[dec_mode] + 1;\n\n\n\n    if (packet_size > buf_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"amr frame too short (%u, should be %u)\\n\",\n\n               buf_size, packet_size);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    av_dlog(avctx, \"packet_size=%d buf= 0x%X %X %X %X\\n\",\n\n              packet_size, buf[0], buf[1], buf[2], buf[3]);\n\n    /* call decoder */\n\n    Decoder_Interface_Decode(s->dec_state, buf, data, 0);\n\n    *data_size = 160 * 2;\n\n\n\n    return packet_size;\n\n}\n", "idx": 22822}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_h_loop_filter_chroma422_mbaff_msa(uint8_t *src,\n\n                                                  int32_t stride,\n\n                                                  int32_t alpha_in,\n\n                                                  int32_t beta_in,\n\n                                                  int8_t *tc0)\n\n{\n\n    int32_t col, tc_val;\n\n    int16_t out0, out1;\n\n    v16u8 alpha, beta, res;\n\n\n\n    alpha = (v16u8) __msa_fill_b(alpha_in);\n\n    beta = (v16u8) __msa_fill_b(beta_in);\n\n\n\n    for (col = 0; col < 4; col++) {\n\n        tc_val = (tc0[col] - 1) + 1;\n\n\n\n        if (tc_val <= 0) {\n\n            src += 4 * stride;\n\n            continue;\n\n        }\n\n\n\n        AVC_LPF_H_2BYTE_CHROMA_422(src, stride, tc_val, alpha, beta, res);\n\n\n\n        out0 = __msa_copy_s_h((v8i16) res, 0);\n\n        out1 = __msa_copy_s_h((v8i16) res, 1);\n\n\n\n        STORE_HWORD((src - 1), out0);\n\n        src += stride;\n\n        STORE_HWORD((src - 1), out1);\n\n        src += stride;\n\n    }\n\n}\n", "idx": 22825}
{"project": "FFmpeg", "commit_id": "a0a872d0733f60876b0c93f236bc4606f36fbf89", "target": 0, "func": "static void copy_cell(Indeo3DecodeContext *ctx, Plane *plane, Cell *cell)\n\n{\n\n    int     h, w, mv_x, mv_y, offset, offset_dst;\n\n    uint8_t *src, *dst;\n\n\n\n    /* setup output and reference pointers */\n\n    offset_dst  = (cell->ypos << 2) * plane->pitch + (cell->xpos << 2);\n\n    dst         = plane->pixels[ctx->buf_sel] + offset_dst;\n\n    mv_y        = cell->mv_ptr[0];\n\n    mv_x        = cell->mv_ptr[1];\n\n    offset      = offset_dst + mv_y * plane->pitch + mv_x;\n\n    src         = plane->pixels[ctx->buf_sel ^ 1] + offset;\n\n\n\n    h = cell->height << 2;\n\n\n\n    for (w = cell->width; w > 0;) {\n\n        /* copy using 16xH blocks */\n\n        if (!((cell->xpos << 2) & 15) && w >= 4) {\n\n            for (; w >= 4; src += 16, dst += 16, w -= 4)\n\n                ctx->dsp.put_no_rnd_pixels_tab[0][0](dst, src, plane->pitch, h);\n\n        }\n\n\n\n        /* copy using 8xH blocks */\n\n        if (!((cell->xpos << 2) & 7) && w >= 2) {\n\n            ctx->dsp.put_no_rnd_pixels_tab[1][0](dst, src, plane->pitch, h);\n\n            w -= 2;\n\n            src += 8;\n\n            dst += 8;\n\n        }\n\n\n\n        if (w >= 1) {\n\n            ctx->dsp.put_no_rnd_pixels_tab[2][0](dst, src, plane->pitch, h);\n\n            w--;\n\n            src += 4;\n\n            dst += 4;\n\n        }\n\n    }\n\n}\n", "idx": 22828}
{"project": "qemu", "commit_id": "cb5ef3fa1871522a0886627033459e94bd537fb7", "target": 1, "func": "static int tmp105_tx(I2CSlave *i2c, uint8_t data)\n\n{\n\n    TMP105State *s = (TMP105State *) i2c;\n\n\n\n    if (!s->len ++)\n\n        s->pointer = data;\n\n    else {\n\n        if (s->len <= 2)\n\n            s->buf[s->len - 1] = data;\n\n        tmp105_write(s);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22837}
{"project": "FFmpeg", "commit_id": "831274fba4b14c542458ce5a3d0135b49499299a", "target": 1, "func": "static void flac_lpc_16_c(int32_t *decoded, const int coeffs[32],\n\n                          int pred_order, int qlevel, int len)\n\n{\n\n    int i, j;\n\n\n\n    for (i = pred_order; i < len - 1; i += 2, decoded += 2) {\n\n        int c = coeffs[0];\n\n        int d = decoded[0];\n\n        int s0 = 0, s1 = 0;\n\n        for (j = 1; j < pred_order; j++) {\n\n            s0 += c*d;\n\n            d = decoded[j];\n\n            s1 += c*d;\n\n            c = coeffs[j];\n\n        }\n\n        s0 += c*d;\n\n        d = decoded[j] += s0 >> qlevel;\n\n        s1 += c*d;\n\n        decoded[j + 1] += s1 >> qlevel;\n\n    }\n\n    if (i < len) {\n\n        int sum = 0;\n\n        for (j = 0; j < pred_order; j++)\n\n            sum += coeffs[j] * decoded[j];\n\n        decoded[j] += sum >> qlevel;\n\n    }\n\n}\n", "idx": 22850}
{"project": "qemu", "commit_id": "215e79c01c4e6f766eb9add56c56453e9ea1d948", "target": 0, "func": "static bool cpu_thread_is_idle(CPUState *cpu)\n\n{\n\n    if (cpu->stop || cpu->queued_work_first) {\n\n        return false;\n\n    }\n\n    if (cpu->stopped || !runstate_is_running()) {\n\n        return true;\n\n    }\n\n    if (!cpu->halted || qemu_cpu_has_work(cpu) ||\n\n        kvm_async_interrupts_enabled()) {\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 22855}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static inline QEMUClock *qemu_clock_ptr(QEMUClockType type)\n\n{\n\n    return &qemu_clocks[type];\n\n}\n", "idx": 22867}
{"project": "FFmpeg", "commit_id": "9d0b45ade864f3d2ccd8610149fe1fff53c4e937", "target": 1, "func": "static int rprobe(AVFormatContext *s, uint8_t *enc_header, const uint8_t *r_val)\n\n{\n\n    OMAContext *oc = s->priv_data;\n\n    unsigned int pos;\n\n    struct AVDES av_des;\n\n\n\n    if (!enc_header || !r_val)\n\n        return -1;\n\n\n\n    /* m_val */\n\n    av_des_init(&av_des, r_val, 192, 1);\n\n    av_des_crypt(&av_des, oc->m_val, &enc_header[48], 1, NULL, 1);\n\n\n\n    /* s_val */\n\n    av_des_init(&av_des, oc->m_val, 64, 0);\n\n    av_des_crypt(&av_des, oc->s_val, NULL, 1, NULL, 0);\n\n\n\n    /* sm_val */\n\n    pos = OMA_ENC_HEADER_SIZE + oc->k_size + oc->e_size;\n\n    av_des_init(&av_des, oc->s_val, 64, 0);\n\n    av_des_mac(&av_des, oc->sm_val, &enc_header[pos], (oc->i_size >> 3));\n\n\n\n    pos += oc->i_size;\n\n\n\n    return memcmp(&enc_header[pos], oc->sm_val, 8) ? -1 : 0;\n\n}\n", "idx": 22895}
{"project": "FFmpeg", "commit_id": "dcbe15813ed09cf491e75a21cce0e751f5bc2b34", "target": 0, "func": "static int check_opcodes(MMCO *mmco1, MMCO *mmco2, int n_mmcos)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < n_mmcos; i++) {\n\n        if (mmco1[i].opcode != mmco2[i].opcode)\n\n            return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 22902}
{"project": "FFmpeg", "commit_id": "6796a1dd8c14843b77925cb83a3ef88706ae1dd0", "target": 0, "func": "void ff_put_h264_qpel4_mc03_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_vt_qrt_4w_msa(src - (stride * 2), stride, dst, stride, 4, 1);\n\n}\n", "idx": 22937}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static VncJobQueue *vnc_queue_init(void)\n\n{\n\n    VncJobQueue *queue = g_malloc0(sizeof(VncJobQueue));\n\n\n\n    qemu_cond_init(&queue->cond);\n\n    qemu_mutex_init(&queue->mutex);\n\n    QTAILQ_INIT(&queue->jobs);\n\n    return queue;\n\n}\n", "idx": 22954}
{"project": "qemu", "commit_id": "7b35030eedc26eff82210caa2b0fff2f9d0df453", "target": 1, "func": "void test_tls_write_cert_chain(const char *filename,\n\n                               gnutls_x509_crt_t *certs,\n\n                               size_t ncerts)\n\n{\n\n    size_t i;\n\n    size_t capacity = 1024, offset = 0;\n\n    char *buffer = g_new0(char, capacity);\n\n    int err;\n\n\n\n    for (i = 0; i < ncerts; i++) {\n\n        size_t len = capacity - offset;\n\n    retry:\n\n        err = gnutls_x509_crt_export(certs[i], GNUTLS_X509_FMT_PEM,\n\n                                     buffer + offset, &len);\n\n        if (err < 0) {\n\n            if (err == GNUTLS_E_SHORT_MEMORY_BUFFER) {\n\n                buffer = g_renew(char, buffer, offset + len);\n\n                capacity = offset + len;\n\n                goto retry;\n\n            }\n\n            g_critical(\"Failed to export certificate chain %s: %d\",\n\n                       gnutls_strerror(err), err);\n\n            abort();\n\n        }\n\n        offset += len;\n\n    }\n\n\n\n    if (!g_file_set_contents(filename, buffer, offset, NULL)) {\n\n        abort();\n\n    }\n\n\n}", "idx": 22957}
{"project": "FFmpeg", "commit_id": "0b54f3c0878a3acaa9142e4f24942e762d97e350", "target": 1, "func": "static int gif_read_header(AVFormatContext * s1,\n\n                           AVFormatParameters * ap)\n\n{\n\n    GifState *s = s1->priv_data;\n\n    ByteIOContext *f = s1->pb;\n\n    AVStream *st;\n\n\n\n    s->f = f;\n\n    if (gif_read_header1(s) < 0)\n\n        return -1;\n\n\n\n    /* allocate image buffer */\n\n    s->image_linesize = s->screen_width * 3;\n\n    s->image_buf = av_malloc(s->screen_height * s->image_linesize);\n\n    if (!s->image_buf)\n\n        return AVERROR(ENOMEM);\n\n    s->pix_fmt = PIX_FMT_RGB24;\n\n    /* now we are ready: build format streams */\n\n    st = av_new_stream(s1, 0);\n\n    if (!st)\n\n        return -1;\n\n\n\n    st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_RAWVIDEO;\n\n    st->codec->time_base.den = 5;\n\n    st->codec->time_base.num = 1;\n\n    /* XXX: check if screen size is always valid */\n\n    st->codec->width = s->screen_width;\n\n    st->codec->height = s->screen_height;\n\n    st->codec->pix_fmt = PIX_FMT_RGB24;\n\n    return 0;\n\n}\n", "idx": 22978}
{"project": "qemu", "commit_id": "eba90e4efc80bc30c7d952ee6ea442207517a0da", "target": 0, "func": "int64_t strtosz_suffix_unit(const char *nptr, char **end,\n\n                            const char default_suffix, int64_t unit)\n\n{\n\n    int64_t retval = -1;\n\n    char *endptr;\n\n    unsigned char c, d;\n\n    int mul_required = 0;\n\n    double val, mul, integral, fraction;\n\n\n\n    errno = 0;\n\n    val = strtod(nptr, &endptr);\n\n    if (isnan(val) || endptr == nptr || errno != 0) {\n\n        goto fail;\n\n    }\n\n    fraction = modf(val, &integral);\n\n    if (fraction != 0) {\n\n        mul_required = 1;\n\n    }\n\n    /*\n\n     * Any whitespace character is fine for terminating the number,\n\n     * in addition we accept ',' to handle strings where the size is\n\n     * part of a multi token argument.\n\n     */\n\n    c = *endptr;\n\n    d = c;\n\n    if (qemu_isspace(c) || c == '\\0' || c == ',') {\n\n        c = 0;\n\n        d = default_suffix;\n\n    }\n\n    switch (qemu_toupper(d)) {\n\n    case STRTOSZ_DEFSUFFIX_B:\n\n        mul = 1;\n\n        if (mul_required) {\n\n            goto fail;\n\n        }\n\n        break;\n\n    case STRTOSZ_DEFSUFFIX_KB:\n\n        mul = unit;\n\n        break;\n\n    case STRTOSZ_DEFSUFFIX_MB:\n\n        mul = unit * unit;\n\n        break;\n\n    case STRTOSZ_DEFSUFFIX_GB:\n\n        mul = unit * unit * unit;\n\n        break;\n\n    case STRTOSZ_DEFSUFFIX_TB:\n\n        mul = unit * unit * unit * unit;\n\n        break;\n\n    default:\n\n        goto fail;\n\n    }\n\n    /*\n\n     * If not terminated by whitespace, ',', or \\0, increment endptr\n\n     * to point to next character, then check that we are terminated\n\n     * by an appropriate separating character, ie. whitespace, ',', or\n\n     * \\0. If not, we are seeing trailing garbage, thus fail.\n\n     */\n\n    if (c != 0) {\n\n        endptr++;\n\n        if (!qemu_isspace(*endptr) && *endptr != ',' && *endptr != 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n    if ((val * mul >= INT64_MAX) || val < 0) {\n\n        goto fail;\n\n    }\n\n    retval = val * mul;\n\n\n\nfail:\n\n    if (end) {\n\n        *end = endptr;\n\n    }\n\n\n\n    return retval;\n\n}\n", "idx": 23011}
{"project": "qemu", "commit_id": "7d5e199ade76c53ec316ab6779800581bb47c50a", "target": 0, "func": "static void qmp_output_push_obj(QmpOutputVisitor *qov, QObject *value,\n\n                                void *qapi)\n\n{\n\n    QStackEntry *e = g_malloc0(sizeof(*e));\n\n\n\n    assert(qov->root);\n\n    assert(value);\n\n    e->value = value;\n\n    e->qapi = qapi;\n\n    QSLIST_INSERT_HEAD(&qov->stack, e, node);\n\n}\n", "idx": 23015}
{"project": "FFmpeg", "commit_id": "e75e603c1a5d1b56b6297d2cbc1f32e6bf7b2b15", "target": 0, "func": "static int sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){\n\n    RMDemuxContext *rm = s->priv_data;\n\n    ByteIOContext *pb = s->pb;\n\n    int len, num, res, i;\n\n    AVStream *st;\n\n    uint32_t state=0xFFFFFFFF;\n\n\n\n    while(!url_feof(pb)){\n\n        *pos= url_ftell(pb) - 3;\n\n        if(rm->remaining_len > 0){\n\n            num= rm->current_stream;\n\n            len= rm->remaining_len;\n\n            *timestamp = AV_NOPTS_VALUE;\n\n            *flags= 0;\n\n        }else{\n\n            state= (state<<8) + get_byte(pb);\n\n\n\n            if(state == MKBETAG('I', 'N', 'D', 'X')){\n\n                int n_pkts, expected_len;\n\n                len = get_be32(pb);\n\n                url_fskip(pb, 2);\n\n                n_pkts = get_be32(pb);\n\n                expected_len = 20 + n_pkts * 14;\n\n                if (len == 20)\n\n                    /* some files don't add index entries to chunk size... */\n\n                    len = expected_len;\n\n                else if (len != expected_len)\n\n                    av_log(s, AV_LOG_WARNING,\n\n                           \"Index size %d (%d pkts) is wrong, should be %d.\\n\",\n\n                           len, n_pkts, expected_len);\n\n                len -= 14; // we already read part of the index header\n\n                if(len<0)\n\n                    continue;\n\n                goto skip;\n\n            }\n\n\n\n            if(state > (unsigned)0xFFFF || state < 12)\n\n                continue;\n\n            len=state;\n\n            state= 0xFFFFFFFF;\n\n\n\n            num = get_be16(pb);\n\n            *timestamp = get_be32(pb);\n\n            res= get_byte(pb); /* reserved */\n\n            *flags = get_byte(pb); /* flags */\n\n\n\n\n\n            len -= 12;\n\n        }\n\n        for(i=0;i<s->nb_streams;i++) {\n\n            st = s->streams[i];\n\n            if (num == st->id)\n\n                break;\n\n        }\n\n        if (i == s->nb_streams) {\n\nskip:\n\n            /* skip packet if unknown number */\n\n            url_fskip(pb, len);\n\n            rm->remaining_len = 0;\n\n            continue;\n\n        }\n\n        *stream_index= i;\n\n\n\n        return len;\n\n    }\n\n    return -1;\n\n}\n", "idx": 23019}
{"project": "FFmpeg", "commit_id": "ef4c71e8f83a46fb31a11f0a066efb90821c579f", "target": 0, "func": "static int config_props(AVFilterLink *link)\n\n{\n\n    UnsharpContext *unsharp = link->dst->priv;\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(link->format);\n\n\n\n    unsharp->hsub = desc->log2_chroma_w;\n\n    unsharp->vsub = desc->log2_chroma_h;\n\n\n\n    init_filter_param(link->dst, &unsharp->luma,   \"luma\",   link->w);\n\n    init_filter_param(link->dst, &unsharp->chroma, \"chroma\", SHIFTUP(link->w, unsharp->hsub));\n\n\n\n    return 0;\n\n}\n", "idx": 23022}
{"project": "FFmpeg", "commit_id": "dc2e4c2e532b80565f5fbacd3a24a6db7567c257", "target": 0, "func": "static int64_t wav_seek_tag(AVIOContext *s, int64_t offset, int whence)\n\n{\n\n    offset += offset < INT64_MAX && offset & 1;\n\n\n\n    return avio_seek(s, offset, whence);\n\n}\n", "idx": 23027}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "int qemu_global_option(const char *str)\n\n{\n\n    char driver[64], property[64];\n\n    QemuOpts *opts;\n\n    int rc, offset;\n\n\n\n    rc = sscanf(str, \"%63[^.].%63[^=]%n\", driver, property, &offset);\n\n    if (rc < 2 || str[offset] != '=') {\n\n        error_report(\"can't parse: \\\"%s\\\"\", str);\n\n        return -1;\n\n    }\n\n\n\n    opts = qemu_opts_create(&qemu_global_opts, NULL, 0);\n\n    qemu_opt_set(opts, \"driver\", driver);\n\n    qemu_opt_set(opts, \"property\", property);\n\n    qemu_opt_set(opts, \"value\", str+offset+1);\n\n    return 0;\n\n}\n", "idx": 23033}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "QEMUFile *qemu_fdopen(int fd, const char *mode)\n\n{\n\n    QEMUFileSocket *s;\n\n\n\n    if (mode == NULL ||\n\n        (mode[0] != 'r' && mode[0] != 'w') ||\n\n        mode[1] != 'b' || mode[2] != 0) {\n\n        fprintf(stderr, \"qemu_fdopen: Argument validity check failed\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s = g_malloc0(sizeof(QEMUFileSocket));\n\n    s->fd = fd;\n\n\n\n    if (mode[0] == 'r') {\n\n        s->file = qemu_fopen_ops(s, &unix_read_ops);\n\n    } else {\n\n        s->file = qemu_fopen_ops(s, &unix_write_ops);\n\n    }\n\n    return s->file;\n\n}\n", "idx": 23034}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static bool cmd_read_pio(IDEState *s, uint8_t cmd)\n\n{\n\n    bool lba48 = (cmd == WIN_READ_EXT);\n\n\n\n    if (s->drive_kind == IDE_CD) {\n\n        ide_set_signature(s); /* odd, but ATA4 8.27.5.2 requires it */\n\n        ide_abort_command(s);\n\n        return true;\n\n    }\n\n\n\n    if (!s->bs) {\n\n        ide_abort_command(s);\n\n        return true;\n\n    }\n\n\n\n    ide_cmd_lba48_transform(s, lba48);\n\n    s->req_nb_sectors = 1;\n\n    ide_sector_read(s);\n\n\n\n    return false;\n\n}\n", "idx": 23075}
{"project": "qemu", "commit_id": "25cec2b896a977565ca04e5c649aab8c6e48bda8", "target": 1, "func": "void os_setup_post(void)\n\n{\n\n    int fd = 0;\n\n\n\n    if (daemonize) {\n\n        uint8_t status = 0;\n\n        ssize_t len;\n\n\n\n        do {        \n\n            len = write(daemon_pipe, &status, 1);\n\n        } while (len < 0 && errno == EINTR);\n\n        if (len != 1) {\n\n            exit(1);\n\n        }\n\n        if (chdir(\"/\")) {\n\n            perror(\"not able to chdir to /\");\n\n            exit(1);\n\n        }\n\n        TFR(fd = qemu_open(\"/dev/null\", O_RDWR));\n\n        if (fd == -1) {\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    change_root();\n\n    change_process_uid();\n\n\n\n    if (daemonize) {\n\n        dup2(fd, 0);\n\n        dup2(fd, 1);\n\n        dup2(fd, 2);\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 23093}
{"project": "qemu", "commit_id": "7c08db30e6a43f7083a881eb07bfbc878e001e08", "target": 0, "func": "static int cpu_x86_find_by_name(X86CPU *cpu, x86_def_t *x86_cpu_def,\n\n                                const char *name)\n\n{\n\n    x86_def_t *def;\n\n    int i;\n\n\n\n    if (name == NULL) {\n\n        return -1;\n\n    }\n\n    if (kvm_enabled() && strcmp(name, \"host\") == 0) {\n\n        kvm_cpu_fill_host(x86_cpu_def);\n\n        object_property_set_bool(OBJECT(cpu), true, \"pmu\", &error_abort);\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < ARRAY_SIZE(builtin_x86_defs); i++) {\n\n        def = &builtin_x86_defs[i];\n\n        if (strcmp(name, def->name) == 0) {\n\n            memcpy(x86_cpu_def, def, sizeof(*def));\n\n            /* sysenter isn't supported in compatibility mode on AMD,\n\n             * syscall isn't supported in compatibility mode on Intel.\n\n             * Normally we advertise the actual CPU vendor, but you can\n\n             * override this using the 'vendor' property if you want to use\n\n             * KVM's sysenter/syscall emulation in compatibility mode and\n\n             * when doing cross vendor migration\n\n             */\n\n            if (kvm_enabled()) {\n\n                uint32_t  ebx = 0, ecx = 0, edx = 0;\n\n                host_cpuid(0, 0, NULL, &ebx, &ecx, &edx);\n\n                x86_cpu_vendor_words2str(x86_cpu_def->vendor, ebx, edx, ecx);\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 23109}
{"project": "qemu", "commit_id": "9005b2a7589540a3733b3abdcfbccfe7746cd1a1", "target": 0, "func": "static int pty_chr_write(CharDriverState *chr, const uint8_t *buf, int len)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (!s->connected) {\n\n        /* guest sends data, check for (re-)connect */\n\n        pty_chr_update_read_handler(chr);\n\n        return 0;\n\n    }\n\n    return io_channel_send(s->fd, buf, len);\n\n}\n", "idx": 23135}
{"project": "qemu", "commit_id": "63ae0915f8ec9746d17a25c27f64cf65550627ab", "target": 0, "func": "static void gen_rlwimi(DisasContext *ctx)\n\n{\n\n    uint32_t mb, me, sh;\n\n\n\n    mb = MB(ctx->opcode);\n\n    me = ME(ctx->opcode);\n\n    sh = SH(ctx->opcode);\n\n    if (likely(sh == (31-me) && mb <= me)) {\n\n        tcg_gen_deposit_tl(cpu_gpr[rA(ctx->opcode)], cpu_gpr[rA(ctx->opcode)],\n\n                           cpu_gpr[rS(ctx->opcode)], sh, me - mb + 1);\n\n    } else {\n\n        target_ulong mask;\n\n        TCGv t1;\n\n        TCGv t0 = tcg_temp_new();\n\n#if defined(TARGET_PPC64)\n\n        tcg_gen_deposit_i64(t0, cpu_gpr[rS(ctx->opcode)],\n\n            cpu_gpr[rS(ctx->opcode)], 32, 32);\n\n        tcg_gen_rotli_i64(t0, t0, sh);\n\n#else\n\n        tcg_gen_rotli_i32(t0, cpu_gpr[rS(ctx->opcode)], sh);\n\n#endif\n\n#if defined(TARGET_PPC64)\n\n        mb += 32;\n\n        me += 32;\n\n#endif\n\n        mask = MASK(mb, me);\n\n        t1 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, t0, mask);\n\n        tcg_gen_andi_tl(t1, cpu_gpr[rA(ctx->opcode)], ~mask);\n\n        tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);\n\n        tcg_temp_free(t0);\n\n        tcg_temp_free(t1);\n\n    }\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 23146}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static int av_seek_frame_generic(AVFormatContext *s, \n\n                                 int stream_index, int64_t timestamp)\n\n{\n\n    int index;\n\n    AVStream *st;\n\n    AVIndexEntry *ie;\n\n\n\n    if (!s->index_built) {\n\n        if (is_raw_stream(s)) {\n\n            av_build_index_raw(s);\n\n        } else {\n\n            return -1;\n\n        }\n\n        s->index_built = 1;\n\n    }\n\n\n\n    if (stream_index < 0)\n\n        stream_index = 0;\n\n    st = s->streams[stream_index];\n\n    index = index_search_timestamp(st->index_entries, st->nb_index_entries,\n\n                                   timestamp);\n\n    if (index < 0)\n\n        return -1;\n\n\n\n    /* now we have found the index, we can seek */\n\n    ie = &st->index_entries[index];\n\n    av_read_frame_flush(s);\n\n    url_fseek(&s->pb, ie->pos, SEEK_SET);\n\n    st->cur_dts = ie->timestamp;\n\n    return 0;\n\n}\n", "idx": 23156}
{"project": "qemu", "commit_id": "e4a3507e86a1ef1453d603031bca27d5ac4cff3c", "target": 0, "func": "static ssize_t test_block_write_func(QCryptoBlock *block,\n\n                                     void *opaque,\n\n                                     size_t offset,\n\n                                     const uint8_t *buf,\n\n                                     size_t buflen,\n\n                                     Error **errp)\n\n{\n\n    Buffer *header = opaque;\n\n\n\n    g_assert_cmpint(buflen + offset, <=, header->capacity);\n\n\n\n    memcpy(header->buffer + offset, buf, buflen);\n\n    header->offset = offset + buflen;\n\n\n\n    return buflen;\n\n}\n", "idx": 23167}
{"project": "qemu", "commit_id": "375092332eeaa6e47561ce47fd36144cdaf964d0", "target": 0, "func": "static ssize_t block_crypto_read_func(QCryptoBlock *block,\n\n                                      size_t offset,\n\n                                      uint8_t *buf,\n\n                                      size_t buflen,\n\n                                      Error **errp,\n\n                                      void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    ssize_t ret;\n\n\n\n    ret = bdrv_pread(bs->file, offset, buf, buflen);\n\n    if (ret < 0) {\n\n        error_setg_errno(errp, -ret, \"Could not read encryption header\");\n\n        return ret;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23173}
{"project": "qemu", "commit_id": "a5b0f6d5c0f6678c078354c432a1f0943374f087", "target": 0, "func": "static void lm32_cpu_reset(CPUState *s)\n\n{\n\n    LM32CPU *cpu = LM32_CPU(s);\n\n    LM32CPUClass *lcc = LM32_CPU_GET_CLASS(cpu);\n\n    CPULM32State *env = &cpu->env;\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", s->cpu_index);\n\n        log_cpu_state(env, 0);\n\n    }\n\n\n\n    lcc->parent_reset(s);\n\n\n\n    tlb_flush(env, 1);\n\n\n\n    /* reset cpu state */\n\n    memset(env, 0, offsetof(CPULM32State, breakpoints));\n\n}\n", "idx": 23227}
{"project": "FFmpeg", "commit_id": "fef7b2e0bef6972d8d48df51e477af7b017d1a38", "target": 0, "func": "static int null_draw_slice(AVFilterLink *link, int y, int h, int slice_dir) { return 0; }\n", "idx": 23249}
{"project": "qemu", "commit_id": "b5e85329026115b5a679849f45e7c19c2714e4fd", "target": 1, "func": "uint32_t HELPER(tprot)(CPUS390XState *env, uint64_t a1, uint64_t a2)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n\n\n    /*\n\n     * TODO: we currently don't handle all access protection types\n\n     * (including access-list and key-controlled) as well as AR mode.\n\n     */\n\n    if (!s390_cpu_virt_mem_check_write(cpu, a1, 0, 1)) {\n\n        /* Fetching permitted; storing permitted */\n\n        return 0;\n\n    }\n\n    switch (env->int_pgm_code) {\n\n    case PGM_PROTECTION:\n\n        /* Fetching permitted; storing not permitted */\n\n        cs->exception_index = 0;\n\n        return 1;\n\n    case PGM_ADDRESSING:\n\n        /* Fetching not permitted; storing not permitted */\n\n        cs->exception_index = 0;\n\n        return 2;\n\n    case PGM_ASCE_TYPE:\n\n    case PGM_REG_FIRST_TRANS:\n\n    case PGM_REG_SEC_TRANS:\n\n    case PGM_REG_THIRD_TRANS:\n\n    case PGM_SEGMENT_TRANS:\n\n    case PGM_PAGE_TRANS:\n\n    case PGM_ALET_SPEC:\n\n    case PGM_ALEN_SPEC:\n\n    case PGM_ALE_SEQ:\n\n    case PGM_ASTE_VALID:\n\n    case PGM_ASTE_SEQ:\n\n    case PGM_EXT_AUTH:\n\n        /* Translation not available */\n\n        cs->exception_index = 0;\n\n        return 3;\n\n    }\n\n    /* any other exception is forwarded to the guest */\n\n    s390_cpu_virt_mem_handle_exc(cpu, GETPC());\n\n    return 0;\n\n}\n", "idx": 23292}
{"project": "qemu", "commit_id": "77cb0f5aafc8e6d0c6d3c339f381c9b7921648e0", "target": 1, "func": "static int adb_kbd_poll(ADBDevice *d, uint8_t *obuf)\n\n{\n\n    KBDState *s = ADB_KEYBOARD(d);\n\n    int keycode;\n\n    int olen;\n\n\n\n    olen = 0;\n\n    if (s->count == 0) {\n\n        return 0;\n\n    }\n\n    keycode = s->data[s->rptr];\n\n    s->rptr++;\n\n    if (s->rptr == sizeof(s->data)) {\n\n        s->rptr = 0;\n\n    }\n\n    s->count--;\n\n    /*\n\n     * The power key is the only two byte value key, so it is a special case.\n\n     * Since 0x7f is not a used keycode for ADB we overload it to indicate the\n\n     * power button when we're storing keycodes in our internal buffer, and\n\n     * expand it out to two bytes when we send to the guest.\n\n     */\n\n    if (keycode == 0x7f) {\n\n        obuf[0] = 0x7f;\n\n        obuf[1] = 0x7f;\n\n        olen = 2;\n\n    } else {\n\n        obuf[0] = keycode;\n\n        /* NOTE: the power key key-up is the two byte sequence 0xff 0xff;\n\n         * otherwise we could in theory send a second keycode in the second\n\n         * byte, but choose not to bother.\n\n         */\n\n        obuf[1] = 0xff;\n\n        olen = 2;\n\n    }\n\n\n\n    return olen;\n\n}\n", "idx": 23298}
{"project": "FFmpeg", "commit_id": "0953736b7e97f6e121a0587a95434bf1857a27da", "target": 1, "func": "static inline int signed_shift(int i, int shift) {\n\n    if (shift > 0)\n\n        return i << shift;\n\n    return i >> -shift;\n\n}\n", "idx": 23316}
{"project": "qemu", "commit_id": "1bc04a8880374407c4b12d82ceb8752e12ff5336", "target": 0, "func": "static void pmsav7_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                         uint64_t value)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    uint32_t *u32p = *(uint32_t **)raw_ptr(env, ri);\n\n\n\n    if (!u32p) {\n\n        return;\n\n    }\n\n\n\n    u32p += env->pmsav7.rnr;\n\n    tlb_flush(CPU(cpu)); /* Mappings may have changed - purge! */\n\n    *u32p = value;\n\n}\n", "idx": 23365}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_opts_del(QemuOpts *opts)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    for (;;) {\n\n        opt = TAILQ_FIRST(&opts->head);\n\n        if (opt == NULL)\n\n            break;\n\n        qemu_opt_del(opt);\n\n    }\n\n    TAILQ_REMOVE(&opts->list->head, opts, next);\n\n    qemu_free(opts);\n\n}\n", "idx": 23366}
{"project": "qemu", "commit_id": "581b9e29f36eec5de0779c3dbade980e4405d92e", "target": 0, "func": "static int raw_pwrite(BlockDriverState *bs, int64_t offset,\n\n                      const uint8_t *buf, int count)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int size, ret, shift, sum;\n\n\n\n    sum = 0;\n\n\n\n    if (s->aligned_buf != NULL) {\n\n\n\n        if (offset & 0x1ff) {\n\n            /* align offset on a 512 bytes boundary */\n\n            shift = offset & 0x1ff;\n\n            ret = raw_pread_aligned(bs, offset - shift, s->aligned_buf, 512);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            size = 512 - shift;\n\n            if (size > count)\n\n                size = count;\n\n            memcpy(s->aligned_buf + shift, buf, size);\n\n\n\n            ret = raw_pwrite_aligned(bs, offset - shift, s->aligned_buf, 512);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            buf += size;\n\n            offset += size;\n\n            count -= size;\n\n            sum += size;\n\n\n\n            if (count == 0)\n\n                return sum;\n\n        }\n\n        if (count & 0x1ff || (uintptr_t) buf & 0x1ff) {\n\n\n\n            while ((size = (count & ~0x1ff)) != 0) {\n\n\n\n                if (size > ALIGNED_BUFFER_SIZE)\n\n                    size = ALIGNED_BUFFER_SIZE;\n\n\n\n                memcpy(s->aligned_buf, buf, size);\n\n\n\n                ret = raw_pwrite_aligned(bs, offset, s->aligned_buf, size);\n\n                if (ret < 0)\n\n                    return ret;\n\n\n\n                buf += ret;\n\n                offset += ret;\n\n                count -= ret;\n\n                sum += ret;\n\n            }\n\n            /* here, count < 512 because (count & ~0x1ff) == 0 */\n\n            if (count) {\n\n                ret = raw_pread_aligned(bs, offset, s->aligned_buf, 512);\n\n                if (ret < 0)\n\n                    return ret;\n\n                 memcpy(s->aligned_buf, buf, count);\n\n\n\n                 ret = raw_pwrite_aligned(bs, offset, s->aligned_buf, 512);\n\n                 if (ret < 0)\n\n                     return ret;\n\n                 if (count < ret)\n\n                     ret = count;\n\n\n\n                 sum += ret;\n\n            }\n\n            return sum;\n\n        }\n\n    }\n\n    return raw_pwrite_aligned(bs, offset, buf, count) + sum;\n\n}\n", "idx": 23368}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "void acpi_pcihp_device_unplug_cb(HotplugHandler *hotplug_dev, AcpiPciHpState *s,\n\n                                 DeviceState *dev, Error **errp)\n\n{\n\n    PCIDevice *pdev = PCI_DEVICE(dev);\n\n    int slot = PCI_SLOT(pdev->devfn);\n\n    int bsel = acpi_pcihp_get_bsel(pdev->bus);\n\n    if (bsel < 0) {\n\n        error_setg(errp, \"Unsupported bus. Bus doesn't have property '\"\n\n                   ACPI_PCIHP_PROP_BSEL \"' set\");\n\n        return;\n\n    }\n\n\n\n    s->acpi_pcihp_pci_status[bsel].down |= (1U << slot);\n\n    acpi_send_event(DEVICE(hotplug_dev), ACPI_PCI_HOTPLUG_STATUS);\n\n}\n", "idx": 23373}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_debug_resume(BlockDriverState *bs, const char *tag)\n\n{\n\n    while (bs && (!bs->drv || !bs->drv->bdrv_debug_resume)) {\n\n        bs = bs->file;\n\n    }\n\n\n\n    if (bs && bs->drv && bs->drv->bdrv_debug_resume) {\n\n        return bs->drv->bdrv_debug_resume(bs, tag);\n\n    }\n\n\n\n    return -ENOTSUP;\n\n}\n", "idx": 23379}
{"project": "FFmpeg", "commit_id": "38beab19ab3b997bcbe2e95699d4952922f1f673", "target": 1, "func": "static int r3d_read_redv(AVFormatContext *s, AVPacket *pkt, Atom *atom)\n\n{\n\n    AVStream *st = s->streams[0];\n\n    int tmp, tmp2;\n\n    uint64_t pos = url_ftell(s->pb);\n\n    unsigned dts;\n\n\n\n    dts = get_be32(s->pb);\n\n\n\n    tmp = get_be32(s->pb);\n\n    dprintf(s, \"frame num %d\\n\", tmp);\n\n\n\n    tmp  = get_byte(s->pb); // major version\n\n    tmp2 = get_byte(s->pb); // minor version\n\n    dprintf(s, \"version %d.%d\\n\", tmp, tmp2);\n\n\n\n    tmp = get_be16(s->pb); // unknown\n\n    dprintf(s, \"unknown %d\\n\", tmp);\n\n\n\n    if (tmp > 4) {\n\n        tmp = get_be16(s->pb); // unknown\n\n        dprintf(s, \"unknown %d\\n\", tmp);\n\n\n\n        tmp = get_be16(s->pb); // unknown\n\n        dprintf(s, \"unknown %d\\n\", tmp);\n\n\n\n        tmp = get_be32(s->pb);\n\n        dprintf(s, \"width %d\\n\", tmp);\n\n        tmp = get_be32(s->pb);\n\n        dprintf(s, \"height %d\\n\", tmp);\n\n\n\n        tmp = get_be32(s->pb);\n\n        dprintf(s, \"metadata len %d\\n\", tmp);\n\n    }\n\n    tmp = atom->size - 8 - (url_ftell(s->pb) - pos);\n\n    if (tmp < 0)\n\n        return -1;\n\n\n\n    if (av_get_packet(s->pb, pkt, tmp) != tmp) {\n\n        av_log(s, AV_LOG_ERROR, \"error reading video packet\\n\");\n\n        return -1;\n\n    }\n\n\n\n    pkt->stream_index = 0;\n\n    pkt->dts = dts;\n\n    if (st->codec->time_base.den)\n\n        pkt->duration = (uint64_t)st->time_base.den*\n\n            st->codec->time_base.num/st->codec->time_base.den;\n\n    dprintf(s, \"pkt dts %lld duration %d\\n\", pkt->dts, pkt->duration);\n\n\n\n    return 0;\n\n}\n", "idx": 23384}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mpc8544_guts_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    uint32_t value = 0;\n\n    CPUPPCState *env = cpu_single_env;\n\n\n\n    addr &= MPC8544_GUTS_MMIO_SIZE - 1;\n\n    switch (addr) {\n\n    case MPC8544_GUTS_ADDR_PVR:\n\n        value = env->spr[SPR_PVR];\n\n        break;\n\n    case MPC8544_GUTS_ADDR_SVR:\n\n        value = env->spr[SPR_E500_SVR];\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"guts: Unknown register read: %x\\n\", (int)addr);\n\n        break;\n\n    }\n\n\n\n    return value;\n\n}\n", "idx": 23394}
{"project": "qemu", "commit_id": "45803a039670cbee914dcb54cf3952f9b2d64d1f", "target": 0, "func": "int bdrv_set_read_only(BlockDriverState *bs, bool read_only, Error **errp)\n\n{\n\n    /* Do not set read_only if copy_on_read is enabled */\n\n    if (bs->copy_on_read && read_only) {\n\n        error_setg(errp, \"Can't set node '%s' to r/o with copy-on-read enabled\",\n\n                   bdrv_get_device_or_node_name(bs));\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Do not clear read_only if it is prohibited */\n\n    if (!read_only && !(bs->open_flags & BDRV_O_ALLOW_RDWR)) {\n\n        error_setg(errp, \"Node '%s' is read only\",\n\n                   bdrv_get_device_or_node_name(bs));\n\n        return -EPERM;\n\n    }\n\n\n\n    bs->read_only = read_only;\n\n    return 0;\n\n}\n", "idx": 23396}
{"project": "qemu", "commit_id": "539de1246d355d3b8aa33fb7cde732352d8827c7", "target": 0, "func": "int qemu_savevm_state_begin(Monitor *mon, QEMUFile *f, int blk_enable,\n\n                            int shared)\n\n{\n\n    SaveStateEntry *se;\n\n    int ret;\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        if(se->set_params == NULL) {\n\n            continue;\n\n\t}\n\n\tse->set_params(blk_enable, shared, se->opaque);\n\n    }\n\n    \n\n    qemu_put_be32(f, QEMU_VM_FILE_MAGIC);\n\n    qemu_put_be32(f, QEMU_VM_FILE_VERSION);\n\n\n\n    QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n\n        int len;\n\n\n\n        if (se->save_live_state == NULL)\n\n            continue;\n\n\n\n        /* Section type */\n\n        qemu_put_byte(f, QEMU_VM_SECTION_START);\n\n        qemu_put_be32(f, se->section_id);\n\n\n\n        /* ID string */\n\n        len = strlen(se->idstr);\n\n        qemu_put_byte(f, len);\n\n        qemu_put_buffer(f, (uint8_t *)se->idstr, len);\n\n\n\n        qemu_put_be32(f, se->instance_id);\n\n        qemu_put_be32(f, se->version_id);\n\n\n\n        ret = se->save_live_state(mon, f, QEMU_VM_SECTION_START, se->opaque);\n\n        if (ret < 0) {\n\n            qemu_savevm_state_cancel(mon, f);\n\n            return ret;\n\n        }\n\n    }\n\n    ret = qemu_file_get_error(f);\n\n    if (ret != 0) {\n\n        qemu_savevm_state_cancel(mon, f);\n\n    }\n\n\n\n    return ret;\n\n\n\n}\n", "idx": 23404}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_conditional_jump(DisasContext * ctx,\n\n\t\t\t\t target_ulong ift, target_ulong ifnott)\n\n{\n\n    int l1;\n\n    TCGv sr;\n\n\n\n    l1 = gen_new_label();\n\n    sr = tcg_temp_new();\n\n    tcg_gen_andi_i32(sr, cpu_sr, SR_T);\n\n    tcg_gen_brcondi_i32(TCG_COND_NE, sr, 0, l1);\n\n    gen_goto_tb(ctx, 0, ifnott);\n\n    gen_set_label(l1);\n\n    gen_goto_tb(ctx, 1, ift);\n\n}\n", "idx": 23409}
{"project": "qemu", "commit_id": "57d84cf35302fe51789c18354bf09a521bb603df", "target": 1, "func": "static void remove_port(VirtIOSerial *vser, uint32_t port_id)\n\n{\n\n    VirtIOSerialPort *port;\n\n    unsigned int i;\n\n\n\n    i = port_id / 32;\n\n    vser->ports_map[i] &= ~(1U << (port_id % 32));\n\n\n\n    port = find_port_by_id(vser, port_id);\n\n    /*\n\n     * This function is only called from qdev's unplug callback; if we\n\n     * get a NULL port here, we're in trouble.\n\n     */\n\n    assert(port);\n\n\n\n    /* Flush out any unconsumed buffers first */\n\n    discard_vq_data(port->ovq, VIRTIO_DEVICE(port->vser));\n\n\n\n    send_control_event(vser, port->id, VIRTIO_CONSOLE_PORT_REMOVE, 1);\n\n}\n", "idx": 23430}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "void rgb16tobgr32(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tconst uint16_t *end;\n\n\tuint8_t *d = (uint8_t *)dst;\n\n\tconst uint16_t *s = (uint16_t *)src;\n\n\tend = s + src_size/2;\n\n\twhile(s < end)\n\n\t{\n\n\t\tregister uint16_t bgr;\n\n\t\tbgr = *s++;\n\n\t\t*d++ = (bgr&0xF800)>>8;\n\n\t\t*d++ = (bgr&0x7E0)>>3;\n\n\t\t*d++ = (bgr&0x1F)<<3;\n\n\t\t*d++ = 0;\n\n\t}\n\n}\n", "idx": 23431}
{"project": "FFmpeg", "commit_id": "26f2e2f3f73f0da088e6765291d0839ebb077b03", "target": 1, "func": "static void write_header(AVFormatContext *s)\n\n{\n\n    double min_buffer_time = 1.0;\n\n    avio_printf(s->pb, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n\n    avio_printf(s->pb, \"<MPD\\n\");\n\n    avio_printf(s->pb, \"  xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n\");\n\n    avio_printf(s->pb, \"  xmlns=\\\"urn:mpeg:DASH:schema:MPD:2011\\\"\\n\");\n\n    avio_printf(s->pb, \"  xsi:schemaLocation=\\\"urn:mpeg:DASH:schema:MPD:2011\\\"\\n\");\n\n    avio_printf(s->pb, \"  type=\\\"static\\\"\\n\");\n\n    avio_printf(s->pb, \"  mediaPresentationDuration=\\\"PT%gS\\\"\\n\",\n\n                get_duration(s));\n\n    avio_printf(s->pb, \"  minBufferTime=\\\"PT%gS\\\"\\n\",\n\n                min_buffer_time);\n\n    avio_printf(s->pb, \"  profiles=\\\"urn:webm:dash:profile:webm-on-demand:2012\\\"\");\n\n    avio_printf(s->pb, \">\\n\");\n\n}\n", "idx": 23434}
{"project": "FFmpeg", "commit_id": "636ced8e1dc8248a1353b416240b93d70ad03edb", "target": 1, "func": "static void opt_input_file(void *optctx, const char *arg)\n\n{\n\n    if (input_filename) {\n\n        fprintf(stderr,\n\n                \"Argument '%s' provided as input filename, but '%s' was already specified.\\n\",\n\n                arg, input_filename);\n\n        exit(1);\n\n    }\n\n    if (!strcmp(arg, \"-\"))\n\n        arg = \"pipe:\";\n\n    input_filename = arg;\n\n}\n", "idx": 23440}
{"project": "FFmpeg", "commit_id": "398f015f077c6a2406deffd9e37ff34b9c7bb3bc", "target": 0, "func": "static int transcode_subtitles(InputStream *ist, AVPacket *pkt, int *got_output)\n\n{\n\n    AVSubtitle subtitle;\n\n    int i, ret = avcodec_decode_subtitle2(ist->dec_ctx,\n\n                                          &subtitle, got_output, pkt);\n\n    if (ret < 0)\n\n        return ret;\n\n    if (!*got_output)\n\n        return ret;\n\n\n\n    ist->frames_decoded++;\n\n\n\n    for (i = 0; i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || !ost->encoding_needed)\n\n            continue;\n\n\n\n        do_subtitle_out(output_files[ost->file_index]->ctx, ost, ist, &subtitle, pkt->pts);\n\n    }\n\n\n\n    avsubtitle_free(&subtitle);\n\n    return ret;\n\n}\n", "idx": 23471}
{"project": "qemu", "commit_id": "08844473820c93541fc47bdfeae0f2cc88cfab59", "target": 0, "func": "void bdrv_setup_io_funcs(BlockDriver *bdrv)\n\n{\n\n    /* Block drivers without coroutine functions need emulation */\n\n    if (!bdrv->bdrv_co_readv) {\n\n        bdrv->bdrv_co_readv = bdrv_co_readv_em;\n\n        bdrv->bdrv_co_writev = bdrv_co_writev_em;\n\n\n\n        /* bdrv_co_readv_em()/brdv_co_writev_em() work in terms of aio, so if\n\n         * the block driver lacks aio we need to emulate that too.\n\n         */\n\n        if (!bdrv->bdrv_aio_readv) {\n\n            /* add AIO emulation layer */\n\n            bdrv->bdrv_aio_readv = bdrv_aio_readv_em;\n\n            bdrv->bdrv_aio_writev = bdrv_aio_writev_em;\n\n        }\n\n    }\n\n}\n", "idx": 23483}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct8_add4_mmx(uint8_t *dst, const int *block_offset, DCTELEM *block, int stride, const uint8_t nnzc[6*8]){\n\n    int i;\n\n    for(i=0; i<16; i+=4){\n\n        if(nnzc[ scan8[i] ])\n\n            ff_h264_idct8_add_mmx(dst + block_offset[i], block + i*16, stride);\n\n    }\n\n}\n", "idx": 23488}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "size_t virtio_serial_guest_ready(VirtIOSerialPort *port)\n\n{\n\n    VirtQueue *vq = port->ivq;\n\n    unsigned int bytes;\n\n\n\n    if (!virtio_queue_ready(vq) ||\n\n        !(port->vser->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK) ||\n\n        virtio_queue_empty(vq)) {\n\n        return 0;\n\n    }\n\n    if (use_multiport(port->vser) && !port->guest_connected) {\n\n        return 0;\n\n    }\n\n    virtqueue_get_avail_bytes(vq, &bytes, NULL);\n\n    return bytes;\n\n}\n", "idx": 23511}
{"project": "qemu", "commit_id": "2d0d2837dcf786da415cf4165d37f4ddd684ff57", "target": 0, "func": "DriveInfo *add_init_drive(const char *optstr)\n\n{\n\n    DriveInfo *dinfo;\n\n    QemuOpts *opts;\n\n\n\n    opts = drive_def(optstr);\n\n    if (!opts)\n\n        return NULL;\n\n\n\n    dinfo = drive_init(opts, current_machine->use_scsi);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n        return NULL;\n\n    }\n\n\n\n    return dinfo;\n\n}\n", "idx": 23520}
{"project": "qemu", "commit_id": "e912c96f7d2e5ccd8a6352ee74f5beee2a7d9976", "target": 0, "func": "static BusState *qbus_find_recursive(BusState *bus, const char *name,\n\n                                     const char *bus_typename)\n\n{\n\n    BusChild *kid;\n\n    BusState *child, *ret;\n\n    int match = 1;\n\n\n\n    if (name && (strcmp(bus->name, name) != 0)) {\n\n        match = 0;\n\n    }\n\n    if (bus_typename &&\n\n        (strcmp(object_get_typename(OBJECT(bus)), bus_typename) != 0)) {\n\n        match = 0;\n\n    }\n\n    if (match) {\n\n        return bus;\n\n    }\n\n\n\n    QTAILQ_FOREACH(kid, &bus->children, sibling) {\n\n        DeviceState *dev = kid->child;\n\n        QLIST_FOREACH(child, &dev->child_bus, sibling) {\n\n            ret = qbus_find_recursive(child, name, bus_typename);\n\n            if (ret) {\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 23523}
{"project": "qemu", "commit_id": "ee312992a323530ea2cda8680f3a34746c72db8f", "target": 0, "func": "void qemu_input_event_sync(void)\n\n{\n\n    QemuInputHandlerState *s;\n\n\n\n    if (!runstate_is_running() && !runstate_check(RUN_STATE_SUSPENDED)) {\n\n        return;\n\n    }\n\n\n\n    trace_input_event_sync();\n\n\n\n    QTAILQ_FOREACH(s, &handlers, node) {\n\n        if (!s->events) {\n\n            continue;\n\n        }\n\n        if (s->handler->sync) {\n\n            s->handler->sync(s->dev);\n\n        }\n\n        s->events = 0;\n\n    }\n\n}\n", "idx": 23545}
{"project": "FFmpeg", "commit_id": "7546964f96168cd6ac819ef4c3212ee586619f1a", "target": 0, "func": "static int nvdec_h264_decode_init(AVCodecContext *avctx)\n\n{\n\n    const H264Context *h = avctx->priv_data;\n\n    const SPS       *sps = h->ps.sps;\n\n    return ff_nvdec_decode_init(avctx, sps->ref_frame_count + sps->num_reorder_frames);\n\n}\n", "idx": 23575}
{"project": "FFmpeg", "commit_id": "e5755893786ecab2e6f0414d1b2983dcaa3d237e", "target": 1, "func": "static void mxf_free_metadataset(MXFMetadataSet **ctx, int freectx)\n\n{\n\n    MXFIndexTableSegment *seg;\n\n    switch ((*ctx)->type) {\n\n    case Descriptor:\n\n        av_freep(&((MXFDescriptor *)*ctx)->extradata);\n\n        break;\n\n    case MultipleDescriptor:\n\n        av_freep(&((MXFDescriptor *)*ctx)->sub_descriptors_refs);\n\n        break;\n\n    case Sequence:\n\n        av_freep(&((MXFSequence *)*ctx)->structural_components_refs);\n\n        break;\n\n    case EssenceGroup:\n\n        av_freep(&((MXFEssenceGroup *)*ctx)->structural_components_refs);\n\n        break;\n\n    case SourcePackage:\n\n    case MaterialPackage:\n\n        av_freep(&((MXFPackage *)*ctx)->tracks_refs);\n\n        av_freep(&((MXFPackage *)*ctx)->name);\n\n\n        break;\n\n    case TaggedValue:\n\n        av_freep(&((MXFTaggedValue *)*ctx)->name);\n\n        av_freep(&((MXFTaggedValue *)*ctx)->value);\n\n        break;\n\n    case IndexTableSegment:\n\n        seg = (MXFIndexTableSegment *)*ctx;\n\n        av_freep(&seg->temporal_offset_entries);\n\n        av_freep(&seg->flag_entries);\n\n        av_freep(&seg->stream_offset_entries);\n\n    default:\n\n        break;\n\n    }\n\n    if (freectx)\n\n    av_freep(ctx);\n\n}", "idx": 23580}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int64(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_S64);\n\n}\n", "idx": 23589}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "static void qint_destroy_obj(QObject *obj)\n\n{\n\n    assert(obj != NULL);\n\n    g_free(qobject_to_qint(obj));\n\n}\n", "idx": 23590}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "int ioinst_handle_tsch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    IRB irb;\n\n    uint64_t addr;\n\n    int cc, irb_len;\n\n    uint8_t ar;\n\n\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return -EIO;\n\n    }\n\n    trace_ioinst_sch_id(\"tsch\", cssid, ssid, schid);\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return -EIO;\n\n    }\n\n\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        cc = css_do_tsch_get_irb(sch, &irb, &irb_len);\n\n    } else {\n\n        cc = 3;\n\n    }\n\n    /* 0 - status pending, 1 - not status pending, 3 - not operational */\n\n    if (cc != 3) {\n\n        if (s390_cpu_virt_mem_write(cpu, addr, ar, &irb, irb_len) != 0) {\n\n            return -EFAULT;\n\n        }\n\n        css_do_tsch_update_subch(sch);\n\n    } else {\n\n        irb_len = sizeof(irb) - sizeof(irb.emw);\n\n        /* Access exceptions have a higher priority than cc3 */\n\n        if (s390_cpu_virt_mem_check_write(cpu, addr, ar, irb_len) != 0) {\n\n            return -EFAULT;\n\n        }\n\n    }\n\n\n\n    setcc(cpu, cc);\n\n    return 0;\n\n}\n", "idx": 23594}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static ssize_t v9fs_synth_pwritev(FsContext *ctx, V9fsFidOpenState *fs,\n\n                                  const struct iovec *iov,\n\n                                  int iovcnt, off_t offset)\n\n{\n\n    int i, count = 0, wcount;\n\n    V9fsSynthOpenState *synth_open = fs->private;\n\n    V9fsSynthNode *node = synth_open->node;\n\n    if (!node->attr->write) {\n\n        errno = EPERM;\n\n        return -1;\n\n    }\n\n    for (i = 0; i < iovcnt; i++) {\n\n        wcount = node->attr->write(iov[i].iov_base, iov[i].iov_len,\n\n                                   offset, node->private);\n\n        offset += wcount;\n\n        count  += wcount;\n\n        /* If we wrote less than requested. we are done */\n\n        if (wcount < iov[i].iov_len) {\n\n            break;\n\n        }\n\n    }\n\n    return count;\n\n}\n", "idx": 23616}
{"project": "qemu", "commit_id": "153eba4726dfa1bdfc31d1fe973b2a61b9035492", "target": 0, "func": "static void piix4_device_unplug_request_cb(HotplugHandler *hotplug_dev,\n\n                                           DeviceState *dev, Error **errp)\n\n{\n\n    PIIX4PMState *s = PIIX4_PM(hotplug_dev);\n\n\n\n    if (s->acpi_memory_hotplug.is_enabled &&\n\n        object_dynamic_cast(OBJECT(dev), TYPE_PC_DIMM)) {\n\n        acpi_memory_unplug_request_cb(hotplug_dev, &s->acpi_memory_hotplug,\n\n                                      dev, errp);\n\n    } else if (object_dynamic_cast(OBJECT(dev), TYPE_PCI_DEVICE)) {\n\n        acpi_pcihp_device_unplug_cb(hotplug_dev, &s->acpi_pci_hotplug, dev,\n\n                                    errp);\n\n    } else if (object_dynamic_cast(OBJECT(dev), TYPE_CPU) &&\n\n               !s->cpu_hotplug_legacy) {\n\n        acpi_cpu_unplug_request_cb(hotplug_dev, &s->cpuhp_state, dev, errp);\n\n    } else {\n\n        error_setg(errp, \"acpi: device unplug request for not supported device\"\n\n                   \" type: %s\", object_get_typename(OBJECT(dev)));\n\n    }\n\n}\n", "idx": 23621}
{"project": "FFmpeg", "commit_id": "3b199d29cd597a3518136d78860e172060b9e83d", "target": 0, "func": "static av_cold int smc_decode_init(AVCodecContext *avctx)\n\n{\n\n    SmcContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 23653}
{"project": "qemu", "commit_id": "d87aa138039a4be6d705793fd3e397c69c52405a", "target": 1, "func": "static void ohci_td_pkt(const char *msg, const uint8_t *buf, size_t len)\n\n{\n\n    bool print16 = !!trace_event_get_state(TRACE_USB_OHCI_TD_PKT_SHORT);\n\n    bool printall = !!trace_event_get_state(TRACE_USB_OHCI_TD_PKT_FULL);\n\n    const int width = 16;\n\n    int i;\n\n    char tmp[3 * width + 1];\n\n    char *p = tmp;\n\n\n\n    if (!printall && !print16) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; ; i++) {\n\n        if (i && (!(i % width) || (i == len))) {\n\n            if (!printall) {\n\n                trace_usb_ohci_td_pkt_short(msg, tmp);\n\n                break;\n\n            }\n\n            trace_usb_ohci_td_pkt_full(msg, tmp);\n\n            p = tmp;\n\n            *p = 0;\n\n        }\n\n        if (i == len) {\n\n            break;\n\n        }\n\n\n\n        p += sprintf(p, \" %.2x\", buf[i]);\n\n    }\n\n}\n", "idx": 23663}
{"project": "FFmpeg", "commit_id": "290e7eb77bee5a54182fb3d5fb122c1e117190da", "target": 1, "func": "void ff_set_fixed_vector(float *out, const AMRFixed *in, float scale, int size)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i < in->n; i++) {\n\n        int x   = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);\n\n        float y = in->y[i] * scale;\n\n\n\n\n        do {\n\n            out[x] += y;\n\n            y *= in->pitch_fac;\n\n            x += in->pitch_lag;\n\n        } while (x < size && repeats);\n\n    }\n\n}", "idx": 23665}
{"project": "qemu", "commit_id": "9ea63c05d90ba85d819f9b2472ce6dfba7a403b4", "target": 0, "func": "int do_subchannel_work_virtual(SubchDev *sch)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func_virtual(sch);\n\n    } else {\n\n        /* Cannot happen. */\n\n        return 0;\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n    return 0;\n\n}\n", "idx": 23682}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static inline uint64_t ldq_phys_internal(target_phys_addr_t addr,\n\n                                         enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* I/O case */\n\n        addr = memory_region_section_addr(section, addr);\n\n\n\n        /* XXX This is broken when device endian != cpu endian.\n\n               Fix and add \"endian\" variable check */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        val = io_mem_read(section->mr, addr, 4) << 32;\n\n        val |= io_mem_read(section->mr, addr + 4, 4);\n\n#else\n\n        val = io_mem_read(section->mr, addr, 4);\n\n        val |= io_mem_read(section->mr, addr + 4, 4) << 32;\n\n#endif\n\n    } else {\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)\n\n                                & TARGET_PAGE_MASK)\n\n                               + memory_region_section_addr(section, addr));\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            val = ldq_le_p(ptr);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            val = ldq_be_p(ptr);\n\n            break;\n\n        default:\n\n            val = ldq_p(ptr);\n\n            break;\n\n        }\n\n    }\n\n    return val;\n\n}\n", "idx": 23686}
{"project": "qemu", "commit_id": "2e6fc7eb1a4af1b127df5f07b8bb28af891946fa", "target": 0, "func": "static int raw_reopen_prepare(BDRVReopenState *reopen_state,\n\n                              BlockReopenQueue *queue, Error **errp)\n\n{\n\n    assert(reopen_state != NULL);\n\n    assert(reopen_state->bs != NULL);\n\n\n\n    reopen_state->opaque = g_new0(BDRVRawState, 1);\n\n\n\n    return raw_read_options(\n\n        reopen_state->options,\n\n        reopen_state->bs,\n\n        reopen_state->opaque,\n\n        errp);\n\n}\n", "idx": 23689}
{"project": "qemu", "commit_id": "e829b0bb054ed3389e5b22dad61875e51674e629", "target": 1, "func": "iscsi_readcapacity16_cb(struct iscsi_context *iscsi, int status,\n\n                        void *command_data, void *opaque)\n\n{\n\n    struct IscsiTask *itask = opaque;\n\n    struct scsi_readcapacity16 *rc16;\n\n    struct scsi_task *task = command_data;\n\n\n\n    if (status != 0) {\n\n        error_report(\"iSCSI: Failed to read capacity of iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        itask->status   = 1;\n\n        itask->complete = 1;\n\n        scsi_free_scsi_task(task);\n\n        return;\n\n    }\n\n\n\n    rc16 = scsi_datain_unmarshall(task);\n\n    if (rc16 == NULL) {\n\n        error_report(\"iSCSI: Failed to unmarshall readcapacity16 data.\");\n\n        itask->status   = 1;\n\n        itask->complete = 1;\n\n        scsi_free_scsi_task(task);\n\n        return;\n\n    }\n\n\n\n    itask->iscsilun->block_size = rc16->block_length;\n\n    itask->iscsilun->num_blocks = rc16->returned_lba + 1;\n\n    itask->bs->total_sectors    = itask->iscsilun->num_blocks *\n\n                               itask->iscsilun->block_size / BDRV_SECTOR_SIZE ;\n\n\n\n    itask->status   = 0;\n\n    itask->complete = 1;\n\n    scsi_free_scsi_task(task);\n\n}\n", "idx": 23727}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static void fill_scaling_lists(const AVCodecContext *avctx, AVDXVAContext *ctx, const H264Context *h, DXVA_Qmatrix_H264 *qm)\n\n{\n\n    unsigned i, j;\n\n    memset(qm, 0, sizeof(*qm));\n\n    if (DXVA_CONTEXT_WORKAROUND(avctx, ctx) & FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG) {\n\n        for (i = 0; i < 6; i++)\n\n            for (j = 0; j < 16; j++)\n\n                qm->bScalingLists4x4[i][j] = h->pps.scaling_matrix4[i][j];\n\n\n\n        for (i = 0; i < 64; i++) {\n\n            qm->bScalingLists8x8[0][i] = h->pps.scaling_matrix8[0][i];\n\n            qm->bScalingLists8x8[1][i] = h->pps.scaling_matrix8[3][i];\n\n        }\n\n    } else {\n\n        for (i = 0; i < 6; i++)\n\n            for (j = 0; j < 16; j++)\n\n                qm->bScalingLists4x4[i][j] = h->pps.scaling_matrix4[i][ff_zigzag_scan[j]];\n\n\n\n        for (i = 0; i < 64; i++) {\n\n            qm->bScalingLists8x8[0][i] = h->pps.scaling_matrix8[0][ff_zigzag_direct[i]];\n\n            qm->bScalingLists8x8[1][i] = h->pps.scaling_matrix8[3][ff_zigzag_direct[i]];\n\n        }\n\n    }\n\n}\n", "idx": 23731}
{"project": "FFmpeg", "commit_id": "8b31c086b6065084644b86a63c9171f3094cf6ad", "target": 0, "func": "static int decode_tag(AVCodecContext * avctx,\n\n                      void *data, int *data_size,\n\n                      AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    NellyMoserDecodeContext *s = avctx->priv_data;\n\n    int blocks, i;\n\n    int16_t* samples;\n\n    *data_size = 0;\n\n    samples = (int16_t*)data;\n\n\n\n    if (buf_size < avctx->block_align)\n\n        return buf_size;\n\n\n\n    if (buf_size % 64) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Tag size %d.\\n\", buf_size);\n\n        return buf_size;\n\n    }\n\n    blocks = buf_size / 64;\n\n    /* Normal numbers of blocks for sample rates:\n\n     *  8000 Hz - 1\n\n     * 11025 Hz - 2\n\n     * 16000 Hz - 3\n\n     * 22050 Hz - 4\n\n     * 44100 Hz - 8\n\n     */\n\n\n\n    for (i=0 ; i<blocks ; i++) {\n\n        nelly_decode_block(s, &buf[i*NELLY_BLOCK_LEN], s->float_buf);\n\n        s->fmt_conv.float_to_int16(&samples[i*NELLY_SAMPLES], s->float_buf, NELLY_SAMPLES);\n\n        *data_size += NELLY_SAMPLES*sizeof(int16_t);\n\n    }\n\n\n\n    return buf_size;\n\n}\n", "idx": 23756}
{"project": "qemu", "commit_id": "765a707000e838c30b18d712fe6cb3dd8e0435f3", "target": 1, "func": "static int megasas_map_dcmd(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    dma_addr_t iov_pa, iov_size;\n\n\n\n    cmd->flags = le16_to_cpu(cmd->frame->header.flags);\n\n    if (!cmd->frame->header.sge_count) {\n\n        trace_megasas_dcmd_zero_sge(cmd->index);\n\n        cmd->iov_size = 0;\n\n        return 0;\n\n    } else if (cmd->frame->header.sge_count > 1) {\n\n        trace_megasas_dcmd_invalid_sge(cmd->index,\n\n                                       cmd->frame->header.sge_count);\n\n        cmd->iov_size = 0;\n\n        return -1;\n\n    }\n\n    iov_pa = megasas_sgl_get_addr(cmd, &cmd->frame->dcmd.sgl);\n\n    iov_size = megasas_sgl_get_len(cmd, &cmd->frame->dcmd.sgl);\n\n    pci_dma_sglist_init(&cmd->qsg, PCI_DEVICE(s), 1);\n\n    qemu_sglist_add(&cmd->qsg, iov_pa, iov_size);\n\n    cmd->iov_size = iov_size;\n\n    return cmd->iov_size;\n\n}\n", "idx": 23761}
{"project": "qemu", "commit_id": "4b9b7092b4cbef084138a446b8247ba89fd474f4", "target": 1, "func": "static void cdrom_change_cb(void *opaque, int reason)\n\n{\n\n    IDEState *s = opaque;\n\n    uint64_t nb_sectors;\n\n\n\n    if (!(reason & CHANGE_MEDIA)) {\n\n        return;\n\n    }\n\n\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n\n    s->nb_sectors = nb_sectors;\n\n\n\n    s->sense_key = SENSE_UNIT_ATTENTION;\n\n    s->asc = ASC_MEDIUM_MAY_HAVE_CHANGED;\n\n    s->cdrom_changed = 1;\n\n    s->events.new_media = true;\n\n    ide_set_irq(s->bus);\n\n}\n", "idx": 23772}
{"project": "qemu", "commit_id": "599d0c45615b7d099d256738a586d0f63bc707e6", "target": 1, "func": "static int xen_host_pci_sysfs_path(const XenHostPCIDevice *d,\n\n                                   const char *name, char *buf, ssize_t size)\n\n{\n\n    int rc;\n\n\n\n    rc = snprintf(buf, size, \"/sys/bus/pci/devices/%04x:%02x:%02x.%d/%s\",\n\n                  d->domain, d->bus, d->dev, d->func, name);\n\n\n\n    if (rc >= size || rc < 0) {\n\n        /* The output is truncated, or some other error was encountered */\n\n        return -ENODEV;\n\n    }\n\n    return 0;\n\n}\n", "idx": 23806}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_validate_fail_union_native_list(TestInputVisitorData *data,\n\n                                                 const void *unused)\n\n{\n\n    UserDefNativeListUnion *tmp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data,\n\n                           \"{ 'type': 'integer', 'data' : [ 'string' ] }\");\n\n\n\n    visit_type_UserDefNativeListUnion(v, NULL, &tmp, &err);\n\n    error_free_or_abort(&err);\n\n    g_assert(!tmp);\n\n}\n", "idx": 23822}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qpci_msix_disable(QPCIDevice *dev)\n\n{\n\n    uint8_t addr;\n\n    uint16_t val;\n\n\n\n    g_assert(dev->msix_enabled);\n\n    addr = qpci_find_capability(dev, PCI_CAP_ID_MSIX);\n\n    g_assert_cmphex(addr, !=, 0);\n\n    val = qpci_config_readw(dev, addr + PCI_MSIX_FLAGS);\n\n    qpci_config_writew(dev, addr + PCI_MSIX_FLAGS,\n\n                                                val & ~PCI_MSIX_FLAGS_ENABLE);\n\n\n\n    qpci_iounmap(dev, dev->msix_table);\n\n    qpci_iounmap(dev, dev->msix_pba);\n\n    dev->msix_enabled = 0;\n\n    dev->msix_table = NULL;\n\n    dev->msix_pba = NULL;\n\n}\n", "idx": 23841}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_rtc_s *omap_rtc_init(MemoryRegion *system_memory,\n\n                                        target_phys_addr_t base,\n\n                                        qemu_irq timerirq, qemu_irq alarmirq,\n\n                                        omap_clk clk)\n\n{\n\n    struct omap_rtc_s *s = (struct omap_rtc_s *)\n\n            g_malloc0(sizeof(struct omap_rtc_s));\n\n\n\n    s->irq = timerirq;\n\n    s->alarm = alarmirq;\n\n    s->clk = qemu_new_timer_ms(rtc_clock, omap_rtc_tick, s);\n\n\n\n    omap_rtc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_rtc_ops, s,\n\n                          \"omap-rtc\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 23847}
{"project": "qemu", "commit_id": "ccf1e2dcd6091eea1fc2341c63201aa1a6094978", "target": 0, "func": "static ssize_t qio_channel_socket_writev(QIOChannel *ioc,\n\n                                         const struct iovec *iov,\n\n                                         size_t niov,\n\n                                         int *fds,\n\n                                         size_t nfds,\n\n                                         Error **errp)\n\n{\n\n    QIOChannelSocket *sioc = QIO_CHANNEL_SOCKET(ioc);\n\n    ssize_t ret;\n\n    struct msghdr msg = { NULL, };\n\n    char control[CMSG_SPACE(sizeof(int) * SOCKET_MAX_FDS)] = { 0 };\n\n    size_t fdsize = sizeof(int) * nfds;\n\n    struct cmsghdr *cmsg;\n\n\n\n    msg.msg_iov = (struct iovec *)iov;\n\n    msg.msg_iovlen = niov;\n\n\n\n    if (nfds) {\n\n        if (nfds > SOCKET_MAX_FDS) {\n\n            error_setg_errno(errp, EINVAL,\n\n                             \"Only %d FDs can be sent, got %zu\",\n\n                             SOCKET_MAX_FDS, nfds);\n\n            return -1;\n\n        }\n\n\n\n        msg.msg_control = control;\n\n        msg.msg_controllen = CMSG_SPACE(sizeof(int) * nfds);\n\n\n\n        cmsg = CMSG_FIRSTHDR(&msg);\n\n        cmsg->cmsg_len = CMSG_LEN(fdsize);\n\n        cmsg->cmsg_level = SOL_SOCKET;\n\n        cmsg->cmsg_type = SCM_RIGHTS;\n\n        memcpy(CMSG_DATA(cmsg), fds, fdsize);\n\n    }\n\n\n\n retry:\n\n    ret = sendmsg(sioc->fd, &msg, 0);\n\n    if (ret <= 0) {\n\n        if (socket_error() == EAGAIN ||\n\n            socket_error() == EWOULDBLOCK) {\n\n            return QIO_CHANNEL_ERR_BLOCK;\n\n        }\n\n        if (socket_error() == EINTR) {\n\n            goto retry;\n\n        }\n\n        error_setg_errno(errp, socket_error(),\n\n                         \"Unable to write to socket\");\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23849}
{"project": "qemu", "commit_id": "9167a69a816b8956d62da628b5b4dc87674647d6", "target": 0, "func": "void *lsi_scsi_init(PCIBus *bus, int devfn)\n\n{\n\n    LSIState *s;\n\n\n\n    s = (LSIState *)pci_register_device(bus, \"LSI53C895A SCSI HBA\",\n\n                                        sizeof(*s), devfn, NULL, NULL);\n\n    if (s == NULL) {\n\n        fprintf(stderr, \"lsi-scsi: Failed to register PCI device\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    s->pci_dev.config[0x00] = 0x00;\n\n    s->pci_dev.config[0x01] = 0x10;\n\n    s->pci_dev.config[0x02] = 0x12;\n\n    s->pci_dev.config[0x03] = 0x00;\n\n    s->pci_dev.config[0x0b] = 0x01;\n\n    s->pci_dev.config[0x3d] = 0x01; /* interrupt pin 1 */\n\n\n\n    s->mmio_io_addr = cpu_register_io_memory(0, lsi_mmio_readfn,\n\n                                             lsi_mmio_writefn, s);\n\n    s->ram_io_addr = cpu_register_io_memory(0, lsi_ram_readfn,\n\n                                            lsi_ram_writefn, s);\n\n\n\n    pci_register_io_region((struct PCIDevice *)s, 0, 256,\n\n                           PCI_ADDRESS_SPACE_IO, lsi_io_mapfunc);\n\n    pci_register_io_region((struct PCIDevice *)s, 1, 0x400,\n\n                           PCI_ADDRESS_SPACE_MEM, lsi_mmio_mapfunc);\n\n    pci_register_io_region((struct PCIDevice *)s, 2, 0x2000,\n\n                           PCI_ADDRESS_SPACE_MEM, lsi_ram_mapfunc);\n\n    s->queue = qemu_malloc(sizeof(lsi_queue));\n\n    s->queue_len = 1;\n\n    s->active_commands = 0;\n\n\n\n    lsi_soft_reset(s);\n\n\n\n    return s;\n\n}\n", "idx": 23861}
{"project": "qemu", "commit_id": "38ee14f4f33f8836fc0e209ca59c6ae8c6edf380", "target": 1, "func": "static void vnc_refresh(DisplayChangeListener *dcl)\n\n{\n\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n\n    VncState *vs, *vn;\n\n    int has_dirty, rects = 0;\n\n\n\n    graphic_hw_update(NULL);\n\n\n\n    if (vnc_trylock_display(vd)) {\n\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n\n        return;\n\n    }\n\n\n\n    has_dirty = vnc_refresh_server_surface(vd);\n\n    vnc_unlock_display(vd);\n\n\n\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n\n        rects += vnc_update_client(vs, has_dirty);\n\n        /* vs might be free()ed here */\n\n    }\n\n\n\n    if (QTAILQ_EMPTY(&vd->clients)) {\n\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_MAX);\n\n        return;\n\n    }\n\n\n\n    if (has_dirty && rects) {\n\n        vd->dcl.update_interval /= 2;\n\n        if (vd->dcl.update_interval < VNC_REFRESH_INTERVAL_BASE) {\n\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;\n\n        }\n\n    } else {\n\n        vd->dcl.update_interval += VNC_REFRESH_INTERVAL_INC;\n\n        if (vd->dcl.update_interval > VNC_REFRESH_INTERVAL_MAX) {\n\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;\n\n        }\n\n    }\n\n}\n", "idx": 23894}
{"project": "FFmpeg", "commit_id": "8155233413540c63e53a620ff5734fb4b0635611", "target": 1, "func": "static int int_pow(int i, int *exp_ptr)\n\n{\n\n    int e, er, eq, j;\n\n    int a, a1;\n\n    \n\n    /* renormalize */\n\n    a = i;\n\n    e = POW_FRAC_BITS;\n\n    while (a < (1 << (POW_FRAC_BITS - 1))) {\n\n        a = a << 1;\n\n        e--;\n\n    }\n\n    a -= (1 << POW_FRAC_BITS);\n\n    a1 = 0;\n\n    for(j = DEV_ORDER - 1; j >= 0; j--)\n\n        a1 = POW_MULL(a, dev_4_3_coefs[j] + a1);\n\n    a = (1 << POW_FRAC_BITS) + a1;\n\n    /* exponent compute (exact) */\n\n    e = e * 4;\n\n    er = e % 3;\n\n    eq = e / 3;\n\n    a = POW_MULL(a, pow_mult3[er]);\n\n    while (a >= 2 * POW_FRAC_ONE) {\n\n        a = a >> 1;\n\n        eq++;\n\n    }\n\n    /* convert to float */\n\n    while (a < POW_FRAC_ONE) {\n\n        a = a << 1;\n\n        eq--;\n\n    }\n\n    /* now POW_FRAC_ONE <= a < 2 * POW_FRAC_ONE */\n\n#if (POW_FRAC_BITS - 1) > FRAC_BITS\n\n    a = (a + (1 << (POW_FRAC_BITS - FRAC_BITS - 1))) >> (POW_FRAC_BITS - FRAC_BITS);\n\n    /* correct overflow */\n\n    if (a >= 2 * (1 << FRAC_BITS)) {\n\n        a = a >> 1;\n\n        eq++;\n\n    }\n\n#endif\n\n    *exp_ptr = eq;\n\n    return a;\n\n}\n", "idx": 23903}
{"project": "qemu", "commit_id": "751f8cfe2a556b3ef49f6af2860e2d1d2a1ec66a", "target": 1, "func": "int monitor_set_cpu(int cpu_index)\n\n{\n\n    CPUState *cpu;\n\n\n\n    cpu = qemu_get_cpu(cpu_index);\n\n    if (cpu == NULL) {\n\n        return -1;\n\n    }\n\n    cur_mon->mon_cpu = cpu;\n\n    return 0;\n\n}\n", "idx": 23911}
{"project": "FFmpeg", "commit_id": "153b36fc62849e0e1540a43829794e0503994ebb", "target": 0, "func": "unsigned ff_dxva2_get_surface_index(const AVCodecContext *avctx,\n\n                                    const AVDXVAContext *ctx,\n\n                                    const AVFrame *frame)\n\n{\n\n    void *surface = get_surface(frame);\n\n    unsigned i;\n\n\n\n    for (i = 0; i < DXVA_CONTEXT_COUNT(avctx, ctx); i++) {\n\n#if CONFIG_D3D11VA\n\n        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD && ctx->d3d11va.surface[i] == surface)\n\n        {\n\n            D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC viewDesc;\n\n            ID3D11VideoDecoderOutputView_GetDesc(ctx->d3d11va.surface[i], &viewDesc);\n\n            return viewDesc.Texture2D.ArraySlice;\n\n        }\n\n#endif\n\n#if CONFIG_DXVA2\n\n        if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD && ctx->dxva2.surface[i] == surface)\n\n            return i;\n\n#endif\n\n    }\n\n\n\n    assert(0);\n\n    return 0;\n\n}\n", "idx": 23929}
{"project": "qemu", "commit_id": "9ecaa27e7123211f45ca723a736ffae14f6c1f42", "target": 1, "func": "uint32_t HELPER(mul32)(CPUOpenRISCState *env,\n\n                       uint32_t ra, uint32_t rb)\n\n{\n\n    uint64_t result;\n\n    uint32_t high, cy;\n\n\n\n    OpenRISCCPU *cpu = openrisc_env_get_cpu(env);\n\n\n\n    result = (uint64_t)ra * rb;\n\n    /* regisiers in or32 is 32bit, so 32 is NOT a magic number.\n\n       or64 is not handled in this function, and not implement yet,\n\n       TARGET_LONG_BITS for or64 is 64, it will break this function,\n\n       so, we didn't use TARGET_LONG_BITS here.  */\n\n    high = result >> 32;\n\n    cy = result >> (32 - 1);\n\n\n\n    if ((cy & 0x1) == 0x0) {\n\n        if (high == 0x0) {\n\n            return result;\n\n        }\n\n    }\n\n\n\n    if ((cy & 0x1) == 0x1) {\n\n        if (high == 0xffffffff) {\n\n            return result;\n\n        }\n\n    }\n\n\n\n    cpu->env.sr |= (SR_OV | SR_CY);\n\n    if (cpu->env.sr & SR_OVE) {\n\n        raise_exception(cpu, EXCP_RANGE);\n\n    }\n\n\n\n    return result;\n\n}\n", "idx": 23949}
{"project": "FFmpeg", "commit_id": "14bd2a9f25fc0de4fb1a2d4afaef09162c51bb35", "target": 0, "func": "static int find_optimal_param(uint32_t sum, int n)\n\n{\n\n    int k, k_opt;\n\n    uint32_t nbits[MAX_RICE_PARAM+1];\n\n\n\n    k_opt = 0;\n\n    nbits[0] = UINT32_MAX;\n\n    for(k=0; k<=MAX_RICE_PARAM; k++) {\n\n        nbits[k] = rice_encode_count(sum, n, k);\n\n        if(nbits[k] < nbits[k_opt]) {\n\n            k_opt = k;\n\n        }\n\n    }\n\n    return k_opt;\n\n}\n", "idx": 24037}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_sf2df)(float32 x, CPUUniCore32State *env)\n\n{\n\n    return float32_to_float64(x, &env->ucf64.fp_status);\n\n}\n", "idx": 24042}
{"project": "qemu", "commit_id": "30656b097e9dd7978d3fe9416cb9f5a421a9e63e", "target": 0, "func": "static ssize_t colo_rewriter_receive_iov(NetFilterState *nf,\n\n                                         NetClientState *sender,\n\n                                         unsigned flags,\n\n                                         const struct iovec *iov,\n\n                                         int iovcnt,\n\n                                         NetPacketSent *sent_cb)\n\n{\n\n    RewriterState *s = FILTER_COLO_REWRITER(nf);\n\n    Connection *conn;\n\n    ConnectionKey key;\n\n    Packet *pkt;\n\n    ssize_t size = iov_size(iov, iovcnt);\n\n    char *buf = g_malloc0(size);\n\n\n\n    iov_to_buf(iov, iovcnt, 0, buf, size);\n\n    pkt = packet_new(buf, size);\n\n\n\n    /*\n\n     * if we get tcp packet\n\n     * we will rewrite it to make secondary guest's\n\n     * connection established successfully\n\n     */\n\n    if (pkt && is_tcp_packet(pkt)) {\n\n\n\n        fill_connection_key(pkt, &key);\n\n\n\n        if (sender == nf->netdev) {\n\n            /*\n\n             * We need make tcp TX and RX packet\n\n             * into one connection.\n\n             */\n\n            reverse_connection_key(&key);\n\n        }\n\n        conn = connection_get(s->connection_track_table,\n\n                              &key,\n\n                              NULL);\n\n\n\n        if (sender == nf->netdev) {\n\n            /* NET_FILTER_DIRECTION_TX */\n\n            /* handle_primary_tcp_pkt */\n\n        } else {\n\n            /* NET_FILTER_DIRECTION_RX */\n\n            /* handle_secondary_tcp_pkt */\n\n        }\n\n    }\n\n\n\n    packet_destroy(pkt, NULL);\n\n    pkt = NULL;\n\n    return 0;\n\n}\n", "idx": 24046}
{"project": "FFmpeg", "commit_id": "cd2f7ed0007f4803b6bd845366b2398abb32c355", "target": 0, "func": "static void ts_str(char buffer[60], int64_t ts, AVRational base)\n\n{\n\n    if (ts == AV_NOPTS_VALUE) {\n\n        strcpy(buffer, \" NOPTS   \");\n\n        return;\n\n    }\n\n    ts= av_rescale_q(ts, base, (AVRational){1, 1000000});\n\n    snprintf(buffer, 60, \"%c%Ld.%06Ld\", ts<0 ? '-' : ' ', FFABS(ts)/1000000, FFABS(ts)%1000000);\n\n}\n", "idx": 24048}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int alsa_init_out (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    ALSAVoiceOut *alsa = (ALSAVoiceOut *) hw;\n\n    struct alsa_params_req req;\n\n    struct alsa_params_obt obt;\n\n    snd_pcm_t *handle;\n\n    struct audsettings obt_as;\n\n\n\n    req.fmt = aud_to_alsafmt (as->fmt, as->endianness);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.period_size = conf.period_size_out;\n\n    req.buffer_size = conf.buffer_size_out;\n\n    req.size_in_usec = conf.size_in_usec_out;\n\n    req.override_mask =\n\n        (conf.period_size_out_overridden ? 1 : 0) |\n\n        (conf.buffer_size_out_overridden ? 2 : 0);\n\n\n\n    if (alsa_open (0, &req, &obt, &handle)) {\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = obt.fmt;\n\n    obt_as.endianness = obt.endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = obt.samples;\n\n\n\n    alsa->pcm_buf = audio_calloc (AUDIO_FUNC, obt.samples, 1 << hw->info.shift);\n\n    if (!alsa->pcm_buf) {\n\n        dolog (\"Could not allocate DAC buffer (%d samples, each %d bytes)\\n\",\n\n               hw->samples, 1 << hw->info.shift);\n\n        alsa_anal_close1 (&handle);\n\n        return -1;\n\n    }\n\n\n\n    alsa->handle = handle;\n\n    return 0;\n\n}\n", "idx": 24066}
{"project": "qemu", "commit_id": "60dcbcb5b1a0d185be607b03fc7a15bf1bab4bec", "target": 0, "func": "static abi_ulong setup_arg_pages(abi_ulong p, struct linux_binprm *bprm,\n\n                                 struct image_info *info)\n\n{\n\n    abi_ulong stack_base, size, error;\n\n    int i;\n\n\n\n    /* Create enough stack to hold everything.  If we don't use\n\n     * it for args, we'll use it for something else...\n\n     */\n\n    size = guest_stack_size;\n\n    if (size < MAX_ARG_PAGES*TARGET_PAGE_SIZE)\n\n        size = MAX_ARG_PAGES*TARGET_PAGE_SIZE;\n\n    error = target_mmap(0,\n\n                        size + qemu_host_page_size,\n\n                        PROT_READ | PROT_WRITE,\n\n                        MAP_PRIVATE | MAP_ANONYMOUS,\n\n                        -1, 0);\n\n    if (error == -1) {\n\n        perror(\"stk mmap\");\n\n        exit(-1);\n\n    }\n\n    /* we reserve one extra page at the top of the stack as guard */\n\n    target_mprotect(error + size, qemu_host_page_size, PROT_NONE);\n\n\n\n    info->stack_limit = error;\n\n    stack_base = error + size - MAX_ARG_PAGES*TARGET_PAGE_SIZE;\n\n    p += stack_base;\n\n\n\n    for (i = 0 ; i < MAX_ARG_PAGES ; i++) {\n\n        if (bprm->page[i]) {\n\n            info->rss++;\n\n            /* FIXME - check return value of memcpy_to_target() for failure */\n\n            memcpy_to_target(stack_base, bprm->page[i], TARGET_PAGE_SIZE);\n\n            free(bprm->page[i]);\n\n        }\n\n        stack_base += TARGET_PAGE_SIZE;\n\n    }\n\n    return p;\n\n}\n", "idx": 24089}
{"project": "qemu", "commit_id": "9ef91a677110ec200d7b2904fc4bcae5a77329ad", "target": 0, "func": "static size_t handle_aiocb_rw_vector(struct qemu_paiocb *aiocb)\n\n{\n\n    size_t offset = 0;\n\n    ssize_t len;\n\n\n\n    do {\n\n        if (aiocb->aio_type == QEMU_PAIO_WRITE)\n\n            len = qemu_pwritev(aiocb->aio_fildes,\n\n                               aiocb->aio_iov,\n\n                               aiocb->aio_niov,\n\n                               aiocb->aio_offset + offset);\n\n         else\n\n            len = qemu_preadv(aiocb->aio_fildes,\n\n                              aiocb->aio_iov,\n\n                              aiocb->aio_niov,\n\n                              aiocb->aio_offset + offset);\n\n    } while (len == -1 && errno == EINTR);\n\n\n\n    if (len == -1)\n\n        return -errno;\n\n    return len;\n\n}\n", "idx": 24095}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static VncClientInfo *qmp_query_vnc_client(const VncState *client)\n\n{\n\n    struct sockaddr_storage sa;\n\n    socklen_t salen = sizeof(sa);\n\n    char host[NI_MAXHOST];\n\n    char serv[NI_MAXSERV];\n\n    VncClientInfo *info;\n\n\n\n    if (getpeername(client->csock, (struct sockaddr *)&sa, &salen) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    if (getnameinfo((struct sockaddr *)&sa, salen,\n\n                    host, sizeof(host),\n\n                    serv, sizeof(serv),\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    info = g_malloc0(sizeof(*info));\n\n    info->base = g_malloc0(sizeof(*info->base));\n\n    info->base->host = g_strdup(host);\n\n    info->base->service = g_strdup(serv);\n\n    info->base->family = inet_netfamily(sa.ss_family);\n\n    info->base->websocket = client->websocket;\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    if (client->tls.session && client->tls.dname) {\n\n        info->has_x509_dname = true;\n\n        info->x509_dname = g_strdup(client->tls.dname);\n\n    }\n\n#endif\n\n#ifdef CONFIG_VNC_SASL\n\n    if (client->sasl.conn && client->sasl.username) {\n\n        info->has_sasl_username = true;\n\n        info->sasl_username = g_strdup(client->sasl.username);\n\n    }\n\n#endif\n\n\n\n    return info;\n\n}\n", "idx": 24114}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "int kvm_arch_put_registers(CPUState *env)\n\n{\n\n    struct kvm_regs regs;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_GET_REGS, &regs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    regs.ctr = env->ctr;\n\n    regs.lr  = env->lr;\n\n    regs.xer = env->xer;\n\n    regs.msr = env->msr;\n\n    regs.pc = env->nip;\n\n\n\n    regs.srr0 = env->spr[SPR_SRR0];\n\n    regs.srr1 = env->spr[SPR_SRR1];\n\n\n\n    regs.sprg0 = env->spr[SPR_SPRG0];\n\n    regs.sprg1 = env->spr[SPR_SPRG1];\n\n    regs.sprg2 = env->spr[SPR_SPRG2];\n\n    regs.sprg3 = env->spr[SPR_SPRG3];\n\n    regs.sprg4 = env->spr[SPR_SPRG4];\n\n    regs.sprg5 = env->spr[SPR_SPRG5];\n\n    regs.sprg6 = env->spr[SPR_SPRG6];\n\n    regs.sprg7 = env->spr[SPR_SPRG7];\n\n\n\n    for (i = 0;i < 32; i++)\n\n        regs.gpr[i] = env->gpr[i];\n\n\n\n    ret = kvm_vcpu_ioctl(env, KVM_SET_REGS, &regs);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    return ret;\n\n}\n", "idx": 24117}
{"project": "qemu", "commit_id": "5b5cb08683b6715a2aca5314168e68ff0665912b", "target": 0, "func": "static void msix_mmio_writel(void *opaque, target_phys_addr_t addr,\n\n                             uint32_t val)\n\n{\n\n    PCIDevice *dev = opaque;\n\n    unsigned int offset = addr & (MSIX_PAGE_SIZE - 1) & ~0x3;\n\n    int vector = offset / MSIX_ENTRY_SIZE;\n\n    pci_set_long(dev->msix_table_page + offset, val);\n\n    if (!msix_is_masked(dev, vector) && msix_is_pending(dev, vector)) {\n\n        msix_clr_pending(dev, vector);\n\n        msix_notify(dev, vector);\n\n    }\n\n}\n", "idx": 24156}
{"project": "qemu", "commit_id": "698feb5e13a2d763369909ce33f2bd7a7c1c11c0", "target": 0, "func": "static void vhost_iommu_region_del(MemoryListener *listener,\n\n                                   MemoryRegionSection *section)\n\n{\n\n    struct vhost_dev *dev = container_of(listener, struct vhost_dev,\n\n                                         iommu_listener);\n\n    struct vhost_iommu *iommu;\n\n\n\n    if (!memory_region_is_iommu(section->mr)) {\n\n        return;\n\n    }\n\n\n\n    QLIST_FOREACH(iommu, &dev->iommu_list, iommu_next) {\n\n        if (iommu->mr == section->mr) {\n\n            memory_region_unregister_iommu_notifier(iommu->mr,\n\n                                                    &iommu->n);\n\n            QLIST_REMOVE(iommu, iommu_next);\n\n            g_free(iommu);\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 24160}
{"project": "qemu", "commit_id": "ba5e6bfa1aee29a8f72c5538c565dfb9889cf273", "target": 0, "func": "static void vfio_vga_quirk_teardown(VFIOPCIDevice *vdev)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(vdev->vga.region); i++) {\n\n        while (!QLIST_EMPTY(&vdev->vga.region[i].quirks)) {\n\n            VFIOQuirk *quirk = QLIST_FIRST(&vdev->vga.region[i].quirks);\n\n            memory_region_del_subregion(&vdev->vga.region[i].mem, &quirk->mem);\n\n            object_unparent(OBJECT(&quirk->mem));\n\n            QLIST_REMOVE(quirk, next);\n\n            g_free(quirk);\n\n        }\n\n    }\n\n}\n", "idx": 24161}
{"project": "qemu", "commit_id": "6dc06f08b3d6c0347df00ac68d9f30e2b233a749", "target": 0, "func": "int scsi_req_get_sense(SCSIRequest *req, uint8_t *buf, int len)\n\n{\n\n    assert(len >= 14);\n\n    if (!req->sense_len) {\n\n        return 0;\n\n    }\n\n    return scsi_build_sense(req->sense, req->sense_len, buf, len, true);\n\n}\n", "idx": 24168}
{"project": "qemu", "commit_id": "250a87d5561a7212fe43357b084f69992eced75a", "target": 0, "func": "uint64_t HELPER(popcnt)(uint64_t r2)\n\n{\n\n    uint64_t ret = 0;\n\n    int i;\n\n\n\n    for (i = 0; i < 64; i += 8) {\n\n        uint64_t t = ctpop32((r2 >> i) & 0xff);\n\n        ret |= t << i;\n\n    }\n\n    return ret;\n\n}\n", "idx": 24199}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_backspace(void)\n\n{\n\n    if (term_cmd_buf_index > 0) {\n\n        term_backward_char();\n\n        term_delete_char();\n\n    }\n\n}\n", "idx": 24219}
{"project": "FFmpeg", "commit_id": "26fc6ffec45c954cd8ca46342ac75cd90bcc7e02", "target": 1, "func": "static inline void libopenjpeg_copy_to_packed16(AVFrame *picture, opj_image_t *image) {\n\n    uint16_t *img_ptr;\n\n    int index, x, y, c;\n\n    int adjust[4];\n\n    for (x = 0; x < image->numcomps; x++)\n\n        adjust[x] = FFMAX(FFMIN(av_pix_fmt_desc_get(picture->format)->comp[x].depth_minus1 + 1 - image->comps[x].prec, 8), 0);\n\n\n\n    for (y = 0; y < picture->height; y++) {\n\n        index = y*picture->width;\n\n        img_ptr = (uint16_t*) (picture->data[0] + y*picture->linesize[0]);\n\n        for (x = 0; x < picture->width; x++, index++) {\n\n            for (c = 0; c < image->numcomps; c++) {\n\n                *img_ptr++ = 0x8000 * image->comps[c].sgnd + (image->comps[c].data[index] << adjust[c]);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24221}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static void vp3_draw_horiz_band(Vp3DecodeContext *s, int y)\n\n{\n\n    int h, cy, i;\n\n    int offset[AV_NUM_DATA_POINTERS];\n\n\n\n    if (HAVE_THREADS && s->avctx->active_thread_type & FF_THREAD_FRAME) {\n\n        int y_flipped = s->flipped_image ? s->avctx->height - y : y;\n\n\n\n        /* At the end of the frame, report INT_MAX instead of the height of\n\n         * the frame. This makes the other threads' ff_thread_await_progress()\n\n         * calls cheaper, because they don't have to clip their values. */\n\n        ff_thread_report_progress(&s->current_frame,\n\n                                  y_flipped == s->avctx->height ? INT_MAX\n\n                                                                : y_flipped - 1,\n\n                                  0);\n\n    }\n\n\n\n    if (s->avctx->draw_horiz_band == NULL)\n\n        return;\n\n\n\n    h = y - s->last_slice_end;\n\n    s->last_slice_end = y;\n\n    y -= h;\n\n\n\n    if (!s->flipped_image)\n\n        y = s->avctx->height - y - h;\n\n\n\n    cy        = y >> s->chroma_y_shift;\n\n    offset[0] = s->current_frame.f->linesize[0] * y;\n\n    offset[1] = s->current_frame.f->linesize[1] * cy;\n\n    offset[2] = s->current_frame.f->linesize[2] * cy;\n\n    for (i = 3; i < AV_NUM_DATA_POINTERS; i++)\n\n        offset[i] = 0;\n\n\n\n    emms_c();\n\n    s->avctx->draw_horiz_band(s->avctx, s->current_frame.f, offset, y, 3, h);\n\n}\n", "idx": 24226}
{"project": "FFmpeg", "commit_id": "d31e3f7ccc5d1e198b3a582f4413ce7342928d8c", "target": 0, "func": "static int gif_write_header(AVFormatContext *s)\n\n{\n\n    GIFContext *gif = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVCodecContext *enc, *video_enc;\n\n    int i, width, height, loop_count /*, rate*/;\n\n\n\n/* XXX: do we reject audio streams or just ignore them ?\n\n    if(s->nb_streams > 1)\n\n        return -1;\n\n*/\n\n    gif->time = 0;\n\n    gif->file_time = 0;\n\n\n\n    video_enc = NULL;\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        enc = s->streams[i]->codec;\n\n        if (enc->codec_type != AVMEDIA_TYPE_AUDIO)\n\n            video_enc = enc;\n\n    }\n\n\n\n    if (!video_enc) {\n\n        av_free(gif);\n\n        return -1;\n\n    } else {\n\n        width = video_enc->width;\n\n        height = video_enc->height;\n\n        loop_count = s->loop_output;\n\n//        rate = video_enc->time_base.den;\n\n    }\n\n\n\n    if (video_enc->pix_fmt != PIX_FMT_RGB24) {\n\n        av_log(s, AV_LOG_ERROR, \"ERROR: gif only handles the rgb24 pixel format. Use -pix_fmt rgb24.\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    gif_image_write_header(pb, width, height, loop_count, NULL);\n\n\n\n    avio_flush(s->pb);\n\n    return 0;\n\n}\n", "idx": 24227}
{"project": "FFmpeg", "commit_id": "033f1644b59abd755bb529afa5db394d18d9c30b", "target": 1, "func": "fixup_vorbis_headers(AVFormatContext * as, struct oggvorbis_private *priv,\n\n                     uint8_t **buf)\n\n{\n\n    int i,offset, len, buf_len;\n\n    unsigned char *ptr;\n\n\n\n    len = priv->len[0] + priv->len[1] + priv->len[2];\n\n    buf_len = len + len/255 + 64;\n\n    ptr = *buf = av_realloc(NULL, buf_len);\n\n\n\n    memset(*buf, '\\0', buf_len);\n\n\n\n    ptr[0] = 2;\n\n    offset = 1;\n\n    offset += av_xiphlacing(&ptr[offset], priv->len[0]);\n\n    offset += av_xiphlacing(&ptr[offset], priv->len[1]);\n\n    for (i = 0; i < 3; i++) {\n\n        memcpy(&ptr[offset], priv->packet[i], priv->len[i]);\n\n        offset += priv->len[i];\n\n        av_freep(&priv->packet[i]);\n\n    }\n\n    *buf = av_realloc(*buf, offset + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    return offset;\n\n}", "idx": 24235}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "static inline int small_diamond_search4MV(MpegEncContext * s, int *best, int dmin,\n\n                                       UINT8 *new_pic, UINT8 *old_pic, int pic_stride,\n\n                                       int pred_x, int pred_y, UINT16 *mv_penalty, int quant,\n\n                                       int xmin, int ymin, int xmax, int ymax, int shift)\n\n{\n\n    int next_dir=-1;\n\n\n\n    for(;;){\n\n        int d;\n\n        const int dir= next_dir;\n\n        const int x= best[0];\n\n        const int y= best[1];\n\n        next_dir=-1;\n\n\n\n//printf(\"%d\", dir);\n\n        if(dir!=2 && x>xmin) CHECK_MV4_DIR(x-1, y  , 0)\n\n        if(dir!=3 && y>ymin) CHECK_MV4_DIR(x  , y-1, 1)\n\n        if(dir!=0 && x<xmax) CHECK_MV4_DIR(x+1, y  , 2)\n\n        if(dir!=1 && y<ymax) CHECK_MV4_DIR(x  , y+1, 3)\n\n\n\n        if(next_dir==-1){\n\n            return dmin;\n\n        }\n\n    }\n\n}\n", "idx": 24251}
{"project": "FFmpeg", "commit_id": "e09ad5bd0de40da9ac33d86f973a85beed85cc47", "target": 0, "func": "void ff_h264_remove_all_refs(H264Context *h)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        remove_long(h, i, 0);\n\n    }\n\n    assert(h->long_ref_count == 0);\n\n\n\n    ff_h264_unref_picture(h, &h->last_pic_for_ec);\n\n    if (h->short_ref_count)\n\n        ff_h264_ref_picture(h, &h->last_pic_for_ec, h->short_ref[0]);\n\n\n\n    for (i = 0; i < h->short_ref_count; i++) {\n\n        unreference_pic(h, h->short_ref[i], 0);\n\n        h->short_ref[i] = NULL;\n\n    }\n\n    h->short_ref_count = 0;\n\n\n\n    memset(h->default_ref_list, 0, sizeof(h->default_ref_list));\n\n    memset(h->ref_list, 0, sizeof(h->ref_list));\n\n}\n", "idx": 24285}
{"project": "FFmpeg", "commit_id": "474176bf927870168a20413f2a9c28f09b6b1afa", "target": 0, "func": "static int get_max_p_order(int max_porder, int n, int order)\n\n{\n\n    int porder, max_parts;\n\n\n\n    porder = max_porder;\n\n    while(porder > 0) {\n\n        max_parts = (1 << porder);\n\n        if(!(n % max_parts) && (n > max_parts*order)) {\n\n            break;\n\n        }\n\n        porder--;\n\n    }\n\n    return porder;\n\n}\n", "idx": 24290}
{"project": "qemu", "commit_id": "b3a62939561e07bc34493444fa926b6137cba4e8", "target": 0, "func": "TCGv_i64 tcg_global_reg_new_i64(int reg, const char *name)\n\n{\n\n    int idx;\n\n\n\n    idx = tcg_global_reg_new_internal(TCG_TYPE_I64, reg, name);\n\n    return MAKE_TCGV_I64(idx);\n\n}\n", "idx": 24308}
{"project": "qemu", "commit_id": "908c67fca4b2c12a9b2336aa9c188f84468b60b7", "target": 0, "func": "static void gen_window_check1(DisasContext *dc, unsigned r1)\n\n{\n\n    if (dc->tb->flags & XTENSA_TBFLAG_EXCM) {\n\n        return;\n\n    }\n\n    if (option_enabled(dc, XTENSA_OPTION_WINDOWED_REGISTER) &&\n\n            r1 / 4 > dc->used_window) {\n\n        TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n        TCGv_i32 w = tcg_const_i32(r1 / 4);\n\n\n\n        dc->used_window = r1 / 4;\n\n        gen_advance_ccount(dc);\n\n        gen_helper_window_check(cpu_env, pc, w);\n\n\n\n        tcg_temp_free(w);\n\n        tcg_temp_free(pc);\n\n    }\n\n}\n", "idx": 24309}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_notify(AioContext *ctx)\n\n{\n\n    /* Write e.g. bh->scheduled before reading ctx->notify_me.  Pairs\n\n     * with atomic_or in aio_ctx_prepare or atomic_add in aio_poll.\n\n     */\n\n    smp_mb();\n\n    if (ctx->notify_me) {\n\n        event_notifier_set(&ctx->notifier);\n\n        atomic_mb_set(&ctx->notified, true);\n\n    }\n\n}\n", "idx": 24318}
{"project": "qemu", "commit_id": "715c54071a43ab978dc12b9da22a5016203ed284", "target": 0, "func": "static void spapr_reset_htab(sPAPRMachineState *spapr)\n\n{\n\n    long shift;\n\n    int index;\n\n\n\n    shift = kvmppc_reset_htab(spapr->htab_shift);\n\n    if (shift < 0) {\n\n        error_setg(&error_abort, \"Failed to reset HTAB\");\n\n    } else if (shift > 0) {\n\n        if (shift != spapr->htab_shift) {\n\n            error_setg(&error_abort, \"Requested HTAB allocation failed during reset\");\n\n        }\n\n\n\n        /* Tell readers to update their file descriptor */\n\n        if (spapr->htab_fd >= 0) {\n\n            spapr->htab_fd_stale = true;\n\n        }\n\n    } else {\n\n        memset(spapr->htab, 0, HTAB_SIZE(spapr));\n\n\n\n        for (index = 0; index < HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; index++) {\n\n            DIRTY_HPTE(HPTE(spapr->htab, index));\n\n        }\n\n    }\n\n\n\n    /* Update the RMA size if necessary */\n\n    if (spapr->vrma_adjust) {\n\n        spapr->rma_size = kvmppc_rma_size(spapr_node0_size(),\n\n                                          spapr->htab_shift);\n\n    }\n\n}\n", "idx": 24326}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void load_tco(const TestData *d)\n\n{\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO_RLD, 4);\n\n}\n", "idx": 24334}
{"project": "qemu", "commit_id": "4bc02e230d1e0fd41d2a892d81dcad56e3b3702d", "target": 1, "func": "target_ulong helper_srad(CPUPPCState *env, target_ulong value,\n\n                         target_ulong shift)\n\n{\n\n    int64_t ret;\n\n\n\n    if (likely(!(shift & 0x40))) {\n\n        if (likely((uint64_t)shift != 0)) {\n\n            shift &= 0x3f;\n\n            ret = (int64_t)value >> shift;\n\n            if (likely(ret >= 0 || (value & ((1 << shift) - 1)) == 0)) {\n\n                env->ca = 0;\n\n            } else {\n\n                env->ca = 1;\n\n            }\n\n        } else {\n\n            ret = (int64_t)value;\n\n            env->ca = 0;\n\n        }\n\n    } else {\n\n        ret = (int64_t)value >> 63;\n\n        env->ca = (ret != 0);\n\n    }\n\n    return ret;\n\n}\n", "idx": 24336}
{"project": "qemu", "commit_id": "e3cffe6fad29e07d401eabb913a6d88501d5c143", "target": 1, "func": "static target_ulong h_remove(PowerPCCPU *cpu, sPAPRMachineState *spapr,\n\n                             target_ulong opcode, target_ulong *args)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    target_ulong flags = args[0];\n\n    target_ulong pte_index = args[1];\n\n    target_ulong avpn = args[2];\n\n    RemoveResult ret;\n\n\n\n    ret = remove_hpte(cpu, pte_index, avpn, flags,\n\n                      &args[0], &args[1]);\n\n\n\n    switch (ret) {\n\n    case REMOVE_SUCCESS:\n\n        check_tlb_flush(env);\n\n        return H_SUCCESS;\n\n\n\n    case REMOVE_NOT_FOUND:\n\n        return H_NOT_FOUND;\n\n\n\n    case REMOVE_PARM:\n\n        return H_PARAMETER;\n\n\n\n    case REMOVE_HW:\n\n        return H_HARDWARE;\n\n    }\n\n\n\n    g_assert_not_reached();\n\n}\n", "idx": 24339}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME(palToY)(uint8_t *dst, uint8_t *src, int width, uint32_t *pal)\n\n{\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tint d= src[i];\n\n\n\n\t\tdst[i]= pal[d] & 0xFF;\n\n\t}\n\n}\n", "idx": 24379}
{"project": "qemu", "commit_id": "4154c7e03fa55b4cf52509a83d50d6c09d743b77", "target": 1, "func": "e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n\n{\n\n    return core->mac[r->dh] == core->mac[r->dt];\n\n}\n", "idx": 24384}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_full_empty(void)\n\n{\n\n    const char *str = \"\";\n\n    long res = 999L;\n\n    int err;\n\n\n\n    err =  qemu_strtol(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n}\n", "idx": 24410}
{"project": "FFmpeg", "commit_id": "d1b284119bd5c6a52124443de2c45dbe569c25fc", "target": 0, "func": "static int filter_frame(AVFilterLink *link, AVFrame *frame)\n\n{\n\n    AVFilterContext *ctx = link->dst;\n\n    AudioFIRContext *s = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    int ret = 0;\n\n\n\n    av_audio_fifo_write(s->fifo[0], (void **)frame->extended_data,\n\n                        frame->nb_samples);\n\n    if (s->pts == AV_NOPTS_VALUE)\n\n        s->pts = frame->pts;\n\n\n\n    av_frame_free(&frame);\n\n\n\n    if (!s->have_coeffs && s->eof_coeffs) {\n\n        ret = convert_coeffs(ctx);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    if (s->have_coeffs) {\n\n        while (av_audio_fifo_size(s->fifo[0]) >= s->part_size) {\n\n            ret = fir_frame(s, outlink);\n\n            if (ret < 0)\n\n                break;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 24430}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static int nbd_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                        int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    return nbd_client_session_co_readv(&s->client, sector_num,\n\n                                       nb_sectors, qiov);\n\n}\n", "idx": 24448}
{"project": "FFmpeg", "commit_id": "bacc4b6e8173fa944c24f297435dc507a60efb10", "target": 1, "func": "static void revert_acfilter(WmallDecodeCtx *s, int tile_size)\n\n{\n\n    int ich, pred, i, j;\n\n    int16_t *filter_coeffs = s->acfilter_coeffs;\n\n    int scaling            = s->acfilter_scaling;\n\n    int order              = s->acfilter_order;\n\n\n\n    for (ich = 0; ich < s->num_channels; ich++) {\n\n        int *prevvalues = s->acfilter_prevvalues[ich];\n\n        for (i = 0; i < order; i++) {\n\n            pred = 0;\n\n            for (j = 0; j < order; j++) {\n\n                if (i <= j)\n\n                    pred += filter_coeffs[j] * prevvalues[j - i];\n\n                else\n\n                    pred += s->channel_residues[ich][i - j - 1] * filter_coeffs[j];\n\n            }\n\n            pred >>= scaling;\n\n            s->channel_residues[ich][i] += pred;\n\n        }\n\n        for (i = order; i < tile_size; i++) {\n\n            pred = 0;\n\n            for (j = 0; j < order; j++)\n\n                pred += s->channel_residues[ich][i - j - 1] * filter_coeffs[j];\n\n            pred >>= scaling;\n\n            s->channel_residues[ich][i] += pred;\n\n        }\n\n        for (j = 0; j < order; j++)\n\n            prevvalues[j] = s->channel_residues[ich][tile_size - j - 1];\n\n    }\n\n}\n", "idx": 24471}
{"project": "qemu", "commit_id": "de08c606f9ddafe647b6843e2b10a6d6030b0fc0", "target": 0, "func": "int bdrv_snapshot_list(BlockDriverState *bs,\n\n                       QEMUSnapshotInfo **psn_info)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (drv->bdrv_snapshot_list)\n\n        return drv->bdrv_snapshot_list(bs, psn_info);\n\n    if (bs->file)\n\n        return bdrv_snapshot_list(bs->file, psn_info);\n\n    return -ENOTSUP;\n\n}\n", "idx": 24502}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "func": "static void dec_store(DisasContext *dc)\n\n{\n\n    TCGv t, *addr;\n\n    unsigned int size;\n\n\n\n    size = 1 << (dc->opcode & 3);\n\n\n\n    if (size > 4 && (dc->tb_flags & MSR_EE_FLAG)\n\n          && !(dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) {\n\n        tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);\n\n        t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n        return;\n\n    }\n\n\n\n    LOG_DIS(\"s%d%s\\n\", size, dc->type_b ? \"i\" : \"\");\n\n    t_sync_flags(dc);\n\n    /* If we get a fault on a dslot, the jmpstate better be in sync.  */\n\n    sync_jmpstate(dc);\n\n    addr = compute_ldst_addr(dc, &t);\n\n\n\n    /* Verify alignment if needed.  */\n\n    if ((dc->env->pvr.regs[2] & PVR2_UNALIGNED_EXC_MASK) && size > 1) {\n\n        gen_helper_memalign(*addr, tcg_const_tl(dc->rd),\n\n                            tcg_const_tl(1), tcg_const_tl(size - 1));\n\n    }\n\n\n\n    gen_store(dc, *addr, cpu_R[dc->rd], size);\n\n    if (addr == &t)\n\n        tcg_temp_free(t);\n\n}\n", "idx": 24511}
{"project": "qemu", "commit_id": "8360544a6d3a54df1fce80f55ba4ad075a8ded54", "target": 0, "func": "static void qpci_spapr_io_writew(QPCIBus *bus, void *addr, uint16_t value)\n\n{\n\n    QPCIBusSPAPR *s = container_of(bus, QPCIBusSPAPR, bus);\n\n    uint64_t port = (uintptr_t)addr;\n\n    value = bswap16(value);\n\n    if (port < s->pio.size) {\n\n        writew(s->pio_cpu_base + port, value);\n\n    } else {\n\n        writew(s->mmio_cpu_base + port, value);\n\n    }\n\n}\n", "idx": 24514}
{"project": "qemu", "commit_id": "3baf720e6b920d583ce2834d05e5a4e9603a1d56", "target": 1, "func": "static int cdrom_probe_device(const char *filename)\n\n{\n\n    if (strstart(filename, \"/dev/cd\", NULL))\n\n        return 100;\n\n    return 0;\n\n}\n", "idx": 24543}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static int qio_channel_socket_listen_worker(QIOTask *task,\n\n                                            Error **errp,\n\n                                            gpointer opaque)\n\n{\n\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(qio_task_get_source(task));\n\n    SocketAddress *addr = opaque;\n\n    int ret;\n\n\n\n    ret = qio_channel_socket_listen_sync(ioc,\n\n                                         addr,\n\n                                         errp);\n\n\n\n    object_unref(OBJECT(ioc));\n\n    return ret;\n\n}\n", "idx": 24544}
{"project": "qemu", "commit_id": "f2ad97ff81da51c064b9e87720ff48a0874f45d4", "target": 1, "func": "static USBPort *xhci_lookup_uport(XHCIState *xhci, uint32_t *slot_ctx)\n\n{\n\n    USBPort *uport;\n\n    char path[32];\n\n    int i, pos, port;\n\n\n\n    port = (slot_ctx[1]>>16) & 0xFF;\n\n\n\n\n    port = xhci->ports[port-1].uport->index+1;\n\n    pos = snprintf(path, sizeof(path), \"%d\", port);\n\n    for (i = 0; i < 5; i++) {\n\n        port = (slot_ctx[0] >> 4*i) & 0x0f;\n\n        if (!port) {\n\n            break;\n\n\n        pos += snprintf(path + pos, sizeof(path) - pos, \".%d\", port);\n\n\n\n\n    QTAILQ_FOREACH(uport, &xhci->bus.used, next) {\n\n        if (strcmp(uport->path, path) == 0) {\n\n            return uport;\n\n\n\n", "idx": 24547}
{"project": "qemu", "commit_id": "2b316774f60291f57ca9ecb6a9f0712c532cae34", "target": 1, "func": "static void io_watch_poll_finalize(GSource *source)\n\n{\n\n    IOWatchPoll *iwp = io_watch_poll_from_source(source);\n\n    if (iwp->src) {\n\n        g_source_destroy(iwp->src);\n\n        g_source_unref(iwp->src);\n\n        iwp->src = NULL;\n\n    }\n\n}\n", "idx": 24548}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(rgb32tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n    uint8_t *dest = dst;\n\n    const uint8_t *s = src;\n\n    const uint8_t *end;\n\n#if COMPILE_TEMPLATE_MMX\n\n    const uint8_t *mm_end;\n\n#endif\n\n    end = s + src_size;\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");\n\n    mm_end = end - 31;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movq          %1, %%mm0    \\n\\t\"\n\n            \"movq         8%1, %%mm1    \\n\\t\"\n\n            \"movq        16%1, %%mm4    \\n\\t\"\n\n            \"movq        24%1, %%mm5    \\n\\t\"\n\n            \"movq       %%mm0, %%mm2    \\n\\t\"\n\n            \"movq       %%mm1, %%mm3    \\n\\t\"\n\n            \"movq       %%mm4, %%mm6    \\n\\t\"\n\n            \"movq       %%mm5, %%mm7    \\n\\t\"\n\n            STORE_BGR24_MMX\n\n            :\"=m\"(*dest)\n\n            :\"m\"(*s)\n\n            :\"memory\");\n\n        dest += 24;\n\n        s += 32;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n#endif\n\n    while (s < end) {\n\n#if HAVE_BIGENDIAN\n\n        /* RGB32 (= A,B,G,R) -> RGB24 (= R,G,B) */\n\n        s++;\n\n        dest[2] = *s++;\n\n        dest[1] = *s++;\n\n        dest[0] = *s++;\n\n        dest += 3;\n\n#else\n\n        *dest++ = *s++;\n\n        *dest++ = *s++;\n\n        *dest++ = *s++;\n\n        s++;\n\n#endif\n\n    }\n\n}\n", "idx": 24587}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void bmdma_addr_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t data, unsigned width)\n\n{\n\n    BMDMAState *bm = opaque;\n\n    int shift = addr * 8;\n\n    uint32_t mask = (1ULL << (width * 8)) - 1;\n\n\n\n#ifdef DEBUG_IDE\n\n    printf(\"%s: 0x%08x\\n\", __func__, (unsigned)data);\n\n#endif\n\n    bm->addr &= ~(mask << shift);\n\n    bm->addr |= ((data & mask) << shift) & ~3;\n\n}\n", "idx": 24597}
{"project": "qemu", "commit_id": "6f1de6b70d857d5e316ae6fd908f52818b827b08", "target": 0, "func": "int qemu_chr_fe_add_watch(CharDriverState *s, GIOCondition cond,\n\n                          GIOFunc func, void *user_data)\n\n{\n\n    GSource *src;\n\n    guint tag;\n\n\n\n    if (s->chr_add_watch == NULL) {\n\n        return -ENOSYS;\n\n    }\n\n\n\n    src = s->chr_add_watch(s, cond);\n\n    if (!src) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    g_source_set_callback(src, (GSourceFunc)func, user_data, NULL);\n\n    tag = g_source_attach(src, NULL);\n\n    g_source_unref(src);\n\n\n\n    return tag;\n\n}\n", "idx": 24600}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint64_t ldq_phys(target_phys_addr_t addr)\n\n{\n\n    return ldq_phys_internal(addr, DEVICE_NATIVE_ENDIAN);\n\n}\n", "idx": 24602}
{"project": "qemu", "commit_id": "56ad3e54dad6cdcee8668d170df161d89581846f", "target": 1, "func": "static ssize_t mp_dacl_getxattr(FsContext *ctx, const char *path,\n\n                                const char *name, void *value, size_t size)\n\n{\n\n    char *buffer;\n\n    ssize_t ret;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret = lgetxattr(buffer, MAP_ACL_DEFAULT, value, size);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 24611}
{"project": "qemu", "commit_id": "5712db6ae5101db645f71edc393368cd59bfd314", "target": 1, "func": "static void fw_cfg_realize(DeviceState *dev, Error **errp)\n\n{\n\n    FWCfgState *s = FW_CFG(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n\n\n    if (s->ctl_iobase + 1 == s->data_iobase) {\n\n        sysbus_add_io(sbd, s->ctl_iobase, &s->comb_iomem);\n\n    } else {\n\n        if (s->ctl_iobase) {\n\n            sysbus_add_io(sbd, s->ctl_iobase, &s->ctl_iomem);\n\n        }\n\n        if (s->data_iobase) {\n\n            sysbus_add_io(sbd, s->data_iobase, &s->data_iomem);\n\n        }\n\n    }\n\n}\n", "idx": 24615}
{"project": "qemu", "commit_id": "a4d8e8daee324e230b0155915f562743f4fff5d8", "target": 1, "func": "static void vscsi_got_payload(VSCSIState *s, vscsi_crq *crq)\n\n{\n\n    vscsi_req *req;\n\n    int done;\n\n\n\n    req = vscsi_get_req(s);\n\n    if (req == NULL) {\n\n        fprintf(stderr, \"VSCSI: Failed to get a request !\\n\");\n\n        return;\n\n    }\n\n\n\n    /* We only support a limited number of descriptors, we know\n\n     * the ibmvscsi driver uses up to 10 max, so it should fit\n\n     * in our 256 bytes IUs. If not we'll have to increase the size\n\n     * of the structure.\n\n     */\n\n    if (crq->s.IU_length > sizeof(union viosrp_iu)) {\n\n        fprintf(stderr, \"VSCSI: SRP IU too long (%d bytes) !\\n\",\n\n                crq->s.IU_length);\n\n        return;\n\n    }\n\n\n\n    /* XXX Handle failure differently ? */\n\n    if (spapr_tce_dma_read(&s->vdev, crq->s.IU_data_ptr, &req->iu,\n\n                           crq->s.IU_length)) {\n\n        fprintf(stderr, \"vscsi_got_payload: DMA read failure !\\n\");\n\n        g_free(req);\n\n    }\n\n    memcpy(&req->crq, crq, sizeof(vscsi_crq));\n\n\n\n    if (crq->s.format == VIOSRP_MAD_FORMAT) {\n\n        done = vscsi_handle_mad_req(s, req);\n\n    } else {\n\n        done = vscsi_handle_srp_req(s, req);\n\n    }\n\n\n\n    if (done) {\n\n        vscsi_put_req(req);\n\n    }\n\n}\n", "idx": 24620}
{"project": "qemu", "commit_id": "8a5865f331028e66b4ed233129d7a914c2d5bfc7", "target": 1, "func": "static MTPData *usb_mtp_get_object_info(MTPState *s, MTPControl *c,\n\n                                        MTPObject *o)\n\n{\n\n    MTPData *d = usb_mtp_data_alloc(c);\n\n\n\n    trace_usb_mtp_op_get_object_info(s->dev.addr, o->handle, o->path);\n\n\n\n    usb_mtp_add_u32(d, QEMU_STORAGE_ID);\n\n    usb_mtp_add_u16(d, o->format);\n\n    usb_mtp_add_u16(d, 0);\n\n    usb_mtp_add_u32(d, o->stat.st_size);\n\n\n\n    usb_mtp_add_u16(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n    usb_mtp_add_u32(d, 0);\n\n\n\n    if (o->parent) {\n\n        usb_mtp_add_u32(d, o->parent->handle);\n\n    } else {\n\n        usb_mtp_add_u32(d, 0);\n\n    }\n\n    if (o->format == FMT_ASSOCIATION) {\n\n        usb_mtp_add_u16(d, 0x0001);\n\n        usb_mtp_add_u32(d, 0x00000001);\n\n        usb_mtp_add_u32(d, 0);\n\n    } else {\n\n        usb_mtp_add_u16(d, 0);\n\n        usb_mtp_add_u32(d, 0);\n\n        usb_mtp_add_u32(d, 0);\n\n    }\n\n\n\n    usb_mtp_add_str(d, o->name);\n\n    usb_mtp_add_time(d, o->stat.st_ctime);\n\n    usb_mtp_add_time(d, o->stat.st_mtime);\n\n    usb_mtp_add_wstr(d, L\"\");\n\n\n\n    return d;\n\n}\n", "idx": 24632}
{"project": "qemu", "commit_id": "1b57bd4f2f4993104a5cb48912435396faa10d58", "target": 1, "func": "static inline bool rom_order_compare(Rom *rom, Rom *item)\n\n{\n\n    return (rom->as > item->as) ||\n\n           (rom->as == item->as && rom->addr >= item->addr);\n\n}\n", "idx": 24635}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static int slb_lookup (CPUState *env, target_ulong eaddr,\n\n                       target_ulong *vsid, target_ulong *page_mask, int *attr)\n\n{\n\n    target_phys_addr_t sr_base;\n\n    target_ulong mask;\n\n    uint64_t tmp64;\n\n    uint32_t tmp;\n\n    int n, ret;\n\n    int slb_nr;\n\n\n\n    ret = -5;\n\n    sr_base = env->spr[SPR_ASR];\n\n    mask = 0x0000000000000000ULL; /* Avoid gcc warning */\n\n#if 0 /* XXX: Fix this */\n\n    slb_nr = env->slb_nr;\n\n#else\n\n    slb_nr = 32;\n\n#endif\n\n    for (n = 0; n < slb_nr; n++) {\n\n        tmp64 = ldq_phys(sr_base);\n\n        if (tmp64 & 0x0000000008000000ULL) {\n\n            /* SLB entry is valid */\n\n            switch (tmp64 & 0x0000000006000000ULL) {\n\n            case 0x0000000000000000ULL:\n\n                /* 256 MB segment */\n\n                mask = 0xFFFFFFFFF0000000ULL;\n\n                break;\n\n            case 0x0000000002000000ULL:\n\n                /* 1 TB segment */\n\n                mask = 0xFFFF000000000000ULL;\n\n                break;\n\n            case 0x0000000004000000ULL:\n\n            case 0x0000000006000000ULL:\n\n                /* Reserved => segment is invalid */\n\n                continue;\n\n            }\n\n            if ((eaddr & mask) == (tmp64 & mask)) {\n\n                /* SLB match */\n\n                tmp = ldl_phys(sr_base + 8);\n\n                *vsid = ((tmp64 << 24) | (tmp >> 8)) & 0x0003FFFFFFFFFFFFULL;\n\n                *page_mask = ~mask;\n\n                *attr = tmp & 0xFF;\n\n                ret = 0;\n\n                break;\n\n            }\n\n        }\n\n        sr_base += 12;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24644}
{"project": "qemu", "commit_id": "6c8d56a2e95712a6206a2671d2b04b2e59cabc0b", "target": 1, "func": "static uint8_t fw_cfg_read(FWCfgState *s)\n\n{\n\n    int arch = !!(s->cur_entry & FW_CFG_ARCH_LOCAL);\n\n    FWCfgEntry *e = (s->cur_entry == FW_CFG_INVALID) ? NULL :\n\n                    &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];\n\n    uint8_t ret;\n\n\n\n    if (s->cur_entry == FW_CFG_INVALID || !e->data || s->cur_offset >= e->len)\n\n        ret = 0;\n\n    else {\n\n        ret = e->data[s->cur_offset++];\n\n    }\n\n\n\n    trace_fw_cfg_read(s, ret);\n\n    return ret;\n\n}\n", "idx": 24649}
{"project": "qemu", "commit_id": "698bdfa07d66b5ec218a60229e58eae1dcde00e5", "target": 1, "func": "void qmp_block_resize(bool has_device, const char *device,\n\n                      bool has_node_name, const char *node_name,\n\n                      int64_t size, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    BlockBackend *blk = NULL;\n\n    BlockDriverState *bs;\n\n    AioContext *aio_context;\n\n    int ret;\n\n\n\n    bs = bdrv_lookup_bs(has_device ? device : NULL,\n\n                        has_node_name ? node_name : NULL,\n\n                        &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (!bdrv_is_first_non_filter(bs)) {\n\n        error_setg(errp, QERR_FEATURE_DISABLED, \"resize\");\n\n        goto out;\n\n    }\n\n\n\n    if (size < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"size\", \"a >0 size\");\n\n        goto out;\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_RESIZE, NULL)) {\n\n        error_setg(errp, QERR_DEVICE_IN_USE, device);\n\n        goto out;\n\n    }\n\n\n\n    blk = blk_new(BLK_PERM_RESIZE, BLK_PERM_ALL);\n\n    ret = blk_insert_bs(blk, bs, errp);\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* complete all in-flight operations before resizing the device */\n\n    bdrv_drain_all();\n\n\n\n    ret = blk_truncate(blk, size, errp);\n\n\n\nout:\n\n    blk_unref(blk);\n\n    aio_context_release(aio_context);\n\n}\n", "idx": 24650}
{"project": "FFmpeg", "commit_id": "d05bdba2428dd0c1c5cd3426d69c712b127f996c", "target": 1, "func": "static int rac_get_model256_sym(RangeCoder *c, Model256 *m)\n\n{\n\n    int prob, prob2, helper, val;\n\n    int start, end;\n\n    int ssym;\n\n\n\n    prob2      = c->range;\n\n    c->range >>= MODEL_SCALE;\n\n\n\n    helper     = c->low / c->range;\n\n    ssym       = helper >> MODEL256_SEC_SCALE;\n\n    val        = m->secondary[ssym];\n\n\n\n    end = start = m->secondary[ssym + 1] + 1;\n\n    while (end > val + 1) {\n\n        ssym = (end + val) >> 1;\n\n        if (m->freqs[ssym] <= helper) {\n\n            end = start;\n\n            val = ssym;\n\n        } else {\n\n            end   = (end + val) >> 1;\n\n            start = ssym;\n\n        }\n\n    }\n\n    prob = m->freqs[val] * c->range;\n\n    if (val != 255)\n\n        prob2 = m->freqs[val + 1] * c->range;\n\n\n\n    c->low  -= prob;\n\n    c->range = prob2 - prob;\n\n    if (c->range < RAC_BOTTOM)\n\n        rac_normalise(c);\n\n\n\n    model256_update(m, val);\n\n\n\n    return val;\n\n}\n", "idx": 24654}
{"project": "FFmpeg", "commit_id": "ae43c10e36197000de2f3cc99ea35727ce98a796", "target": 0, "func": "int ff_replaygain_export(AVStream *st, AVDictionary *metadata)\n\n{\n\n    const AVDictionaryEntry *tg, *tp, *ag, *ap;\n\n\n\n    tg = av_dict_get(metadata, \"REPLAYGAIN_TRACK_GAIN\", NULL, 0);\n\n    tp = av_dict_get(metadata, \"REPLAYGAIN_TRACK_PEAK\", NULL, 0);\n\n    ag = av_dict_get(metadata, \"REPLAYGAIN_ALBUM_GAIN\", NULL, 0);\n\n    ap = av_dict_get(metadata, \"REPLAYGAIN_ALBUM_PEAK\", NULL, 0);\n\n\n\n    return replaygain_export(st,\n\n                             tg ? tg->value : NULL,\n\n                             tp ? tp->value : NULL,\n\n                             ag ? ag->value : NULL,\n\n                             ap ? ap->value : NULL);\n\n}\n", "idx": 24659}
{"project": "FFmpeg", "commit_id": "34a8dcd031d637273cdea021e5a79cf720c4c51c", "target": 0, "func": "static int decode_end(AVCodecContext * avctx)\n\n{\n\n    KmvcContext *const c = (KmvcContext *) avctx->priv_data;\n\n\n\n    if (c->frm0)\n\n        av_free(c->frm0);\n\n    if (c->frm1)\n\n        av_free(c->frm1);\n\n    if (c->pic.data[0])\n\n        avctx->release_buffer(avctx, &c->pic);\n\n\n\n    return 0;\n\n}\n", "idx": 24673}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_update_bitmap(BlockDriverState *bs, int64_t sector_num,\n\n        int nb_sectors)\n\n{\n\n    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;\n\n    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;\n\n    bool first = true;\n\n    int sector_bits;\n\n\n\n    for ( ; nb_sectors;\n\n            bitnum += sector_bits,\n\n            nb_sectors -= sector_bits,\n\n            offset += BDRV_SECTOR_SIZE) {\n\n        int ret, set;\n\n        uint8_t bitmap[BDRV_SECTOR_SIZE];\n\n\n\n        bitnum &= BITS_PER_BITMAP_SECTOR - 1;\n\n        sector_bits = MIN(nb_sectors, BITS_PER_BITMAP_SECTOR - bitnum);\n\n\n\n        ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        /* Skip over any already set bits */\n\n        set = cow_find_streak(bitmap, 1, bitnum, sector_bits);\n\n        bitnum += set;\n\n        sector_bits -= set;\n\n        nb_sectors -= set;\n\n        if (!sector_bits) {\n\n            continue;\n\n        }\n\n\n\n        if (first) {\n\n            ret = bdrv_flush(bs->file);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            first = false;\n\n        }\n\n\n\n        cow_set_bits(bitmap, bitnum, sector_bits);\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24682}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct_add16_mmx2(uint8_t *dst, const int *block_offset, DCTELEM *block, int stride, const uint8_t nnzc[6*8]){\n\n    int i;\n\n    for(i=0; i<16; i++){\n\n        int nnz = nnzc[ scan8[i] ];\n\n        if(nnz){\n\n            if(nnz==1 && block[i*16]) ff_h264_idct_dc_add_mmx2(dst + block_offset[i], block + i*16, stride);\n\n            else                      ff_h264_idct_add_mmx    (dst + block_offset[i], block + i*16, stride);\n\n        }\n\n    }\n\n}\n", "idx": 24688}
{"project": "qemu", "commit_id": "b29a0341d7ed7e7df4bf77a41db8e614f1ddb645", "target": 0, "func": "void op_mtc0_ebase (void)\n\n{\n\n    /* vectored interrupts not implemented */\n\n    /* Multi-CPU not implemented */\n\n    env->CP0_EBase = (int32_t)0x80000000 | (T0 & 0x3FFFF000);\n\n    RETURN();\n\n}\n", "idx": 24695}
{"project": "FFmpeg", "commit_id": "99982524f93a5fc5f8eadd3e8f9b4e3af446cdaa", "target": 0, "func": "static void check_cpu_flag(const char *name, int flag)\n\n{\n\n    int old_cpu_flag = state.cpu_flag;\n\n\n\n    flag |= old_cpu_flag;\n\n    av_set_cpu_flags_mask(flag);\n\n    state.cpu_flag = av_get_cpu_flags();\n\n\n\n    if (!flag || state.cpu_flag != old_cpu_flag) {\n\n        int i;\n\n\n\n        state.cpu_flag_name = name;\n\n        for (i = 0; tests[i].func; i++) {\n\n            state.current_test_name = tests[i].name;\n\n            tests[i].func();\n\n        }\n\n    }\n\n}\n", "idx": 24699}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "bool replay_checkpoint(ReplayCheckpoint checkpoint)\n\n{\n\n    bool res = false;\n\n    assert(EVENT_CHECKPOINT + checkpoint <= EVENT_CHECKPOINT_LAST);\n\n    replay_save_instructions();\n\n\n\n    if (!replay_file) {\n\n        return true;\n\n    }\n\n\n\n    replay_mutex_lock();\n\n\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        if (replay_next_event_is(EVENT_CHECKPOINT + checkpoint)) {\n\n            replay_finish_event();\n\n        } else if (replay_data_kind != EVENT_ASYNC) {\n\n            res = false;\n\n            goto out;\n\n        }\n\n        replay_read_events(checkpoint);\n\n        /* replay_read_events may leave some unread events.\n\n           Return false if not all of the events associated with\n\n           checkpoint were processed */\n\n        res = replay_data_kind != EVENT_ASYNC;\n\n    } else if (replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_put_event(EVENT_CHECKPOINT + checkpoint);\n\n        replay_save_events(checkpoint);\n\n        res = true;\n\n    }\n\nout:\n\n    replay_mutex_unlock();\n\n    return res;\n\n}\n", "idx": 24711}
{"project": "qemu", "commit_id": "13f1c773640171efa8175b1ba6dcd624c1ad68c1", "target": 0, "func": "static void openrisc_sim_machine_init(MachineClass *mc)\n\n{\n\n    mc->desc = \"or1k simulation\";\n\n    mc->init = openrisc_sim_init;\n\n    mc->max_cpus = 1;\n\n    mc->is_default = 1;\n\n}\n", "idx": 24716}
{"project": "qemu", "commit_id": "1f01e50b8330c24714ddca5841fdbb703076b121", "target": 0, "func": "static int coroutine_fn qed_aio_write_inplace(QEDAIOCB *acb, uint64_t offset,\n\n                                              size_t len)\n\n{\n\n    /* Allocate buffer for zero writes */\n\n    if (acb->flags & QED_AIOCB_ZERO) {\n\n        struct iovec *iov = acb->qiov->iov;\n\n\n\n        if (!iov->iov_base) {\n\n            iov->iov_base = qemu_try_blockalign(acb->bs, iov->iov_len);\n\n            if (iov->iov_base == NULL) {\n\n                return -ENOMEM;\n\n            }\n\n            memset(iov->iov_base, 0, iov->iov_len);\n\n        }\n\n    }\n\n\n\n    /* Calculate the I/O vector */\n\n    acb->cur_cluster = offset;\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Do the actual write */\n\n    return qed_aio_write_main(acb);\n\n}\n", "idx": 24726}
{"project": "qemu", "commit_id": "439e2a6e10ed7f5da819bf7dcaa54b8cfdbeab0d", "target": 0, "func": "Aml *aml_add(Aml *arg1, Aml *arg2)\n\n{\n\n    Aml *var = aml_opcode(0x72 /* AddOp */);\n\n    aml_append(var, arg1);\n\n    aml_append(var, arg2);\n\n    build_append_byte(var->buf, 0x00 /* NullNameOp */);\n\n    return var;\n\n}\n", "idx": 24727}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void find_completion(const char *cmdline)\n\n{\n\n    const char *cmdname;\n\n    char *args[MAX_ARGS];\n\n    int nb_args, i, len;\n\n    const char *ptype, *str;\n\n    term_cmd_t *cmd;\n\n\n\n    parse_cmdline(cmdline, &nb_args, args);\n\n#ifdef DEBUG_COMPLETION\n\n    for(i = 0; i < nb_args; i++) {\n\n        term_printf(\"arg%d = '%s'\\n\", i, (char *)args[i]);\n\n    }\n\n#endif\n\n\n\n    /* if the line ends with a space, it means we want to complete the\n\n       next arg */\n\n    len = strlen(cmdline);\n\n    if (len > 0 && isspace(cmdline[len - 1])) {\n\n        if (nb_args >= MAX_ARGS)\n\n            return;\n\n        args[nb_args++] = qemu_strdup(\"\");\n\n    }\n\n    if (nb_args <= 1) {\n\n        /* command completion */\n\n        if (nb_args == 0)\n\n            cmdname = \"\";\n\n        else\n\n            cmdname = args[0];\n\n        completion_index = strlen(cmdname);\n\n        for(cmd = term_cmds; cmd->name != NULL; cmd++) {\n\n            cmd_completion(cmdname, cmd->name);\n\n        }\n\n    } else {\n\n        /* find the command */\n\n        for(cmd = term_cmds; cmd->name != NULL; cmd++) {\n\n            if (compare_cmd(args[0], cmd->name))\n\n                goto found;\n\n        }\n\n        return;\n\n    found:\n\n        ptype = cmd->args_type;\n\n        for(i = 0; i < nb_args - 2; i++) {\n\n            if (*ptype != '\\0') {\n\n                ptype++;\n\n                while (*ptype == '?')\n\n                    ptype++;\n\n            }\n\n        }\n\n        str = args[nb_args - 1];\n\n        switch(*ptype) {\n\n        case 'F':\n\n            /* file completion */\n\n            completion_index = strlen(str);\n\n            file_completion(str);\n\n            break;\n\n        case 'B':\n\n            /* block device name completion */\n\n            completion_index = strlen(str);\n\n            bdrv_iterate(block_completion_it, (void *)str);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    for(i = 0; i < nb_args; i++)\n\n        qemu_free(args[i]);\n\n}\n", "idx": 24743}
{"project": "qemu", "commit_id": "2c62f08ddbf3fa80dc7202eb9a2ea60ae44e2cc5", "target": 0, "func": "static int pci_cirrus_vga_initfn(PCIDevice *dev)\n\n{\n\n     PCICirrusVGAState *d = DO_UPCAST(PCICirrusVGAState, dev, dev);\n\n     CirrusVGAState *s = &d->cirrus_vga;\n\n     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);\n\n     int16_t device_id = pc->device_id;\n\n\n\n     /* setup VGA */\n\n     vga_common_init(&s->vga);\n\n     cirrus_init_common(s, device_id, 1, pci_address_space(dev),\n\n                        pci_address_space_io(dev));\n\n     s->vga.con = graphic_console_init(s->vga.update, s->vga.invalidate,\n\n                                       s->vga.screen_dump, s->vga.text_update,\n\n                                       &s->vga);\n\n\n\n     /* setup PCI */\n\n\n\n    memory_region_init(&s->pci_bar, \"cirrus-pci-bar0\", 0x2000000);\n\n\n\n    /* XXX: add byte swapping apertures */\n\n    memory_region_add_subregion(&s->pci_bar, 0, &s->cirrus_linear_io);\n\n    memory_region_add_subregion(&s->pci_bar, 0x1000000,\n\n                                &s->cirrus_linear_bitblt_io);\n\n\n\n     /* setup memory space */\n\n     /* memory #0 LFB */\n\n     /* memory #1 memory-mapped I/O */\n\n     /* XXX: s->vga.vram_size must be a power of two */\n\n     pci_register_bar(&d->dev, 0, PCI_BASE_ADDRESS_MEM_PREFETCH, &s->pci_bar);\n\n     if (device_id == CIRRUS_ID_CLGD5446) {\n\n         pci_register_bar(&d->dev, 1, 0, &s->cirrus_mmio_io);\n\n     }\n\n     return 0;\n\n}\n", "idx": 24758}
{"project": "qemu", "commit_id": "7c38ecd09763107513bacc791856fdbb582a107c", "target": 1, "func": "static int acpi_pcihp_get_bsel(PCIBus *bus)\n\n{\n\n    QObject *o = object_property_get_qobject(OBJECT(bus),\n\n                                             ACPI_PCIHP_PROP_BSEL, NULL);\n\n    int64_t bsel = -1;\n\n    if (o) {\n\n        bsel = qint_get_int(qobject_to_qint(o));\n\n    }\n\n    if (bsel < 0) {\n\n        return -1;\n\n    }\n\n    return bsel;\n\n}\n", "idx": 24763}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "void vnc_client_write(void *opaque)\n\n{\n\n    long ret;\n\n    VncState *vs = opaque;\n\n\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls.session) {\n\n\tret = gnutls_write(vs->tls.session, vs->output.buffer, vs->output.offset);\n\n\tif (ret < 0) {\n\n\t    if (ret == GNUTLS_E_AGAIN)\n\n\t\terrno = EAGAIN;\n\n\t    else\n\n\t\terrno = EIO;\n\n\t    ret = -1;\n\n\t}\n\n    } else\n\n#endif /* CONFIG_VNC_TLS */\n\n\tret = send(vs->csock, vs->output.buffer, vs->output.offset, 0);\n\n    ret = vnc_client_io_error(vs, ret, socket_error());\n\n    if (!ret)\n\n\treturn;\n\n\n\n    memmove(vs->output.buffer, vs->output.buffer + ret, (vs->output.offset - ret));\n\n    vs->output.offset -= ret;\n\n\n\n    if (vs->output.offset == 0) {\n\n\tqemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);\n\n    }\n\n}\n", "idx": 24764}
{"project": "qemu", "commit_id": "08942ac17922d923a7cc5cf9854e9cc4b150b942", "target": 1, "func": "int spapr_tce_dma_write(VIOsPAPRDevice *dev, uint64_t taddr, const void *buf,\n                        uint32_t size)\n{\n#ifdef DEBUG_TCE\n    fprintf(stderr, \"spapr_tce_dma_write taddr=0x%llx size=0x%x\\n\",\n            (unsigned long long)taddr, size);\n#endif\n    while (size) {\n        uint64_t tce;\n        uint32_t lsize;\n        uint64_t txaddr;\n        /* Check if we are in bound */\n        if (taddr >= dev->rtce_window_size) {\n#ifdef DEBUG_TCE\n            fprintf(stderr, \"spapr_tce_dma_write out of bounds\\n\");\n#endif\n            return H_DEST_PARM;\n        tce = dev->rtce_table[taddr >> SPAPR_VIO_TCE_PAGE_SHIFT].tce;\n        /* How much til end of page ? */\n        lsize = MIN(size, ((~taddr) & SPAPR_VIO_TCE_PAGE_MASK) + 1);\n        /* Check TCE */\n        if (!(tce & 2)) {\n            return H_DEST_PARM;\n        /* Translate */\n        txaddr = (tce & ~SPAPR_VIO_TCE_PAGE_MASK) |\n            (taddr & SPAPR_VIO_TCE_PAGE_MASK);\n#ifdef DEBUG_TCE\n        fprintf(stderr, \" -> write to txaddr=0x%llx, size=0x%x\\n\",\n                (unsigned long long)txaddr, lsize);\n#endif\n        /* Do it */\n        cpu_physical_memory_write(txaddr, buf, lsize);\n        buf += lsize;\n        taddr += lsize;\n        size -= lsize;", "idx": 24813}
{"project": "FFmpeg", "commit_id": "853a97530e0aabfd1474b1679e3dc8be978e5ef8", "target": 0, "func": "static void mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)\n\n{\n\n    uint32_t v, spf;\n\n    int frames = -1; /* Total number of frames in file */\n\n    const int64_t xing_offtbl[2][2] = {{32, 17}, {17,9}};\n\n    MPADecodeContext c;\n\n\n\n    v = get_be32(s->pb);\n\n    if(ff_mpa_check_header(v) < 0)\n\n      return;\n\n\n\n    ff_mpegaudio_decode_header(&c, v);\n\n    if(c.layer != 3)\n\n        return;\n\n\n\n    /* Check for Xing / Info tag */\n\n    url_fseek(s->pb, xing_offtbl[c.lsf == 1][c.nb_channels == 1], SEEK_CUR);\n\n    v = get_be32(s->pb);\n\n    if(v == MKBETAG('X', 'i', 'n', 'g') || v == MKBETAG('I', 'n', 'f', 'o')) {\n\n        v = get_be32(s->pb);\n\n        if(v & 0x1)\n\n            frames = get_be32(s->pb);\n\n    }\n\n\n\n    /* Check for VBRI tag (always 32 bytes after end of mpegaudio header) */\n\n    url_fseek(s->pb, base + 4 + 32, SEEK_SET);\n\n    v = get_be32(s->pb);\n\n    if(v == MKBETAG('V', 'B', 'R', 'I')) {\n\n        /* Check tag version */\n\n        if(get_be16(s->pb) == 1) {\n\n            /* skip delay, quality and total bytes */\n\n            url_fseek(s->pb, 8, SEEK_CUR);\n\n            frames = get_be32(s->pb);\n\n        }\n\n    }\n\n\n\n    if(frames < 0)\n\n        return;\n\n\n\n    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */\n\n    st->duration = av_rescale_q(frames, (AVRational){spf, c.sample_rate},\n\n                                st->time_base);\n\n}\n", "idx": 24827}
{"project": "qemu", "commit_id": "5bf81c8d63db0216a4d29dc87f9ce530bb791dd1", "target": 1, "func": "void vmstate_save_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                        void *opaque)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n\n\n    if (vmsd->pre_save) {\n\n        vmsd->pre_save(opaque);\n\n\n    while (field->name) {\n\n        if (!field->field_exists ||\n\n            field->field_exists(opaque, vmsd->version_id)) {\n\n            void *base_addr = vmstate_base_addr(opaque, field);\n\n            int i, n_elems = vmstate_n_elems(opaque, field);\n\n            int size = vmstate_size(opaque, field);\n\n\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *addr = base_addr + size * i;\n\n\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n\n                    addr = *(void **)addr;\n\n\n                if (field->flags & VMS_STRUCT) {\n\n                    vmstate_save_state(f, field->vmsd, addr);\n\n\n                    field->info->put(f, addr, size);\n\n\n\n\n\n\n\n\n\n\n        field++;\n\n\n    vmstate_subsection_save(f, vmsd, opaque);\n", "idx": 24830}
{"project": "qemu", "commit_id": "364031f17932814484657e5551ba12957d993d7e", "target": 0, "func": "static int v9fs_synth_closedir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    V9fsSynthOpenState *synth_open = fs->private;\n\n    V9fsSynthNode *node = synth_open->node;\n\n\n\n    node->open_count--;\n\n    g_free(synth_open);\n\n    fs->private = NULL;\n\n    return 0;\n\n}\n", "idx": 24842}
{"project": "FFmpeg", "commit_id": "9d8533368f55e1f6a0ea30d6492b26399b030066", "target": 0, "func": "static void mdct512(int32_t *out, int16_t *in)\n\n{\n\n    int i, re, im, re1, im1;\n\n    int16_t rot[MDCT_SAMPLES];\n\n    IComplex x[MDCT_SAMPLES/4];\n\n\n\n    /* shift to simplify computations */\n\n    for (i = 0; i < MDCT_SAMPLES/4; i++)\n\n        rot[i] = -in[i + 3*MDCT_SAMPLES/4];\n\n    for (;i < MDCT_SAMPLES; i++)\n\n        rot[i] =  in[i -   MDCT_SAMPLES/4];\n\n\n\n    /* pre rotation */\n\n    for (i = 0; i < MDCT_SAMPLES/4; i++) {\n\n        re =  ((int)rot[               2*i] - (int)rot[MDCT_SAMPLES  -1-2*i]) >> 1;\n\n        im = -((int)rot[MDCT_SAMPLES/2+2*i] - (int)rot[MDCT_SAMPLES/2-1-2*i]) >> 1;\n\n        CMUL(x[i].re, x[i].im, re, im, -xcos1[i], xsin1[i]);\n\n    }\n\n\n\n    fft(x, MDCT_NBITS - 2);\n\n\n\n    /* post rotation */\n\n    for (i = 0; i < MDCT_SAMPLES/4; i++) {\n\n        re = x[i].re;\n\n        im = x[i].im;\n\n        CMUL(re1, im1, re, im, xsin1[i], xcos1[i]);\n\n        out[                 2*i] = im1;\n\n        out[MDCT_SAMPLES/2-1-2*i] = re1;\n\n    }\n\n}\n", "idx": 24859}
{"project": "qemu", "commit_id": "c16de8f59a2bcbe2dc037524cc648de896f581a4", "target": 0, "func": "static int blk_root_inactivate(BdrvChild *child)\n\n{\n\n    BlockBackend *blk = child->opaque;\n\n\n\n    if (blk->disable_perm) {\n\n        return 0;\n\n    }\n\n\n\n    /* Only inactivate BlockBackends for guest devices (which are inactive at\n\n     * this point because the VM is stopped) and unattached monitor-owned\n\n     * BlockBackends. If there is still any other user like a block job, then\n\n     * we simply can't inactivate the image. */\n\n    if (!blk->dev && !blk_name(blk)[0]) {\n\n        return -EPERM;\n\n    }\n\n\n\n    blk->disable_perm = true;\n\n    if (blk->root) {\n\n        bdrv_child_try_set_perm(blk->root, 0, BLK_PERM_ALL, &error_abort);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24863}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)\n\n{\n\n    struct vmsvga_rect_s *rect;\n\n    if (s->invalidated) {\n\n        s->redraw_fifo_first = s->redraw_fifo_last;\n\n        return;\n\n    }\n\n    /* Overlapping region updates can be optimised out here - if someone\n\n     * knows a smart algorithm to do that, please share.  */\n\n    while (s->redraw_fifo_first != s->redraw_fifo_last) {\n\n        rect = &s->redraw_fifo[s->redraw_fifo_first ++];\n\n        s->redraw_fifo_first &= REDRAW_FIFO_LEN - 1;\n\n        vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);\n\n    }\n\n}\n", "idx": 24865}
{"project": "qemu", "commit_id": "0923c577f993d61eeaf41f66db1e1010fa113976", "target": 0, "func": "length_f(int argc, char **argv)\n\n{\n\n        int64_t size;\n\n\tchar s1[64];\n\n\n\n\tsize = bdrv_getlength(bs);\n\n\tif (size < 0) {\n\n\t\tprintf(\"getlength: %s\", strerror(size));\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tcvtstr(size, s1, sizeof(s1));\n\n\tprintf(\"%s\\n\", s1);\n\n\treturn 0;\n\n}\n", "idx": 24872}
{"project": "qemu", "commit_id": "855011be05fad72e17e0280d0bab87a4bc840695", "target": 0, "func": "static void kvm_arm_gic_get(GICState *s)\n\n{\n\n    /* TODO: there isn't currently a kernel interface to get the GIC state */\n\n}\n", "idx": 24885}
{"project": "qemu", "commit_id": "faadf50e2962dd54175647a80bd6fc4319c91973", "target": 1, "func": "static void init_proc_601 (CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_601(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_601_HID15, \"HID15\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->nb_tlb = 64;\n\n    env->nb_ways = 2;\n\n    env->id_tlbs = 0;\n\n#endif\n\n    init_excp_601(env);\n\n    env->dcache_line_size = 64;\n\n    env->icache_line_size = 64;\n\n    /* XXX: TODO: allocate internal IRQ controller */\n\n}\n", "idx": 24918}
{"project": "qemu", "commit_id": "24b856ca63f1c72b5043af6b291e7cc35900f4d6", "target": 0, "func": "static int i6300esb_init(PCIDevice *dev)\n\n{\n\n    I6300State *d = DO_UPCAST(I6300State, dev, dev);\n\n    uint8_t *pci_conf;\n\n    int io_mem;\n\n    static CPUReadMemoryFunc * const mem_read[3] = {\n\n        i6300esb_mem_readb,\n\n        i6300esb_mem_readw,\n\n        i6300esb_mem_readl,\n\n    };\n\n    static CPUWriteMemoryFunc * const mem_write[3] = {\n\n        i6300esb_mem_writeb,\n\n        i6300esb_mem_writew,\n\n        i6300esb_mem_writel,\n\n    };\n\n\n\n    i6300esb_debug(\"I6300State = %p\\n\", d);\n\n\n\n    d->timer = qemu_new_timer_ns(vm_clock, i6300esb_timer_expired, d);\n\n    d->previous_reboot_flag = 0;\n\n\n\n    pci_conf = d->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_ESB_9);\n\n    pci_config_set_class(pci_conf, PCI_CLASS_SYSTEM_OTHER);\n\n\n\n    io_mem = cpu_register_io_memory(mem_read, mem_write, d,\n\n                                    DEVICE_NATIVE_ENDIAN);\n\n    pci_register_bar_simple(&d->dev, 0, 0x10, 0, io_mem);\n\n    /* qemu_register_coalesced_mmio (addr, 0x10); ? */\n\n\n\n    return 0;\n\n}\n", "idx": 24935}
{"project": "qemu", "commit_id": "0ddf08db22a9ef6b122d8c4cfe5b25d2c2c51962", "target": 0, "func": "NBDExport *nbd_export_new(BlockDriverState *bs, off_t dev_offset,\n\n                          off_t size, uint32_t nbdflags)\n\n{\n\n    NBDExport *exp = g_malloc0(sizeof(NBDExport));\n\n    QSIMPLEQ_INIT(&exp->requests);\n\n    exp->refcount = 1;\n\n    QTAILQ_INIT(&exp->clients);\n\n    exp->bs = bs;\n\n    exp->dev_offset = dev_offset;\n\n    exp->nbdflags = nbdflags;\n\n    exp->size = size == -1 ? bdrv_getlength(bs) : size;\n\n    return exp;\n\n}\n", "idx": 24937}
{"project": "qemu", "commit_id": "2572b37a4751cc967582d7d04f21d9bf97187ae5", "target": 0, "func": "static BlockDriverAIOCB *bdrv_aio_rw_vector(BlockDriverState *bs,\n\n                                            int64_t sector_num,\n\n                                            QEMUIOVector *qiov,\n\n                                            int nb_sectors,\n\n                                            BlockDriverCompletionFunc *cb,\n\n                                            void *opaque,\n\n                                            int is_write)\n\n\n\n{\n\n    BlockDriverAIOCBSync *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_aiocb_info, bs, cb, opaque);\n\n    acb->is_write = is_write;\n\n    acb->qiov = qiov;\n\n    acb->bounce = qemu_blockalign(bs, qiov->size);\n\n    acb->bh = qemu_bh_new(bdrv_aio_bh_cb, acb);\n\n\n\n    if (is_write) {\n\n        qemu_iovec_to_buf(acb->qiov, 0, acb->bounce, qiov->size);\n\n        acb->ret = bs->drv->bdrv_write(bs, sector_num, acb->bounce, nb_sectors);\n\n    } else {\n\n        acb->ret = bs->drv->bdrv_read(bs, sector_num, acb->bounce, nb_sectors);\n\n    }\n\n\n\n    qemu_bh_schedule(acb->bh);\n\n\n\n    return &acb->common;\n\n}\n", "idx": 24938}
{"project": "qemu", "commit_id": "49fb65c7f985baa56d2964e0a85c1f098e3e2a9d", "target": 1, "func": "static void virtio_scsi_push_event(VirtIOSCSI *s, SCSIDevice *dev,\n\n                                   uint32_t event, uint32_t reason)\n\n{\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);\n\n    VirtIOSCSIReq *req = virtio_scsi_pop_req(s, vs->event_vq);\n\n    VirtIOSCSIEvent *evt;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    int in_size;\n\n\n\n    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\n        return;\n\n    }\n\n\n\n    if (!req) {\n\n        s->events_dropped = true;\n\n        return;\n\n    }\n\n\n\n    if (req->elem.out_num || req->elem.in_num != 1) {\n\n        virtio_scsi_bad_req();\n\n    }\n\n\n\n    if (s->events_dropped) {\n\n        event |= VIRTIO_SCSI_T_EVENTS_MISSED;\n\n        s->events_dropped = false;\n\n    }\n\n\n\n    in_size = req->elem.in_sg[0].iov_len;\n\n    if (in_size < sizeof(VirtIOSCSIEvent)) {\n\n        virtio_scsi_bad_req();\n\n    }\n\n\n\n    evt = req->resp.event;\n\n    memset(evt, 0, sizeof(VirtIOSCSIEvent));\n\n    evt->event = event;\n\n    evt->reason = reason;\n\n    if (!dev) {\n\n        assert(event == VIRTIO_SCSI_T_NO_EVENT);\n\n    } else {\n\n        evt->lun[0] = 1;\n\n        evt->lun[1] = dev->id;\n\n\n\n        /* Linux wants us to keep the same encoding we use for REPORT LUNS.  */\n\n        if (dev->lun >= 256) {\n\n            evt->lun[2] = (dev->lun >> 8) | 0x40;\n\n        }\n\n        evt->lun[3] = dev->lun & 0xFF;\n\n    }\n\n    virtio_scsi_complete_req(req);\n\n}\n", "idx": 24950}
{"project": "FFmpeg", "commit_id": "c084a975aa13eb1d0161f36a06051a9b2d4abb83", "target": 1, "func": "AVFrame *avcodec_alloc_frame(void)\n\n{\n\n    AVFrame *frame = av_malloc(sizeof(AVFrame));\n\n\n\n    if (frame == NULL)\n\n        return NULL;\n\n\n\n    avcodec_get_frame_defaults(frame);\n\n\n\n    return frame;\n\n}\n", "idx": 24953}
{"project": "qemu", "commit_id": "bb639f829f139ddc83325b3b6825f93096ee44f1", "target": 1, "func": "static void ahci_irq_raise(AHCIState *s, AHCIDevice *dev)\n\n{\n\n    AHCIPCIState *d = container_of(s, AHCIPCIState, ahci);\n\n    PCIDevice *pci_dev =\n\n        (PCIDevice *)object_dynamic_cast(OBJECT(d), TYPE_PCI_DEVICE);\n\n\n\n    DPRINTF(0, \"raise irq\\n\");\n\n\n\n    if (pci_dev && msi_enabled(pci_dev)) {\n\n        msi_notify(pci_dev, 0);\n\n    } else {\n\n        qemu_irq_raise(s->irq);\n\n    }\n\n}\n", "idx": 24965}
{"project": "FFmpeg", "commit_id": "985688b8e597b616246746a16649653db6dcf023", "target": 1, "func": "static int mov_write_hdlr_tag(ByteIOContext *pb, MOVTrack *track)\n\n{\n\n    const char *descr, *hdlr, *hdlr_type;\n\n    int64_t pos = url_ftell(pb);\n\n\n\n    if (!track) { /* no media --> data handler */\n\n        hdlr = \"dhlr\";\n\n        hdlr_type = \"url \";\n\n        descr = \"DataHandler\";\n\n    } else {\n\n        hdlr = (track->mode == MODE_MOV) ? \"mhlr\" : \"\\0\\0\\0\\0\";\n\n        if (track->enc->codec_type == CODEC_TYPE_VIDEO) {\n\n            hdlr_type = \"vide\";\n\n            descr = \"VideoHandler\";\n\n        } else if (track->enc->codec_type == CODEC_TYPE_AUDIO){\n\n            hdlr_type = \"soun\";\n\n            descr = \"SoundHandler\";\n\n        } else if (track->enc->codec_type == CODEC_TYPE_SUBTITLE){\n\n            if (track->mode == MODE_IPOD) hdlr_type = \"sbtl\";\n\n            else                          hdlr_type = \"text\";\n\n            descr = \"SubtitleHandler\";\n\n        }\n\n    }\n\n\n\n    put_be32(pb, 0); /* size */\n\n    put_tag(pb, \"hdlr\");\n\n    put_be32(pb, 0); /* Version & flags */\n\n    put_buffer(pb, hdlr, 4); /* handler */\n\n    put_tag(pb, hdlr_type); /* handler type */\n\n    put_be32(pb ,0); /* reserved */\n\n    put_be32(pb ,0); /* reserved */\n\n    put_be32(pb ,0); /* reserved */\n\n    put_byte(pb, strlen(descr)); /* string counter */\n\n    put_buffer(pb, descr, strlen(descr)); /* handler description */\n\n    return updateSize(pb, pos);\n\n}\n", "idx": 24966}
{"project": "FFmpeg", "commit_id": "db85d11d9d880c932b13d37b5f1ca2bc9e3a253b", "target": 1, "func": "static int ftp_features(FTPContext *s)\n\n{\n\n    static const char *feat_command        = \"FEAT\\r\\n\";\n\n    static const char *enable_utf8_command = \"OPTS UTF8 ON\\r\\n\";\n\n    static const int feat_codes[] = {211, 0};\n\n    static const int opts_codes[] = {200, 451};\n\n    char *feat;\n\n\n\n    if (ftp_send_command(s, feat_command, feat_codes, &feat) == 211) {\n\n        if (av_stristr(feat, \"UTF8\"))\n\n            ftp_send_command(s, enable_utf8_command, opts_codes, NULL);\n\n    }\n\n    return 0;\n\n}\n", "idx": 24985}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "void run_on_cpu(CPUState *env, void (*func)(void *data), void *data)\n\n{\n\n    struct qemu_work_item wi;\n\n\n\n    if (qemu_cpu_self(env)) {\n\n        func(data);\n\n        return;\n\n    }\n\n\n\n    wi.func = func;\n\n    wi.data = data;\n\n    if (!env->queued_work_first)\n\n        env->queued_work_first = &wi;\n\n    else\n\n        env->queued_work_last->next = &wi;\n\n    env->queued_work_last = &wi;\n\n    wi.next = NULL;\n\n    wi.done = false;\n\n\n\n    qemu_cpu_kick(env);\n\n    while (!wi.done) {\n\n        CPUState *self_env = cpu_single_env;\n\n\n\n        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);\n\n        cpu_single_env = self_env;\n\n    }\n\n}\n", "idx": 25007}
{"project": "FFmpeg", "commit_id": "4bb1070c154e49d35805fbcdac9c9e92f702ef96", "target": 0, "func": "void ffv1_clear_slice_state(FFV1Context *f, FFV1Context *fs)\n\n{\n\n    int i, j;\n\n\n\n    for (i = 0; i < f->plane_count; i++) {\n\n        PlaneContext *p = &fs->plane[i];\n\n\n\n        p->interlace_bit_state[0] = 128;\n\n        p->interlace_bit_state[1] = 128;\n\n\n\n        if (fs->ac) {\n\n            if (f->initial_states[p->quant_table_index]) {\n\n                memcpy(p->state, f->initial_states[p->quant_table_index],\n\n                       CONTEXT_SIZE * p->context_count);\n\n            } else\n\n                memset(p->state, 128, CONTEXT_SIZE * p->context_count);\n\n        } else {\n\n            for (j = 0; j < p->context_count; j++) {\n\n                p->vlc_state[j].drift     = 0;\n\n                p->vlc_state[j].error_sum = 4;    //FFMAX((RANGE + 32)/64, 2);\n\n                p->vlc_state[j].bias      = 0;\n\n                p->vlc_state[j].count     = 1;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 25071}
{"project": "FFmpeg", "commit_id": "d8dccf69ff2df7014a2bb8e0e17828a820f45b27", "target": 1, "func": "static int av_buffersrc_add_frame_internal(AVFilterContext *ctx,\n\n                                           AVFrame *frame, int flags)\n\n{\n\n    BufferSourceContext *s = ctx->priv;\n\n    AVFrame *copy;\n\n    int ret;\n\n\n\n    if (!frame) {\n\n        s->eof = 1;\n\n        return 0;\n\n    } else if (s->eof)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {\n\n\n\n    switch (ctx->outputs[0]->type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        CHECK_VIDEO_PARAM_CHANGE(ctx, s, frame->width, frame->height,\n\n                                 frame->format);\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        CHECK_AUDIO_PARAM_CHANGE(ctx, s, frame->sample_rate, frame->channel_layout,\n\n                                 frame->format);\n\n        break;\n\n    default:\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    }\n\n\n\n    if (!av_fifo_space(s->fifo) &&\n\n        (ret = av_fifo_realloc2(s->fifo, av_fifo_size(s->fifo) +\n\n                                         sizeof(copy))) < 0)\n\n        return ret;\n\n\n\n    if (!(copy = av_frame_alloc()))\n\n        return AVERROR(ENOMEM);\n\n    av_frame_move_ref(copy, frame);\n\n\n\n    if ((ret = av_fifo_generic_write(s->fifo, &copy, sizeof(copy), NULL)) < 0) {\n\n        av_frame_move_ref(frame, copy);\n\n        av_frame_free(&copy);\n\n        return ret;\n\n    }\n\n\n\n    if ((flags & AV_BUFFERSRC_FLAG_PUSH))\n\n        if ((ret = ctx->output_pads[0].request_frame(ctx->outputs[0])) < 0)\n\n            return ret;\n\n\n\n    return 0;\n\n}\n", "idx": 25077}
{"project": "FFmpeg", "commit_id": "ac1d489320f476c18d6a8125f73389aecb73f3d3", "target": 0, "func": "static int asf_read_seek(AVFormatContext *s, int stream_index, int64_t pts, int flags)\n\n{\n\n    ASFContext *asf = s->priv_data;\n\n    AVStream *st = s->streams[stream_index];\n\n    int64_t pos;\n\n    int index;\n\n\n\n    if (s->packet_size <= 0)\n\n        return -1;\n\n\n\n    /* Try using the protocol's read_seek if available */\n\n    if(s->pb) {\n\n        int ret = avio_seek_time(s->pb, stream_index, pts, flags);\n\n        if(ret >= 0)\n\n            asf_reset_header(s);\n\n        if (ret != AVERROR(ENOSYS))\n\n            return ret;\n\n    }\n\n\n\n    if (!asf->index_read)\n\n        asf_build_simple_index(s, stream_index);\n\n\n\n    if((asf->index_read && st->index_entries)){\n\n        index= av_index_search_timestamp(st, pts, flags);\n\n        if(index >= 0) {\n\n            /* find the position */\n\n            pos = st->index_entries[index].pos;\n\n\n\n            /* do the seek */\n\n            av_log(s, AV_LOG_DEBUG, \"SEEKTO: %\"PRId64\"\\n\", pos);\n\n            avio_seek(s->pb, pos, SEEK_SET);\n\n            asf_reset_header(s);\n\n            return 0;\n\n        }\n\n    }\n\n    /* no index or seeking by index failed */\n\n    if(av_seek_frame_binary(s, stream_index, pts, flags)<0)\n\n        return -1;\n\n    asf_reset_header(s);\n\n    return 0;\n\n}\n", "idx": 25089}
{"project": "FFmpeg", "commit_id": "e3751aa6ec8147ab7ca2649d4daadf8d4dce27d5", "target": 0, "func": "static void decode(RA288Context *ractx, float gain, int cb_coef)\n\n{\n\n    int i, j;\n\n    double sumsum;\n\n    float sum, buffer[5];\n\n\n\n    memmove(ractx->sp_block + 5, ractx->sp_block, 36*sizeof(*ractx->sp_block));\n\n\n\n    for (i=4; i >= 0; i--)\n\n        ractx->sp_block[i] = -scalar_product_float(ractx->sp_block + i + 1,\n\n                                             ractx->sp_lpc, 36);\n\n\n\n    /* block 46 of G.728 spec */\n\n    sum = 32. - scalar_product_float(ractx->gain_lpc, ractx->gain_block, 10);\n\n\n\n    /* block 47 of G.728 spec */\n\n    sum = av_clipf(sum, 0, 60);\n\n\n\n    /* block 48 of G.728 spec */\n\n    sumsum = exp(sum * 0.1151292546497) * gain; /* pow(10.0,sum/20)*gain */\n\n\n\n    for (i=0; i < 5; i++)\n\n        buffer[i] = codetable[cb_coef][i] * sumsum;\n\n\n\n    sum = scalar_product_float(buffer, buffer, 5) / 5;\n\n\n\n    sum = FFMAX(sum, 1);\n\n\n\n    /* shift and store */\n\n    memmove(ractx->gain_block, ractx->gain_block - 1,\n\n            10 * sizeof(*ractx->gain_block));\n\n\n\n    *ractx->gain_block = 10 * log10(sum) - 32;\n\n\n\n    for (i=1; i < 5; i++)\n\n        for (j=i-1; j >= 0; j--)\n\n            buffer[i] -= ractx->sp_lpc[i-j-1] * buffer[j];\n\n\n\n    /* output */\n\n    for (i=0; i < 5; i++)\n\n        ractx->sp_block[4-i] =\n\n            av_clipf(ractx->sp_block[4-i] + buffer[i], -4095, 4095);\n\n}\n", "idx": 25090}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_uint8_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    uint8_t v2;\n\n    qemu_get_8s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n", "idx": 25123}
{"project": "qemu", "commit_id": "74f24cb6306d065045d0e2215a7d10533fa59c57", "target": 1, "func": "static void test_visitor_in_intList(TestInputVisitorData *data,\n\n                                    const void *unused)\n\n{\n\n    int64_t value[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 20};\n\n    int16List *res = NULL, *tmp;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n    int i = 0;\n\n\n\n    v = visitor_input_test_init(data, \"1,2,0,2-4,20,5-9,1-8\");\n\n\n\n    visit_type_int16List(v, NULL, &res, &error_abort);\n\n    tmp = res;\n\n    while (i < sizeof(value) / sizeof(value[0])) {\n\n        g_assert(tmp);\n\n        g_assert_cmpint(tmp->value, ==, value[i++]);\n\n        tmp = tmp->next;\n\n    }\n\n    g_assert(!tmp);\n\n\n\n    tmp = res;\n\n    while (tmp) {\n\n        res = res->next;\n\n        g_free(tmp);\n\n        tmp = res;\n\n    }\n\n\n\n    visitor_input_teardown(data, unused);\n\n\n\n    v = visitor_input_test_init(data, \"not an int list\");\n\n\n\n    visit_type_int16List(v, NULL, &res, &err);\n\n    /* FIXME fix the visitor, then error_free_or_abort(&err) here */\n\n}\n", "idx": 25146}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_4x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = (17 * dc +  4) >> 3;\n\n    dc = (17 * dc + 64) >> 7;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 4; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 25194}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "void bdrv_io_limits_disable(BlockDriverState *bs)\n\n{\n\n    bs->io_limits_enabled = false;\n\n\n\n    bdrv_start_throttled_reqs(bs);\n\n\n\n    throttle_destroy(&bs->throttle_state);\n\n}\n", "idx": 25206}
{"project": "qemu", "commit_id": "1ec26c757d5996468afcc0dced4fad04139574b3", "target": 0, "func": "void kvmppc_update_sdr1(target_ulong sdr1)\n\n{\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        run_on_cpu(cs, kvmppc_pivot_hpt_cpu, RUN_ON_CPU_TARGET_PTR(sdr1));\n\n    }\n\n}\n", "idx": 25232}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_start_irqfd_injection(SysBusDevice *sbdev, qemu_irq irq)\n\n{\n\n    VFIOPlatformDevice *vdev = VFIO_PLATFORM_DEVICE(sbdev);\n\n    VFIOINTp *intp;\n\n\n\n    if (!kvm_irqfds_enabled() || !kvm_resamplefds_enabled() ||\n\n        !vdev->irqfd_allowed) {\n\n        goto fail_irqfd;\n\n    }\n\n\n\n    QLIST_FOREACH(intp, &vdev->intp_list, next) {\n\n        if (intp->qemuirq == irq) {\n\n            break;\n\n        }\n\n    }\n\n    assert(intp);\n\n\n\n    if (kvm_irqchip_add_irqfd_notifier(kvm_state, &intp->interrupt,\n\n                                   &intp->unmask, irq) < 0) {\n\n        goto fail_irqfd;\n\n    }\n\n\n\n    if (vfio_set_trigger_eventfd(intp, NULL) < 0) {\n\n        goto fail_vfio;\n\n    }\n\n    if (vfio_set_resample_eventfd(intp) < 0) {\n\n        goto fail_vfio;\n\n    }\n\n\n\n    intp->kvm_accel = true;\n\n\n\n    trace_vfio_platform_start_irqfd_injection(intp->pin,\n\n                                     event_notifier_get_fd(&intp->interrupt),\n\n                                     event_notifier_get_fd(&intp->unmask));\n\n    return;\n\nfail_vfio:\n\n    kvm_irqchip_remove_irqfd_notifier(kvm_state, &intp->interrupt, irq);\n\n    error_report(\"vfio: failed to start eventfd signaling for IRQ %d: %m\",\n\n                 intp->pin);\n\n    abort();\n\nfail_irqfd:\n\n    vfio_start_eventfd_injection(sbdev, irq);\n\n    return;\n\n}\n", "idx": 25234}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_mpuio_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t value, unsigned size)\n\n{\n\n    struct omap_mpuio_s *s = (struct omap_mpuio_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n    uint16_t diff;\n\n    int ln;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_write16(opaque, addr, value);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x04:\t/* OUTPUT_REG */\n\n        diff = (s->outputs ^ value) & ~s->dir;\n\n        s->outputs = value;\n\n        while ((ln = ffs(diff))) {\n\n            ln --;\n\n            if (s->handler[ln])\n\n                qemu_set_irq(s->handler[ln], (value >> ln) & 1);\n\n            diff &= ~(1 << ln);\n\n        }\n\n        break;\n\n\n\n    case 0x08:\t/* IO_CNTL */\n\n        diff = s->outputs & (s->dir ^ value);\n\n        s->dir = value;\n\n\n\n        value = s->outputs & ~s->dir;\n\n        while ((ln = ffs(diff))) {\n\n            ln --;\n\n            if (s->handler[ln])\n\n                qemu_set_irq(s->handler[ln], (value >> ln) & 1);\n\n            diff &= ~(1 << ln);\n\n        }\n\n        break;\n\n\n\n    case 0x14:\t/* KBC_REG */\n\n        s->cols = value;\n\n        omap_mpuio_kbd_update(s);\n\n        break;\n\n\n\n    case 0x18:\t/* GPIO_EVENT_MODE_REG */\n\n        s->event = value & 0x1f;\n\n        break;\n\n\n\n    case 0x1c:\t/* GPIO_INT_EDGE_REG */\n\n        s->edge = value;\n\n        break;\n\n\n\n    case 0x28:\t/* KBD_MASKIT */\n\n        s->kbd_mask = value & 1;\n\n        omap_mpuio_kbd_update(s);\n\n        break;\n\n\n\n    case 0x2c:\t/* GPIO_MASKIT */\n\n        s->mask = value;\n\n        break;\n\n\n\n    case 0x30:\t/* GPIO_DEBOUNCING_REG */\n\n        s->debounce = value & 0x1ff;\n\n        break;\n\n\n\n    case 0x00:\t/* INPUT_LATCH */\n\n    case 0x10:\t/* KBR_LATCH */\n\n    case 0x20:\t/* KBD_INT */\n\n    case 0x24:\t/* GPIO_INT */\n\n    case 0x34:\t/* GPIO_LATCH_REG */\n\n        OMAP_RO_REG(addr);\n\n        return;\n\n\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 25238}
{"project": "FFmpeg", "commit_id": "6950cca97fed890ec56259a2f868f37b65513d92", "target": 0, "func": "int av_image_fill_pointers(uint8_t *data[4], enum PixelFormat pix_fmt, int height,\n\n                           uint8_t *ptr, const int linesizes[4])\n\n{\n\n    int i, total_size, size[4], has_plane[4];\n\n\n\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt];\n\n    memset(data     , 0, sizeof(data[0])*4);\n\n    memset(size     , 0, sizeof(size));\n\n    memset(has_plane, 0, sizeof(has_plane));\n\n\n\n    if (desc->flags & PIX_FMT_HWACCEL)\n\n        return AVERROR(EINVAL);\n\n\n\n    data[0] = ptr;\n\n    size[0] = linesizes[0] * height;\n\n\n\n    if (desc->flags & PIX_FMT_PAL) {\n\n        size[0] = (size[0] + 3) & ~3;\n\n        data[1] = ptr + size[0]; /* palette is stored here as 256 32 bits words */\n\n        return size[0] + 256 * 4;\n\n    }\n\n\n\n    for (i = 0; i < 4; i++)\n\n        has_plane[desc->comp[i].plane] = 1;\n\n\n\n    total_size = size[0];\n\n    for (i = 1; has_plane[i] && i < 4; i++) {\n\n        int h, s = (i == 1 || i == 2) ? desc->log2_chroma_h : 0;\n\n        data[i] = data[i-1] + size[i-1];\n\n        h = (height + (1 << s) - 1) >> s;\n\n        size[i] = h * linesizes[i];\n\n        total_size += size[i];\n\n    }\n\n\n\n    return total_size;\n\n}\n", "idx": 25266}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static void proxy_rewinddir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    rewinddir(fs->dir);\n\n}\n", "idx": 25278}
{"project": "FFmpeg", "commit_id": "15c41cb6adc4d6720d51c21f8baebebce923b213", "target": 1, "func": "void ff_thread_await_progress(ThreadFrame *f, int n, int field)\n\n{\n\n    PerThreadContext *p;\n\n    atomic_int *progress = f->progress ? (atomic_int*)f->progress->data : NULL;\n\n\n\n    if (!progress ||\n\n        atomic_load_explicit(&progress[field], memory_order_acquire) >= n)\n\n        return;\n\n\n\n    p = f->owner[field]->internal->thread_ctx;\n\n\n\n    pthread_mutex_lock(&p->progress_mutex);\n\n    if (f->owner[field]->debug&FF_DEBUG_THREADS)\n\n        av_log(f->owner[field], AV_LOG_DEBUG,\n\n               \"thread awaiting %d field %d from %p\\n\", n, field, progress);\n\n    while (atomic_load_explicit(&progress[field], memory_order_relaxed) < n)\n\n        pthread_cond_wait(&p->progress_cond, &p->progress_mutex);\n\n    pthread_mutex_unlock(&p->progress_mutex);\n\n}\n", "idx": 25306}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_struct(gconstpointer opaque)\n\n{\n\n    TestArgs *args = (TestArgs *) opaque;\n\n    const SerializeOps *ops = args->ops;\n\n    TestStruct *ts = struct_create();\n\n    TestStruct *ts_copy = NULL;\n\n    Error *err = NULL;\n\n    void *serialize_data;\n\n\n\n    ops->serialize(ts, &serialize_data, visit_struct, &err);\n\n    ops->deserialize((void **)&ts_copy, serialize_data, visit_struct, &err); \n\n\n\n    g_assert(err == NULL);\n\n    struct_compare(ts, ts_copy);\n\n\n\n    struct_cleanup(ts);\n\n    struct_cleanup(ts_copy);\n\n\n\n    ops->cleanup(serialize_data);\n\n    g_free(args);\n\n}\n", "idx": 25325}
{"project": "FFmpeg", "commit_id": "f0ff20a197dd98d2c0ecef3d183185a5c45c7196", "target": 0, "func": "AVResampleContext *av_resample_init(int out_rate, int in_rate, int filter_size, int phase_shift, int linear, double cutoff){\n\n    AVResampleContext *c= av_mallocz(sizeof(AVResampleContext));\n\n    double factor= FFMIN(out_rate * cutoff / in_rate, 1.0);\n\n    int phase_count= 1<<phase_shift;\n\n    \n\n    c->phase_shift= phase_shift;\n\n    c->phase_mask= phase_count-1;\n\n    c->linear= linear;\n\n\n\n    c->filter_length= FFMAX(ceil(filter_size/factor), 1);\n\n    c->filter_bank= av_mallocz(c->filter_length*(phase_count+1)*sizeof(FELEM));\n\n    av_build_filter(c->filter_bank, factor, c->filter_length, phase_count, 1<<FILTER_SHIFT, 1);\n\n    memcpy(&c->filter_bank[c->filter_length*phase_count+1], c->filter_bank, (c->filter_length-1)*sizeof(FELEM));\n\n    c->filter_bank[c->filter_length*phase_count]= c->filter_bank[c->filter_length - 1];\n\n\n\n    c->src_incr= out_rate;\n\n    c->ideal_dst_incr= c->dst_incr= in_rate * phase_count;\n\n    c->index= -phase_count*((c->filter_length-1)/2);\n\n\n\n    return c;\n\n}\n", "idx": 25347}
{"project": "FFmpeg", "commit_id": "baf2ffd3297b707dbb5794ec568c61091acf5c0c", "target": 0, "func": "static int mov_read_elst(MOVContext *c, ByteIOContext *pb, MOVAtom atom)\n\n{\n\n    MOVStreamContext *sc = c->fc->streams[c->fc->nb_streams-1]->priv_data;\n\n    int i, edit_count;\n\n\n\n    get_byte(pb); /* version */\n\n    get_be24(pb); /* flags */\n\n    edit_count= sc->edit_count = get_be32(pb);     /* entries */\n\n\n\n    for(i=0; i<edit_count; i++){\n\n        int time;\n\n        get_be32(pb); /* Track duration */\n\n        time = get_be32(pb); /* Media time */\n\n        get_be32(pb); /* Media rate */\n\n        if (time != 0)\n\n            av_log(c->fc, AV_LOG_WARNING, \"edit list not starting at 0, \"\n\n                   \"a/v desync might occur, patch welcome\\n\");\n\n    }\n\n    dprintf(c->fc, \"track[%i].edit_count = %i\\n\", c->fc->nb_streams-1, sc->edit_count);\n\n    return 0;\n\n}\n", "idx": 25348}
{"project": "qemu", "commit_id": "2fb50a33401a2415b71ddc291e8a77bcd2f9e547", "target": 0, "func": "static void set_irq_level(void *opaque, int n, int level)\n\n{\n\n    NVICState *s = opaque;\n\n    VecInfo *vec;\n\n\n\n    n += NVIC_FIRST_IRQ;\n\n\n\n    assert(n >= NVIC_FIRST_IRQ && n < s->num_irq);\n\n\n\n    trace_nvic_set_irq_level(n, level);\n\n\n\n    /* The pending status of an external interrupt is\n\n     * latched on rising edge and exception handler return.\n\n     *\n\n     * Pulsing the IRQ will always run the handler\n\n     * once, and the handler will re-run until the\n\n     * level is low when the handler completes.\n\n     */\n\n    vec = &s->vectors[n];\n\n    if (level != vec->level) {\n\n        vec->level = level;\n\n        if (level) {\n\n            armv7m_nvic_set_pending(s, n);\n\n        }\n\n    }\n\n}\n", "idx": 25363}
{"project": "qemu", "commit_id": "93b91c59dbccde6e4d25661150c1529bd5ee4a06", "target": 1, "func": "QObject *qmp_dispatch(QObject *request)\n\n{\n\n    Error *err = NULL;\n\n    QObject *ret;\n\n    QDict *rsp;\n\n\n\n    ret = do_qmp_dispatch(request, &err);\n\n\n\n    rsp = qdict_new();\n\n    if (err) {\n\n        qdict_put_obj(rsp, \"error\", error_get_qobject(err));\n\n        error_free(err);\n\n    } else if (ret) {\n\n        qdict_put_obj(rsp, \"return\", ret);\n\n    } else {\n\n        QDECREF(rsp);\n\n        return NULL;\n\n    }\n\n\n\n    return QOBJECT(rsp);\n\n}\n", "idx": 25388}
{"project": "qemu", "commit_id": "e05ca8200216149008fa1b1d1d847bf16691f6b4", "target": 1, "func": "int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev)\n\n{\n\n    int i, r;\n\n\n\n    hdev->started = true;\n\n\n\n    r = vhost_dev_set_features(hdev, hdev->log_enabled);\n\n    if (r < 0) {\n\n        goto fail_features;\n\n    }\n\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_MEM_TABLE, hdev->mem);\n\n    if (r < 0) {\n\n        r = -errno;\n\n        goto fail_mem;\n\n    }\n\n    for (i = 0; i < hdev->nvqs; ++i) {\n\n        r = vhost_virtqueue_start(hdev,\n\n                                  vdev,\n\n                                  hdev->vqs + i,\n\n                                  hdev->vq_index + i);\n\n        if (r < 0) {\n\n            goto fail_vq;\n\n        }\n\n    }\n\n\n\n    if (hdev->log_enabled) {\n\n        hdev->log_size = vhost_get_log_size(hdev);\n\n        hdev->log = hdev->log_size ?\n\n            g_malloc0(hdev->log_size * sizeof *hdev->log) : NULL;\n\n        r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_LOG_BASE, hdev->log);\n\n        if (r < 0) {\n\n            r = -errno;\n\n            goto fail_log;\n\n        }\n\n    }\n\n\n\n    return 0;\n\nfail_log:\n\nfail_vq:\n\n    while (--i >= 0) {\n\n        vhost_virtqueue_stop(hdev,\n\n                             vdev,\n\n                             hdev->vqs + i,\n\n                             hdev->vq_index + i);\n\n    }\n\n    i = hdev->nvqs;\n\nfail_mem:\n\nfail_features:\n\n\n\n    hdev->started = false;\n\n    return r;\n\n}\n", "idx": 25414}
{"project": "FFmpeg", "commit_id": "53e0d5d7247548743e13c59c35e59fc2161e9582", "target": 1, "func": "static int io_open_default(AVFormatContext *s, AVIOContext **pb,\n                           const char *url, int flags, AVDictionary **options)\n{\n#if FF_API_OLD_OPEN_CALLBACKS\nFF_DISABLE_DEPRECATION_WARNINGS\n    if (s->open_cb)\n        return s->open_cb(s, pb, url, flags, &s->interrupt_callback, options);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n    return ffio_open_whitelist(pb, url, flags, &s->interrupt_callback, options, s->protocol_whitelist, s->protocol_blacklist);\n}", "idx": 25466}
{"project": "qemu", "commit_id": "21b2f13ae21974e0fd7f8da99d84628a8000d1d7", "target": 1, "func": "static void mmubooke_dump_mmu(FILE *f, fprintf_function cpu_fprintf,\n\n                                 CPUPPCState *env)\n\n{\n\n    ppcemb_tlb_t *entry;\n\n    int i;\n\n\n\n    if (kvm_enabled() && !env->kvm_sw_tlb) {\n\n        cpu_fprintf(f, \"Cannot access KVM TLB\\n\");\n\n        return;\n\n    }\n\n\n\n    cpu_fprintf(f, \"\\nTLB:\\n\");\n\n    cpu_fprintf(f, \"Effective          Physical           Size PID   Prot     \"\n\n                \"Attr\\n\");\n\n\n\n    entry = &env->tlb.tlbe[0];\n\n    for (i = 0; i < env->nb_tlb; i++, entry++) {\n\n        hwaddr ea, pa;\n\n        target_ulong mask;\n\n        uint64_t size = (uint64_t)entry->size;\n\n        char size_buf[20];\n\n\n\n        /* Check valid flag */\n\n        if (!(entry->prot & PAGE_VALID)) {\n\n            continue;\n\n        }\n\n\n\n        mask = ~(entry->size - 1);\n\n        ea = entry->EPN & mask;\n\n        pa = entry->RPN & mask;\n\n#if (TARGET_PHYS_ADDR_SPACE_BITS >= 36)\n\n        /* Extend the physical address to 36 bits */\n\n        pa |= (hwaddr)(entry->RPN & 0xF) << 32;\n\n#endif\n\n        size /= 1024;\n\n        if (size >= 1024) {\n\n            snprintf(size_buf, sizeof(size_buf), \"%3\" PRId64 \"M\", size / 1024);\n\n        } else {\n\n            snprintf(size_buf, sizeof(size_buf), \"%3\" PRId64 \"k\", size);\n\n        }\n\n        cpu_fprintf(f, \"0x%016\" PRIx64 \" 0x%016\" PRIx64 \" %s %-5u %08x %08x\\n\",\n\n                    (uint64_t)ea, (uint64_t)pa, size_buf, (uint32_t)entry->PID,\n\n                    entry->prot, entry->attr);\n\n    }\n\n\n\n}\n", "idx": 25468}
{"project": "FFmpeg", "commit_id": "f4ae3cce64bd46b1d539bdeac39753f83015f114", "target": 1, "func": "static void rstrip_spaces_buf(AVBPrint *buf)\n\n{\n\n    while (buf->len > 0 && buf->str[buf->len - 1] == ' ')\n\n        buf->str[--buf->len] = 0;\n\n}\n", "idx": 25477}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(rgb24ToY)(uint8_t *dst, const uint8_t *src, long width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_RGB24);\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        int r= src[i*3+0];\n\n        int g= src[i*3+1];\n\n        int b= src[i*3+2];\n\n\n\n        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);\n\n    }\n\n#endif\n\n}\n", "idx": 25481}
{"project": "FFmpeg", "commit_id": "6c23a85000fd5956a2820495b2a081f65d03b962", "target": 1, "func": "static int compand_drain(AVFilterLink *outlink)\n\n{\n\n    AVFilterContext *ctx = outlink->src;\n\n    CompandContext *s    = ctx->priv;\n\n    const int channels   = outlink->channels;\n\n    AVFrame *frame       = NULL;\n\n    int chan, i, dindex;\n\n\n\n    /* 2048 is to limit output frame size during drain */\n\n    frame = ff_get_audio_buffer(outlink, FFMIN(2048, s->delay_count));\n\n    if (!frame)\n\n        return AVERROR(ENOMEM);\n\n    frame->pts = s->pts;\n\n    s->pts += av_rescale_q(frame->nb_samples,\n\n            (AVRational){ 1, outlink->sample_rate }, outlink->time_base);\n\n\n\n\n    for (chan = 0; chan < channels; chan++) {\n\n        AVFrame *delay_frame = s->delay_frame;\n\n        double *dbuf = (double *)delay_frame->extended_data[chan];\n\n        double *dst = (double *)frame->extended_data[chan];\n\n        ChanParam *cp = &s->channels[chan];\n\n\n\n        dindex = s->delay_index;\n\n        for (i = 0; i < frame->nb_samples; i++) {\n\n            dst[i] = av_clipd(dbuf[dindex] * get_volume(s, cp->volume),\n\n                    -1, 1);\n\n            dindex = MOD(dindex + 1, s->delay_samples);\n\n        }\n\n    }\n\n    s->delay_count -= frame->nb_samples;\n\n    s->delay_index = dindex;\n\n\n\n    return ff_filter_frame(outlink, frame);\n\n}", "idx": 25489}
{"project": "qemu", "commit_id": "967b75230b9720ea2b3ae49f38f8287026125f9f", "target": 1, "func": "static void pnv_chip_power9_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PnvChipClass *k = PNV_CHIP_CLASS(klass);\n\n\n\n    k->cpu_model = \"POWER9\";\n\n    k->chip_type = PNV_CHIP_POWER9;\n\n    k->chip_cfam_id = 0x100d104980000000ull; /* P9 Nimbus DD1.0 */\n\n    k->cores_mask = POWER9_CORE_MASK;\n\n    k->core_pir = pnv_chip_core_pir_p9;\n\n\n    dc->desc = \"PowerNV Chip POWER9\";\n\n}", "idx": 25498}
{"project": "FFmpeg", "commit_id": "74ef8b434d8d8ef02bee6a5394da849136ed1bf1", "target": 1, "func": "static int rtsp_read_packet(AVFormatContext *s,\n\n                            AVPacket *pkt)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    RTSPStream *rtsp_st;\n\n    int ret, len;\n\n    uint8_t buf[RTP_MAX_PACKET_LENGTH];\n\n\n\n    /* get next frames from the same RTP packet */\n\n    if (rt->cur_rtp) {\n\n        ret = rtp_parse_packet(rt->cur_rtp, pkt, NULL, 0);\n\n        if (ret == 0) {\n\n            rt->cur_rtp = NULL;\n\n            return 0;\n\n        } else if (ret == 1) {\n\n            return 0;\n\n        } else {\n\n            rt->cur_rtp = NULL;\n\n        }\n\n    }\n\n\n\n    /* read next RTP packet */\n\n redo:\n\n    switch(rt->protocol) {\n\n    default:\n\n    case RTSP_PROTOCOL_RTP_TCP:\n\n        len = tcp_read_packet(s, &rtsp_st, buf, sizeof(buf));\n\n        break;\n\n    case RTSP_PROTOCOL_RTP_UDP:\n\n    case RTSP_PROTOCOL_RTP_UDP_MULTICAST:\n\n        len = udp_read_packet(s, &rtsp_st, buf, sizeof(buf));\n\n        if (rtsp_st->rtp_ctx)\n\n            rtp_check_and_send_back_rr(rtsp_st->rtp_ctx, len);\n\n        break;\n\n    }\n\n    if (len < 0)\n\n        return AVERROR_IO;\n\n    ret = rtp_parse_packet(rtsp_st->rtp_ctx, pkt, buf, len);\n\n    if (ret < 0)\n\n        goto redo;\n\n    if (ret == 1) {\n\n        /* more packets may follow, so we save the RTP context */\n\n        rt->cur_rtp = rtsp_st->rtp_ctx;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25500}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,\n\n                          unsigned npfd, int64_t timeout)\n\n{\n\n    return false;\n\n}\n", "idx": 25519}
{"project": "FFmpeg", "commit_id": "d371c3c2e2830d9783465ecfe1ab7d93351083b7", "target": 1, "func": "static int source_config_props(AVFilterLink *outlink)\n\n{\n\n    AVFilterContext *ctx = outlink->src;\n\n    Frei0rContext *s = ctx->priv;\n\n\n\n    if (av_image_check_size(s->w, s->h, 0, ctx) < 0)\n\n        return AVERROR(EINVAL);\n\n    outlink->w = s->w;\n\n    outlink->h = s->h;\n\n    outlink->time_base = s->time_base;\n\n\n\n\n\n    if (!(s->instance = s->construct(outlink->w, outlink->h))) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Impossible to load frei0r instance\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    return set_params(ctx, s->params);\n\n}", "idx": 25528}
{"project": "qemu", "commit_id": "53724ee565565f69560dbe17553bede8c0169379", "target": 0, "func": "void spapr_tce_reset(DMAContext *dma)\n\n{\n\n    if (dma) {\n\n        sPAPRTCETable *tcet = DO_UPCAST(sPAPRTCETable, dma, dma);\n\n        size_t table_size = (tcet->window_size >> SPAPR_TCE_PAGE_SHIFT)\n\n            * sizeof(sPAPRTCE);\n\n\n\n        memset(tcet->table, 0, table_size);\n\n    }\n\n}\n", "idx": 25551}
{"project": "qemu", "commit_id": "90e496386fe7fd32c189561f846b7913f95b8cf4", "target": 0, "func": "static inline int fp_reg_hi_offset(int regno)\n\n{\n\n    return offsetof(CPUARMState, vfp.regs[regno * 2 + 1]);\n\n}\n", "idx": 25570}
{"project": "qemu", "commit_id": "7466bc49107fbd84336ba680f860d5eadd6def13", "target": 0, "func": "void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    sdpy.ds = ds;\n\n    sdpy.bufsize = (16 * 1024 * 1024);\n\n    sdpy.buf = qemu_malloc(sdpy.bufsize);\n\n    pthread_mutex_init(&sdpy.lock, NULL);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_add_vm_change_state_handler(qemu_spice_vm_change_state_handler, &sdpy);\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n", "idx": 25576}
{"project": "FFmpeg", "commit_id": "51b0694bc051cda2bfed048a35e694d1047c6ef0", "target": 0, "func": "const DVprofile* ff_dv_frame_profile2(AVCodecContext* codec, const DVprofile *sys,\n\n                                  const uint8_t* frame, unsigned buf_size)\n\n{\n\n   int i;\n\n\n\n   int dsf = (frame[3] & 0x80) >> 7;\n\n\n\n   int stype = frame[80*5 + 48 + 3] & 0x1f;\n\n\n\n   /* 576i50 25Mbps 4:1:1 is a special case */\n\n   if (dsf == 1 && stype == 0 && frame[4] & 0x07 /* the APT field */) {\n\n       return &dv_profiles[2];\n\n   }\n\n\n\n   if(codec && codec->codec_tag==AV_RL32(\"dvsd\") &&  codec->width==720 && codec->height==576)\n\n       return &dv_profiles[1];\n\n\n\n   for (i=0; i<FF_ARRAY_ELEMS(dv_profiles); i++)\n\n       if (dsf == dv_profiles[i].dsf && stype == dv_profiles[i].video_stype)\n\n           return &dv_profiles[i];\n\n\n\n   /* check if old sys matches and assumes corrupted input */\n\n   if (sys && buf_size == sys->frame_size)\n\n       return sys;\n\n\n\n   return NULL;\n\n}\n", "idx": 25577}
{"project": "qemu", "commit_id": "b7bad50ae81efeb180609eeecdb086ebc7536ed7", "target": 0, "func": "static void cryptodev_builtin_cleanup(\n\n             CryptoDevBackend *backend,\n\n             Error **errp)\n\n{\n\n    CryptoDevBackendBuiltin *builtin =\n\n                      CRYPTODEV_BACKEND_BUILTIN(backend);\n\n    size_t i;\n\n    int queues = backend->conf.peers.queues;\n\n    CryptoDevBackendClient *cc;\n\n\n\n    for (i = 0; i < MAX_NUM_SESSIONS; i++) {\n\n        if (builtin->sessions[i] != NULL) {\n\n            cryptodev_builtin_sym_close_session(\n\n                    backend, i, 0, errp);\n\n        }\n\n    }\n\n\n\n    assert(queues == 1);\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        cc = backend->conf.peers.ccs[i];\n\n        if (cc) {\n\n            cryptodev_backend_free_client(cc);\n\n            backend->conf.peers.ccs[i] = NULL;\n\n        }\n\n    }\n\n\n\n    cryptodev_backend_set_ready(backend, false);\n\n}\n", "idx": 25585}
{"project": "qemu", "commit_id": "ce137829e7e58fcdc5ba63b5e256f972e80be438", "target": 1, "func": "static void clear_commits(BDRVVVFATState* s)\n\n{\n\n    int i;\n\nDLOG(fprintf(stderr, \"clear_commits (%d commits)\\n\", s->commits.next));\n\n    for (i = 0; i < s->commits.next; i++) {\n\n\tcommit_t* commit = array_get(&(s->commits), i);\n\n\tassert(commit->path || commit->action == ACTION_WRITEOUT);\n\n\tif (commit->action != ACTION_WRITEOUT) {\n\n\t    assert(commit->path);\n\n\t    free(commit->path);\n\n\t} else\n\n\t    assert(commit->path == NULL);\n\n    }\n\n    s->commits.next = 0;\n\n}\n", "idx": 25586}
{"project": "qemu", "commit_id": "c527e0afcd7d719abc3a5ca5e4c8ac2fe48b999f", "target": 1, "func": "vmxnet3_dump_rx_descr(struct Vmxnet3_RxDesc *descr)\n\n{\n\n    VMW_PKPRN(\"RX DESCR: addr %\" PRIx64 \", len: %d, gen: %d, rsvd: %d, \"\n\n              \"dtype: %d, ext1: %d, btype: %d\",\n\n              le64_to_cpu(descr->addr), descr->len, descr->gen,\n\n              descr->rsvd, descr->dtype, descr->ext1, descr->btype);\n\n}\n", "idx": 25600}
{"project": "FFmpeg", "commit_id": "caedd51e56e2ad47991a1b8bddcfaa8f7094a060", "target": 1, "func": "static int mxf_compute_sample_count(MXFContext *mxf, int stream_index, uint64_t *sample_count)\n\n{\n\n    int i, total = 0, size = 0;\n\n    AVStream *st = mxf->fc->streams[stream_index];\n\n    MXFTrack *track = st->priv_data;\n\n    AVRational time_base = av_inv_q(track->edit_rate);\n\n    AVRational sample_rate = av_inv_q(st->time_base);\n\n    const MXFSamplesPerFrame *spf = NULL;\n\n\n\n    if ((sample_rate.num / sample_rate.den) == 48000)\n\n        spf = ff_mxf_get_samples_per_frame(mxf->fc, time_base);\n\n    if (!spf) {\n\n        int remainder = (sample_rate.num * time_base.num) % (time_base.den * sample_rate.den);\n\n        *sample_count = av_q2d(av_mul_q((AVRational){mxf->current_edit_unit, 1},\n\n                                        av_mul_q(sample_rate, time_base)));\n\n        if (remainder)\n\n            av_log(mxf->fc, AV_LOG_WARNING,\n\n                   \"seeking detected on stream #%d with time base (%d/%d) and sample rate (%d/%d), audio pts won't be accurate.\\n\",\n\n                   stream_index, time_base.num, time_base.den, sample_rate.num, sample_rate.den);\n\n        return 0;\n\n    }\n\n\n\n    while (spf->samples_per_frame[size]) {\n\n        total += spf->samples_per_frame[size];\n\n        size++;\n\n    }\n\n\n\n    av_assert2(size);\n\n\n\n    *sample_count = (mxf->current_edit_unit / size) * total;\n\n    for (i = 0; i < mxf->current_edit_unit % size; i++) {\n\n        *sample_count += spf->samples_per_frame[i];\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 25610}
{"project": "qemu", "commit_id": "2ffcb18de0bc02ad8a836ec955584c02b70e0e24", "target": 0, "func": "int do_netdev_del(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *id = qdict_get_str(qdict, \"id\");\n\n    VLANClientState *vc;\n\n\n\n    vc = qemu_find_netdev(id);\n\n    if (!vc || vc->info->type == NET_CLIENT_TYPE_NIC) {\n\n        qerror_report(QERR_DEVICE_NOT_FOUND, id);\n\n        return -1;\n\n    }\n\n    if (vc->peer) {\n\n        qerror_report(QERR_DEVICE_IN_USE, id);\n\n        return -1;\n\n    }\n\n    qemu_del_vlan_client(vc);\n\n    qemu_opts_del(qemu_opts_find(&qemu_netdev_opts, id));\n\n    return 0;\n\n}\n", "idx": 25622}
{"project": "qemu", "commit_id": "59b060be184aff59cfa101c937c8139e66f452f2", "target": 0, "func": "int qcrypto_pbkdf2(QCryptoHashAlgorithm hash G_GNUC_UNUSED,\n\n                   const uint8_t *key G_GNUC_UNUSED,\n\n                   size_t nkey G_GNUC_UNUSED,\n\n                   const uint8_t *salt G_GNUC_UNUSED,\n\n                   size_t nsalt G_GNUC_UNUSED,\n\n                   unsigned int iterations G_GNUC_UNUSED,\n\n                   uint8_t *out G_GNUC_UNUSED,\n\n                   size_t nout G_GNUC_UNUSED,\n\n                   Error **errp)\n\n{\n\n    error_setg_errno(errp, ENOSYS,\n\n                     \"No crypto library supporting PBKDF in this build\");\n\n    return -1;\n\n}\n", "idx": 25624}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static inline void vmxnet3_ring_read_curr_cell(Vmxnet3Ring *ring, void *buff)\n\n{\n\n    vmw_shmem_read(vmxnet3_ring_curr_cell_pa(ring), buff, ring->cell_size);\n\n}\n", "idx": 25676}
{"project": "qemu", "commit_id": "456d60692310e7ac25cf822cc1e98192ad636ece", "target": 1, "func": "static CharDriverState* create_eventfd_chr_device(void * opaque, EventNotifier *n,\n\n                                                  int vector)\n\n{\n\n    /* create a event character device based on the passed eventfd */\n\n    IVShmemState *s = opaque;\n\n    CharDriverState * chr;\n\n    int eventfd = event_notifier_get_fd(n);\n\n\n\n    chr = qemu_chr_open_eventfd(eventfd);\n\n\n\n    if (chr == NULL) {\n\n        fprintf(stderr, \"creating eventfd for eventfd %d failed\\n\", eventfd);\n\n        exit(-1);\n\n    }\n\n\n\n\n    /* if MSI is supported we need multiple interrupts */\n\n    if (ivshmem_has_feature(s, IVSHMEM_MSI)) {\n\n        s->eventfd_table[vector].pdev = &s->dev;\n\n        s->eventfd_table[vector].vector = vector;\n\n\n\n        qemu_chr_add_handlers(chr, ivshmem_can_receive, fake_irqfd,\n\n                      ivshmem_event, &s->eventfd_table[vector]);\n\n    } else {\n\n        qemu_chr_add_handlers(chr, ivshmem_can_receive, ivshmem_receive,\n\n                      ivshmem_event, s);\n\n    }\n\n\n\n    return chr;\n\n\n\n}", "idx": 25682}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "static void xics_realize(DeviceState *dev, Error **errp)\n\n{\n\n    XICSState *icp = XICS(dev);\n\n    Error *error = NULL;\n\n    int i;\n\n\n\n    if (!icp->nr_servers) {\n\n        error_setg(errp, \"Number of servers needs to be greater 0\");\n\n        return;\n\n    }\n\n\n\n    /* Registration of global state belongs into realize */\n\n    spapr_rtas_register(\"ibm,set-xive\", rtas_set_xive);\n\n    spapr_rtas_register(\"ibm,get-xive\", rtas_get_xive);\n\n    spapr_rtas_register(\"ibm,int-off\", rtas_int_off);\n\n    spapr_rtas_register(\"ibm,int-on\", rtas_int_on);\n\n\n\n    spapr_register_hypercall(H_CPPR, h_cppr);\n\n    spapr_register_hypercall(H_IPI, h_ipi);\n\n    spapr_register_hypercall(H_XIRR, h_xirr);\n\n    spapr_register_hypercall(H_XIRR_X, h_xirr_x);\n\n    spapr_register_hypercall(H_EOI, h_eoi);\n\n    spapr_register_hypercall(H_IPOLL, h_ipoll);\n\n\n\n    object_property_set_bool(OBJECT(icp->ics), true, \"realized\", &error);\n\n    if (error) {\n\n        error_propagate(errp, error);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < icp->nr_servers; i++) {\n\n        object_property_set_bool(OBJECT(&icp->ss[i]), true, \"realized\", &error);\n\n        if (error) {\n\n            error_propagate(errp, error);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 25686}
{"project": "qemu", "commit_id": "428c3ece97179557f2753071fb0ca97a03437267", "target": 0, "func": "static bool msi_is_masked(const PCIDevice *dev, unsigned int vector)\n\n{\n\n    uint16_t flags = pci_get_word(dev->config + msi_flags_off(dev));\n\n    uint32_t mask;\n\n    assert(vector < PCI_MSI_VECTORS_MAX);\n\n\n\n    if (!(flags & PCI_MSI_FLAGS_MASKBIT)) {\n\n        return false;\n\n    }\n\n\n\n    mask = pci_get_long(dev->config +\n\n                        msi_mask_off(dev, flags & PCI_MSI_FLAGS_64BIT));\n\n    return mask & (1U << vector);\n\n}\n", "idx": 25706}
{"project": "qemu", "commit_id": "ba5e6bfa1aee29a8f72c5538c565dfb9889cf273", "target": 0, "func": "static void vfio_bar_quirk_teardown(VFIOPCIDevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    while (!QLIST_EMPTY(&bar->quirks)) {\n\n        VFIOQuirk *quirk = QLIST_FIRST(&bar->quirks);\n\n        memory_region_del_subregion(&bar->region.mem, &quirk->mem);\n\n        object_unparent(OBJECT(&quirk->mem));\n\n        QLIST_REMOVE(quirk, next);\n\n        g_free(quirk);\n\n    }\n\n}\n", "idx": 25713}
{"project": "qemu", "commit_id": "eaf944a43835399f12808aebd0d0a1db6249ed07", "target": 1, "func": "static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    const char *config;\n\n    uint64_t align;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    /* Read rules from config file or command line options */\n\n    config = qemu_opt_get(opts, \"config\");\n\n    ret = read_config(s, config, options, errp);\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Set initial state */\n\n    s->state = 1;\n\n\n\n    /* Open the backing file */\n\n    ret = bdrv_open_image(&bs->file, qemu_opt_get(opts, \"x-image\"), options, \"image\",\n\n                          flags, true, false, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    /* Set request alignment */\n\n    align = qemu_opt_get_size(opts, \"align\", bs->request_alignment);\n\n    if (align > 0 && align < INT_MAX && !(align & (align - 1))) {\n\n        bs->request_alignment = align;\n\n    } else {\n\n        error_setg(errp, \"Invalid alignment\");\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_opts_del(opts);\n\n    return ret;\n\n}\n", "idx": 25714}
{"project": "qemu", "commit_id": "baf35cb90204d75404892aa4e52628ae7a00669b", "target": 1, "func": "void qemu_aio_init(void)\n\n{\n\n    struct sigaction act;\n\n\n\n    aio_initialized = 1;\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0; /* do not restart syscalls to interrupt select() */\n\n    act.sa_handler = aio_signal_handler;\n\n    sigaction(aio_sig_num, &act, NULL);\n\n\n\n#if defined(__GLIBC__) && defined(__linux__)\n\n    {\n\n        /* XXX: aio thread exit seems to hang on RedHat 9 and this init\n\n           seems to fix the problem. */\n\n        struct aioinit ai;\n\n        memset(&ai, 0, sizeof(ai));\n\n        ai.aio_threads = 1;\n\n        ai.aio_num = 1;\n\n        ai.aio_idle_time = 365 * 100000;\n\n        aio_init(&ai);\n\n    }\n\n#endif\n\n}\n", "idx": 25717}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_type_any(Visitor *v, const char *name, QObject **obj,\n\n                               Error **errp)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qmp_input_get_object(qiv, name, true, errp);\n\n\n\n    *obj = NULL;\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n\n\n    qobject_incref(qobj);\n\n    *obj = qobj;\n\n}\n", "idx": 25769}
{"project": "qemu", "commit_id": "9d7a4c6690ef9962a3b20034f65008f1ea15c1d6", "target": 1, "func": "void *g_try_malloc(size_t n_bytes)\n\n{\n\n    __coverity_negative_sink__(n_bytes);\n\n    return malloc(n_bytes == 0 ? 1 : n_bytes);\n\n}\n", "idx": 25775}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC(pred8x8l_vertical_add)(uint8_t *_pix, const int16_t *_block,\n\n                                         ptrdiff_t stride)\n\n{\n\n    int i;\n\n    pixel *pix = (pixel*)_pix;\n\n    const dctcoef *block = (const dctcoef*)_block;\n\n    stride >>= sizeof(pixel)-1;\n\n    pix -= stride;\n\n    for(i=0; i<8; i++){\n\n        pixel v = pix[0];\n\n        pix[1*stride]= v += block[0];\n\n        pix[2*stride]= v += block[8];\n\n        pix[3*stride]= v += block[16];\n\n        pix[4*stride]= v += block[24];\n\n        pix[5*stride]= v += block[32];\n\n        pix[6*stride]= v += block[40];\n\n        pix[7*stride]= v += block[48];\n\n        pix[8*stride]= v +  block[56];\n\n        pix++;\n\n        block++;\n\n    }\n\n}\n", "idx": 25777}
{"project": "FFmpeg", "commit_id": "c37de519202ac2e5f20141673081b0e6b57ab983", "target": 1, "func": "int ff_vorbis_len2vlc(uint8_t *bits, uint32_t *codes, unsigned num)\n\n{\n\n    uint32_t exit_at_level[33] = { 404 };\n\n    unsigned i, j, p, code;\n\n\n\n    for (p = 0; (bits[p] == 0) && (p < num); ++p)\n\n        ;\n\n    if (p == num)\n\n        return 0;\n\n\n\n    codes[p] = 0;\n\n    if (bits[p] > 32)\n\n        return AVERROR_INVALIDDATA;\n\n    for (i = 0; i < bits[p]; ++i)\n\n        exit_at_level[i+1] = 1 << i;\n\n\n\n    ++p;\n\n\n\n    for (i = p; (bits[i] == 0) && (i < num); ++i)\n\n        ;\n\n    if (i == num)\n\n        return 0;\n\n\n\n    for (; p < num; ++p) {\n\n        if (bits[p] > 32)\n\n             return AVERROR_INVALIDDATA;\n\n        if (bits[p] == 0)\n\n             continue;\n\n        // find corresponding exit(node which the tree can grow further from)\n\n        for (i = bits[p]; i > 0; --i)\n\n            if (exit_at_level[i])\n\n                break;\n\n        if (!i) // overspecified tree\n\n             return AVERROR_INVALIDDATA;\n\n        code = exit_at_level[i];\n\n        exit_at_level[i] = 0;\n\n        // construct code (append 0s to end) and introduce new exits\n\n        for (j = i + 1 ;j <= bits[p]; ++j)\n\n            exit_at_level[j] = code + (1 << (j - 1));\n\n        codes[p] = code;\n\n    }\n\n\n\n    //no exits should be left (underspecified tree - ie. unused valid vlcs - not allowed by SPEC)\n\n    for (p = 1; p < 33; p++)\n\n        if (exit_at_level[p])\n\n            return AVERROR_INVALIDDATA;\n\n\n\n    return 0;\n\n}\n", "idx": 25782}
{"project": "qemu", "commit_id": "17eb587aeb492fe68f8130b027154ff0921fc0b4", "target": 1, "func": "static int tftp_session_allocate(Slirp *slirp, struct sockaddr_storage *srcsas,\n\n                                 struct tftp_t *tp)\n\n{\n\n  struct tftp_session *spt;\n\n  int k;\n\n\n\n  for (k = 0; k < TFTP_SESSIONS_MAX; k++) {\n\n    spt = &slirp->tftp_sessions[k];\n\n\n\n    if (!tftp_session_in_use(spt))\n\n        goto found;\n\n\n\n    /* sessions time out after 5 inactive seconds */\n\n    if ((int)(curtime - spt->timestamp) > 5000) {\n\n        tftp_session_terminate(spt);\n\n        goto found;\n\n    }\n\n  }\n\n\n\n  return -1;\n\n\n\n found:\n\n  memset(spt, 0, sizeof(*spt));\n\n  spt->client_addr = *srcsas;\n\n  spt->fd = -1;\n\n  spt->block_size = 512;\n\n  spt->client_port = tp->udp.uh_sport;\n\n  spt->slirp = slirp;\n\n\n\n  tftp_session_update(spt);\n\n\n\n  return k;\n\n}\n", "idx": 25785}
{"project": "qemu", "commit_id": "e53f27b9d9df73461308618151fa6e6392aebd85", "target": 1, "func": "static int tcp_get_msgfd(CharDriverState *chr)\n\n{\n\n    TCPCharDriver *s = chr->opaque;\n\n\n\n    return s->msgfd;\n\n}\n", "idx": 25839}
{"project": "FFmpeg", "commit_id": "dae7ff04160901a30a35af05f2f149b289c4f0b1", "target": 1, "func": "static void decode_cdlms(WmallDecodeCtx *s)\n\n{\n\n    int c, i;\n\n    int cdlms_send_coef = get_bits1(&s->gb);\n\n\n\n    for(c = 0; c < s->num_channels; c++) {\n\n\ts->cdlms_ttl[c] = get_bits(&s->gb, 3) + 1;\n\n\tfor(i = 0; i < s->cdlms_ttl[c]; i++) {\n\n\t    s->cdlms[c][i].order = (get_bits(&s->gb, 7) + 1) * 8;\n\n\t}\n\n\n\n\tfor(i = 0; i < s->cdlms_ttl[c]; i++) {\n\n\t    s->cdlms[c][i].scaling = get_bits(&s->gb, 4);\n\n\t}\n\n\n\n\tif(cdlms_send_coef) {\n\n\t    for(i = 0; i < s->cdlms_ttl[c]; i++) {\n\n\t\tint cbits, shift_l, shift_r, j;\n\n\t\tcbits = av_log2(s->cdlms[c][i].order);\n\n\t\tif(1 << cbits < s->cdlms[c][i].order)\n\n\t\t    cbits++;\n\n\t\ts->cdlms[c][i].coefsend = get_bits(&s->gb, cbits) + 1;\n\n\n\n\t\tcbits = av_log2(s->cdlms[c][i].scaling + 1);\n\n\t\tif(1 << cbits < s->cdlms[c][i].scaling + 1)\n\n\t\t    cbits++;\n\n\n\n\t\ts->cdlms[c][i].bitsend = get_bits(&s->gb, cbits) + 2;\n\n\t\tshift_l = 32 - s->cdlms[c][i].bitsend;\n\n\t\tshift_r = 32 - 2 - s->cdlms[c][i].scaling;\n\n\t\tfor(j = 0; j < s->cdlms[c][i].coefsend; j++) {\n\n\t\t    s->cdlms[c][i].coefs[j] =\n\n\t\t\t(get_bits(&s->gb, s->cdlms[c][i].bitsend) << shift_l) >> shift_r;\n\n\t\t}\n\n\t    }\n\n\t}\n\n    }\n\n}\n", "idx": 25856}
{"project": "FFmpeg", "commit_id": "44f1698a3824836d32708ae93e78ac1f2310a07e", "target": 1, "func": "static void imdct12(int *out, int *in)\n\n{\n\n    int in0, in1, in2, in3, in4, in5, t1, t2;\n\n    in0= in[0*3]<<5;\n\n    in1= (in[1*3] + in[0*3])<<5;\n\n    in2= (in[2*3] + in[1*3])<<5;\n\n    in3= (in[3*3] + in[2*3])<<5;\n\n    in4= (in[4*3] + in[3*3])<<5;\n\n    in5= (in[5*3] + in[4*3])<<5;\n\n    in5 += in3;\n\n    in3 += in1;\n\n\n\n    in2= MULH(2*in2, C3);\n\n    in3= MULH(2*in3, C3);\n\n    \n\n    t1 = in0 - in4;\n\n    t2 = MULL(in1 - in5, icos36[4]);\n\n\n\n    out[ 7]= \n\n    out[10]= t1 + t2;\n\n    out[ 1]=\n\n    out[ 4]= t1 - t2;\n\n\n\n    in0 += in4>>1;\n\n    in4 = in0 + in2;\n\n    in1 += in5>>1;\n\n    in5 = MULL(in1 + in3, icos36[1]);    \n\n    out[ 8]= \n\n    out[ 9]= in4 + in5;\n\n    out[ 2]=\n\n    out[ 3]= in4 - in5;\n\n    \n\n    in0 -= in2;\n\n    in1 = MULL(in1 - in3, icos36[7]);\n\n    out[ 0]=\n\n    out[ 5]= in0 - in1;\n\n    out[ 6]=\n\n    out[11]= in0 + in1;    \n\n}\n", "idx": 25889}
{"project": "qemu", "commit_id": "0e3b800e71cb7759d099eabbd8ad4c4fe848e381", "target": 1, "func": "static void lan9118_eeprom_cmd(lan9118_state *s, int cmd, int addr)\n\n{\n\n    s->e2p_cmd = (s->e2p_cmd & 0x10) | (cmd << 28) | addr;\n\n    switch (cmd) {\n\n    case 0:\n\n        s->e2p_data = s->eeprom[addr];\n\n        DPRINTF(\"EEPROM Read %d = 0x%02x\\n\", addr, s->e2p_data);\n\n\n    case 1:\n\n        s->eeprom_writable = 0;\n\n        DPRINTF(\"EEPROM Write Disable\\n\");\n\n\n    case 2: /* EWEN */\n\n        s->eeprom_writable = 1;\n\n        DPRINTF(\"EEPROM Write Enable\\n\");\n\n\n    case 3: /* WRITE */\n\n        if (s->eeprom_writable) {\n\n            s->eeprom[addr] &= s->e2p_data;\n\n            DPRINTF(\"EEPROM Write %d = 0x%02x\\n\", addr, s->e2p_data);\n\n        } else {\n\n            DPRINTF(\"EEPROM Write %d (ignored)\\n\", addr);\n\n        }\n\n\n    case 4: /* WRAL */\n\n        if (s->eeprom_writable) {\n\n            for (addr = 0; addr < 128; addr++) {\n\n                s->eeprom[addr] &= s->e2p_data;\n\n            }\n\n            DPRINTF(\"EEPROM Write All 0x%02x\\n\", s->e2p_data);\n\n        } else {\n\n            DPRINTF(\"EEPROM Write All (ignored)\\n\");\n\n        }\n\n\n    case 5: /* ERASE */\n\n        if (s->eeprom_writable) {\n\n            s->eeprom[addr] = 0xff;\n\n            DPRINTF(\"EEPROM Erase %d\\n\", addr);\n\n        } else {\n\n            DPRINTF(\"EEPROM Erase %d (ignored)\\n\", addr);\n\n        }\n\n\n    case 6: /* ERAL */\n\n        if (s->eeprom_writable) {\n\n            memset(s->eeprom, 0xff, 128);\n\n            DPRINTF(\"EEPROM Erase All\\n\");\n\n        } else {\n\n            DPRINTF(\"EEPROM Erase All (ignored)\\n\");\n\n        }\n\n\n    case 7: /* RELOAD */\n\n        lan9118_reload_eeprom(s);\n\n\n    }\n\n}", "idx": 25913}
{"project": "qemu", "commit_id": "74b4c74d5efb0a489bdf0acc5b5d0197167e7649", "target": 0, "func": "static void sigp_store_status_at_address(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    SigpInfo *si = arg.host_ptr;\n\n    uint32_t address = si->param & 0x7ffffe00u;\n\n\n\n    /* cpu has to be stopped */\n\n    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {\n\n        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);\n\n        return;\n\n    }\n\n\n\n    cpu_synchronize_state(cs);\n\n\n\n    if (s390_store_status(cpu, address, false)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n", "idx": 25921}
{"project": "qemu", "commit_id": "791230d8bbd5c09d80845755a54074cd2d8b5a22", "target": 1, "func": "int qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n                          BdrvCheckMode fix)\n{\n    BDRVQcowState *s = bs->opaque;\n    BdrvCheckResult pre_compare_res;\n    int64_t size, highest_cluster, nb_clusters;\n    uint16_t *refcount_table = NULL;\n    bool rebuild = false;\n    int ret;\n    size = bdrv_getlength(bs->file);\n    if (size < 0) {\n        res->check_errors++;\n        return size;\n    nb_clusters = size_to_clusters(s, size);\n    if (nb_clusters > INT_MAX) {\n        res->check_errors++;\n        return -EFBIG;\n    res->bfi.total_clusters =\n        size_to_clusters(s, bs->total_sectors * BDRV_SECTOR_SIZE);\n    ret = calculate_refcounts(bs, res, fix, &rebuild, &refcount_table,\n    /* In case we don't need to rebuild the refcount structure (but want to fix\n     * something), this function is immediately called again, in which case the\n     * result should be ignored */\n    pre_compare_res = *res;\n    compare_refcounts(bs, res, 0, &rebuild, &highest_cluster, refcount_table,\n                      nb_clusters);\n    if (rebuild && (fix & BDRV_FIX_ERRORS)) {\n        fprintf(stderr, \"Rebuilding refcount structure\\n\");\n        ret = rebuild_refcount_structure(bs, res, &refcount_table,\n    } else if (fix) {\n            fprintf(stderr, \"ERROR need to rebuild refcount structures\\n\");\n            res->check_errors++;\n            ret = -EIO;\n        if (res->leaks || res->corruptions) {\n            *res = pre_compare_res;\n            compare_refcounts(bs, res, fix, &rebuild, &highest_cluster,\n                              refcount_table, nb_clusters);\n    /* check OFLAG_COPIED */\n    ret = check_oflag_copied(bs, res, fix);\n    res->image_end_offset = (highest_cluster + 1) * s->cluster_size;\n    ret = 0;\nfail:\n    g_free(refcount_table);\n    return ret;", "idx": 25944}
{"project": "qemu", "commit_id": "97225170f6ee6d0ad8653916c7a5e4508cbffc18", "target": 1, "func": "static void pmac_ide_atapi_transfer_cb(void *opaque, int ret)\n\n{\n\n    DBDMA_io *io = opaque;\n\n    MACIOIDEState *m = io->opaque;\n\n    IDEState *s = idebus_active_if(&m->bus);\n\n    int64_t offset;\n\n\n\n    MACIO_DPRINTF(\"pmac_ide_atapi_transfer_cb\\n\");\n\n\n\n    if (ret < 0) {\n\n        MACIO_DPRINTF(\"DMA error: %d\\n\", ret);\n\n        ide_atapi_io_error(s, ret);\n\n        goto done;\n\n    }\n\n\n\n    if (!m->dma_active) {\n\n        MACIO_DPRINTF(\"waiting for data (%#x - %#x - %x)\\n\",\n\n                      s->nsector, io->len, s->status);\n\n        /* data not ready yet, wait for the channel to get restarted */\n\n        io->processing = false;\n\n        return;\n\n    }\n\n\n\n    if (s->io_buffer_size <= 0) {\n\n        MACIO_DPRINTF(\"End of IDE transfer\\n\");\n\n        ide_atapi_cmd_ok(s);\n\n        m->dma_active = false;\n\n        goto done;\n\n    }\n\n\n\n    if (io->len == 0) {\n\n        MACIO_DPRINTF(\"End of DMA transfer\\n\");\n\n        goto done;\n\n    }\n\n\n\n    if (s->lba == -1) {\n\n        /* Non-block ATAPI transfer - just copy to RAM */\n\n        s->io_buffer_size = MIN(s->io_buffer_size, io->len);\n\n        cpu_physical_memory_write(io->addr, s->io_buffer, s->io_buffer_size);\n\n        ide_atapi_cmd_ok(s);\n\n        m->dma_active = false;\n\n        goto done;\n\n    }\n\n\n\n    /* Calculate current offset */\n\n    offset = (int64_t)(s->lba << 11) + s->io_buffer_index;\n\n\n\n    pmac_dma_read(s->blk, offset, io->len, pmac_ide_atapi_transfer_cb, io);\n\n    return;\n\n\n\ndone:\n\n    if (ret < 0) {\n\n        block_acct_failed(blk_get_stats(s->blk), &s->acct);\n\n    } else {\n\n        block_acct_done(blk_get_stats(s->blk), &s->acct);\n\n    }\n\n    io->dma_end(opaque);\n\n}\n", "idx": 25951}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static void qemu_chr_parse_spice_port(QemuOpts *opts, ChardevBackend *backend,\n\n                                      Error **errp)\n\n{\n\n    const char *name = qemu_opt_get(opts, \"name\");\n\n    ChardevSpicePort *spiceport;\n\n\n\n    if (name == NULL) {\n\n        error_setg(errp, \"chardev: spice port: no name given\");\n\n        return;\n\n    }\n\n    spiceport = backend->u.spiceport = g_new0(ChardevSpicePort, 1);\n\n    qemu_chr_parse_common(opts, qapi_ChardevSpicePort_base(spiceport));\n\n    spiceport->fqdn = g_strdup(name);\n\n}\n", "idx": 25962}
{"project": "qemu", "commit_id": "4c8d0d27676778febad3802a95218d5ceaca171e", "target": 0, "func": "void qemu_fd_register(int fd)\n\n{\n\n    WSAEventSelect(fd, qemu_event_handle, FD_READ | FD_ACCEPT | FD_CLOSE |\n\n                   FD_CONNECT | FD_WRITE | FD_OOB);\n\n}\n", "idx": 25975}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "static struct pxa2xx_i2s_s *pxa2xx_i2s_init(target_phys_addr_t base,\n\n                qemu_irq irq, struct pxa2xx_dma_state_s *dma)\n\n{\n\n    int iomemtype;\n\n    struct pxa2xx_i2s_s *s = (struct pxa2xx_i2s_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_i2s_s));\n\n\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->data_req = pxa2xx_i2s_data_req;\n\n\n\n    pxa2xx_i2s_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_i2s_readfn,\n\n                    pxa2xx_i2s_writefn, s);\n\n    cpu_register_physical_memory(s->base & 0xfff00000, 0xfffff, iomemtype);\n\n\n\n    register_savevm(\"pxa2xx_i2s\", base, 0,\n\n                    pxa2xx_i2s_save, pxa2xx_i2s_load, s);\n\n\n\n    return s;\n\n}\n", "idx": 25980}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void perf_nesting(void)\n\n{\n\n    unsigned int i, maxcycles, maxnesting;\n\n    double duration;\n\n\n\n    maxcycles = 10000;\n\n    maxnesting = 1000;\n\n    Coroutine *root;\n\n\n\n    g_test_timer_start();\n\n    for (i = 0; i < maxcycles; i++) {\n\n        NestData nd = {\n\n            .n_enter  = 0,\n\n            .n_return = 0,\n\n            .max      = maxnesting,\n\n        };\n\n        root = qemu_coroutine_create(nest);\n\n        qemu_coroutine_enter(root, &nd);\n\n    }\n\n    duration = g_test_timer_elapsed();\n\n\n\n    g_test_message(\"Nesting %u iterations of %u depth each: %f s\\n\",\n\n        maxcycles, maxnesting, duration);\n\n}\n", "idx": 25982}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "void hpet_init(qemu_irq *irq) {\n\n    int i, iomemtype;\n\n    HPETState *s;\n\n\n\n    DPRINTF (\"hpet_init\\n\");\n\n\n\n    s = qemu_mallocz(sizeof(HPETState));\n\n    hpet_statep = s;\n\n    s->irqs = irq;\n\n    for (i=0; i<HPET_NUM_TIMERS; i++) {\n\n        HPETTimer *timer = &s->timer[i];\n\n        timer->qemu_timer = qemu_new_timer(vm_clock, hpet_timer, timer);\n\n    }\n\n    vmstate_register(-1, &vmstate_hpet, s);\n\n    qemu_register_reset(hpet_reset, s);\n\n    /* HPET Area */\n\n    iomemtype = cpu_register_io_memory(hpet_ram_read,\n\n                                       hpet_ram_write, s);\n\n    cpu_register_physical_memory(HPET_BASE, 0x400, iomemtype);\n\n}\n", "idx": 25986}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void slavio_serial_ms_kbd_init(target_phys_addr_t base, qemu_irq irq,\n\n                               int disabled, int clock, int it_shift)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"escc\");\n\n    qdev_prop_set_uint32(dev, \"disabled\", disabled);\n\n    qdev_prop_set_uint32(dev, \"frequency\", clock);\n\n    qdev_prop_set_uint32(dev, \"it_shift\", it_shift);\n\n    qdev_prop_set_chr(dev, \"chrB\", NULL);\n\n    qdev_prop_set_chr(dev, \"chrA\", NULL);\n\n    qdev_prop_set_uint32(dev, \"chnBtype\", mouse);\n\n    qdev_prop_set_uint32(dev, \"chnAtype\", kbd);\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_connect_irq(s, 1, irq);\n\n    sysbus_mmio_map(s, 0, base);\n\n}\n", "idx": 26007}
{"project": "qemu", "commit_id": "9eeb8306d56e8fd831bbbac6e3cfe69a40312a33", "target": 0, "func": "abi_long do_sigaltstack(abi_ulong uss_addr, abi_ulong uoss_addr, abi_ulong sp)\n\n{\n\n    int ret;\n\n    struct target_sigaltstack oss;\n\n\n\n    /* XXX: test errors */\n\n    if(uoss_addr)\n\n    {\n\n        __put_user(target_sigaltstack_used.ss_sp, &oss.ss_sp);\n\n        __put_user(target_sigaltstack_used.ss_size, &oss.ss_size);\n\n        __put_user(sas_ss_flags(sp), &oss.ss_flags);\n\n    }\n\n\n\n    if(uss_addr)\n\n    {\n\n        struct target_sigaltstack *uss;\n\n        struct target_sigaltstack ss;\n\n\n\n\tret = -TARGET_EFAULT;\n\n        if (!lock_user_struct(VERIFY_READ, uss, uss_addr, 1)\n\n\t    || __get_user(ss.ss_sp, &uss->ss_sp)\n\n\t    || __get_user(ss.ss_size, &uss->ss_size)\n\n\t    || __get_user(ss.ss_flags, &uss->ss_flags))\n\n            goto out;\n\n        unlock_user_struct(uss, uss_addr, 0);\n\n\n\n\tret = -TARGET_EPERM;\n\n\tif (on_sig_stack(sp))\n\n            goto out;\n\n\n\n\tret = -TARGET_EINVAL;\n\n\tif (ss.ss_flags != TARGET_SS_DISABLE\n\n            && ss.ss_flags != TARGET_SS_ONSTACK\n\n            && ss.ss_flags != 0)\n\n            goto out;\n\n\n\n\tif (ss.ss_flags == TARGET_SS_DISABLE) {\n\n            ss.ss_size = 0;\n\n            ss.ss_sp = 0;\n\n\t} else {\n\n            ret = -TARGET_ENOMEM;\n\n            if (ss.ss_size < MINSIGSTKSZ)\n\n                goto out;\n\n\t}\n\n\n\n        target_sigaltstack_used.ss_sp = ss.ss_sp;\n\n        target_sigaltstack_used.ss_size = ss.ss_size;\n\n    }\n\n\n\n    if (uoss_addr) {\n\n        ret = -TARGET_EFAULT;\n\n        if (copy_to_user(uoss_addr, &oss, sizeof(oss)))\n\n            goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    return ret;\n\n}\n", "idx": 26027}
{"project": "FFmpeg", "commit_id": "d0d8a9b1384ba3cd465d6ef3439f3979d4518b4b", "target": 1, "func": "void ff_mov_close_hinting(MOVTrack *track) {\n\n    AVFormatContext* rtp_ctx = track->rtp_ctx;\n\n    uint8_t *ptr;\n\n\n\n    av_freep(&track->enc);\n\n    sample_queue_free(&track->sample_queue);\n\n    if (!rtp_ctx)\n\n        return;\n\n    if (rtp_ctx->pb) {\n\n        av_write_trailer(rtp_ctx);\n\n        url_close_dyn_buf(rtp_ctx->pb, &ptr);\n\n        av_free(ptr);\n\n    }\n\n    av_metadata_free(&rtp_ctx->streams[0]->metadata);\n\n    av_metadata_free(&rtp_ctx->metadata);\n\n\n    av_free(rtp_ctx->streams[0]);\n\n    av_freep(&rtp_ctx);\n\n}", "idx": 26037}
{"project": "qemu", "commit_id": "a1abf40d6be2fc4b40d90ae3b46442f4a671776b", "target": 1, "func": "void laio_cleanup(void *s_)\n{\n    struct qemu_laio_state *s = s_;\n    event_notifier_cleanup(&s->e);\n    g_free(s);", "idx": 26049}
{"project": "qemu", "commit_id": "7bb5d6ade6d8afbcad72a871f712370ffae457c6", "target": 0, "func": "static void pc_dimm_init(Object *obj)\n\n{\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n\n\n    object_property_add(obj, PC_DIMM_SIZE_PROP, \"int\", pc_dimm_get_size,\n\n                        NULL, NULL, NULL, &error_abort);\n\n    object_property_add_link(obj, PC_DIMM_MEMDEV_PROP, TYPE_MEMORY_BACKEND,\n\n                             (Object **)&dimm->hostmem,\n\n                             qdev_prop_allow_set_link_before_realize,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE,\n\n                             &error_abort);\n\n}\n", "idx": 26118}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "static always_inline int find_pte (CPUState *env, mmu_ctx_t *ctx,\n\n                                   int h, int rw)\n\n{\n\n#if defined(TARGET_PPC64)\n\n    if (env->mmu_model == POWERPC_MMU_64B)\n\n        return find_pte64(ctx, h, rw);\n\n#endif\n\n\n\n    return find_pte32(ctx, h, rw);\n\n}\n", "idx": 26122}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "static void tcp_chr_accept(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    TCPCharDriver *s = chr->opaque;\n\n    struct sockaddr_in saddr;\n\n#ifndef _WIN32\n\n    struct sockaddr_un uaddr;\n\n#endif\n\n    struct sockaddr *addr;\n\n    socklen_t len;\n\n    int fd;\n\n\n\n    for(;;) {\n\n#ifndef _WIN32\n\n\tif (s->is_unix) {\n\n\t    len = sizeof(uaddr);\n\n\t    addr = (struct sockaddr *)&uaddr;\n\n\t} else\n\n#endif\n\n\t{\n\n\t    len = sizeof(saddr);\n\n\t    addr = (struct sockaddr *)&saddr;\n\n\t}\n\n        fd = accept(s->listen_fd, addr, &len);\n\n        if (fd < 0 && errno != EINTR) {\n\n            return;\n\n        } else if (fd >= 0) {\n\n            if (s->do_telnetopt)\n\n                tcp_chr_telnet_init(fd);\n\n            break;\n\n        }\n\n    }\n\n    socket_set_nonblock(fd);\n\n    if (s->do_nodelay)\n\n        socket_set_nodelay(fd);\n\n    s->fd = fd;\n\n    qemu_set_fd_handler(s->listen_fd, NULL, NULL, NULL);\n\n    tcp_chr_connect(chr);\n\n}\n", "idx": 26141}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_native_list_int8(TestOutputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_S8);\n\n}\n", "idx": 26149}
{"project": "FFmpeg", "commit_id": "a4d70941cd4a82f7db9fbaa2148d60ce550e7611", "target": 1, "func": "static void start_children(FFStream *feed)\n{\n    if (no_launch)\n        return;\n    for (; feed; feed = feed->next) {\n        if (feed->child_argv && !feed->pid) {\n            feed->pid_start = time(0);\n            feed->pid = fork();\n            if (feed->pid < 0) {\n                fprintf(stderr, \"Unable to create children\\n\");\n                exit(1);\n            }\n            if (!feed->pid) {\n                /* In child */\n                char pathname[1024];\n                char *slash;\n                int i;\n                for (i = 3; i < 256; i++) {\n                    close(i);\n                }\n                if (!ffserver_debug) {\n                    i = open(\"/dev/null\", O_RDWR);\n                    if (i)\n                        dup2(i, 0);\n                    dup2(i, 1);\n                    dup2(i, 2);\n                    if (i)\n                        close(i);\n                }\n                pstrcpy(pathname, sizeof(pathname), my_program_name);\n                slash = strrchr(pathname, '/');\n                if (!slash) {\n                    slash = pathname;\n                } else {\n                    slash++;\n                }\n                strcpy(slash, \"ffmpeg\");\n                /* This is needed to make relative pathnames work */\n                chdir(my_program_dir);\n                execvp(pathname, feed->child_argv);\n                _exit(1);\n            }\n        }\n    }\n}", "idx": 26174}
{"project": "FFmpeg", "commit_id": "a4fd95b5d511384ed3ce388d8d20a16b1c4c0530", "target": 0, "func": "int ff_h264_check_intra_pred_mode(H264Context *h, int mode){\n\n    MpegEncContext * const s = &h->s;\n\n    static const int8_t top [7]= {LEFT_DC_PRED8x8, 1,-1,-1};\n\n    static const int8_t left[7]= { TOP_DC_PRED8x8,-1, 2,-1,DC_128_PRED8x8};\n\n\n\n    if(mode > 6U) {\n\n        av_log(h->s.avctx, AV_LOG_ERROR, \"out of range intra chroma pred mode at %d %d\\n\", s->mb_x, s->mb_y);\n\n        return -1;\n\n    }\n\n\n\n    if(!(h->top_samples_available&0x8000)){\n\n        mode= top[ mode ];\n\n        if(mode<0){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"top block unavailable for requested intra mode at %d %d\\n\", s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if((h->left_samples_available&0x8080) != 0x8080){\n\n        mode= left[ mode ];\n\n        if(h->left_samples_available&0x8080){ //mad cow disease mode, aka MBAFF + constrained_intra_pred\n\n            mode= ALZHEIMER_DC_L0T_PRED8x8 + (!(h->left_samples_available&0x8000)) + 2*(mode == DC_128_PRED8x8);\n\n        }\n\n        if(mode<0){\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"left block unavailable for requested intra mode at %d %d\\n\", s->mb_x, s->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return mode;\n\n}\n", "idx": 26180}
{"project": "qemu", "commit_id": "f186d64d8fda4bb22c15beb8e45b7814fbd8b51e", "target": 0, "func": "void replay_finish_event(void)\n\n{\n\n    replay_has_unread_data = 0;\n\n    replay_fetch_data_kind();\n\n}\n", "idx": 26199}
{"project": "qemu", "commit_id": "b25b387fa5928e516cb2c9e7fde68e958bd7e50a", "target": 0, "func": "static int64_t coroutine_fn qcow2_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum, BlockDriverState **file)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t cluster_offset;\n\n    int index_in_cluster, ret;\n\n    unsigned int bytes;\n\n    int64_t status = 0;\n\n\n\n    bytes = MIN(INT_MAX, nb_sectors * BDRV_SECTOR_SIZE);\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_get_cluster_offset(bs, sector_num << 9, &bytes,\n\n                                   &cluster_offset);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    *pnum = bytes >> BDRV_SECTOR_BITS;\n\n\n\n    if (cluster_offset != 0 && ret != QCOW2_CLUSTER_COMPRESSED &&\n\n        !s->cipher) {\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        cluster_offset |= (index_in_cluster << BDRV_SECTOR_BITS);\n\n        *file = bs->file->bs;\n\n        status |= BDRV_BLOCK_OFFSET_VALID | cluster_offset;\n\n    }\n\n    if (ret == QCOW2_CLUSTER_ZERO_PLAIN || ret == QCOW2_CLUSTER_ZERO_ALLOC) {\n\n        status |= BDRV_BLOCK_ZERO;\n\n    } else if (ret != QCOW2_CLUSTER_UNALLOCATED) {\n\n        status |= BDRV_BLOCK_DATA;\n\n    }\n\n    return status;\n\n}\n", "idx": 26202}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    return truncate(rpath(ctx, path, buffer), size);\n\n}\n", "idx": 26223}
{"project": "qemu", "commit_id": "298a1665a2800f7264e483c2dd1f551574243a2f", "target": 0, "func": "static bool is_zero_sectors(BlockDriverState *bs, int64_t start,\n\n                            uint32_t count)\n\n{\n\n    int nr;\n\n    BlockDriverState *file;\n\n    int64_t res;\n\n\n\n    if (start + count > bs->total_sectors) {\n\n        count = bs->total_sectors - start;\n\n    }\n\n\n\n    if (!count) {\n\n        return true;\n\n    }\n\n    res = bdrv_get_block_status_above(bs, NULL, start, count,\n\n                                      &nr, &file);\n\n    return res >= 0 && (res & BDRV_BLOCK_ZERO) && nr == count;\n\n}\n", "idx": 26227}
{"project": "qemu", "commit_id": "5dd7a535b71a0f2f8e7af75c5d694174359ce323", "target": 1, "func": "static void iscsi_nop_timed_event(void *opaque)\n\n{\n\n    IscsiLun *iscsilun = opaque;\n\n\n\n    if (iscsi_get_nops_in_flight(iscsilun->iscsi) > MAX_NOP_FAILURES) {\n\n        error_report(\"iSCSI: NOP timeout. Reconnecting...\");\n\n        iscsi_reconnect(iscsilun->iscsi);\n\n    }\n\n\n\n    if (iscsi_nop_out_async(iscsilun->iscsi, NULL, NULL, 0, NULL) != 0) {\n\n        error_report(\"iSCSI: failed to sent NOP-Out. Disabling NOP messages.\");\n\n        return;\n\n    }\n\n\n\n    timer_mod(iscsilun->nop_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + NOP_INTERVAL);\n\n    iscsi_set_events(iscsilun);\n\n}\n", "idx": 26237}
{"project": "qemu", "commit_id": "1a28cac3161f8a85ee0256776068eaed2da025e5", "target": 0, "func": "void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (kvm_enabled()) {\n\n        qemu_mutex_lock(&qemu_fair_mutex);\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n        qemu_mutex_unlock(&qemu_fair_mutex);\n\n    } else\n\n        qemu_signal_lock(100);\n\n}\n", "idx": 26275}
{"project": "qemu", "commit_id": "83f7f32901c630f4fc01acd0d9082da466b17102", "target": 1, "func": "static bool is_special_wait_psw(CPUState *cs)\n\n{\n\n    /* signal quiesce */\n\n    return cs->kvm_run->psw_addr == 0xfffUL;\n\n}\n", "idx": 26296}
{"project": "qemu", "commit_id": "af60314291af3cabda18d27f928b0e0ff899cc76", "target": 1, "func": "static void vhost_commit(MemoryListener *listener)\n\n{\n\n}\n", "idx": 26331}
{"project": "qemu", "commit_id": "7a95434e0ca8a037fd8aa1a2e2461f92585eb77b", "target": 1, "func": "static struct dirent *local_readdir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    struct dirent *entry;\n\n\n\nagain:\n\n    entry = readdir(fs->dir.stream);\n\n    if (!entry) {\n\n        return NULL;\n\n    }\n\n\n\n    if (ctx->export_flags & V9FS_SM_MAPPED) {\n\n        entry->d_type = DT_UNKNOWN;\n\n    } else if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        if (!strcmp(entry->d_name, VIRTFS_META_DIR)) {\n\n            /* skp the meta data directory */\n\n            goto again;\n\n        }\n\n        entry->d_type = DT_UNKNOWN;\n\n    }\n\n\n\n    return entry;\n\n}\n", "idx": 26346}
{"project": "qemu", "commit_id": "49cffbc6079c27432b4635d5d03ce14a249d86e2", "target": 1, "func": "void virtio_blk_submit_multireq(BlockBackend *blk, MultiReqBuffer *mrb)\n\n{\n\n    int i = 0, start = 0, num_reqs = 0, niov = 0, nb_sectors = 0;\n\n    int max_xfer_len = 0;\n\n    int64_t sector_num = 0;\n\n\n\n    if (mrb->num_reqs == 1) {\n\n        submit_requests(blk, mrb, 0, 1, -1);\n\n        mrb->num_reqs = 0;\n\n        return;\n\n    }\n\n\n\n    max_xfer_len = blk_get_max_transfer_length(mrb->reqs[0]->dev->blk);\n\n    max_xfer_len = MIN_NON_ZERO(max_xfer_len, BDRV_REQUEST_MAX_SECTORS);\n\n\n\n    qsort(mrb->reqs, mrb->num_reqs, sizeof(*mrb->reqs),\n\n          &multireq_compare);\n\n\n\n    for (i = 0; i < mrb->num_reqs; i++) {\n\n        VirtIOBlockReq *req = mrb->reqs[i];\n\n        if (num_reqs > 0) {\n\n            bool merge = true;\n\n\n\n            /* merge would exceed maximum number of IOVs */\n\n            if (niov + req->qiov.niov > IOV_MAX) {\n\n                merge = false;\n\n            }\n\n\n\n            /* merge would exceed maximum transfer length of backend device */\n\n            if (req->qiov.size / BDRV_SECTOR_SIZE + nb_sectors > max_xfer_len) {\n\n                merge = false;\n\n            }\n\n\n\n            /* requests are not sequential */\n\n            if (sector_num + nb_sectors != req->sector_num) {\n\n                merge = false;\n\n            }\n\n\n\n            if (!merge) {\n\n                submit_requests(blk, mrb, start, num_reqs, niov);\n\n                num_reqs = 0;\n\n            }\n\n        }\n\n\n\n        if (num_reqs == 0) {\n\n            sector_num = req->sector_num;\n\n            nb_sectors = niov = 0;\n\n            start = i;\n\n        }\n\n\n\n        nb_sectors += req->qiov.size / BDRV_SECTOR_SIZE;\n\n        niov += req->qiov.niov;\n\n        num_reqs++;\n\n    }\n\n\n\n    submit_requests(blk, mrb, start, num_reqs, niov);\n\n    mrb->num_reqs = 0;\n\n}\n", "idx": 26368}
{"project": "qemu", "commit_id": "14cec170ea4724e6881ba2febb20e88a942e52d3", "target": 1, "func": "static int xen_pt_bar_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                               uint32_t *value, uint32_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint32_t valid_emu_mask = 0;\n\n    uint32_t bar_emu_mask = 0;\n\n    int index;\n\n\n\n    /* get BAR index */\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if (index < 0 || index >= PCI_NUM_REGIONS) {\n\n        XEN_PT_ERR(&s->dev, \"Internal error: Invalid BAR index [%d].\\n\", index);\n\n        return -1;\n\n    }\n\n\n\n    /* use fixed-up value from kernel sysfs */\n\n    *value = base_address_with_flags(&s->real_device.io_regions[index]);\n\n\n\n    /* set emulate mask depend on BAR flag */\n\n    switch (s->bases[index].bar_flag) {\n\n    case XEN_PT_BAR_FLAG_MEM:\n\n        bar_emu_mask = XEN_PT_BAR_MEM_EMU_MASK;\n\n        break;\n\n    case XEN_PT_BAR_FLAG_IO:\n\n        bar_emu_mask = XEN_PT_BAR_IO_EMU_MASK;\n\n        break;\n\n    case XEN_PT_BAR_FLAG_UPPER:\n\n        bar_emu_mask = XEN_PT_BAR_ALLF;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* emulate BAR */\n\n    valid_emu_mask = bar_emu_mask & valid_mask;\n\n    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 26372}
{"project": "FFmpeg", "commit_id": "db5604ac26f06be34030c8ae8040c19d549280f1", "target": 1, "func": "static av_cold int join_init(AVFilterContext *ctx)\n\n{\n\n    JoinContext *s = ctx->priv;\n\n    int ret, i;\n\n\n\n    if (!(s->channel_layout = av_get_channel_layout(s->channel_layout_str))) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Error parsing channel layout '%s'.\\n\",\n\n               s->channel_layout_str);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    s->nb_channels  = av_get_channel_layout_nb_channels(s->channel_layout);\n\n    s->channels     = av_mallocz_array(s->nb_channels, sizeof(*s->channels));\n\n    s->buffers      = av_mallocz_array(s->nb_channels, sizeof(*s->buffers));\n\n    s->input_frames = av_mallocz_array(s->inputs, sizeof(*s->input_frames));\n\n    if (!s->channels || !s->buffers|| !s->input_frames)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < s->nb_channels; i++) {\n\n        s->channels[i].out_channel = av_channel_layout_extract_channel(s->channel_layout, i);\n\n        s->channels[i].input       = -1;\n\n    }\n\n\n\n    if ((ret = parse_maps(ctx)) < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < s->inputs; i++) {\n\n        char name[32];\n\n        AVFilterPad pad = { 0 };\n\n\n\n        snprintf(name, sizeof(name), \"input%d\", i);\n\n        pad.type           = AVMEDIA_TYPE_AUDIO;\n\n        pad.name           = av_strdup(name);\n\n        if (!pad.name)\n\n            return AVERROR(ENOMEM);\n\n        pad.filter_frame   = filter_frame;\n\n\n\n        pad.needs_fifo = 1;\n\n\n\n        ff_insert_inpad(ctx, i, &pad);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26389}
{"project": "qemu", "commit_id": "cdd5cc12ba8cf0c068da319370bdd3ba45eaf7ac", "target": 0, "func": "static int virtio_net_can_receive(VLANClientState *vc)\n\n{\n\n    VirtIONet *n = vc->opaque;\n\n\n\n    return do_virtio_net_can_receive(n, VIRTIO_NET_MAX_BUFSIZE);\n\n}\n", "idx": 26394}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "static av_cold int v4l2_encode_init(AVCodecContext *avctx)\n\n{\n\n    V4L2m2mContext *s = avctx->priv_data;\n\n    V4L2Context *capture = &s->capture;\n\n    V4L2Context *output = &s->output;\n\n    int ret;\n\n\n\n    /* common settings output/capture */\n\n    output->height = capture->height = avctx->height;\n\n    output->width = capture->width = avctx->width;\n\n\n\n    /* output context */\n\n    output->av_codec_id = AV_CODEC_ID_RAWVIDEO;\n\n    output->av_pix_fmt = avctx->pix_fmt;\n\n\n\n    /* capture context */\n\n    capture->av_codec_id = avctx->codec_id;\n\n    capture->av_pix_fmt = AV_PIX_FMT_NONE;\n\n\n\n    ret = ff_v4l2_m2m_codec_init(avctx);\n\n    if (ret) {\n\n        av_log(avctx, AV_LOG_ERROR, \"can't configure encoder\\n\");\n\n        return ret;\n\n    }\n\n\n\n    return v4l2_prepare_encoder(s);\n\n}\n", "idx": 26414}
{"project": "FFmpeg", "commit_id": "4c7b023d56e09a78a587d036db1b64bf7c493b3d", "target": 0, "func": "static int nvdec_vp9_decode_slice(AVCodecContext *avctx, const uint8_t *buffer, uint32_t size)\n\n{\n\n    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;\n\n    void *tmp;\n\n\n\n    tmp = av_fast_realloc(ctx->slice_offsets, &ctx->slice_offsets_allocated,\n\n                          (ctx->nb_slices + 1) * sizeof(*ctx->slice_offsets));\n\n    if (!tmp)\n\n        return AVERROR(ENOMEM);\n\n    ctx->slice_offsets = tmp;\n\n\n\n    if (!ctx->bitstream)\n\n        ctx->bitstream = (uint8_t*)buffer;\n\n\n\n    ctx->slice_offsets[ctx->nb_slices] = buffer - ctx->bitstream;\n\n    ctx->bitstream_len += size;\n\n    ctx->nb_slices++;\n\n\n\n    return 0;\n\n}\n", "idx": 26423}
{"project": "qemu", "commit_id": "544a3731591f5d53e15f22de00ce5ac758d490b3", "target": 1, "func": "bool visit_start_union(Visitor *v, bool data_present, Error **errp)\n\n{\n\n    if (v->start_union) {\n\n        return v->start_union(v, data_present, errp);\n\n    }\n\n    return true;\n\n}\n", "idx": 26426}
{"project": "qemu", "commit_id": "062ba099e01ff1474be98c0a4f3da351efab5d9d", "target": 1, "func": "static bool arm_cpu_has_work(CPUState *cs)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n\n\n    return !cpu->powered_off\n\n        && cs->interrupt_request &\n\n        (CPU_INTERRUPT_FIQ | CPU_INTERRUPT_HARD\n\n         | CPU_INTERRUPT_VFIQ | CPU_INTERRUPT_VIRQ\n\n         | CPU_INTERRUPT_EXITTB);\n\n}\n", "idx": 26445}
{"project": "FFmpeg", "commit_id": "4cb6964244fd6c099383d8b7e99731e72cc844b9", "target": 0, "func": "static void int8x8_fmul_int32_c(float *dst, const int8_t *src, int scale)\n\n{\n\n    float fscale = scale / 16.0;\n\n    int i;\n\n    for (i = 0; i < 8; i++)\n\n        dst[i] = src[i] * fscale;\n\n}\n", "idx": 26459}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static inline void gen_movcf_d (DisasContext *ctx, int fs, int fd, int cc, int tf)\n\n{\n\n    int cond;\n\n    TCGv_i32 t0 = tcg_temp_new_i32();\n\n    TCGv_i64 fp0;\n\n    int l1 = gen_new_label();\n\n\n\n    if (tf)\n\n        cond = TCG_COND_EQ;\n\n    else\n\n        cond = TCG_COND_NE;\n\n\n\n    tcg_gen_andi_i32(t0, fpu_fcr31, 1 << get_fp_bit(cc));\n\n    tcg_gen_brcondi_i32(cond, t0, 0, l1);\n\n    tcg_temp_free_i32(t0);\n\n    fp0 = tcg_temp_new_i64();\n\n    gen_load_fpr64(ctx, fp0, fs);\n\n    gen_store_fpr64(ctx, fp0, fd);\n\n    tcg_temp_free_i64(fp0);\n\n    gen_set_label(l1);\n\n}\n", "idx": 26463}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "int kvm_irqchip_remove_irqfd(KVMState *s, int fd, int virq)\n\n{\n\n    return -ENOSYS;\n\n}\n", "idx": 26464}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static void noop_conv (st_sample_t *dst, const void *src,\n\n                       int samples, volume_t *vol)\n\n{\n\n    (void) src;\n\n    (void) dst;\n\n    (void) samples;\n\n    (void) vol;\n\n}\n", "idx": 26465}
{"project": "qemu", "commit_id": "81b23ef82cd1be29ca3d69ab7e98b5b5e55926ce", "target": 1, "func": "static int xen_pt_cmd_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,\n\n                               uint16_t *value, uint16_t valid_mask)\n\n{\n\n    XenPTRegInfo *reg = cfg_entry->reg;\n\n    uint16_t valid_emu_mask = 0;\n\n    uint16_t emu_mask = reg->emu_mask;\n\n\n\n    if (s->is_virtfn) {\n\n        emu_mask |= PCI_COMMAND_MEMORY;\n\n    }\n\n\n\n    /* emulate word register */\n\n    valid_emu_mask = emu_mask & valid_mask;\n\n    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);\n\n\n\n    return 0;\n\n}\n", "idx": 26509}
{"project": "qemu", "commit_id": "06b1297017415ae6a07a0e97ad7d8e90b2d95823", "target": 1, "func": "static int virtio_net_has_buffers(VirtIONet *n, int bufsize)\n\n{\n\n    if (virtio_queue_empty(n->rx_vq) ||\n\n        (n->mergeable_rx_bufs &&\n\n         !virtqueue_avail_bytes(n->rx_vq, bufsize, 0))) {\n\n        virtio_queue_set_notification(n->rx_vq, 1);\n\n        return 0;\n\n    }\n\n\n\n    virtio_queue_set_notification(n->rx_vq, 0);\n\n    return 1;\n\n}\n", "idx": 26516}
{"project": "FFmpeg", "commit_id": "697400eac07c0614f6b9f2e7615563982dbcbe4a", "target": 0, "func": "static int mov_read_chap(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    c->chapter_track = avio_rb32(pb);\n\n    return 0;\n\n}\n", "idx": 26521}
{"project": "qemu", "commit_id": "9561fda8d90e176bef598ba87c42a1bd6ad03ef7", "target": 1, "func": "static void qbus_initfn(Object *obj)\n\n{\n\n    BusState *bus = BUS(obj);\n\n\n\n    QTAILQ_INIT(&bus->children);\n\n    object_property_add_link(obj, QDEV_HOTPLUG_HANDLER_PROPERTY,\n\n                             TYPE_HOTPLUG_HANDLER,\n\n                             (Object **)&bus->hotplug_handler, NULL);\n\n    object_property_add_bool(obj, \"realized\",\n\n                             bus_get_realized, bus_set_realized, NULL);\n\n}\n", "idx": 26522}
{"project": "FFmpeg", "commit_id": "f863bee841670384fc46f4f99f511b27eb89a216", "target": 0, "func": "static void final(Real144_internal *glob, short *i1, short *i2, void *out,\n\n                  int *statbuf, int len)\n\n{\n\n    int x, sum;\n\n    int buffer[10];\n\n    short *ptr;\n\n    short *ptr2;\n\n\n\n    memcpy(glob->work, statbuf,20);\n\n    memcpy(glob->work + 10, i2, len * 2);\n\n\n\n    buffer[9] = i1[0];\n\n    buffer[8] = i1[1];\n\n    buffer[7] = i1[2];\n\n    buffer[6] = i1[3];\n\n    buffer[5] = i1[4];\n\n    buffer[4] = i1[5];\n\n    buffer[3] = i1[6];\n\n    buffer[2] = i1[7];\n\n    buffer[1] = i1[8];\n\n    buffer[0] = i1[9];\n\n\n\n    ptr2 = (ptr = glob->work) + len;\n\n\n\n    while (ptr < ptr2) {\n\n        for(sum=0, x=0; x<=9; x++)\n\n            sum += buffer[x] * (ptr[x]);\n\n\n\n        sum = sum >> 12;\n\n        x = ptr[10] - sum;\n\n\n\n        if (x<-32768 || x>32767) {\n\n            memset(out, 0, len * 2);\n\n            memset(statbuf, 0, 20);\n\n            return;\n\n        }\n\n\n\n        ptr[10] = x;\n\n        ptr++;\n\n    }\n\n    memcpy(out, ptr+10 - len, len * 2);\n\n    memcpy(statbuf, ptr, 20);\n\n}\n", "idx": 26525}
{"project": "qemu", "commit_id": "3af9187fc6caaf415ab9c0c6d92c9678f65cb17f", "target": 1, "func": "static ssize_t mipsnet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n\n{\n\n    MIPSnetState *s = qemu_get_nic_opaque(nc);\n\n\n\n    trace_mipsnet_receive(size);\n\n    if (!mipsnet_can_receive(nc))\n\n\n\n\n\n\n\n    s->busy = 1;\n\n\n\n    /* Just accept everything. */\n\n\n\n    /* Write packet data. */\n\n    memcpy(s->rx_buffer, buf, size);\n\n\n\n    s->rx_count = size;\n\n    s->rx_read = 0;\n\n\n\n    /* Now we can signal we have received something. */\n\n    s->intctl |= MIPSNET_INTCTL_RXDONE;\n\n    mipsnet_update_irq(s);\n\n\n\n    return size;\n", "idx": 26527}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static AVBufferRef *vaapi_encode_alloc_output_buffer(void *opaque,\n\n                                                     int size)\n\n{\n\n    AVCodecContext   *avctx = opaque;\n\n    VAAPIEncodeContext *ctx = avctx->priv_data;\n\n    VABufferID buffer_id;\n\n    VAStatus vas;\n\n    AVBufferRef *ref;\n\n\n\n    // The output buffer size is fixed, so it needs to be large enough\n\n    // to hold the largest possible compressed frame.  We assume here\n\n    // that the uncompressed frame plus some header data is an upper\n\n    // bound on that.\n\n    vas = vaCreateBuffer(ctx->hwctx->display, ctx->va_context,\n\n                         VAEncCodedBufferType,\n\n                         3 * ctx->aligned_width * ctx->aligned_height +\n\n                         (1 << 16), 1, 0, &buffer_id);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to create bitstream \"\n\n               \"output buffer: %d (%s).\\n\", vas, vaErrorStr(vas));\n\n        return NULL;\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_DEBUG, \"Allocated output buffer %#x\\n\", buffer_id);\n\n\n\n    ref = av_buffer_create((uint8_t*)(uintptr_t)buffer_id,\n\n                           sizeof(buffer_id),\n\n                           &vaapi_encode_free_output_buffer,\n\n                           avctx, AV_BUFFER_FLAG_READONLY);\n\n    if (!ref) {\n\n        vaDestroyBuffer(ctx->hwctx->display, buffer_id);\n\n        return NULL;\n\n    }\n\n\n\n    return ref;\n\n}\n", "idx": 26537}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_tipb_bridge_s *omap_tipb_bridge_init(\n\n    MemoryRegion *memory, target_phys_addr_t base,\n\n    qemu_irq abort_irq, omap_clk clk)\n\n{\n\n    struct omap_tipb_bridge_s *s = (struct omap_tipb_bridge_s *)\n\n            g_malloc0(sizeof(struct omap_tipb_bridge_s));\n\n\n\n    s->abort = abort_irq;\n\n    omap_tipb_bridge_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_tipb_bridge_ops, s,\n\n                          \"omap-tipb-bridge\", 0x100);\n\n    memory_region_add_subregion(memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 26566}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void thread_pool_submit(ThreadPool *pool, ThreadPoolFunc *func, void *arg)\n\n{\n\n    thread_pool_submit_aio(pool, func, arg, NULL, NULL);\n\n}\n", "idx": 26569}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_writev_vmstate(BlockDriverState *bs, QEMUIOVector *qiov, int64_t pos)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    } else if (drv->bdrv_save_vmstate) {\n\n        return drv->bdrv_save_vmstate(bs, qiov, pos);\n\n    } else if (bs->file) {\n\n        return bdrv_writev_vmstate(bs->file, qiov, pos);\n\n    }\n\n\n\n    return -ENOTSUP;\n\n}\n", "idx": 26573}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_statfs(FsContext *s, V9fsPath *fs_path, struct statfs *stbuf)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    return statfs(rpath(s, path, buffer), stbuf);\n\n}\n", "idx": 26576}
{"project": "FFmpeg", "commit_id": "5d20f19be25c973fe10d0d17db9245002585710d", "target": 1, "func": "static void init_multbl2(uint8_t tbl[1024], const int c[4],\n\n                         const uint8_t *log8, const uint8_t *alog8,\n\n                         const uint8_t *sbox)\n\n{\n\n    int i, j;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        int x = sbox[i >> 2];\n\n        if (x)\n\n            tbl[i] = alog8[log8[x] + log8[c[i & 3]]];\n\n    }\n\n#if !CONFIG_SMALL\n\n    for (j = 256; j < 1024; j++)\n\n        for (i = 0; i < 4; i++)\n\n            tbl[4*j + i] = tbl[4*j + ((i - 1) & 3) - 1024];\n\n#endif\n\n}\n", "idx": 26584}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static int kvm_get_msr(CPUState *env, struct kvm_msr_entry *msrs, int n)\n\n{\n\n    struct kvm_msrs *kmsrs = qemu_malloc(sizeof *kmsrs + n * sizeof *msrs);\n\n    int r;\n\n\n\n    kmsrs->nmsrs = n;\n\n    memcpy(kmsrs->entries, msrs, n * sizeof *msrs);\n\n    r = kvm_vcpu_ioctl(env, KVM_GET_MSRS, kmsrs);\n\n    memcpy(msrs, kmsrs->entries, n * sizeof *msrs);\n\n    free(kmsrs);\n\n    return r;\n\n}\n", "idx": 26600}
{"project": "qemu", "commit_id": "cfdf2c40577ed99bb19cdc05d0537e2808d77a78", "target": 0, "func": "static void do_balloon(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    int value = qdict_get_int(qdict, \"value\");\n\n    ram_addr_t target = value;\n\n    qemu_balloon(target << 20);\n\n}\n", "idx": 26606}
{"project": "qemu", "commit_id": "1d2acc3162d9c7772510c973f446353fbdd1f9a8", "target": 1, "func": "static void migrate_fd_cancel(MigrationState *s)\n{\n    int old_state ;\n    QEMUFile *f = migrate_get_current()->to_dst_file;\n    trace_migrate_fd_cancel();\n    if (s->rp_state.from_dst_file) {\n        /* shutdown the rp socket, so causing the rp thread to shutdown */\n        qemu_file_shutdown(s->rp_state.from_dst_file);\n    do {\n        old_state = s->state;\n        if (!migration_is_setup_or_active(old_state)) {\n            break;\n        migrate_set_state(&s->state, old_state, MIGRATION_STATUS_CANCELLING);\n    } while (s->state != MIGRATION_STATUS_CANCELLING);\n    /*\n     * If we're unlucky the migration code might be stuck somewhere in a\n     * send/write while the network has failed and is waiting to timeout;\n     * if we've got shutdown(2) available then we can force it to quit.\n     * The outgoing qemu file gets closed in migrate_fd_cleanup that is\n     * called in a bh, so there is no race against this cancel.\n     */\n    if (s->state == MIGRATION_STATUS_CANCELLING && f) {\n        qemu_file_shutdown(f);", "idx": 26619}
{"project": "FFmpeg", "commit_id": "bd737b5178f361a9b592691848f29a7a79603a7e", "target": 0, "func": "static int decode_init_thread_copy(AVCodecContext *avctx)\n\n{\n\n    H264Context *h = avctx->priv_data;\n\n    int ret;\n\n\n\n    if (!avctx->internal->is_copy)\n\n        return 0;\n\n    memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n\n    memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n\n\n\n    ret = h264_init_context(avctx, h);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    h->context_initialized = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 26629}
{"project": "qemu", "commit_id": "bf55b7afce53718ef96f4e6616da62c0ccac37dd", "target": 0, "func": "static IOMMUTLBEntry vtd_iommu_translate(MemoryRegion *iommu, hwaddr addr,\n\n                                         bool is_write)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu, VTDAddressSpace, iommu);\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    IOMMUTLBEntry ret = {\n\n        .target_as = &address_space_memory,\n\n        .iova = addr,\n\n        .translated_addr = 0,\n\n        .addr_mask = ~(hwaddr)0,\n\n        .perm = IOMMU_NONE,\n\n    };\n\n\n\n    if (!s->dmar_enabled) {\n\n        /* DMAR disabled, passthrough, use 4k-page*/\n\n        ret.iova = addr & VTD_PAGE_MASK_4K;\n\n        ret.translated_addr = addr & VTD_PAGE_MASK_4K;\n\n        ret.addr_mask = ~VTD_PAGE_MASK_4K;\n\n        ret.perm = IOMMU_RW;\n\n        return ret;\n\n    }\n\n\n\n    vtd_do_iommu_translate(vtd_as, vtd_as->bus, vtd_as->devfn, addr,\n\n                           is_write, &ret);\n\n    VTD_DPRINTF(MMU,\n\n                \"bus %\"PRIu8 \" slot %\"PRIu8 \" func %\"PRIu8 \" devfn %\"PRIu8\n\n                \" iova 0x%\"PRIx64 \" hpa 0x%\"PRIx64, pci_bus_num(vtd_as->bus),\n\n                VTD_PCI_SLOT(vtd_as->devfn), VTD_PCI_FUNC(vtd_as->devfn),\n\n                vtd_as->devfn, addr, ret.translated_addr);\n\n    return ret;\n\n}\n", "idx": 26646}
{"project": "qemu", "commit_id": "d185c094b404b4ff392b77d1244c0233da7d53bd", "target": 0, "func": "static gboolean io_watch_poll_check(GSource *source)\n\n{\n\n    IOWatchPoll *iwp = io_watch_poll_from_source(source);\n\n\n\n    if (iwp->max_size == 0) {\n\n        return FALSE;\n\n    }\n\n\n\n    return g_io_watch_funcs.check(source);\n\n}\n", "idx": 26647}
{"project": "qemu", "commit_id": "240f64b6dc3346d044d7beb7cc3a53668ce47384", "target": 0, "func": "void qmp_object_add(const char *type, const char *id,\n\n                    bool has_props, QObject *props, Error **errp)\n\n{\n\n    const QDict *pdict = NULL;\n\n    QmpInputVisitor *qiv;\n\n    Object *obj;\n\n\n\n    if (props) {\n\n        pdict = qobject_to_qdict(props);\n\n        if (!pdict) {\n\n            error_setg(errp, QERR_INVALID_PARAMETER_TYPE, \"props\", \"dict\");\n\n            return;\n\n        }\n\n    }\n\n\n\n    qiv = qmp_input_visitor_new(props, false);\n\n    obj = user_creatable_add_type(type, id, pdict,\n\n                                  qmp_input_get_visitor(qiv), errp);\n\n    qmp_input_visitor_cleanup(qiv);\n\n    if (obj) {\n\n        object_unref(obj);\n\n    }\n\n}\n", "idx": 26676}
{"project": "qemu", "commit_id": "f6bb84d53110398f4899c19dab4e0fe9908ec060", "target": 1, "func": "static inline TranslationBlock *tb_find(CPUState *cpu,\n\n                                        TranslationBlock *last_tb,\n\n                                        int tb_exit)\n\n{\n\n    CPUArchState *env = (CPUArchState *)cpu->env_ptr;\n\n    TranslationBlock *tb;\n\n    target_ulong cs_base, pc;\n\n    uint32_t flags;\n\n    bool acquired_tb_lock = false;\n\n\n\n    /* we record a subset of the CPU state. It will\n\n       always be the same before a given translated block\n\n       is executed. */\n\n    cpu_get_tb_cpu_state(env, &pc, &cs_base, &flags);\n\n    tb = atomic_rcu_read(&cpu->tb_jmp_cache[tb_jmp_cache_hash_func(pc)]);\n\n    if (unlikely(!tb || tb->pc != pc || tb->cs_base != cs_base ||\n\n                 tb->flags != flags ||\n\n                 tb->trace_vcpu_dstate != *cpu->trace_dstate)) {\n\n        tb = tb_htable_lookup(cpu, pc, cs_base, flags);\n\n        if (!tb) {\n\n\n\n            /* mmap_lock is needed by tb_gen_code, and mmap_lock must be\n\n             * taken outside tb_lock. As system emulation is currently\n\n             * single threaded the locks are NOPs.\n\n             */\n\n            mmap_lock();\n\n            tb_lock();\n\n            acquired_tb_lock = true;\n\n\n\n            /* There's a chance that our desired tb has been translated while\n\n             * taking the locks so we check again inside the lock.\n\n             */\n\n            tb = tb_htable_lookup(cpu, pc, cs_base, flags);\n\n            if (!tb) {\n\n                /* if no translated code available, then translate it now */\n\n                tb = tb_gen_code(cpu, pc, cs_base, flags, 0);\n\n            }\n\n\n\n            mmap_unlock();\n\n        }\n\n\n\n        /* We add the TB in the virtual pc hash table for the fast lookup */\n\n        atomic_set(&cpu->tb_jmp_cache[tb_jmp_cache_hash_func(pc)], tb);\n\n    }\n\n#ifndef CONFIG_USER_ONLY\n\n    /* We don't take care of direct jumps when address mapping changes in\n\n     * system emulation. So it's not safe to make a direct jump to a TB\n\n     * spanning two pages because the mapping for the second page can change.\n\n     */\n\n    if (tb->page_addr[1] != -1) {\n\n        last_tb = NULL;\n\n    }\n\n#endif\n\n    /* See if we can patch the calling TB. */\n\n    if (last_tb && !qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) {\n\n        if (!acquired_tb_lock) {\n\n            tb_lock();\n\n            acquired_tb_lock = true;\n\n        }\n\n        if (!tb->invalid) {\n\n            tb_add_jump(last_tb, tb_exit, tb);\n\n        }\n\n    }\n\n    if (acquired_tb_lock) {\n\n        tb_unlock();\n\n    }\n\n    return tb;\n\n}\n", "idx": 26715}
{"project": "qemu", "commit_id": "f332e830e38b3ff3953ef02ac04e409ae53769c5", "target": 1, "func": "static void parse_type_size(Visitor *v, const char *name, uint64_t *obj,\n\n                            Error **errp)\n\n{\n\n    StringInputVisitor *siv = to_siv(v);\n\n    Error *err = NULL;\n\n    uint64_t val;\n\n\n\n    if (siv->string) {\n\n        parse_option_size(name, siv->string, &val, &err);\n\n    } else {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"size\");\n\n        return;\n\n    }\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n\n\n    *obj = val;\n\n}\n", "idx": 26754}
{"project": "qemu", "commit_id": "da98c8eb4c35225049cad8cf767647eb39788b5d", "target": 0, "func": "void acpi_pm1_cnt_init(ACPIREGS *ar, qemu_irq cmos_s3)\n\n{\n\n    ar->pm1.cnt.cmos_s3 = cmos_s3;\n\n}\n", "idx": 26791}
{"project": "qemu", "commit_id": "4083733db5e4120939acee57019ff52db1f45b9d", "target": 0, "func": "static void console_refresh(QemuConsole *s)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s);\n\n    TextCell *c;\n\n    int x, y, y1;\n\n\n\n    if (s->ds->have_text) {\n\n        s->text_x[0] = 0;\n\n        s->text_y[0] = 0;\n\n        s->text_x[1] = s->width - 1;\n\n        s->text_y[1] = s->height - 1;\n\n        s->cursor_invalidate = 1;\n\n    }\n\n\n\n    vga_fill_rect(s, 0, 0, surface_width(surface), surface_height(surface),\n\n                  color_table_rgb[0][COLOR_BLACK]);\n\n    y1 = s->y_displayed;\n\n    for (y = 0; y < s->height; y++) {\n\n        c = s->cells + y1 * s->width;\n\n        for (x = 0; x < s->width; x++) {\n\n            vga_putcharxy(s, x, y, c->ch,\n\n                          &(c->t_attrib));\n\n            c++;\n\n        }\n\n        if (++y1 == s->total_height) {\n\n            y1 = 0;\n\n        }\n\n    }\n\n    console_show_cursor(s, 1);\n\n    dpy_gfx_update(s, 0, 0,\n\n                   surface_width(surface), surface_height(surface));\n\n}\n", "idx": 26807}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static void qemu_init_child_watch(void)\n\n{\n\n    struct sigaction act;\n\n    sigchld_bh = qemu_bh_new(sigchld_bh_handler, NULL);\n\n\n\n    memset(&act, 0, sizeof(act));\n\n    act.sa_handler = sigchld_handler;\n\n    act.sa_flags = SA_NOCLDSTOP;\n\n    sigaction(SIGCHLD, &act, NULL);\n\n}\n", "idx": 26808}
{"project": "FFmpeg", "commit_id": "240fd8c96f59ebe9dcfc4152a1086cd3f63400c0", "target": 0, "func": "int av_packet_split_side_data(AVPacket *pkt){\n\n    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){\n\n        int i;\n\n        unsigned int size, orig_pktsize = pkt->size;\n\n        uint8_t *p;\n\n\n\n        p = pkt->data + pkt->size - 8 - 5;\n\n        for (i=1; ; i++){\n\n            size = AV_RB32(p);\n\n            if (size>INT_MAX || p - pkt->data < size)\n\n                return 0;\n\n            if (p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n\n\n        pkt->side_data = av_malloc(i * sizeof(*pkt->side_data));\n\n        if (!pkt->side_data)\n\n            return AVERROR(ENOMEM);\n\n\n\n        p= pkt->data + pkt->size - 8 - 5;\n\n        for (i=0; ; i++){\n\n            size= AV_RB32(p);\n\n            av_assert0(size<=INT_MAX && p - pkt->data >= size);\n\n            pkt->side_data[i].data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            pkt->side_data[i].size = size;\n\n            pkt->side_data[i].type = p[4]&127;\n\n            if (!pkt->side_data[i].data)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(pkt->side_data[i].data, p-size, size);\n\n            pkt->size -= size + 5;\n\n            if(p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n        pkt->size -= 8;\n\n        /* FFMIN() prevents overflow in case the packet wasn't allocated with\n\n         * proper padding.\n\n         * If the side data is smaller than the buffer padding size, the\n\n         * remaining bytes should have already been filled with zeros by the\n\n         * original packet allocation anyway. */\n\n        memset(pkt->data + pkt->size, 0,\n\n               FFMIN(orig_pktsize - pkt->size, FF_INPUT_BUFFER_PADDING_SIZE));\n\n        pkt->side_data_elems = i+1;\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 26818}
{"project": "FFmpeg", "commit_id": "f6b7f72461673e4d398b1edf9ed2a7fe70d99c47", "target": 0, "func": "static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h, int intra ) {\n\n    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);\n\n    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 || !intra ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n\n        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 26870}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static inline void bt_hci_lmp_acl_data(struct bt_hci_s *hci, uint16_t handle,\n\n                const uint8_t *data, int start, int len)\n\n{\n\n    struct hci_acl_hdr *pkt = (void *) hci->acl_buf;\n\n\n\n    /* TODO: packet flags */\n\n    /* TODO: avoid memcpy'ing */\n\n\n\n    if (len + HCI_ACL_HDR_SIZE > sizeof(hci->acl_buf)) {\n\n        fprintf(stderr, \"%s: can't take ACL packets %i bytes long\\n\",\n\n                        __FUNCTION__, len);\n\n        return;\n\n    }\n\n    memcpy(hci->acl_buf + HCI_ACL_HDR_SIZE, data, len);\n\n\n\n    pkt->handle = cpu_to_le16(\n\n                    acl_handle_pack(handle, start ? ACL_START : ACL_CONT));\n\n    pkt->dlen = cpu_to_le16(len);\n\n    hci->info.acl_recv(hci->info.opaque,\n\n                    hci->acl_buf, len + HCI_ACL_HDR_SIZE);\n\n}\n", "idx": 26875}
{"project": "qemu", "commit_id": "42bb9c9178ae7ac4c439172b1ae99cc29188a5c6", "target": 0, "func": "static void xilinx_enet_init(Object *obj)\n\n{\n\n    XilinxAXIEnet *s = XILINX_AXI_ENET(obj);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n\n    Error *errp = NULL;\n\n\n\n    object_property_add_link(obj, \"axistream-connected\", TYPE_STREAM_SLAVE,\n\n                             (Object **) &s->tx_dev, &errp);\n\n    assert_no_error(errp);\n\n\n\n    object_initialize(&s->rx_data_dev, TYPE_XILINX_AXI_ENET_DATA_STREAM);\n\n    object_property_add_child(OBJECT(s), \"axistream-connected-target\",\n\n                              (Object *)&s->rx_data_dev, &errp);\n\n    assert_no_error(errp);\n\n\n\n    sysbus_init_irq(sbd, &s->irq);\n\n\n\n    memory_region_init_io(&s->iomem, &enet_ops, s, \"enet\", 0x40000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n}\n", "idx": 26892}
{"project": "qemu", "commit_id": "23326164ae6fe8d94b7eff123e03f97ca6978d33", "target": 0, "func": "bool address_space_rw(AddressSpace *as, hwaddr addr, uint8_t *buf,\n\n                      int len, bool is_write)\n\n{\n\n    hwaddr l;\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    hwaddr addr1;\n\n    MemoryRegion *mr;\n\n    bool error = false;\n\n\n\n    while (len > 0) {\n\n        l = len;\n\n        mr = address_space_translate(as, addr, &addr1, &l, is_write);\n\n\n\n        if (is_write) {\n\n            if (!memory_access_is_direct(mr, is_write)) {\n\n                l = memory_access_size(mr, l, addr1);\n\n                /* XXX: could force current_cpu to NULL to avoid\n\n                   potential bugs */\n\n                if (l == 4) {\n\n                    /* 32 bit write access */\n\n                    val = ldl_p(buf);\n\n                    error |= io_mem_write(mr, addr1, val, 4);\n\n                } else if (l == 2) {\n\n                    /* 16 bit write access */\n\n                    val = lduw_p(buf);\n\n                    error |= io_mem_write(mr, addr1, val, 2);\n\n                } else {\n\n                    /* 8 bit write access */\n\n                    val = ldub_p(buf);\n\n                    error |= io_mem_write(mr, addr1, val, 1);\n\n                }\n\n            } else {\n\n                addr1 += memory_region_get_ram_addr(mr);\n\n                /* RAM case */\n\n                ptr = qemu_get_ram_ptr(addr1);\n\n                memcpy(ptr, buf, l);\n\n                invalidate_and_set_dirty(addr1, l);\n\n            }\n\n        } else {\n\n            if (!memory_access_is_direct(mr, is_write)) {\n\n                /* I/O case */\n\n                l = memory_access_size(mr, l, addr1);\n\n                if (l == 4) {\n\n                    /* 32 bit read access */\n\n                    error |= io_mem_read(mr, addr1, &val, 4);\n\n                    stl_p(buf, val);\n\n                } else if (l == 2) {\n\n                    /* 16 bit read access */\n\n                    error |= io_mem_read(mr, addr1, &val, 2);\n\n                    stw_p(buf, val);\n\n                } else {\n\n                    /* 8 bit read access */\n\n                    error |= io_mem_read(mr, addr1, &val, 1);\n\n                    stb_p(buf, val);\n\n                }\n\n            } else {\n\n                /* RAM case */\n\n                ptr = qemu_get_ram_ptr(mr->ram_addr + addr1);\n\n                memcpy(buf, ptr, l);\n\n            }\n\n        }\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n\n\n    return error;\n\n}\n", "idx": 26893}
{"project": "qemu", "commit_id": "5c55ff99fa88158871d5b9f619c485deae5f3d5b", "target": 0, "func": "static int create_ppc_opcodes (CPUPPCState *env, const ppc_def_t *def)\n\n{\n\n    opcode_t *opc, *start, *end;\n\n\n\n    fill_new_table(env->opcodes, 0x40);\n\n    if (&opc_start < &opc_end) {\n\n        start = &opc_start;\n\n        end = &opc_end;\n\n    } else {\n\n        start = &opc_end;\n\n        end = &opc_start;\n\n    }\n\n    for (opc = start + 1; opc != end; opc++) {\n\n        if ((opc->handler.type & def->insns_flags) != 0) {\n\n            if (register_insn(env->opcodes, opc) < 0) {\n\n                printf(\"*** ERROR initializing PowerPC instruction \"\n\n                       \"0x%02x 0x%02x 0x%02x\\n\", opc->opc1, opc->opc2,\n\n                       opc->opc3);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n    fix_opcode_tables(env->opcodes);\n\n    fflush(stdout);\n\n    fflush(stderr);\n\n\n\n    return 0;\n\n}\n", "idx": 26906}
{"project": "qemu", "commit_id": "b7f43fe46029d8fd0594cd599fa2599dcce0f553", "target": 1, "func": "Object *object_dynamic_cast_assert(Object *obj, const char *typename)\n\n{\n\n    Object *inst;\n\n\n\n    inst = object_dynamic_cast(obj, typename);\n\n\n\n    if (!inst) {\n\n        fprintf(stderr, \"Object %p is not an instance of type %s\\n\",\n\n                obj, typename);\n\n        abort();\n\n    }\n\n\n\n    return inst;\n\n}\n", "idx": 26933}
{"project": "qemu", "commit_id": "d8754f40acb2d30e4735cdcd21a16e7ac29264a3", "target": 0, "func": "opts_end_list(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = DO_UPCAST(OptsVisitor, visitor, v);\n\n\n\n    assert(ov->list_mode == LM_STARTED || ov->list_mode == LM_IN_PROGRESS);\n\n    ov->repeated_opts = NULL;\n\n    ov->list_mode = LM_NONE;\n\n}\n", "idx": 26965}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static CaptureVoiceOut *audio_pcm_capture_find_specific (\n\n    AudioState *s,\n\n    audsettings_t *as\n\n    )\n\n{\n\n    CaptureVoiceOut *cap;\n\n\n\n    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {\n\n        if (audio_pcm_info_eq (&cap->hw.info, as)) {\n\n            return cap;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 26969}
{"project": "FFmpeg", "commit_id": "fbd6c97f9ca858140df16dd07200ea0d4bdc1a83", "target": 1, "func": "AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)\n\n{\n\n    AVBufferRef *ret;\n\n    BufferPoolEntry *buf;\n\n\n\n    /* check whether the pool is empty */\n\n    buf = get_pool(pool);\n\n    if (!buf)\n\n        return pool_alloc_buffer(pool);\n\n\n\n    /* keep the first entry, return the rest of the list to the pool */\n\n    add_to_pool(buf->next);\n\n    buf->next = NULL;\n\n\n\n    ret = av_buffer_create(buf->data, pool->size, pool_release_buffer,\n\n                           buf, 0);\n\n    if (!ret) {\n\n        add_to_pool(buf);\n\n        return NULL;\n\n    }\n\n    avpriv_atomic_int_add_and_fetch(&pool->refcount, 1);\n\n\n\n    return ret;\n\n}\n", "idx": 26983}
{"project": "qemu", "commit_id": "c599d4d6d6e9bfdb64e54c33a22cb26e3496b96d", "target": 1, "func": "static void QEMU_NORETURN force_sig(int target_sig)\n\n{\n\n    CPUState *cpu = thread_cpu;\n\n    CPUArchState *env = cpu->env_ptr;\n\n    TaskState *ts = (TaskState *)cpu->opaque;\n\n    int host_sig, core_dumped = 0;\n\n    struct sigaction act;\n\n\n\n    host_sig = target_to_host_signal(target_sig);\n\n    trace_user_force_sig(env, target_sig, host_sig);\n\n    gdb_signalled(env, target_sig);\n\n\n\n    /* dump core if supported by target binary format */\n\n    if (core_dump_signal(target_sig) && (ts->bprm->core_dump != NULL)) {\n\n        stop_all_tasks();\n\n        core_dumped =\n\n            ((*ts->bprm->core_dump)(target_sig, env) == 0);\n\n    }\n\n    if (core_dumped) {\n\n        /* we already dumped the core of target process, we don't want\n\n         * a coredump of qemu itself */\n\n        struct rlimit nodump;\n\n        getrlimit(RLIMIT_CORE, &nodump);\n\n        nodump.rlim_cur=0;\n\n        setrlimit(RLIMIT_CORE, &nodump);\n\n        (void) fprintf(stderr, \"qemu: uncaught target signal %d (%s) - %s\\n\",\n\n            target_sig, strsignal(host_sig), \"core dumped\" );\n\n    }\n\n\n\n    /* The proper exit code for dying from an uncaught signal is\n\n     * -<signal>.  The kernel doesn't allow exit() or _exit() to pass\n\n     * a negative value.  To get the proper exit code we need to\n\n     * actually die from an uncaught signal.  Here the default signal\n\n     * handler is installed, we send ourself a signal and we wait for\n\n     * it to arrive. */\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_handler = SIG_DFL;\n\n    act.sa_flags = 0;\n\n    sigaction(host_sig, &act, NULL);\n\n\n\n    /* For some reason raise(host_sig) doesn't send the signal when\n\n     * statically linked on x86-64. */\n\n    kill(getpid(), host_sig);\n\n\n\n    /* Make sure the signal isn't masked (just reuse the mask inside\n\n    of act) */\n\n    sigdelset(&act.sa_mask, host_sig);\n\n    sigsuspend(&act.sa_mask);\n\n\n\n    /* unreachable */\n\n    abort();\n\n}\n", "idx": 26984}
{"project": "FFmpeg", "commit_id": "20035fa24103da9199de3515ca75ba1f6bb275aa", "target": 1, "func": "static int scale_vector(int16_t *dst, const int16_t *vector, int length)\n\n{\n\n    int bits, max = 0;\n\n    int i;\n\n\n\n    for (i = 0; i < length; i++)\n\n        max |= FFABS(vector[i]);\n\n\n\n    bits  = normalize_bits(max, 15);\n\n\n\n    if (bits == 15)\n\n        for (i = 0; i < length; i++)\n\n            dst[i] = vector[i] * 0x7fff >> 3;\n\n    else\n\n        for (i = 0; i < length; i++)\n\n            dst[i] = vector[i] << bits >> 3;\n\n\n\n    return bits - 3;\n\n}\n", "idx": 26997}
{"project": "qemu", "commit_id": "8dfbaa6ac450c4ec2646b1ca08a4017052a90c1d", "target": 0, "func": "static int virtio_ccw_hcall_notify(const uint64_t *args)\n\n{\n\n    uint64_t subch_id = args[0];\n\n    uint64_t queue = args[1];\n\n    SubchDev *sch;\n\n    int cssid, ssid, schid, m;\n\n\n\n    if (ioinst_disassemble_sch_ident(subch_id, &m, &cssid, &ssid, &schid)) {\n\n        return -EINVAL;\n\n    }\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (!sch || !css_subch_visible(sch)) {\n\n        return -EINVAL;\n\n    }\n\n    if (queue >= VIRTIO_PCI_QUEUE_MAX) {\n\n        return -EINVAL;\n\n    }\n\n    virtio_queue_notify(virtio_ccw_get_vdev(sch), queue);\n\n    return 0;\n\n\n\n}\n", "idx": 27008}
{"project": "FFmpeg", "commit_id": "9156a5ad72e989e0fa2735741edf894fffad33b9", "target": 0, "func": "static void ipvideo_decode_opcodes(IpvideoContext *s)\n\n{\n\n    int x, y;\n\n    unsigned char opcode;\n\n    int ret;\n\n    static int frame = 0;\n\n    GetBitContext gb;\n\n\n\n    debug_interplay(\"------------------ frame %d\\n\", frame);\n\n    frame++;\n\n\n\n    /* this is PAL8, so make the palette available */\n\n    memcpy(s->current_frame.data[1], s->avctx->palctrl->palette, PALETTE_COUNT * 4);\n\n\n\n    s->stride = s->current_frame.linesize[0];\n\n    s->stream_ptr = s->buf + 14;  /* data starts 14 bytes in */\n\n    s->stream_end = s->buf + s->size;\n\n    s->line_inc = s->stride - 8;\n\n    s->upper_motion_limit_offset = (s->avctx->height - 8) * s->stride\n\n        + s->avctx->width - 8;\n\n\n\n    init_get_bits(&gb, s->decoding_map, s->decoding_map_size * 8);\n\n    for (y = 0; y < (s->stride * s->avctx->height); y += s->stride * 8) {\n\n        for (x = y; x < y + s->avctx->width; x += 8) {\n\n            opcode = get_bits(&gb, 4);\n\n\n\n            debug_interplay(\"  block @ (%3d, %3d): encoding 0x%X, data ptr @ %p\\n\",\n\n                            x - y, y / s->stride, opcode, s->stream_ptr);\n\n\n\n            s->pixel_ptr = s->current_frame.data[0] + x;\n\n            ret = ipvideo_decode_block[opcode](s);\n\n            if (ret != 0) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: decode problem on frame %d, @ block (%d, %d)\\n\",\n\n                       frame, x - y, y / s->stride);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n    if (s->stream_end - s->stream_ptr > 1) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: decode finished with %td bytes left over\\n\",\n\n               s->stream_end - s->stream_ptr);\n\n    }\n\n}\n", "idx": 27026}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline void cris_fidx_i(unsigned int x)\n\n{\n\n\tregister unsigned int v asm(\"$r10\") = x;\n\n\tasm (\"fidxi\\t[%0]\\n\" : : \"r\" (v) );\n\n}\n", "idx": 27036}
{"project": "qemu", "commit_id": "b6fcf32d9b851a83dedcb609091236b97cc4a985", "target": 0, "func": "static void test_nested_struct_list(gconstpointer opaque)\n\n{\n\n    TestArgs *args = (TestArgs *) opaque;\n\n    const SerializeOps *ops = args->ops;\n\n    UserDefNestedList *listp = NULL, *tmp, *tmp_copy, *listp_copy = NULL;\n\n    Error *err = NULL;\n\n    void *serialize_data;\n\n    int i = 0;\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        tmp = g_malloc0(sizeof(UserDefNestedList));\n\n        tmp->value = nested_struct_create();\n\n        tmp->next = listp;\n\n        listp = tmp;\n\n    }\n\n    \n\n    ops->serialize(listp, &serialize_data, visit_nested_struct_list, &err);\n\n    ops->deserialize((void **)&listp_copy, serialize_data,\n\n                     visit_nested_struct_list, &err); \n\n\n\n    g_assert(err == NULL);\n\n\n\n    tmp = listp;\n\n    tmp_copy = listp_copy;\n\n    while (listp_copy) {\n\n        g_assert(listp);\n\n        nested_struct_compare(listp->value, listp_copy->value);\n\n        listp = listp->next;\n\n        listp_copy = listp_copy->next;\n\n    }\n\n\n\n    qapi_free_UserDefNestedList(tmp);\n\n    qapi_free_UserDefNestedList(tmp_copy);\n\n\n\n    ops->cleanup(serialize_data);\n\n    g_free(args);\n\n}\n", "idx": 27060}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static void handle_char(CCaptionSubContext *ctx, char hi, char lo, int64_t pts)\n\n{\n\n    struct Screen *screen = get_writing_screen(ctx);\n\n    char *row = screen->characters[ctx->cursor_row];\n\n    int ret;\n\n\n\n    SET_FLAG(screen->row_used,ctx->cursor_row);\n\n\n\n    ret = write_char(ctx, row, ctx->cursor_column, hi);\n\n    if( ret == 0 )\n\n        ctx->cursor_column++;\n\n\n\n    if(lo) {\n\n        ret = write_char(ctx, row, ctx->cursor_column, lo);\n\n        if ( ret == 0 )\n\n            ctx->cursor_column++;\n\n    }\n\n    write_char(ctx, row, ctx->cursor_column, 0);\n\n\n\n    /* reset prev command since character can repeat */\n\n    ctx->prev_cmd[0] = 0;\n\n    ctx->prev_cmd[1] = 0;\n\n    if (lo)\n\n       av_dlog(ctx, \"(%c,%c)\\n\",hi,lo);\n\n    else\n\n       av_dlog(ctx, \"(%c)\\n\",hi);\n\n}\n", "idx": 27067}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "int qemu_cpu_is_self(void *env)\n\n{\n\n    return 1;\n\n}\n", "idx": 27069}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,\n                                  QEMUIOVector *iov, int nb_sectors,\n                                  BlockDriverCompletionFunc *cb, void *opaque)\n{\n    return bdrv_aio_rw_vector(bs, sector_num, iov, nb_sectors,\n                              cb, opaque, 1);\n}", "idx": 27072}
{"project": "FFmpeg", "commit_id": "ffa1de8a3b93139097214bc600d356ab62bfdf05", "target": 1, "func": "static void dequantization_int_97(int x, int y, Jpeg2000Cblk *cblk,\n\n                               Jpeg2000Component *comp,\n\n                               Jpeg2000T1Context *t1, Jpeg2000Band *band)\n\n{\n\n    int i, j;\n\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n\n        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n\n        int *src = t1->data[j];\n\n        for (i = 0; i < w; ++i)\n\n            datap[i] = (src[i] * band->i_stepsize + (1<<14)) >> 15;\n\n    }\n\n}\n", "idx": 27135}
{"project": "FFmpeg", "commit_id": "38c48be213b86baa04e64762622afefbba1afa70", "target": 0, "func": "static int mpegts_read_packet(AVFormatContext *s,\n\n                              AVPacket *pkt)\n\n{\n\n    MpegTSContext *ts = s->priv_data;\n\n\n\n    if (!ts->mpeg2ts_raw) {\n\n        ts->pkt = pkt;\n\n        return handle_packets(ts, 0);\n\n    } else {\n\n        return mpegts_raw_read_packet(s, pkt);\n\n    }\n\n}\n", "idx": 27183}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "static inline int load_segment(uint32_t *e1_ptr, uint32_t *e2_ptr,\n\n                               int selector)\n\n{\n\n    SegmentCache *dt;\n\n    int index;\n\n    uint8_t *ptr;\n\n\n\n    if (selector & 0x4)\n\n        dt = &env->ldt;\n\n    else\n\n        dt = &env->gdt;\n\n    index = selector & ~7;\n\n    if ((index + 7) > dt->limit)\n\n        return -1;\n\n    ptr = dt->base + index;\n\n    *e1_ptr = ldl_kernel(ptr);\n\n    *e2_ptr = ldl_kernel(ptr + 4);\n\n    return 0;\n\n}\n", "idx": 27187}
{"project": "FFmpeg", "commit_id": "1dc42050185d63c1de5d16146fbaee92640af187", "target": 0, "func": "static int start_frame(AVFilterLink *link, AVFilterBufferRef *picref)\n\n{\n\n    AVFilterContext *ctx = link->dst;\n\n    YADIFContext *yadif = ctx->priv;\n\n\n\n    if (yadif->frame_pending)\n\n        return_frame(ctx, 1);\n\n\n\n    if (yadif->prev)\n\n        avfilter_unref_buffer(yadif->prev);\n\n    yadif->prev = yadif->cur;\n\n    yadif->cur  = yadif->next;\n\n    yadif->next = picref;\n\n\n\n    if (!yadif->cur)\n\n        return 0;\n\n\n\n    if (yadif->auto_enable && !yadif->cur->video->interlaced) {\n\n        yadif->out  = avfilter_ref_buffer(yadif->cur, AV_PERM_READ);\n\n        avfilter_unref_bufferp(&yadif->prev);\n\n        if (yadif->out->pts != AV_NOPTS_VALUE)\n\n            yadif->out->pts *= 2;\n\n        return ff_start_frame(ctx->outputs[0], yadif->out);\n\n    }\n\n\n\n    if (!yadif->prev)\n\n        yadif->prev = avfilter_ref_buffer(yadif->cur, AV_PERM_READ);\n\n\n\n    yadif->out = ff_get_video_buffer(ctx->outputs[0], AV_PERM_WRITE | AV_PERM_PRESERVE |\n\n                                     AV_PERM_REUSE, link->w, link->h);\n\n\n\n    avfilter_copy_buffer_ref_props(yadif->out, yadif->cur);\n\n    yadif->out->video->interlaced = 0;\n\n    if (yadif->out->pts != AV_NOPTS_VALUE)\n\n        yadif->out->pts *= 2;\n\n    return ff_start_frame(ctx->outputs[0], yadif->out);\n\n}\n", "idx": 27194}
{"project": "FFmpeg", "commit_id": "f6b7f72461673e4d398b1edf9ed2a7fe70d99c47", "target": 0, "func": "static void av_always_inline filter_mb_edgeh( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h, int intra ) {\n\n    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);\n\n    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 || !intra ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]];\n\n        tc[1] = tc0_table[index_a][bS[1]];\n\n        tc[2] = tc0_table[index_a][bS[2]];\n\n        tc[3] = tc0_table[index_a][bS[3]];\n\n        h->h264dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 27199}
{"project": "FFmpeg", "commit_id": "ca203e9985cd2dcf42a0c0853940850d3a8edf3a", "target": 1, "func": "static void calc_thr_3gpp(const FFPsyWindowInfo *wi, const int num_bands, AacPsyChannel *pch,\n\n                          const uint8_t *band_sizes, const float *coefs)\n\n{\n\n    int i, w, g;\n\n    int start = 0;\n\n    for (w = 0; w < wi->num_windows*16; w += 16) {\n\n        for (g = 0; g < num_bands; g++) {\n\n            AacPsyBand *band = &pch->band[w+g];\n\n\n\n            float form_factor = 0.0f;\n\n            float Temp;\n\n            band->energy = 0.0f;\n\n            for (i = 0; i < band_sizes[g]; i++) {\n\n                band->energy += coefs[start+i] * coefs[start+i];\n\n                form_factor  += sqrtf(fabs(coefs[start+i]));\n\n            }\n\n            Temp = band->energy > 0 ? sqrtf((float)band_sizes[g] / band->energy) : 0;\n\n            band->thr      = band->energy * 0.001258925f;\n\n            band->nz_lines = form_factor * sqrtf(Temp);\n\n\n\n            start += band_sizes[g];\n\n        }\n\n    }\n\n}\n", "idx": 27216}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_bh_schedule_oneshot(AioContext *ctx, QEMUBHFunc *cb, void *opaque)\n\n{\n\n    QEMUBH *bh;\n\n    bh = g_new(QEMUBH, 1);\n\n    *bh = (QEMUBH){\n\n        .ctx = ctx,\n\n        .cb = cb,\n\n        .opaque = opaque,\n\n    };\n\n    qemu_lockcnt_lock(&ctx->list_lock);\n\n    bh->next = ctx->first_bh;\n\n    bh->scheduled = 1;\n\n    bh->deleted = 1;\n\n    /* Make sure that the members are ready before putting bh into list */\n\n    smp_wmb();\n\n    ctx->first_bh = bh;\n\n    qemu_lockcnt_unlock(&ctx->list_lock);\n\n    aio_notify(ctx);\n\n}\n", "idx": 27242}
{"project": "qemu", "commit_id": "9012a53f067a78022947e18050b145c34a3dc599", "target": 0, "func": "static void rtas_start_cpu(PowerPCCPU *cpu_, sPAPRMachineState *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id, start, r3;\n\n    PowerPCCPU *cpu;\n\n\n\n    if (nargs != 3 || nret != 1) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    start = rtas_ld(args, 1);\n\n    r3 = rtas_ld(args, 2);\n\n\n\n    cpu = spapr_find_cpu(id);\n\n    if (cpu != NULL) {\n\n        CPUState *cs = CPU(cpu);\n\n        CPUPPCState *env = &cpu->env;\n\n        PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n\n        Error *local_err = NULL;\n\n\n\n        if (!cs->halted) {\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        /* This will make sure qemu state is up to date with kvm, and\n\n         * mark it dirty so our changes get flushed back before the\n\n         * new cpu enters */\n\n        kvm_cpu_synchronize_state(cs);\n\n\n\n        /* Set compatibility mode to match existing cpus */\n\n        ppc_set_compat(cpu, POWERPC_CPU(first_cpu)->compat_pvr, &local_err);\n\n        if (local_err) {\n\n            error_report_err(local_err);\n\n            rtas_st(rets, 0, RTAS_OUT_HW_ERROR);\n\n            return;\n\n        }\n\n\n\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n\n\n\n        /* Enable Power-saving mode Exit Cause exceptions for the new CPU */\n\n        env->spr[SPR_LPCR] |= pcc->lpcr_pm;\n\n\n\n        env->nip = start;\n\n        env->gpr[3] = r3;\n\n        cs->halted = 0;\n\n        spapr_cpu_set_endianness(cpu);\n\n        spapr_cpu_update_tb_offset(cpu);\n\n\n\n        qemu_cpu_kick(cs);\n\n\n\n        rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 27269}
{"project": "qemu", "commit_id": "ad196a9d0c14f681f010bb4b979030ec125ba976", "target": 0, "func": "void net_slirp_redir(Monitor *mon, const char *redir_str, const char *redir_opt2)\n\n{\n\n    struct slirp_config_str *config;\n\n\n\n    if (!slirp_inited) {\n\n        if (mon) {\n\n            monitor_printf(mon, \"user mode network stack not in use\\n\");\n\n        } else {\n\n            config = qemu_malloc(sizeof(*config));\n\n            config->str = redir_str;\n\n            config->next = slirp_redirs;\n\n            slirp_redirs = config;\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (!strcmp(redir_str, \"remove\")) {\n\n        net_slirp_redir_rm(mon, redir_opt2);\n\n        return;\n\n    }\n\n\n\n    slirp_redirection(mon, redir_str);\n\n}\n", "idx": 27275}
{"project": "qemu", "commit_id": "196a778428989217b82de042725dc8eb29c8f8d8", "target": 1, "func": "static void qxl_reset_surfaces(PCIQXLDevice *d)\n\n{\n\n    dprint(d, 1, \"%s:\\n\", __FUNCTION__);\n\n    d->mode = QXL_MODE_UNDEFINED;\n\n    qemu_mutex_unlock_iothread();\n\n    d->ssd.worker->destroy_surfaces(d->ssd.worker);\n\n    qemu_mutex_lock_iothread();\n\n    memset(&d->guest_surfaces.cmds, 0, sizeof(d->guest_surfaces.cmds));\n\n}\n", "idx": 27290}
